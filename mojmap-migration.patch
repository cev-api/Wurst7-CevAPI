diff --git a/build.gradle b/build.gradle
index 378139941..fc652c065 100644
--- a/build.gradle
+++ b/build.gradle
@@ -60,7 +60,7 @@ repositories {
 dependencies {
 	// To change the versions see the gradle.properties file
 	minecraft "com.mojang:minecraft:${project.minecraft_version}"
-	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
+	mappings loom.officialMojangMappings()
 	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
 	testImplementation "net.fabricmc:fabric-loader-junit:${project.loader_version}"
 	
diff --git a/gradle.properties b/gradle.properties
index 285198571..22eb62aad 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -7,9 +7,9 @@ org.gradle.configuration-cache=true
 # check these at https://fabricmc.net/develop/ and
 # https://modrinth.com/mod/fabric-api/versions
 minecraft_version=1.21.10
-yarn_mappings=1.21.10+build.2
+official_mappings=1.21.10
 loader_version=0.17.3
-loom_version=1.13-SNAPSHOT
+loom_version=1.14-SNAPSHOT
 
 # Fabric API
 fabric_version=0.138.3+1.21.10
diff --git a/src/gametest/java/net/wurstclient/gametest/WurstClientTestHelper.java b/src/gametest/java/net/wurstclient/gametest/WurstClientTestHelper.java
index a06a7362a..69dc4a194 100644
--- a/src/gametest/java/net/wurstclient/gametest/WurstClientTestHelper.java
+++ b/src/gametest/java/net/wurstclient/gametest/WurstClientTestHelper.java
@@ -23,7 +23,7 @@ import java.util.UUID;
 import org.joml.Vector2i;
 import org.lwjgl.glfw.GLFW;
 import org.lwjgl.system.MemoryUtil;
-
+import com.mojang.blaze3d.platform.NativeImage;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 
@@ -34,12 +34,11 @@ import net.fabricmc.fabric.api.client.gametest.v1.screenshot.TestScreenshotCompa
 import net.fabricmc.fabric.api.client.gametest.v1.screenshot.TestScreenshotComparisonAlgorithm.RawImage;
 import net.fabricmc.fabric.impl.client.gametest.screenshot.TestScreenshotComparisonAlgorithms.RawImageImpl;
 import net.fabricmc.fabric.impl.client.gametest.threading.ThreadingImpl;
-import net.minecraft.block.Block;
-import net.minecraft.client.gui.screen.TitleScreen;
-import net.minecraft.client.texture.NativeImage;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.server.command.ServerCommandSource;
+import net.minecraft.client.gui.screens.TitleScreen;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
 
 public enum WurstClientTestHelper
 {
@@ -99,7 +98,7 @@ public enum WurstClientTestHelper
 	
 	private static boolean[][] alphaChannelToMask(NativeImage template)
 	{
-		if(!template.getFormat().hasAlpha())
+		if(!template.format().hasAlpha())
 		{
 			int width = template.getWidth();
 			int height = template.getHeight();
@@ -115,15 +114,15 @@ public enum WurstClientTestHelper
 		boolean[][] mask = new boolean[width][height];
 		
 		int size = width * height;
-		int alphaOffset = template.getFormat().getAlphaOffset() / 8;
-		int channelCount = template.getFormat().getChannelCount();
+		int alphaOffset = template.format().alphaOffset() / 8;
+		int channelCount = template.format().components();
 		
 		for(int i = 0; i < size; i++)
 		{
 			int x = i % width;
 			int y = i / width;
 			int alpha = MemoryUtil.memGetByte(
-				template.imageId() + i * channelCount + alphaOffset) & 0xff;
+				template.getPointer() + i * channelCount + alphaOffset) & 0xff;
 			mask[x][y] = alpha > 127;
 		}
 		
@@ -172,7 +171,7 @@ public enum WurstClientTestHelper
 	public static void hideSplashTexts(ClientGameTestContext context)
 	{
 		context.runOnClient(mc -> {
-			mc.options.getHideSplashTexts().setValue(true);
+			mc.options.hideSplashTexts().set(true);
 		});
 	}
 	
@@ -183,10 +182,10 @@ public enum WurstClientTestHelper
 	public static void waitForTitleScreenFade(ClientGameTestContext context)
 	{
 		context.waitFor(mc -> {
-			if(!(mc.currentScreen instanceof TitleScreen titleScreen))
+			if(!(mc.screen instanceof TitleScreen titleScreen))
 				return false;
 			
-			return !titleScreen.doBackgroundFade;
+			return !titleScreen.fading;
 		});
 	}
 	
@@ -194,9 +193,9 @@ public enum WurstClientTestHelper
 	{
 		String commandWithPlayer = "execute as @p at @s run " + command;
 		server.runOnServer(mc -> {
-			ParseResults<ServerCommandSource> results =
-				mc.getCommandManager().getDispatcher().parse(commandWithPlayer,
-					mc.getCommandSource());
+			ParseResults<CommandSourceStack> results =
+				mc.getCommands().getDispatcher().parse(commandWithPlayer,
+					mc.createCommandSourceStack());
 			
 			if(!results.getExceptions().isEmpty())
 			{
@@ -208,7 +207,7 @@ public enum WurstClientTestHelper
 				throw new RuntimeException(errors.toString());
 			}
 			
-			mc.getCommandManager().execute(results, commandWithPlayer);
+			mc.getCommands().performCommand(results, commandWithPlayer);
 		});
 	}
 	
@@ -288,14 +287,14 @@ public enum WurstClientTestHelper
 	public static void waitForBlock(ClientGameTestContext context, int relX,
 		int relY, int relZ, Block block)
 	{
-		context.waitFor(mc -> mc.world
-			.getBlockState(mc.player.getBlockPos().add(relX, relY, relZ))
+		context.waitFor(mc -> mc.level
+			.getBlockState(mc.player.blockPosition().offset(relX, relY, relZ))
 			.getBlock() == block);
 	}
 	
 	public static void clearChat(ClientGameTestContext context)
 	{
-		context.runOnClient(mc -> mc.inGameHud.getChatHud().clear(true));
+		context.runOnClient(mc -> mc.gui.getChat().clearMessages(true));
 	}
 	
 	public static void clearInventory(ClientGameTestContext context)
@@ -308,7 +307,7 @@ public enum WurstClientTestHelper
 	
 	public static void clearParticles(ClientGameTestContext context)
 	{
-		context.runOnClient(mc -> mc.particleManager.clearParticles());
+		context.runOnClient(mc -> mc.particleEngine.clearParticles());
 	}
 	
 	public static void clearToasts(ClientGameTestContext context)
@@ -320,8 +319,8 @@ public enum WurstClientTestHelper
 		int slot, Item item)
 	{
 		ItemStack stack = context
-			.computeOnClient(mc -> mc.player.getInventory().getStack(slot));
-		if(!stack.isOf(item) || stack.getCount() != 1)
+			.computeOnClient(mc -> mc.player.getInventory().getItem(slot));
+		if(!stack.is(item) || stack.getCount() != 1)
 			throw new RuntimeException(
 				"Expected 1 " + item.getName().getString() + " at slot " + slot
 					+ ", found " + stack.getCount() + " "
@@ -332,7 +331,7 @@ public enum WurstClientTestHelper
 		int slot)
 	{
 		ItemStack stack = context
-			.computeOnClient(mc -> mc.player.getInventory().getStack(slot));
+			.computeOnClient(mc -> mc.player.getInventory().getItem(slot));
 		if(!stack.isEmpty())
 			throw new RuntimeException("Expected no item in slot " + slot
 				+ ", found " + stack.getCount() + " "
diff --git a/src/gametest/java/net/wurstclient/gametest/WurstTest.java b/src/gametest/java/net/wurstclient/gametest/WurstTest.java
index 1a2b3d22e..0a59700dc 100644
--- a/src/gametest/java/net/wurstclient/gametest/WurstTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/WurstTest.java
@@ -24,12 +24,12 @@ import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.world.TestWorldBuilder;
 import net.minecraft.SharedConstants;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.gui.screen.world.WorldCreator;
-import net.minecraft.world.GameRules;
-import net.minecraft.world.gen.chunk.FlatChunkGenerator;
-import net.minecraft.world.gen.chunk.FlatChunkGeneratorConfig;
-import net.minecraft.world.gen.chunk.FlatChunkGeneratorLayer;
+import net.minecraft.client.gui.screens.worldselection.WorldCreationUiState;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.levelgen.FlatLevelSource;
+import net.minecraft.world.level.levelgen.flat.FlatLayerInfo;
+import net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorSettings;
 import net.wurstclient.gametest.tests.*;
 
 public class WurstTest implements FabricClientGameTest
@@ -55,10 +55,10 @@ public class WurstTest implements FabricClientGameTest
 		LOGGER.info("Creating test world");
 		TestWorldBuilder worldBuilder = context.worldBuilder();
 		worldBuilder.adjustSettings(creator -> {
-			String mcVersion = SharedConstants.getGameVersion().name();
-			creator.setWorldName("E2E Test " + mcVersion);
-			creator.setGameMode(WorldCreator.Mode.CREATIVE);
-			creator.getGameRules().get(GameRules.SEND_COMMAND_FEEDBACK)
+			String mcVersion = SharedConstants.getCurrentVersion().name();
+			creator.setName("E2E Test " + mcVersion);
+			creator.setGameMode(WorldCreationUiState.SelectedGameMode.CREATIVE);
+			creator.getGameRules().getRule(GameRules.RULE_SENDCOMMANDFEEDBACK)
 				.set(false, null);
 			applyFlatPresetWithSmoothStone(creator);
 		});
@@ -138,19 +138,19 @@ public class WurstTest implements FabricClientGameTest
 	}
 	
 	// because the grass texture is randomized and smooth stone isn't
-	private void applyFlatPresetWithSmoothStone(WorldCreator creator)
+	private void applyFlatPresetWithSmoothStone(WorldCreationUiState creator)
 	{
-		FlatChunkGeneratorConfig config =
-			((FlatChunkGenerator)creator.getGeneratorOptionsHolder()
-				.selectedDimensions().getChunkGenerator()).getConfig();
-		
-		List<FlatChunkGeneratorLayer> layers =
-			List.of(new FlatChunkGeneratorLayer(1, Blocks.BEDROCK),
-				new FlatChunkGeneratorLayer(2, Blocks.DIRT),
-				new FlatChunkGeneratorLayer(1, Blocks.SMOOTH_STONE));
-		
-		creator.applyModifier((drm, dorHolder) -> dorHolder.with(drm,
-			new FlatChunkGenerator(config.with(layers,
-				config.getStructureOverrides(), config.getBiome()))));
+		FlatLevelGeneratorSettings config = ((FlatLevelSource)creator
+			.getSettings().selectedDimensions().overworld()).settings();
+		
+		List<FlatLayerInfo> layers =
+			List.of(new FlatLayerInfo(1, Blocks.BEDROCK),
+				new FlatLayerInfo(2, Blocks.DIRT),
+				new FlatLayerInfo(1, Blocks.SMOOTH_STONE));
+		
+		creator.updateDimensions(
+			(drm, dorHolder) -> dorHolder.replaceOverworldGenerator(drm,
+				new FlatLevelSource(config.withBiomeAndLayers(layers,
+					config.structureOverrides(), config.getBiome()))));
 	}
 }
diff --git a/src/gametest/java/net/wurstclient/gametest/mixin/ScreenMixin.java b/src/gametest/java/net/wurstclient/gametest/mixin/ScreenMixin.java
index 332c92981..59c0f0201 100644
--- a/src/gametest/java/net/wurstclient/gametest/mixin/ScreenMixin.java
+++ b/src/gametest/java/net/wurstclient/gametest/mixin/ScreenMixin.java
@@ -7,21 +7,20 @@
  */
 package net.wurstclient.gametest.mixin;
 
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.components.events.AbstractContainerEventHandler;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.util.CommonColors;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-import net.minecraft.client.gui.AbstractParentElement;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.util.Colors;
-
 @Mixin(Screen.class)
-public abstract class ScreenMixin extends AbstractParentElement
-	implements Drawable
+public abstract class ScreenMixin extends AbstractContainerEventHandler
+	implements Renderable
 {
 	@Shadow
 	public int width;
@@ -32,13 +31,11 @@ public abstract class ScreenMixin extends AbstractParentElement
 	 * Replaces the panorama background with a gray background to make test
 	 * screenshots consistent.
 	 */
-	@Inject(at = @At("HEAD"),
-		method = "renderPanoramaBackground",
-		cancellable = true)
-	public void renderPanoramaBackground(DrawContext context, float deltaTicks,
+	@Inject(at = @At("HEAD"), method = "renderPanorama", cancellable = true)
+	public void renderPanoramaBackground(GuiGraphics context, float deltaTicks,
 		CallbackInfo ci)
 	{
-		context.fill(0, 0, width, height, Colors.GRAY);
+		context.fill(0, 0, width, height, CommonColors.GRAY);
 		ci.cancel();
 	}
 }
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/AltManagerTest.java b/src/gametest/java/net/wurstclient/gametest/tests/AltManagerTest.java
index 12006b607..f74495a30 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/AltManagerTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/AltManagerTest.java
@@ -8,11 +8,11 @@
 package net.wurstclient.gametest.tests;
 
 import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.TitleScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.resource.language.I18n;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.TitleScreen;
+import net.minecraft.client.resources.language.I18n;
 import net.wurstclient.gametest.WurstTest;
 
 public enum AltManagerTest
@@ -26,12 +26,12 @@ public enum AltManagerTest
 		WurstTest.LOGGER.info("Checking AltManager button position");
 		
 		context.runOnClient(mc -> {
-			if(!(mc.currentScreen instanceof TitleScreen))
+			if(!(mc.screen instanceof TitleScreen))
 				throw new RuntimeException("Not on the title screen");
 			
-			ButtonWidget multiplayerButton = findButton(mc, "menu.multiplayer");
-			ButtonWidget realmsButton = findButton(mc, "menu.online");
-			ButtonWidget altManagerButton = findButton(mc, "Alt Manager");
+			Button multiplayerButton = findButton(mc, "menu.multiplayer");
+			Button realmsButton = findButton(mc, "menu.online");
+			Button altManagerButton = findButton(mc, "Alt Manager");
 			
 			checkButtonPosition(altManagerButton, realmsButton.getRight() + 4,
 				multiplayerButton.getBottom() + 4);
@@ -46,13 +46,12 @@ public enum AltManagerTest
 	 * For non-translated buttons, the translationKey parameter should be the
 	 * raw button text instead.
 	 */
-	public static ButtonWidget findButton(MinecraftClient mc,
-		String translationKey)
+	public static Button findButton(Minecraft mc, String translationKey)
 	{
-		String message = I18n.translate(translationKey);
+		String message = I18n.get(translationKey);
 		
-		for(Drawable drawable : mc.currentScreen.drawables)
-			if(drawable instanceof ButtonWidget button
+		for(Renderable drawable : mc.screen.renderables)
+			if(drawable instanceof Button button
 				&& button.getMessage().getString().equals(message))
 				return button;
 			
@@ -63,7 +62,7 @@ public enum AltManagerTest
 	 * Looks for the given button at the given coordinates and fails if it is
 	 * not there.
 	 */
-	public static void checkButtonPosition(ButtonWidget button, int expectedX,
+	public static void checkButtonPosition(Button button, int expectedX,
 		int expectedY)
 	{
 		String buttonName = button.getMessage().getString();
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/AutoMineHackTest.java b/src/gametest/java/net/wurstclient/gametest/tests/AutoMineHackTest.java
index 88023db73..074fa2181 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/AutoMineHackTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/AutoMineHackTest.java
@@ -13,7 +13,7 @@ import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestClientWorldContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.block.Blocks;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.gametest.WurstTest;
 
 public enum AutoMineHackTest
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/CopyItemCmdTest.java b/src/gametest/java/net/wurstclient/gametest/tests/CopyItemCmdTest.java
index ac1b77d3c..b3e0d051e 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/CopyItemCmdTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/CopyItemCmdTest.java
@@ -16,7 +16,7 @@ import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestClientWorldContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.item.Items;
+import net.minecraft.world.item.Items;
 import net.wurstclient.gametest.WurstTest;
 
 public enum CopyItemCmdTest
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/GiveCmdTest.java b/src/gametest/java/net/wurstclient/gametest/tests/GiveCmdTest.java
index faedef497..096228a47 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/GiveCmdTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/GiveCmdTest.java
@@ -11,7 +11,7 @@ import static net.wurstclient.gametest.WurstClientTestHelper.*;
 
 import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.item.Items;
+import net.minecraft.world.item.Items;
 import net.wurstclient.gametest.WurstTest;
 
 public enum GiveCmdTest
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/ModifyCmdTest.java b/src/gametest/java/net/wurstclient/gametest/tests/ModifyCmdTest.java
index 5375cd914..0302d85c8 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/ModifyCmdTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/ModifyCmdTest.java
@@ -12,10 +12,10 @@ import static net.wurstclient.gametest.WurstClientTestHelper.*;
 import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.text.Text;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.wurstclient.gametest.WurstTest;
 
 public enum ModifyCmdTest
@@ -38,9 +38,9 @@ public enum ModifyCmdTest
 			"modify set custom_name {\"text\":\"$cRed Name\"}");
 		assertOneItemInSlot(context, 0, Items.DIAMOND);
 		ItemStack stack = context
-			.computeOnClient(mc -> mc.player.getInventory().getSelectedStack());
+			.computeOnClient(mc -> mc.player.getInventory().getSelectedItem());
 		String name = stack.getComponents()
-			.getOrDefault(DataComponentTypes.CUSTOM_NAME, Text.empty())
+			.getOrDefault(DataComponents.CUSTOM_NAME, Component.empty())
 			.getString();
 		if(!name.equals("\u00a7cRed Name"))
 			throw new RuntimeException("Custom name is wrong: " + name);
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/NoFallHackTest.java b/src/gametest/java/net/wurstclient/gametest/tests/NoFallHackTest.java
index 107a744c2..da0a8bc10 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/NoFallHackTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/NoFallHackTest.java
@@ -32,7 +32,7 @@ public enum NoFallHackTest
 		
 		input.pressKey(GLFW.GLFW_KEY_F5);
 		runCommand(server, "gamemode survival");
-		if(!context.computeOnClient(mc -> mc.player.isOnGround()))
+		if(!context.computeOnClient(mc -> mc.player.onGround()))
 			throw new RuntimeException("Player is not on ground");
 		assertPlayerHealth(context, health -> health == 20);
 		
@@ -62,8 +62,8 @@ public enum NoFallHackTest
 		TestServerContext server)
 	{
 		runCommand(server, "tp ~ ~5 ~");
-		context.waitFor(mc -> !mc.player.isOnGround());
-		context.waitFor(mc -> mc.player.isOnGround());
+		context.waitFor(mc -> !mc.player.onGround());
+		context.waitFor(mc -> mc.player.onGround());
 		context.waitTick();
 	}
 	
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/PistonTest.java b/src/gametest/java/net/wurstclient/gametest/tests/PistonTest.java
index c3c1c6651..48586e49c 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/PistonTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/PistonTest.java
@@ -13,7 +13,7 @@ import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestClientWorldContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.block.Blocks;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.gametest.WurstTest;
 
 public enum PistonTest
diff --git a/src/gametest/java/net/wurstclient/gametest/tests/XRayHackTest.java b/src/gametest/java/net/wurstclient/gametest/tests/XRayHackTest.java
index 3ebaa333d..afc56118a 100644
--- a/src/gametest/java/net/wurstclient/gametest/tests/XRayHackTest.java
+++ b/src/gametest/java/net/wurstclient/gametest/tests/XRayHackTest.java
@@ -16,7 +16,7 @@ import net.fabricmc.fabric.api.client.gametest.v1.context.ClientGameTestContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestClientWorldContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestServerContext;
 import net.fabricmc.fabric.api.client.gametest.v1.context.TestSingleplayerContext;
-import net.minecraft.block.Blocks;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.gametest.WurstTest;
 
 public enum XRayHackTest
diff --git a/src/main/java/net/cevapi/config/AntiFingerprintConfigScreen.java b/src/main/java/net/cevapi/config/AntiFingerprintConfigScreen.java
index 8b9cc6bf6..fe87c637d 100644
--- a/src/main/java/net/cevapi/config/AntiFingerprintConfigScreen.java
+++ b/src/main/java/net/cevapi/config/AntiFingerprintConfigScreen.java
@@ -7,12 +7,12 @@
  */
 package net.cevapi.config;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.CyclingButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.CycleButton;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
 
 public final class AntiFingerprintConfigScreen extends Screen
 {
@@ -32,14 +32,14 @@ public final class AntiFingerprintConfigScreen extends Screen
 	private final Screen parent;
 	private final AntiFingerprintConfig config = AntiFingerprintConfig.INSTANCE;
 	
-	private TextFieldWidget thresholdField;
-	private TextFieldWidget windowField;
-	private TextFieldWidget whitelistField;
+	private EditBox thresholdField;
+	private EditBox windowField;
+	private EditBox whitelistField;
 	private int contentTop;
 	
 	public AntiFingerprintConfigScreen(Screen parent)
 	{
-		super(Text.literal("Anti-Fingerprint"));
+		super(Component.literal("Anti-Fingerprint"));
 		this.parent = parent;
 	}
 	
@@ -51,51 +51,53 @@ public final class AntiFingerprintConfigScreen extends Screen
 		int y = contentTop;
 		int doneButtonY = Math.min(height - 28, y + CONTENT_HEIGHT + 24);
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Done"), b -> close())
-				.dimensions(centerX - 100, doneButtonY, 200, 20).build());
-		
-		addDrawableChild(
-			CyclingButtonWidget.<AntiFingerprintConfig.Policy> builder(
-				policy -> Text.literal(policy.toString()))
-				.values(AntiFingerprintConfig.Policy.values())
-				.initially(config.getPolicy()).build(centerX - 100, y, 200, 20,
-					Text.literal("Policy"), (button, value) -> config
-						.getPolicySetting().setSelected(value)));
+		addRenderableWidget(
+			Button.builder(Component.literal("Done"), b -> onClose())
+				.bounds(centerX - 100, doneButtonY, 200, 20).build());
+		
+		addRenderableWidget(CycleButton.<AntiFingerprintConfig.Policy> builder(
+			policy -> Component.literal(policy.toString()))
+			.withValues(AntiFingerprintConfig.Policy.values())
+			.withInitialValue(config.getPolicy()).create(centerX - 100, y, 200,
+				20, Component.literal("Policy"), (button, value) -> config
+					.getPolicySetting().setSelected(value)));
 		y += 26;
 		
-		addDrawableChild(
-			CyclingButtonWidget.<AntiFingerprintConfig.ToastVerbosity> builder(
-				level -> Text.literal(level.toString()))
-				.values(AntiFingerprintConfig.ToastVerbosity.values())
-				.initially(config.getToastVerbosity()).build(centerX - 100, y,
-					200, 20, Text.literal("Toast verbosity"),
+		addRenderableWidget(
+			CycleButton.<AntiFingerprintConfig.ToastVerbosity> builder(
+				level -> Component.literal(level.toString()))
+				.withValues(AntiFingerprintConfig.ToastVerbosity.values())
+				.withInitialValue(config.getToastVerbosity())
+				.create(centerX - 100, y, 200, 20,
+					Component.literal("Toast verbosity"),
 					(button, value) -> config.getToastVerbositySetting()
 						.setSelected(value)));
 		y += 26;
 		
-		addDrawableChild(CyclingButtonWidget.onOffBuilder()
-			.initially(config.isAuditLogEnabled()).build(centerX - 100, y, 200,
-				20, Text.literal("Audit logging"), (button, value) -> config
-					.getAuditLogSetting().setChecked(value)));
+		addRenderableWidget(CycleButton.onOffBuilder()
+			.withInitialValue(config.isAuditLogEnabled()).create(centerX - 100,
+				y, 200, 20, Component.literal("Audit logging"), (button,
+					value) -> config.getAuditLogSetting().setChecked(value)));
 		y += 34;
 		
-		addDrawableChild(CyclingButtonWidget.onOffBuilder()
-			.initially(config.shouldClearCache()).build(centerX - 100, y, 200,
-				20, Text.literal("Clear cache before download"), (button,
-					value) -> config.getPurgeCacheSetting().setChecked(value)));
+		addRenderableWidget(CycleButton.onOffBuilder()
+			.withInitialValue(config.shouldClearCache()).create(centerX - 100,
+				y, 200, 20, Component.literal("Clear cache before download"),
+				(button, value) -> config.getPurgeCacheSetting()
+					.setChecked(value)));
 		y += 34;
 		
-		addDrawableChild(CyclingButtonWidget.onOffBuilder()
-			.initially(config.shouldIsolateCache()).build(centerX - 100, y, 200,
-				20, Text.literal("Isolate cached packs"),
+		addRenderableWidget(CycleButton.onOffBuilder()
+			.withInitialValue(config.shouldIsolateCache()).create(centerX - 100,
+				y, 200, 20, Component.literal("Isolate cached packs"),
 				(button, value) -> config.getIsolateCacheSetting()
 					.setChecked(value)));
 		y += 34;
 		
-		addDrawableChild(CyclingButtonWidget.onOffBuilder()
-			.initially(config.shouldExtractSandbox()).build(centerX - 100, y,
-				200, 20, Text.literal("Extract sandbox copy"),
+		addRenderableWidget(CycleButton.onOffBuilder()
+			.withInitialValue(config.shouldExtractSandbox())
+			.create(centerX - 100, y, 200, 20,
+				Component.literal("Extract sandbox copy"),
 				(button, value) -> config.getExtractSandboxSetting()
 					.setChecked(value)));
 		y += 34;
@@ -104,67 +106,67 @@ public final class AntiFingerprintConfigScreen extends Screen
 		y += FIRST_FIELD_TOP_SPACER;
 		
 		// Text fields
-		thresholdField = new TextFieldWidget(textRenderer, centerX - 100, y,
-			200, 20, Text.literal("Threshold"));
+		thresholdField = new EditBox(font, centerX - 100, y, 200, 20,
+			Component.literal("Threshold"));
 		thresholdField
-			.setText(Integer.toString(config.getFingerprintThreshold()));
-		thresholdField.setChangedListener(this::onThresholdChanged);
-		addDrawableChild(thresholdField);
+			.setValue(Integer.toString(config.getFingerprintThreshold()));
+		thresholdField.setResponder(this::onThresholdChanged);
+		addRenderableWidget(thresholdField);
 		y += FIELD_SPACING;
 		
-		windowField = new TextFieldWidget(textRenderer, centerX - 100, y, 200,
-			20, Text.literal("Window"));
-		windowField.setText(Long.toString(config.getFingerprintWindowMs()));
-		windowField.setChangedListener(this::onWindowChanged);
-		addDrawableChild(windowField);
+		windowField = new EditBox(font, centerX - 100, y, 200, 20,
+			Component.literal("Window"));
+		windowField.setValue(Long.toString(config.getFingerprintWindowMs()));
+		windowField.setResponder(this::onWindowChanged);
+		addRenderableWidget(windowField);
 		y += FIELD_SPACING;
 		
-		whitelistField = new TextFieldWidget(textRenderer, centerX - 100, y,
-			200, 20, Text.literal("Whitelist"));
+		whitelistField = new EditBox(font, centerX - 100, y, 200, 20,
+			Component.literal("Whitelist"));
 		whitelistField.setMaxLength(256);
-		whitelistField.setText(config.getWhitelistRaw());
-		whitelistField.setChangedListener(config::setWhitelistRaw);
-		addDrawableChild(whitelistField);
+		whitelistField.setValue(config.getWhitelistRaw());
+		whitelistField.setResponder(config::setWhitelistRaw);
+		addRenderableWidget(whitelistField);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY, float delta)
+	public void render(GuiGraphics context, int mouseX, int mouseY, float delta)
 	{
 		super.render(context, mouseX, mouseY, delta);
 		
 		// Title
-		context.drawCenteredTextWithShadow(textRenderer, title, width / 2,
+		context.drawCenteredString(font, title, width / 2,
 			Math.max(20, contentTop - 26), LABEL_COLOR);
 		
 		// Labels above text fields (with extra offset for breathing room)
 		if(thresholdField != null)
-			context.drawTextWithShadow(textRenderer,
-				"Fingerprint threshold (packs)", thresholdField.getX(),
-				thresholdField.getY() - LABEL_Y_OFFSET, LABEL_COLOR);
+			context.drawString(font, "Fingerprint threshold (packs)",
+				thresholdField.getX(), thresholdField.getY() - LABEL_Y_OFFSET,
+				LABEL_COLOR);
 		
 		if(windowField != null)
-			context.drawTextWithShadow(textRenderer, "Detection window (ms)",
+			context.drawString(font, "Detection window (ms)",
 				windowField.getX(), windowField.getY() - LABEL_Y_OFFSET,
 				LABEL_COLOR);
 		
 		if(whitelistField != null)
 		{
-			context.drawTextWithShadow(textRenderer,
-				"Whitelisted hosts (comma separated)", whitelistField.getX(),
-				whitelistField.getY() - LABEL_Y_OFFSET, LABEL_COLOR);
+			context.drawString(font, "Whitelisted hosts (comma separated)",
+				whitelistField.getX(), whitelistField.getY() - LABEL_Y_OFFSET,
+				LABEL_COLOR);
 			
-			if(whitelistField.getText().isBlank()
+			if(whitelistField.getValue().isBlank()
 				&& !whitelistField.isFocused())
-				context.drawTextWithShadow(textRenderer,
-					"example.com, static.server", whitelistField.getX() + 4,
-					whitelistField.getY() + 6, PLACEHOLDER_COLOR);
+				context.drawString(font, "example.com, static.server",
+					whitelistField.getX() + 4, whitelistField.getY() + 6,
+					PLACEHOLDER_COLOR);
 		}
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(parent);
+		minecraft.setScreen(parent);
 	}
 	
 	private void onThresholdChanged(String text)
diff --git a/src/main/java/net/cevapi/security/ResourcePackProtector.java b/src/main/java/net/cevapi/security/ResourcePackProtector.java
index 00b17aef4..8daaf6c9f 100644
--- a/src/main/java/net/cevapi/security/ResourcePackProtector.java
+++ b/src/main/java/net/cevapi/security/ResourcePackProtector.java
@@ -53,15 +53,15 @@ import org.apache.logging.log4j.Logger;
 import net.cevapi.config.AntiFingerprintConfig;
 import net.cevapi.config.AntiFingerprintConfig.Policy;
 import net.cevapi.config.AntiFingerprintConfig.ToastLevel;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.client.toast.SystemToast;
-import net.minecraft.client.toast.ToastManager;
-import net.minecraft.network.ClientConnection;
-import net.minecraft.network.packet.s2c.common.ResourcePackSendS2CPacket;
-import net.minecraft.network.packet.c2s.common.ResourcePackStatusC2SPacket;
-import net.minecraft.text.Text;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.components.toasts.SystemToast;
+import net.minecraft.client.gui.components.toasts.ToastManager;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.network.Connection;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.common.ClientboundResourcePackPushPacket;
+import net.minecraft.network.protocol.common.ServerboundResourcePackPacket;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.ChatUtils;
 
@@ -110,11 +110,11 @@ public final class ResourcePackProtector
 		if(!CONFIG.shouldClearCache())
 			return;
 		
-		MinecraftClient client = WurstClient.MC;
-		if(client == null || client.runDirectory == null)
+		Minecraft client = WurstClient.MC;
+		if(client == null || client.gameDirectory == null)
 			return;
 		
-		Path cacheDir = client.runDirectory.toPath().resolve("resourcepacks")
+		Path cacheDir = client.gameDirectory.toPath().resolve("resourcepacks")
 			.resolve("server");
 		if(!Files.exists(cacheDir))
 			return;
@@ -158,13 +158,13 @@ public final class ResourcePackProtector
 		Path target = original;
 		if(CONFIG.shouldIsolateCache())
 		{
-			MinecraftClient mc = MinecraftClient.getInstance();
+			Minecraft mc = Minecraft.getInstance();
 			String accountSegment = "no-account";
-			if(mc != null && mc.getSession() != null)
+			if(mc != null && mc.getUser() != null)
 			{
 				try
 				{
-					UUID accountId = mc.getSession().getUuidOrNull();
+					UUID accountId = mc.getUser().getProfileId();
 					if(accountId != null)
 						accountSegment = accountId.toString();
 				}catch(Exception e)
@@ -191,19 +191,20 @@ public final class ResourcePackProtector
 	
 	private static InetSocketAddress getRemoteAddress()
 	{
-		MinecraftClient mc = MinecraftClient.getInstance();
+		Minecraft mc = Minecraft.getInstance();
 		if(mc == null)
 			return null;
 		
-		ClientPlayNetworkHandler handler = mc.getNetworkHandler();
+		ClientPacketListener handler = mc.getConnection();
 		if(handler == null)
 			return null;
 		
-		var address = handler.getConnection().getAddress();
+		var address = handler.getConnection().getRemoteAddress();
 		return address instanceof InetSocketAddress isa ? isa : null;
 	}
 	
-	public static PolicyResult evaluate(ResourcePackSendS2CPacket packet)
+	public static PolicyResult evaluate(
+		ClientboundResourcePackPushPacket packet)
 	{
 		if(packet == null)
 			return new PolicyResult(Decision.ALLOW, "No packet",
@@ -238,7 +239,7 @@ public final class ResourcePackProtector
 	}
 	
 	public static boolean applyDecision(PolicyResult result,
-		ClientConnection connection, MinecraftClient mcClient)
+		Connection connection, Minecraft mcClient)
 	{
 		if(result == null)
 			return false;
@@ -248,12 +249,12 @@ public final class ResourcePackProtector
 		{
 			case BLOCK ->
 			{
-				MinecraftClient target =
-					mcClient != null ? mcClient : MinecraftClient.getInstance();
+				Minecraft target =
+					mcClient != null ? mcClient : Minecraft.getInstance();
 				if(target != null)
-					target.getToastManager().toastQueue.clear();
+					target.getToastManager().queued.clear();
 				sendStatus(connection, context,
-					ResourcePackStatusC2SPacket.Status.DECLINED);
+					ServerboundResourcePackPacket.Action.DECLINED);
 				noteHandled(context);
 				return true;
 			}
@@ -261,10 +262,10 @@ public final class ResourcePackProtector
 			case SANDBOX ->
 			{
 				sendStatus(connection, context,
-					ResourcePackStatusC2SPacket.Status.FAILED_DOWNLOAD);
+					ServerboundResourcePackPacket.Action.FAILED_DOWNLOAD);
 				
-				MinecraftClient target =
-					mcClient != null ? mcClient : MinecraftClient.getInstance();
+				Minecraft target =
+					mcClient != null ? mcClient : Minecraft.getInstance();
 				if(target != null)
 					target.execute(() -> sandboxDownload(context));
 				return true;
@@ -374,7 +375,7 @@ public final class ResourcePackProtector
 					handleSandboxFailure(context, sandboxTarget,
 						new IOException("HTTP " + status), sandboxRequest,
 						dedupeKey);
-				}, Util.getIoWorkerExecutor());
+				}, Util.ioPool());
 			
 		}catch(Exception e)
 		{
@@ -390,7 +391,7 @@ public final class ResourcePackProtector
 	
 	public static void flushToasts()
 	{
-		MinecraftClient client = WurstClient.MC;
+		Minecraft client = WurstClient.MC;
 		if(client == null)
 			return;
 		
@@ -493,7 +494,7 @@ public final class ResourcePackProtector
 		if(!PROMPT_SNAPSHOTS.add(key))
 			return;
 		
-		MinecraftClient client = WurstClient.MC;
+		Minecraft client = WurstClient.MC;
 		if(client == null)
 		{
 			PROMPT_SNAPSHOTS.remove(key);
@@ -539,7 +540,7 @@ public final class ResourcePackProtector
 							+ context.host.displayName() + " ("
 							+ history.timestamps.size() + " packs / " + windowMs
 							+ "ms)";
-					MinecraftClient client = WurstClient.MC;
+					Minecraft client = WurstClient.MC;
 					if(client != null)
 					{
 						client.execute(() -> ChatUtils.warning(message));
@@ -600,7 +601,7 @@ public final class ResourcePackProtector
 		if(CONFIG.shouldExtractSandbox())
 			CompletableFuture
 				.runAsync(() -> extractSandboxPack(absolute, context),
-					Util.getIoWorkerExecutor())
+					Util.ioPool())
 				.whenComplete((unused, throwable) -> noteHandled(context));
 		else
 			noteHandled(context);
@@ -611,7 +612,7 @@ public final class ResourcePackProtector
 	{
 		CompletableFuture
 			.supplyAsync(() -> copyCachedPackSync(context, sandboxTarget),
-				Util.getIoWorkerExecutor())
+				Util.ioPool())
 			.whenComplete((absolute, throwable) -> {
 				if(throwable != null)
 				{
@@ -902,16 +903,16 @@ public final class ResourcePackProtector
 		return dot > 0 ? value.substring(0, dot) : value;
 	}
 	
-	private static void sendStatus(ClientConnection connection,
-		PackContext context, ResourcePackStatusC2SPacket.Status status)
+	private static void sendStatus(Connection connection, PackContext context,
+		ServerboundResourcePackPacket.Action status)
 	{
 		if(connection == null || status == null)
 			return;
 		
 		try
 		{
-			connection
-				.send(new ResourcePackStatusC2SPacket(context.packId, status));
+			connection.send(
+				new ServerboundResourcePackPacket(context.packId, status));
 		}catch(Exception e)
 		{
 			LOGGER.debug("Failed to send resource-pack status update.", e);
@@ -946,9 +947,9 @@ public final class ResourcePackProtector
 		if(!CONFIG.getToastVerbosity().allows(level))
 			return;
 		
-		Text toastTitle = Text.literal(title == null ? "" : title);
-		Text toastMessage = message == null || message.isBlank()
-			? Text.literal("") : Text.literal(message);
+		Component toastTitle = Component.literal(title == null ? "" : title);
+		Component toastMessage = message == null || message.isBlank()
+			? Component.literal("") : Component.literal(message);
 		
 		ToastPayload payload =
 			new ToastPayload(toToastType(level), toastTitle, toastMessage);
@@ -1065,13 +1066,13 @@ public final class ResourcePackProtector
 		return value.replace('\r', ' ').replace('\n', ' ').trim();
 	}
 	
-	private static SystemToast.Type toToastType(ToastLevel level)
+	private static SystemToast.SystemToastId toToastType(ToastLevel level)
 	{
 		return switch(level)
 		{
-			case INFO -> SystemToast.Type.NARRATOR_TOGGLE;
-			case WARN -> SystemToast.Type.UNSECURE_SERVER_WARNING;
-			case ERROR -> SystemToast.Type.PACK_LOAD_FAILURE;
+			case INFO -> SystemToast.SystemToastId.NARRATOR_TOGGLE;
+			case WARN -> SystemToast.SystemToastId.UNSECURE_SERVER_WARNING;
+			case ERROR -> SystemToast.SystemToastId.PACK_LOAD_FAILURE;
 		};
 	}
 	
@@ -1280,7 +1281,7 @@ public final class ResourcePackProtector
 		return null;
 	}
 	
-	private static Text invokeText(Object target, String... candidates)
+	private static Component invokeText(Object target, String... candidates)
 	{
 		for(String name : candidates)
 		{
@@ -1297,17 +1298,17 @@ public final class ResourcePackProtector
 					if(optional.isPresent())
 					{
 						Object value = optional.get();
-						if(value instanceof Text text)
+						if(value instanceof Component text)
 							return text;
-						return Text.literal(Objects.toString(value, ""));
+						return Component.literal(Objects.toString(value, ""));
 					}
 					continue;
 				}
 				
-				if(result instanceof Text text)
+				if(result instanceof Component text)
 					return text;
 				
-				return Text.literal(Objects.toString(result, ""));
+				return Component.literal(Objects.toString(result, ""));
 				
 			}catch(ReflectiveOperationException e)
 			{
@@ -1435,7 +1436,8 @@ public final class ResourcePackProtector
 		return false;
 	}
 	
-	private static PackContext buildContext(ResourcePackSendS2CPacket packet)
+	private static PackContext buildContext(
+		ClientboundResourcePackPushPacket packet)
 	{
 		String url = invokeString(packet, "getUrl", "getURL", "url");
 		String hash = invokeString(packet, "getHash", "hash", "getHashValue");
@@ -1447,7 +1449,7 @@ public final class ResourcePackProtector
 			invokeBoolean(packet, false, "isRequired", "isMandatory");
 		
 		UUID packId = invokeUuid(packet, "getId", "id");
-		Text promptText = invokeText(packet, "getPrompt", "prompt");
+		Component promptText = invokeText(packet, "getPrompt", "prompt");
 		String prompt =
 			promptText == null ? "" : sanitizeMultiline(promptText.getString());
 		
@@ -1466,7 +1468,7 @@ public final class ResourcePackProtector
 	private record PackContext(String url, String hash, HostInfo host,
 		boolean required, String cacheKey, UUID packId, String prompt)
 	{
-		static PackContext from(ResourcePackSendS2CPacket packet)
+		static PackContext from(ClientboundResourcePackPushPacket packet)
 		{
 			try
 			{
@@ -1637,7 +1639,7 @@ public final class ResourcePackProtector
 		PackContext context)
 	{}
 	
-	private record ToastPayload(SystemToast.Type type, Text title,
-		Text description)
+	private record ToastPayload(SystemToast.SystemToastId type, Component title,
+		Component description)
 	{}
 }
diff --git a/src/main/java/net/wurstclient/Feature.java b/src/main/java/net/wurstclient/Feature.java
index 9b73ad818..53dc00f64 100644
--- a/src/main/java/net/wurstclient/Feature.java
+++ b/src/main/java/net/wurstclient/Feature.java
@@ -12,8 +12,7 @@ import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
-
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.keybinds.PossibleKeybind;
 import net.wurstclient.mixinterface.IMinecraftClient;
@@ -24,7 +23,7 @@ public abstract class Feature
 {
 	protected static final WurstClient WURST = WurstClient.INSTANCE;
 	protected static final EventManager EVENTS = WURST.getEventManager();
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	protected static final IMinecraftClient IMC = WurstClient.IMC;
 	
 	private final LinkedHashMap<String, Setting> settings =
diff --git a/src/main/java/net/wurstclient/FriendsList.java b/src/main/java/net/wurstclient/FriendsList.java
index 8e5a37711..bf0e42eb2 100644
--- a/src/main/java/net/wurstclient/FriendsList.java
+++ b/src/main/java/net/wurstclient/FriendsList.java
@@ -14,9 +14,8 @@ import java.util.ArrayList;
 import java.util.TreeSet;
 
 import com.google.gson.JsonArray;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
 import net.wurstclient.commands.FriendsCmd;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.util.json.JsonException;
@@ -52,7 +51,7 @@ public class FriendsList
 	
 	public void middleClick(Entity entity)
 	{
-		if(entity == null || !(entity instanceof PlayerEntity))
+		if(entity == null || !(entity instanceof Player))
 			return;
 		
 		FriendsCmd friendsCmd = WurstClient.INSTANCE.getCmds().friendsCmd;
diff --git a/src/main/java/net/wurstclient/RotationFaker.java b/src/main/java/net/wurstclient/RotationFaker.java
index e1143c82f..cf6359990 100644
--- a/src/main/java/net/wurstclient/RotationFaker.java
+++ b/src/main/java/net/wurstclient/RotationFaker.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.events.PostMotionListener;
 import net.wurstclient.events.PreMotionListener;
 import net.wurstclient.util.Rotation;
@@ -29,11 +29,11 @@ public final class RotationFaker
 		if(!fakeRotation)
 			return;
 		
-		ClientPlayerEntity player = WurstClient.MC.player;
-		realYaw = player.getYaw();
-		realPitch = player.getPitch();
-		player.setYaw(serverYaw);
-		player.setPitch(serverPitch);
+		LocalPlayer player = WurstClient.MC.player;
+		realYaw = player.getYRot();
+		realPitch = player.getXRot();
+		player.setYRot(serverYaw);
+		player.setXRot(serverPitch);
 	}
 	
 	@Override
@@ -42,50 +42,50 @@ public final class RotationFaker
 		if(!fakeRotation)
 			return;
 		
-		ClientPlayerEntity player = WurstClient.MC.player;
-		player.setYaw(realYaw);
-		player.setPitch(realPitch);
+		LocalPlayer player = WurstClient.MC.player;
+		player.setYRot(realYaw);
+		player.setXRot(realPitch);
 		fakeRotation = false;
 	}
 	
-	public void faceVectorPacket(Vec3d vec)
+	public void faceVectorPacket(Vec3 vec)
 	{
 		Rotation needed = RotationUtils.getNeededRotations(vec);
-		ClientPlayerEntity player = WurstClient.MC.player;
+		LocalPlayer player = WurstClient.MC.player;
 		
 		fakeRotation = true;
 		serverYaw =
-			RotationUtils.limitAngleChange(player.getYaw(), needed.yaw());
+			RotationUtils.limitAngleChange(player.getYRot(), needed.yaw());
 		serverPitch = needed.pitch();
 	}
 	
-	public void faceVectorClient(Vec3d vec)
+	public void faceVectorClient(Vec3 vec)
 	{
 		Rotation needed = RotationUtils.getNeededRotations(vec);
 		
-		ClientPlayerEntity player = WurstClient.MC.player;
-		player.setYaw(
-			RotationUtils.limitAngleChange(player.getYaw(), needed.yaw()));
-		player.setPitch(needed.pitch());
+		LocalPlayer player = WurstClient.MC.player;
+		player.setYRot(
+			RotationUtils.limitAngleChange(player.getYRot(), needed.yaw()));
+		player.setXRot(needed.pitch());
 	}
 	
-	public void faceVectorClientIgnorePitch(Vec3d vec)
+	public void faceVectorClientIgnorePitch(Vec3 vec)
 	{
 		Rotation needed = RotationUtils.getNeededRotations(vec);
 		
-		ClientPlayerEntity player = WurstClient.MC.player;
-		player.setYaw(
-			RotationUtils.limitAngleChange(player.getYaw(), needed.yaw()));
-		player.setPitch(0);
+		LocalPlayer player = WurstClient.MC.player;
+		player.setYRot(
+			RotationUtils.limitAngleChange(player.getYRot(), needed.yaw()));
+		player.setXRot(0);
 	}
 	
 	public float getServerYaw()
 	{
-		return fakeRotation ? serverYaw : WurstClient.MC.player.getYaw();
+		return fakeRotation ? serverYaw : WurstClient.MC.player.getYRot();
 	}
 	
 	public float getServerPitch()
 	{
-		return fakeRotation ? serverPitch : WurstClient.MC.player.getPitch();
+		return fakeRotation ? serverPitch : WurstClient.MC.player.getXRot();
 	}
 }
diff --git a/src/main/java/net/wurstclient/WurstClient.java b/src/main/java/net/wurstclient/WurstClient.java
index b6e30db9e..7425d4425 100644
--- a/src/main/java/net/wurstclient/WurstClient.java
+++ b/src/main/java/net/wurstclient/WurstClient.java
@@ -13,8 +13,7 @@ import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.altmanager.AltManager;
 import net.wurstclient.altmanager.Encryption;
 import net.wurstclient.analytics.PlausibleAnalytics;
@@ -50,7 +49,7 @@ public enum WurstClient
 {
 	INSTANCE;
 	
-	public static MinecraftClient MC;
+	public static Minecraft MC;
 	public static IMinecraftClient IMC;
 	
 	public static final String VERSION = "7.51.1";
@@ -84,7 +83,7 @@ public enum WurstClient
 	{
 		System.out.println("Starting Wurst Client...");
 		
-		MC = MinecraftClient.getInstance();
+		MC = Minecraft.getInstance();
 		IMC = (IMinecraftClient)MC;
 		wurstFolder = createWurstFolder();
 		
@@ -153,7 +152,7 @@ public enum WurstClient
 	
 	private Path createWurstFolder()
 	{
-		Path dotMinecraftFolder = MC.runDirectory.toPath().normalize();
+		Path dotMinecraftFolder = MC.gameDirectory.toPath().normalize();
 		String folderName = BuildConfig.NICE_WURST ? "nicewurst" : "wurst";
 		Path wurstFolder = dotMinecraftFolder.resolve(folderName);
 		
diff --git a/src/main/java/net/wurstclient/WurstRenderLayers.java b/src/main/java/net/wurstclient/WurstRenderLayers.java
index 991a8fa9d..c8f9d4cff 100644
--- a/src/main/java/net/wurstclient/WurstRenderLayers.java
+++ b/src/main/java/net/wurstclient/WurstRenderLayers.java
@@ -8,95 +8,103 @@
 package net.wurstclient;
 
 import java.util.OptionalDouble;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.RenderPhase;
+import net.minecraft.client.renderer.RenderStateShard;
+import net.minecraft.client.renderer.RenderType;
 
 public enum WurstRenderLayers
 {
 	;
 	
 	/**
-	 * Similar to {@link RenderLayer#getLines()}, but with line width 2.
+	 * Similar to {@link RenderType#lines()}, but with line width 2.
 	 */
-	public static final RenderLayer.MultiPhase LINES = RenderLayer.of(
-		"wurst:lines", 1536, WurstShaderPipelines.DEPTH_TEST_LINES,
-		RenderLayer.MultiPhaseParameters.builder()
-			.lineWidth(new RenderPhase.LineWidth(OptionalDouble.of(2)))
-			.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-			.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+	public static final RenderType.CompositeRenderType LINES = RenderType
+		.create("wurst:lines", 1536, WurstShaderPipelines.DEPTH_TEST_LINES,
+			RenderType.CompositeState.builder()
+				.setLineState(
+					new RenderStateShard.LineStateShard(OptionalDouble.of(2)))
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getLines()}, but with line width 2 and no
+	 * Similar to {@link RenderType#lines()}, but with line width 2 and no
 	 * depth test.
 	 */
-	public static final RenderLayer.MultiPhase ESP_LINES =
-		RenderLayer.of("wurst:esp_lines", 1536, WurstShaderPipelines.ESP_LINES,
-			RenderLayer.MultiPhaseParameters.builder()
-				.lineWidth(new RenderPhase.LineWidth(OptionalDouble.of(2)))
-				.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-				.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+	public static final RenderType.CompositeRenderType ESP_LINES = RenderType
+		.create("wurst:esp_lines", 1536, WurstShaderPipelines.ESP_LINES,
+			RenderType.CompositeState.builder()
+				.setLineState(
+					new RenderStateShard.LineStateShard(OptionalDouble.of(2)))
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getLineStrip()}, but with line width 2.
+	 * Similar to {@link RenderType#lineStrip()}, but with line width 2.
 	 */
-	public static final RenderLayer.MultiPhase LINE_STRIP =
-		RenderLayer.of("wurst:line_strip", 1536, false, true,
+	public static final RenderType.CompositeRenderType LINE_STRIP =
+		RenderType.create("wurst:line_strip", 1536, false, true,
 			WurstShaderPipelines.DEPTH_TEST_LINE_STRIP,
-			RenderLayer.MultiPhaseParameters.builder()
-				.lineWidth(new RenderPhase.LineWidth(OptionalDouble.of(2)))
-				.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-				.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+			RenderType.CompositeState.builder()
+				.setLineState(
+					new RenderStateShard.LineStateShard(OptionalDouble.of(2)))
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getLineStrip()}, but with line width 2 and
+	 * Similar to {@link RenderType#lineStrip()}, but with line width 2 and
 	 * no depth test.
 	 */
-	public static final RenderLayer.MultiPhase ESP_LINE_STRIP =
-		RenderLayer.of("wurst:esp_line_strip", 1536, false, true,
+	public static final RenderType.CompositeRenderType ESP_LINE_STRIP =
+		RenderType.create("wurst:esp_line_strip", 1536, false, true,
 			WurstShaderPipelines.ESP_LINE_STRIP,
-			RenderLayer.MultiPhaseParameters.builder()
-				.lineWidth(new RenderPhase.LineWidth(OptionalDouble.of(2)))
-				.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-				.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+			RenderType.CompositeState.builder()
+				.setLineState(
+					new RenderStateShard.LineStateShard(OptionalDouble.of(2)))
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getDebugQuads()}, but with culling enabled.
+	 * Similar to {@link RenderType#debugQuads()}, but with culling enabled.
 	 */
-	public static final RenderLayer.MultiPhase QUADS = RenderLayer.of(
-		"wurst:quads", 1536, false, true, WurstShaderPipelines.QUADS,
-		RenderLayer.MultiPhaseParameters.builder().build(false));
+	public static final RenderType.CompositeRenderType QUADS = RenderType
+		.create("wurst:quads", 1536, false, true, WurstShaderPipelines.QUADS,
+			RenderType.CompositeState.builder().createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getDebugQuads()}, but without back-face
+	 * Similar to {@link RenderType#debugQuads()}, but without back-face
 	 * culling.
 	 */
-	public static final RenderLayer.MultiPhase QUADS_NO_CULLING =
-		RenderLayer.of("wurst:quads_no_culling", 1536, false, true,
+	public static final RenderType.CompositeRenderType QUADS_NO_CULLING =
+		RenderType.create("wurst:quads_no_culling", 1536, false, true,
 			WurstShaderPipelines.QUADS_NO_CULLING,
-			RenderLayer.MultiPhaseParameters.builder().build(false));
+			RenderType.CompositeState.builder().createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getDebugQuads()}, but with culling enabled
+	 * Similar to {@link RenderType#debugQuads()}, but with culling enabled
 	 * and no depth test.
 	 */
-	public static final RenderLayer.MultiPhase ESP_QUADS = RenderLayer.of(
-		"wurst:esp_quads", 1536, false, true, WurstShaderPipelines.ESP_QUADS,
-		RenderLayer.MultiPhaseParameters.builder().build(false));
+	public static final RenderType.CompositeRenderType ESP_QUADS =
+		RenderType.create("wurst:esp_quads", 1536, false, true,
+			WurstShaderPipelines.ESP_QUADS,
+			RenderType.CompositeState.builder().createCompositeState(false));
 	
 	/**
-	 * Similar to {@link RenderLayer#getDebugQuads()}, but with no depth test.
+	 * Similar to {@link RenderType#debugQuads()}, but with no depth test.
 	 */
-	public static final RenderLayer.MultiPhase ESP_QUADS_NO_CULLING =
-		RenderLayer.of("wurst:esp_quads_no_culling", 1536, false, true,
+	public static final RenderType.CompositeRenderType ESP_QUADS_NO_CULLING =
+		RenderType.create("wurst:esp_quads_no_culling", 1536, false, true,
 			WurstShaderPipelines.ESP_QUADS_NO_CULLING,
-			RenderLayer.MultiPhaseParameters.builder().build(false));
+			RenderType.CompositeState.builder().createCompositeState(false));
 	
 	/**
 	 * Returns either {@link #QUADS} or {@link #ESP_QUADS} depending on the
 	 * value of {@code depthTest}.
 	 */
-	public static RenderLayer.MultiPhase getQuads(boolean depthTest)
+	public static RenderType.CompositeRenderType getQuads(boolean depthTest)
 	{
 		return depthTest ? QUADS : ESP_QUADS;
 	}
@@ -105,7 +113,7 @@ public enum WurstRenderLayers
 	 * Returns either {@link #LINES} or {@link #ESP_LINES} depending on the
 	 * value of {@code depthTest}.
 	 */
-	public static RenderLayer.MultiPhase getLines(boolean depthTest)
+	public static RenderType.CompositeRenderType getLines(boolean depthTest)
 	{
 		return depthTest ? LINES : ESP_LINES;
 	}
@@ -113,24 +121,26 @@ public enum WurstRenderLayers
 	/**
 	 * Returns a line render layer with a custom width.
 	 */
-	public static RenderLayer.MultiPhase getLines(boolean depthTest,
+	public static RenderType.CompositeRenderType getLines(boolean depthTest,
 		double width)
 	{
-		return RenderLayer.of(
+		return RenderType.create(
 			depthTest ? "wurst:lines_custom" : "wurst:esp_lines_custom", 1536,
 			depthTest ? WurstShaderPipelines.DEPTH_TEST_LINES
 				: WurstShaderPipelines.ESP_LINES,
-			RenderLayer.MultiPhaseParameters.builder()
-				.lineWidth(new RenderPhase.LineWidth(OptionalDouble.of(width)))
-				.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-				.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+			RenderType.CompositeState.builder()
+				.setLineState(new RenderStateShard.LineStateShard(
+					OptionalDouble.of(width)))
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	}
 	
 	/**
 	 * Returns either {@link #LINE_STRIP} or {@link #ESP_LINE_STRIP} depending
 	 * on the value of {@code depthTest}.
 	 */
-	public static RenderLayer.MultiPhase getLineStrip(boolean depthTest)
+	public static RenderType.CompositeRenderType getLineStrip(boolean depthTest)
 	{
 		return depthTest ? LINE_STRIP : ESP_LINE_STRIP;
 	}
@@ -138,19 +148,20 @@ public enum WurstRenderLayers
 	/**
 	 * Line strip with custom width.
 	 */
-	public static RenderLayer.MultiPhase getLineStrip(boolean depthTest,
+	public static RenderType.CompositeRenderType getLineStrip(boolean depthTest,
 		double width)
 	{
-		return RenderLayer.of(
+		return RenderType.create(
 			depthTest
 				? "wurst:line_strip_custom" : "wurst:esp_line_strip_custom",
 			1536,
 			depthTest ? WurstShaderPipelines.DEPTH_TEST_LINE_STRIP
 				: WurstShaderPipelines.ESP_LINE_STRIP,
-			RenderLayer.MultiPhaseParameters.builder()
-				.lineWidth(new RenderPhase.LineWidth(
+			RenderType.CompositeState.builder()
+				.setLineState(new RenderStateShard.LineStateShard(
 					java.util.OptionalDouble.of(width)))
-				.layering(RenderLayer.VIEW_OFFSET_Z_LAYERING)
-				.target(RenderLayer.ITEM_ENTITY_TARGET).build(false));
+				.setLayeringState(RenderType.VIEW_OFFSET_Z_LAYERING)
+				.setOutputState(RenderType.ITEM_ENTITY_TARGET)
+				.createCompositeState(false));
 	}
 }
diff --git a/src/main/java/net/wurstclient/WurstShaderPipelines.java b/src/main/java/net/wurstclient/WurstShaderPipelines.java
index ade1a3f9e..41f0f0419 100644
--- a/src/main/java/net/wurstclient/WurstShaderPipelines.java
+++ b/src/main/java/net/wurstclient/WurstShaderPipelines.java
@@ -11,11 +11,10 @@ import com.mojang.blaze3d.pipeline.BlendFunction;
 import com.mojang.blaze3d.pipeline.RenderPipeline;
 import com.mojang.blaze3d.pipeline.RenderPipeline.Snippet;
 import com.mojang.blaze3d.platform.DepthTestFunction;
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.client.gl.RenderPipelines;
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.util.Identifier;
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
+import net.minecraft.client.renderer.RenderPipelines;
+import net.minecraft.resources.ResourceLocation;
 
 public enum WurstShaderPipelines
 {
@@ -25,12 +24,12 @@ public enum WurstShaderPipelines
 	 * Similar to the RENDERTYPE_LINES Snippet, but without fog.
 	 */
 	public static final Snippet FOGLESS_LINES_SNIPPET = RenderPipeline
-		.builder(RenderPipelines.TRANSFORMS_PROJECTION_FOG_SNIPPET,
+		.builder(RenderPipelines.MATRICES_FOG_SNIPPET,
 			RenderPipelines.GLOBALS_SNIPPET)
-		.withVertexShader(Identifier.of("wurst:core/fogless_lines"))
-		.withFragmentShader(Identifier.of("wurst:core/fogless_lines"))
+		.withVertexShader(ResourceLocation.parse("wurst:core/fogless_lines"))
+		.withFragmentShader(ResourceLocation.parse("wurst:core/fogless_lines"))
 		.withBlend(BlendFunction.TRANSLUCENT).withCull(false)
-		.withVertexFormat(VertexFormats.POSITION_COLOR_NORMAL, DrawMode.LINES)
+		.withVertexFormat(DefaultVertexFormat.POSITION_COLOR_NORMAL, Mode.LINES)
 		.buildSnippet();
 	
 	/**
@@ -39,7 +38,7 @@ public enum WurstShaderPipelines
 	public static final RenderPipeline DEPTH_TEST_LINES =
 		RenderPipelines.register(RenderPipeline.builder(FOGLESS_LINES_SNIPPET)
 			.withLocation(
-				Identifier.of("wurst:pipeline/wurst_depth_test_lines"))
+				ResourceLocation.parse("wurst:pipeline/wurst_depth_test_lines"))
 			.build());
 	
 	/**
@@ -47,7 +46,8 @@ public enum WurstShaderPipelines
 	 */
 	public static final RenderPipeline ESP_LINES =
 		RenderPipelines.register(RenderPipeline.builder(FOGLESS_LINES_SNIPPET)
-			.withLocation(Identifier.of("wurst:pipeline/wurst_esp_lines"))
+			.withLocation(
+				ResourceLocation.parse("wurst:pipeline/wurst_esp_lines"))
 			.withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
 	
 	/**
@@ -55,10 +55,10 @@ public enum WurstShaderPipelines
 	 */
 	public static final RenderPipeline DEPTH_TEST_LINE_STRIP =
 		RenderPipelines.register(RenderPipeline.builder(FOGLESS_LINES_SNIPPET)
-			.withLocation(
-				Identifier.of("wurst:pipeline/wurst_depth_test_line_strip"))
-			.withVertexFormat(VertexFormats.POSITION_COLOR_NORMAL,
-				DrawMode.LINE_STRIP)
+			.withLocation(ResourceLocation
+				.parse("wurst:pipeline/wurst_depth_test_line_strip"))
+			.withVertexFormat(DefaultVertexFormat.POSITION_COLOR_NORMAL,
+				Mode.LINE_STRIP)
 			.build());
 	
 	/**
@@ -66,17 +66,18 @@ public enum WurstShaderPipelines
 	 */
 	public static final RenderPipeline ESP_LINE_STRIP =
 		RenderPipelines.register(RenderPipeline.builder(FOGLESS_LINES_SNIPPET)
-			.withLocation(Identifier.of("wurst:pipeline/wurst_esp_line_strip"))
-			.withVertexFormat(VertexFormats.POSITION_COLOR_NORMAL,
-				DrawMode.LINE_STRIP)
+			.withLocation(
+				ResourceLocation.parse("wurst:pipeline/wurst_esp_line_strip"))
+			.withVertexFormat(DefaultVertexFormat.POSITION_COLOR_NORMAL,
+				Mode.LINE_STRIP)
 			.withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
 	
 	/**
 	 * Similar to the DEBUG_QUADS ShaderPipeline, but with culling enabled.
 	 */
 	public static final RenderPipeline QUADS = RenderPipelines
-		.register(RenderPipeline.builder(RenderPipelines.POSITION_COLOR_SNIPPET)
-			.withLocation(Identifier.of("wurst:pipeline/wurst_quads"))
+		.register(RenderPipeline.builder(RenderPipelines.DEBUG_FILLED_SNIPPET)
+			.withLocation(ResourceLocation.parse("wurst:pipeline/wurst_quads"))
 			.withDepthTestFunction(DepthTestFunction.LEQUAL_DEPTH_TEST)
 			.build());
 	
@@ -84,9 +85,9 @@ public enum WurstShaderPipelines
 	 * Similar to the DEBUG_QUADS ShaderPipeline, but with no back-face culling.
 	 */
 	public static final RenderPipeline QUADS_NO_CULLING = RenderPipelines
-		.register(RenderPipeline.builder(RenderPipelines.POSITION_COLOR_SNIPPET)
+		.register(RenderPipeline.builder(RenderPipelines.DEBUG_FILLED_SNIPPET)
 			.withLocation(
-				Identifier.of("wurst:pipeline/wurst_quads_no_culling"))
+				ResourceLocation.parse("wurst:pipeline/wurst_quads_no_culling"))
 			.withCull(false)
 			.withDepthTestFunction(DepthTestFunction.LEQUAL_DEPTH_TEST)
 			.build());
@@ -96,16 +97,18 @@ public enum WurstShaderPipelines
 	 * and no depth test.
 	 */
 	public static final RenderPipeline ESP_QUADS = RenderPipelines
-		.register(RenderPipeline.builder(RenderPipelines.POSITION_COLOR_SNIPPET)
-			.withLocation(Identifier.of("wurst:pipeline/wurst_esp_quads"))
+		.register(RenderPipeline.builder(RenderPipelines.DEBUG_FILLED_SNIPPET)
+			.withLocation(
+				ResourceLocation.parse("wurst:pipeline/wurst_esp_quads"))
 			.withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
 	
 	/**
 	 * Similar to the DEBUG_QUADS ShaderPipeline, but with no depth test.
 	 */
 	public static final RenderPipeline ESP_QUADS_NO_CULLING = RenderPipelines
-		.register(RenderPipeline.builder(RenderPipelines.POSITION_COLOR_SNIPPET)
-			.withLocation(Identifier.of("wurst:pipeline/wurst_esp_quads"))
+		.register(RenderPipeline.builder(RenderPipelines.DEBUG_FILLED_SNIPPET)
+			.withLocation(
+				ResourceLocation.parse("wurst:pipeline/wurst_esp_quads"))
 			.withCull(false)
 			.withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
 }
diff --git a/src/main/java/net/wurstclient/WurstTranslator.java b/src/main/java/net/wurstclient/WurstTranslator.java
index 4a433b0fe..ef9f66c01 100644
--- a/src/main/java/net/wurstclient/WurstTranslator.java
+++ b/src/main/java/net/wurstclient/WurstTranslator.java
@@ -16,30 +16,28 @@ import java.util.IllegalFormatException;
 import java.util.List;
 import java.util.Map;
 import java.util.function.BiConsumer;
-
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.resources.language.ClientLanguage;
+import net.minecraft.client.resources.language.I18n;
+import net.minecraft.locale.Language;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.packs.resources.Resource;
+import net.minecraft.server.packs.resources.ResourceManager;
+import net.minecraft.server.packs.resources.ResourceManagerReloadListener;
 import com.google.common.collect.Lists;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.resource.language.I18n;
-import net.minecraft.client.resource.language.TranslationStorage;
-import net.minecraft.resource.Resource;
-import net.minecraft.resource.ResourceManager;
-import net.minecraft.resource.SynchronousResourceReloader;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.Language;
-
-public class WurstTranslator implements SynchronousResourceReloader
+public class WurstTranslator implements ResourceManagerReloadListener
 {
 	private final WurstClient wurst = WurstClient.INSTANCE;
-	private TranslationStorage mcEnglish;
+	private ClientLanguage mcEnglish;
 	
 	private Map<String, String> currentLangStrings = Map.of();
 	private Map<String, String> englishOnlyStrings = Map.of();
 	
 	@Override
-	public void reload(ResourceManager manager)
+	public void onResourceManagerReload(ResourceManager manager)
 	{
-		mcEnglish = TranslationStorage.load(manager,
+		mcEnglish = ClientLanguage.loadFrom(manager,
 			Lists.newArrayList("en_us"), false);
 		
 		HashMap<String, String> currentLangStrings = new HashMap<>();
@@ -89,7 +87,7 @@ public class WurstTranslator implements SynchronousResourceReloader
 	{
 		String string = englishOnlyStrings.get(key);
 		if(string == null)
-			string = mcEnglish.get(key);
+			string = mcEnglish.getOrDefault(key);
 		
 		try
 		{
@@ -107,13 +105,13 @@ public class WurstTranslator implements SynchronousResourceReloader
 	 * Minecraft's own translations.
 	 *
 	 * @apiNote This method differs from
-	 *          {@link I18n#translate(String, Object...)} in that it does not
+	 *          {@link I18n#get(String, Object...)} in that it does not
 	 *          return "Format error" if the key contains a percent sign.
 	 */
 	public String translateMc(String key, Object... args)
 	{
-		if(I18n.hasTranslation(key))
-			return I18n.translate(key, args);
+		if(I18n.exists(key))
+			return I18n.get(key, args);
 		
 		return key;
 	}
@@ -123,14 +121,14 @@ public class WurstTranslator implements SynchronousResourceReloader
 	 * the current language, using only Minecraft's own translations.
 	 *
 	 * @apiNote This method differs from
-	 *          {@link I18n#translate(String, Object...)} in that it does not
+	 *          {@link I18n#get(String, Object...)} in that it does not
 	 *          return "Format error" if the key contains a percent sign.
 	 */
 	public String translateMcEnglish(String key, Object... args)
 	{
 		try
 		{
-			return String.format(mcEnglish.get(key), args);
+			return String.format(mcEnglish.getOrDefault(key), args);
 			
 		}catch(IllegalFormatException e)
 		{
@@ -147,7 +145,7 @@ public class WurstTranslator implements SynchronousResourceReloader
 	 * Returns a translation storage for Minecraft's English strings, regardless
 	 * of the current language. Does not include any of Wurst's translations.
 	 */
-	public TranslationStorage getMcEnglish()
+	public ClientLanguage getMcEnglish()
 	{
 		return mcEnglish;
 	}
@@ -167,8 +165,8 @@ public class WurstTranslator implements SynchronousResourceReloader
 	{
 		// Weird bug: Some users have their language set to "en_US" instead of
 		// "en_us" for some reason. Last seen in 1.21.
-		String mainLangCode = MinecraftClient.getInstance().getLanguageManager()
-			.getLanguage().toLowerCase();
+		String mainLangCode = Minecraft.getInstance().getLanguageManager()
+			.getSelected().toLowerCase();
 		
 		ArrayList<String> langCodes = new ArrayList<>();
 		langCodes.add("en_us");
@@ -184,17 +182,18 @@ public class WurstTranslator implements SynchronousResourceReloader
 		for(String langCode : langCodes)
 		{
 			String langFilePath = "translations/" + langCode + ".json";
-			Identifier langId = Identifier.of("wurst", langFilePath);
+			ResourceLocation langId =
+				ResourceLocation.fromNamespaceAndPath("wurst", langFilePath);
 			
-			for(Resource resource : manager.getAllResources(langId))
-				try(InputStream stream = resource.getInputStream())
+			for(Resource resource : manager.getResourceStack(langId))
+				try(InputStream stream = resource.open())
 				{
-					Language.load(stream, entryConsumer);
+					Language.loadFromJson(stream, entryConsumer);
 					
 				}catch(IOException e)
 				{
 					System.out.println("Failed to load translations for "
-						+ langCode + " from pack " + resource.getPackId());
+						+ langCode + " from pack " + resource.sourcePackId());
 					e.printStackTrace();
 				}
 		}
diff --git a/src/main/java/net/wurstclient/ai/FlyPathProcessor.java b/src/main/java/net/wurstclient/ai/FlyPathProcessor.java
index cecd376a2..bf4c0839a 100644
--- a/src/main/java/net/wurstclient/ai/FlyPathProcessor.java
+++ b/src/main/java/net/wurstclient/ai/FlyPathProcessor.java
@@ -8,12 +8,11 @@
 package net.wurstclient.ai;
 
 import java.util.ArrayList;
-
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.Vec3i;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Vec3i;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.util.RotationUtils;
 
 public class FlyPathProcessor extends PathProcessor
@@ -30,11 +29,11 @@ public class FlyPathProcessor extends PathProcessor
 	public void process()
 	{
 		// get positions
-		BlockPos pos = BlockPos.ofFloored(MC.player.getEntityPos());
-		Vec3d posVec = MC.player.getEntityPos();
+		BlockPos pos = BlockPos.containing(MC.player.position());
+		Vec3 posVec = MC.player.position();
 		BlockPos nextPos = path.get(index);
 		int posIndex = path.indexOf(pos);
-		Box nextBox = new Box(nextPos.getX() + 0.3, nextPos.getY(),
+		AABB nextBox = new AABB(nextPos.getX() + 0.3, nextPos.getY(),
 			nextPos.getZ() + 0.3, nextPos.getX() + 0.7, nextPos.getY() + 0.2,
 			nextPos.getZ() + 0.7);
 		
@@ -57,9 +56,10 @@ public class FlyPathProcessor extends PathProcessor
 			// stop when changing directions
 			if(creativeFlying)
 			{
-				Vec3d v = MC.player.getVelocity();
+				Vec3 v = MC.player.getDeltaMovement();
 				
-				MC.player.setVelocity(v.x / Math.max(Math.abs(v.x) * 50, 1),
+				MC.player.setDeltaMovement(
+					v.x / Math.max(Math.abs(v.x) * 50, 1),
 					v.y / Math.max(Math.abs(v.y) * 50, 1),
 					v.z / Math.max(Math.abs(v.z) * 50, 1));
 			}
@@ -81,73 +81,73 @@ public class FlyPathProcessor extends PathProcessor
 		if(horizontal)
 		{
 			facePosition(nextPos);
-			if(Math.abs(MathHelper.wrapDegrees(RotationUtils
-				.getHorizontalAngleToLookVec(Vec3d.ofCenter(nextPos)))) > 1)
+			if(Math.abs(Mth.wrapDegrees(RotationUtils
+				.getHorizontalAngleToLookVec(Vec3.atCenterOf(nextPos)))) > 1)
 				return;
 		}
 		
 		// skip mid-air nodes
 		Vec3i offset = nextPos.subtract(pos);
 		while(index < path.size() - 1
-			&& path.get(index).add(offset).equals(path.get(index + 1)))
+			&& path.get(index).offset(offset).equals(path.get(index + 1)))
 			index++;
 		
 		if(creativeFlying)
 		{
-			Vec3d v = MC.player.getVelocity();
+			Vec3 v = MC.player.getDeltaMovement();
 			
 			if(!x)
-				MC.player.setVelocity(v.x / Math.max(Math.abs(v.x) * 50, 1),
-					v.y, v.z);
+				MC.player.setDeltaMovement(
+					v.x / Math.max(Math.abs(v.x) * 50, 1), v.y, v.z);
 			if(!y)
-				MC.player.setVelocity(v.x,
+				MC.player.setDeltaMovement(v.x,
 					v.y / Math.max(Math.abs(v.y) * 50, 1), v.z);
 			if(!z)
-				MC.player.setVelocity(v.x, v.y,
+				MC.player.setDeltaMovement(v.x, v.y,
 					v.z / Math.max(Math.abs(v.z) * 50, 1));
 		}
 		
-		Vec3d vecInPos = new Vec3d(nextPos.getX() + 0.5, nextPos.getY() + 0.1,
+		Vec3 vecInPos = new Vec3(nextPos.getX() + 0.5, nextPos.getY() + 0.1,
 			nextPos.getZ() + 0.5);
 		
 		// horizontal movement
 		if(horizontal)
 		{
-			if(!creativeFlying && MC.player.getEntityPos().distanceTo(
+			if(!creativeFlying && MC.player.position().distanceTo(
 				vecInPos) <= WURST.getHax().flightHack.horizontalSpeed
 					.getValue())
 			{
-				MC.player.setPosition(vecInPos.x, vecInPos.y, vecInPos.z);
+				MC.player.setPos(vecInPos.x, vecInPos.y, vecInPos.z);
 				return;
 			}
 			
-			MC.options.forwardKey.setPressed(true);
+			MC.options.keyUp.setDown(true);
 			
 			if(MC.player.horizontalCollision)
 				if(posVec.y > nextBox.maxY)
-					MC.options.sneakKey.setPressed(true);
+					MC.options.keyShift.setDown(true);
 				else if(posVec.y < nextBox.minY)
-					MC.options.jumpKey.setPressed(true);
+					MC.options.keyJump.setDown(true);
 				
 			// vertical movement
 		}else if(y)
 		{
-			if(!creativeFlying && MC.player.getEntityPos().distanceTo(
+			if(!creativeFlying && MC.player.position().distanceTo(
 				vecInPos) <= WURST.getHax().flightHack.verticalSpeed.getValue())
 			{
-				MC.player.setPosition(vecInPos.x, vecInPos.y, vecInPos.z);
+				MC.player.setPos(vecInPos.x, vecInPos.y, vecInPos.z);
 				return;
 			}
 			
 			if(posVec.y < nextBox.minY)
-				MC.options.jumpKey.setPressed(true);
+				MC.options.keyJump.setDown(true);
 			else
-				MC.options.sneakKey.setPressed(true);
+				MC.options.keyShift.setDown(true);
 			
 			if(MC.player.verticalCollision)
 			{
-				MC.options.sneakKey.setPressed(false);
-				MC.options.forwardKey.setPressed(true);
+				MC.options.keyShift.setDown(false);
+				MC.options.keyUp.setDown(true);
 			}
 		}
 	}
diff --git a/src/main/java/net/wurstclient/ai/PathFinder.java b/src/main/java/net/wurstclient/ai/PathFinder.java
index 9cffe895c..65b4a1dfb 100644
--- a/src/main/java/net/wurstclient/ai/PathFinder.java
+++ b/src/main/java/net/wurstclient/ai/PathFinder.java
@@ -7,24 +7,40 @@
  */
 package net.wurstclient.ai;
 
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map.Entry;
 
-import net.minecraft.block.*;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.fluid.Fluid;
-import net.minecraft.fluid.LavaFluid;
-import net.minecraft.fluid.WaterFluid;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.CactusBlock;
+import net.minecraft.world.level.block.FenceBlock;
+import net.minecraft.world.level.block.FenceGateBlock;
+import net.minecraft.world.level.block.LadderBlock;
+import net.minecraft.world.level.block.LiquidBlock;
+import net.minecraft.world.level.block.PressurePlateBlock;
+import net.minecraft.world.level.block.SignBlock;
+import net.minecraft.world.level.block.SlimeBlock;
+import net.minecraft.world.level.block.SoulSandBlock;
+import net.minecraft.world.level.block.TripWireBlock;
+import net.minecraft.world.level.block.VineBlock;
+import net.minecraft.world.level.block.WallBlock;
+import net.minecraft.world.level.block.WebBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.LavaFluid;
+import net.minecraft.world.level.material.WaterFluid;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.util.BlockUtils;
@@ -33,7 +49,7 @@ import net.wurstclient.util.RenderUtils;
 
 public class PathFinder
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final PlayerAbilities abilities = PlayerAbilities.get();
 	protected boolean fallingAllowed = true;
@@ -57,11 +73,11 @@ public class PathFinder
 	
 	public PathFinder(BlockPos goal)
 	{
-		if(MC.player.isOnGround())
-			start = new PathPos(BlockPos.ofFloored(MC.player.getX(),
+		if(MC.player.onGround())
+			start = new PathPos(BlockPos.containing(MC.player.getX(),
 				MC.player.getY() + 0.5, MC.player.getZ()));
 		else
-			start = new PathPos(BlockPos.ofFloored(MC.player.getEntityPos()));
+			start = new PathPos(BlockPos.containing(MC.player.position()));
 		this.goal = goal;
 		
 		costMap.put(start, 0F);
@@ -137,8 +153,8 @@ public class PathFinder
 		BlockPos southWest = south.west();
 		BlockPos northWest = north.west();
 		
-		BlockPos up = pos.up();
-		BlockPos down = pos.down();
+		BlockPos up = pos.above();
+		BlockPos down = pos.below();
 		
 		// flying
 		boolean flying = canFlyAt(pos);
@@ -149,7 +165,7 @@ public class PathFinder
 		// or inside of a block that allows sideways movement (ladders, webs,
 		// etc.)
 		if(flying || onGround || pos.isJumping()
-			|| canMoveSidewaysInMidairAt(pos) || canClimbUpAt(pos.down()))
+			|| canMoveSidewaysInMidairAt(pos) || canClimbUpAt(pos.below()))
 		{
 			// north
 			if(checkHorizontalMovement(pos, north))
@@ -185,17 +201,18 @@ public class PathFinder
 		}
 		
 		// up
-		if(pos.getY() < MC.world.getTopYInclusive() && canGoThrough(up.up())
+		if(pos.getY() < MC.level.getMaxY() && canGoThrough(up.above())
 			&& (flying || onGround || canClimbUpAt(pos))
 			&& (flying || canClimbUpAt(pos) || goal.equals(up)
 				|| canSafelyStandOn(north) || canSafelyStandOn(east)
 				|| canSafelyStandOn(south) || canSafelyStandOn(west))
-			&& (divingAllowed || BlockUtils.getBlock(up.up()) != Blocks.WATER))
+			&& (divingAllowed
+				|| BlockUtils.getBlock(up.above()) != Blocks.WATER))
 			neighbors.add(new PathPos(up, onGround));
 		
 		// down
-		if(pos.getY() > MC.world.getBottomY() && canGoThrough(down)
-			&& canGoAbove(down.down()) && (flying || canFallBelow(pos))
+		if(pos.getY() > MC.level.getMinY() && canGoThrough(down)
+			&& canGoAbove(down.below()) && (flying || canFallBelow(pos))
 			&& (divingAllowed || BlockUtils.getBlock(pos) != Blocks.WATER))
 			neighbors.add(new PathPos(down));
 		
@@ -204,8 +221,8 @@ public class PathFinder
 	
 	private boolean checkHorizontalMovement(BlockPos current, BlockPos next)
 	{
-		if(isPassable(next) && (canFlyAt(current) || canGoThrough(next.down())
-			|| canSafelyStandOn(next.down())))
+		if(isPassable(next) && (canFlyAt(current) || canGoThrough(next.below())
+			|| canSafelyStandOn(next.below())))
 			return true;
 		
 		return false;
@@ -214,9 +231,9 @@ public class PathFinder
 	private boolean checkDiagonalMovement(BlockPos current,
 		Direction direction1, Direction direction2)
 	{
-		BlockPos horizontal1 = current.offset(direction1);
-		BlockPos horizontal2 = current.offset(direction2);
-		BlockPos next = horizontal1.offset(direction2);
+		BlockPos horizontal1 = current.relative(direction1);
+		BlockPos horizontal2 = current.relative(direction2);
+		BlockPos next = horizontal1.relative(direction2);
 		
 		if(isPassableWithoutMining(horizontal1)
 			&& isPassableWithoutMining(horizontal2)
@@ -231,11 +248,11 @@ public class PathFinder
 		if(!canGoThrough(pos) && !isMineable(pos))
 			return false;
 		
-		BlockPos up = pos.up();
+		BlockPos up = pos.above();
 		if(!canGoThrough(up) && !isMineable(up))
 			return false;
 		
-		if(!canGoAbove(pos.down()))
+		if(!canGoAbove(pos.below()))
 			return false;
 		
 		if(!divingAllowed && BlockUtils.getBlock(up) == Blocks.WATER)
@@ -249,11 +266,11 @@ public class PathFinder
 		if(!canGoThrough(pos))
 			return false;
 		
-		BlockPos up = pos.up();
+		BlockPos up = pos.above();
 		if(!canGoThrough(up))
 			return false;
 		
-		if(!canGoAbove(pos.down()))
+		if(!canGoAbove(pos.below()))
 			return false;
 		
 		if(!divingAllowed && BlockUtils.getBlock(up) == Blocks.WATER)
@@ -273,7 +290,7 @@ public class PathFinder
 		BlockState state = BlockUtils.getState(pos);
 		Block block = state.getBlock();
 		
-		return state.blocksMovement() && !(block instanceof AbstractSignBlock)
+		return state.blocksMotion() && !(block instanceof SignBlock)
 			|| block instanceof LadderBlock || abilities.jesus()
 				&& (block == Blocks.WATER || block == Blocks.LAVA);
 	}
@@ -284,23 +301,23 @@ public class PathFinder
 		// check if loaded
 		// Can't see why isChunkLoaded() is deprecated. Still seems to be widely
 		// used with no replacement.
-		if(!MC.world.isChunkLoaded(pos))
+		if(!MC.level.hasChunkAt(pos))
 			return false;
 		
 		// check if solid
 		BlockState state = BlockUtils.getState(pos);
 		Block block = state.getBlock();
-		if(state.blocksMovement() && !(block instanceof AbstractSignBlock))
+		if(state.blocksMotion() && !(block instanceof SignBlock))
 			return false;
 		
 		// check if trapped
-		if(block instanceof TripwireBlock
+		if(block instanceof TripWireBlock
 			|| block instanceof PressurePlateBlock)
 			return false;
 		
 		// check if safe
 		if(!abilities.invulnerable()
-			&& (block == Blocks.LAVA || block instanceof AbstractFireBlock))
+			&& (block == Blocks.LAVA || block instanceof BaseFireBlock))
 			return false;
 		
 		return true;
@@ -325,7 +342,7 @@ public class PathFinder
 		
 		// check if safe
 		BlockState state = BlockUtils.getState(pos);
-		Fluid fluid = state.getFluidState().getFluid();
+		Fluid fluid = state.getFluidState().getType();
 		if(!abilities.invulnerable() && (state.getBlock() instanceof CactusBlock
 			|| fluid instanceof LavaFluid))
 			return false;
@@ -336,7 +353,7 @@ public class PathFinder
 	private boolean canFallBelow(PathPos pos)
 	{
 		// check if player can keep falling
-		BlockPos down2 = pos.down(2);
+		BlockPos down2 = pos.below(2);
 		if(fallingAllowed && canGoThrough(down2))
 			return true;
 		
@@ -364,16 +381,16 @@ public class PathFinder
 				
 			// check if point is not part of this fall, meaning that the fall is
 			// too short to cause any damage
-			if(!pos.up(i).equals(prevPos))
+			if(!pos.above(i).equals(prevPos))
 				return true;
 			
 			// check if block resets fall damage
 			Block prevBlock = BlockUtils.getBlock(prevPos);
 			BlockState prevState = BlockUtils.getState(prevPos);
-			if(prevState.getFluidState().getFluid() instanceof WaterFluid
+			if(prevState.getFluidState().getType() instanceof WaterFluid
 				|| prevBlock instanceof LadderBlock
 				|| prevBlock instanceof VineBlock
-				|| prevBlock instanceof CobwebBlock)
+				|| prevBlock instanceof WebBlock)
 				return true;
 			
 			prevPos = prevPosMap.get(prevPos);
@@ -397,7 +414,7 @@ public class PathFinder
 			return false;
 		
 		// check if any adjacent block is solid
-		BlockPos up = pos.up();
+		BlockPos up = pos.above();
 		if(!canBeSolid(pos.north()) && !canBeSolid(pos.east())
 			&& !canBeSolid(pos.south()) && !canBeSolid(pos.west())
 			&& !canBeSolid(up.north()) && !canBeSolid(up.east())
@@ -411,16 +428,15 @@ public class PathFinder
 	{
 		// check feet
 		Block blockFeet = BlockUtils.getBlock(pos);
-		if(BlockUtils.getBlock(pos) instanceof FluidBlock
+		if(BlockUtils.getBlock(pos) instanceof LiquidBlock
 			|| blockFeet instanceof LadderBlock
-			|| blockFeet instanceof VineBlock
-			|| blockFeet instanceof CobwebBlock)
+			|| blockFeet instanceof VineBlock || blockFeet instanceof WebBlock)
 			return true;
 		
 		// check head
-		Block blockHead = BlockUtils.getBlock(pos.up());
-		if(BlockUtils.getBlock(pos.up()) instanceof FluidBlock
-			|| blockHead instanceof CobwebBlock)
+		Block blockHead = BlockUtils.getBlock(pos.above());
+		if(BlockUtils.getBlock(pos.above()) instanceof LiquidBlock
+			|| blockHead instanceof WebBlock)
 			return true;
 		
 		return false;
@@ -444,13 +460,13 @@ public class PathFinder
 			
 			// soul sand
 			if(!canFlyAt(pos)
-				&& BlockUtils.getBlock(pos.down()) instanceof SoulSandBlock)
+				&& BlockUtils.getBlock(pos.below()) instanceof SoulSandBlock)
 				costs[i] *= 2.5F;
 			
 			// mining
 			if(isMineable(pos))
 				costs[i] *= 2F;
-			if(isMineable(pos.up()))
+			if(isMineable(pos.above()))
 				costs[i] *= 2F;
 		}
 		
@@ -522,7 +538,7 @@ public class PathFinder
 			pos = start;
 			for(PathPos next : prevPosMap.keySet())
 				if(getHeuristic(next) < getHeuristic(pos)
-					&& (canFlyAt(next) || canBeSolid(next.down())))
+					&& (canFlyAt(next) || canBeSolid(next.below())))
 					pos = next;
 		}
 		
@@ -539,18 +555,17 @@ public class PathFinder
 		return path;
 	}
 	
-	public void renderPath(MatrixStack matrixStack, boolean debugMode,
+	public void renderPath(PoseStack matrixStack, boolean debugMode,
 		boolean depthTest)
 	{
-		VertexConsumerProvider.Immediate vcp =
-			MC.getBufferBuilders().getEntityVertexConsumers();
+		MultiBufferSource.BufferSource vcp = MC.renderBuffers().bufferSource();
 		VertexConsumer buffer =
 			vcp.getBuffer(WurstRenderLayers.getLines(depthTest));
 		
-		matrixStack.push();
+		matrixStack.pushPose();
 		
 		RegionPos region = RenderUtils.getCameraRegion();
-		Vec3d regionOffset = region.negate().toVec3d();
+		Vec3 regionOffset = region.negate().toVec3d();
 		RenderUtils.applyRegionalRenderOffset(matrixStack, region);
 		
 		if(debugMode)
@@ -563,7 +578,7 @@ public class PathFinder
 				if(thingsRendered >= 5000)
 					break;
 				
-				Box box = new Box(element).offset(regionOffset).contract(0.4);
+				AABB box = new AABB(element).move(regionOffset).deflate(0.4);
 				RenderUtils.drawNode(matrixStack, buffer, box, 0xC0FFFF00);
 				thingsRendered++;
 			}
@@ -589,9 +604,9 @@ public class PathFinder
 			RenderUtils.drawArrow(matrixStack, buffer, path.get(i),
 				path.get(i + 1), region, pathColor);
 		
-		matrixStack.pop();
+		matrixStack.popPose();
 		
-		vcp.drawCurrentLayer();
+		vcp.endLastBatch();
 	}
 	
 	public boolean isPathStillValid(int index)
@@ -607,8 +622,8 @@ public class PathFinder
 		if(index == 0)
 		{
 			PathPos pos = path.get(0);
-			if(!isPassable(pos) || !canFlyAt(pos) && !canGoThrough(pos.down())
-				&& !canSafelyStandOn(pos.down()))
+			if(!isPassable(pos) || !canFlyAt(pos) && !canGoThrough(pos.below())
+				&& !canSafelyStandOn(pos.below()))
 				return false;
 		}
 		
diff --git a/src/main/java/net/wurstclient/ai/PathPos.java b/src/main/java/net/wurstclient/ai/PathPos.java
index 34d6f3911..1c3e262d2 100644
--- a/src/main/java/net/wurstclient/ai/PathPos.java
+++ b/src/main/java/net/wurstclient/ai/PathPos.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.ai;
 
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 
 public class PathPos extends BlockPos
 {
diff --git a/src/main/java/net/wurstclient/ai/PathProcessor.java b/src/main/java/net/wurstclient/ai/PathProcessor.java
index 851dd7b29..41964f1e6 100644
--- a/src/main/java/net/wurstclient/ai/PathProcessor.java
+++ b/src/main/java/net/wurstclient/ai/PathProcessor.java
@@ -8,22 +8,21 @@
 package net.wurstclient.ai;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IKeyBinding;
 
 public abstract class PathProcessor
 {
 	protected static final WurstClient WURST = WurstClient.INSTANCE;
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	
-	private static final KeyBinding[] CONTROLS =
-		{MC.options.forwardKey, MC.options.backKey, MC.options.rightKey,
-			MC.options.leftKey, MC.options.jumpKey, MC.options.sneakKey};
+	private static final KeyMapping[] CONTROLS =
+		{MC.options.keyUp, MC.options.keyDown, MC.options.keyRight,
+			MC.options.keyLeft, MC.options.keyJump, MC.options.keyShift};
 	
 	protected final ArrayList<PathPos> path;
 	protected int index;
@@ -60,14 +59,14 @@ public abstract class PathProcessor
 	protected final void facePosition(BlockPos pos)
 	{
 		WURST.getRotationFaker()
-			.faceVectorClientIgnorePitch(Vec3d.ofCenter(pos));
+			.faceVectorClientIgnorePitch(Vec3.atCenterOf(pos));
 	}
 	
 	public static final void lockControls()
 	{
 		// disable keys
-		for(KeyBinding key : CONTROLS)
-			key.setPressed(false);
+		for(KeyMapping key : CONTROLS)
+			key.setDown(false);
 		
 		// disable sprinting
 		MC.player.setSprinting(false);
@@ -76,7 +75,7 @@ public abstract class PathProcessor
 	public static final void releaseControls()
 	{
 		// reset keys
-		for(KeyBinding key : CONTROLS)
+		for(KeyMapping key : CONTROLS)
 			IKeyBinding.get(key).resetPressedState();
 	}
 }
diff --git a/src/main/java/net/wurstclient/ai/PlayerAbilities.java b/src/main/java/net/wurstclient/ai/PlayerAbilities.java
index 42a07d660..28a16b36d 100644
--- a/src/main/java/net/wurstclient/ai/PlayerAbilities.java
+++ b/src/main/java/net/wurstclient/ai/PlayerAbilities.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.ai;
 
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hack.HackList;
 
@@ -17,16 +17,16 @@ public record PlayerAbilities(boolean invulnerable, boolean creativeFlying,
 {
 	
 	private static final WurstClient WURST = WurstClient.INSTANCE;
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static PlayerAbilities get()
 	{
 		HackList hax = WURST.getHax();
-		net.minecraft.entity.player.PlayerAbilities mcAbilities =
+		net.minecraft.world.entity.player.Abilities mcAbilities =
 			MC.player.getAbilities();
 		
 		boolean invulnerable =
-			mcAbilities.invulnerable || mcAbilities.creativeMode;
+			mcAbilities.invulnerable || mcAbilities.instabuild;
 		boolean creativeFlying = mcAbilities.flying;
 		boolean flying = creativeFlying || hax.flightHack.isEnabled();
 		boolean immuneToFallDamage = invulnerable || hax.noFallHack.isEnabled();
diff --git a/src/main/java/net/wurstclient/ai/WalkPathProcessor.java b/src/main/java/net/wurstclient/ai/WalkPathProcessor.java
index 8732c4913..d0d99dccf 100644
--- a/src/main/java/net/wurstclient/ai/WalkPathProcessor.java
+++ b/src/main/java/net/wurstclient/ai/WalkPathProcessor.java
@@ -8,13 +8,12 @@
 package net.wurstclient.ai;
 
 import java.util.ArrayList;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.LadderBlock;
-import net.minecraft.block.VineBlock;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.LadderBlock;
+import net.minecraft.world.level.block.VineBlock;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.BlockUtils;
 import net.wurstclient.util.RotationUtils;
@@ -31,12 +30,12 @@ public class WalkPathProcessor extends PathProcessor
 	{
 		// get positions
 		BlockPos pos;
-		if(WurstClient.MC.player.isOnGround())
-			pos = BlockPos.ofFloored(WurstClient.MC.player.getX(),
+		if(WurstClient.MC.player.onGround())
+			pos = BlockPos.containing(WurstClient.MC.player.getX(),
 				WurstClient.MC.player.getY() + 0.5,
 				WurstClient.MC.player.getZ());
 		else
-			pos = BlockPos.ofFloored(WurstClient.MC.player.getEntityPos());
+			pos = BlockPos.containing(WurstClient.MC.player.position());
 		PathPos nextPos = path.get(index);
 		int posIndex = path.indexOf(pos);
 		
@@ -70,34 +69,34 @@ public class WalkPathProcessor extends PathProcessor
 		
 		// face next position
 		facePosition(nextPos);
-		if(MathHelper.wrapDegrees(Math.abs(RotationUtils
-			.getHorizontalAngleToLookVec(Vec3d.ofCenter(nextPos)))) > 90)
+		if(Mth.wrapDegrees(Math.abs(RotationUtils
+			.getHorizontalAngleToLookVec(Vec3.atCenterOf(nextPos)))) > 90)
 			return;
 		
 		if(WURST.getHax().jesusHack.isEnabled())
 		{
 			// wait for Jesus to swim up
 			if(WurstClient.MC.player.getY() < nextPos.getY()
-				&& (WurstClient.MC.player.isTouchingWater()
+				&& (WurstClient.MC.player.isInWater()
 					|| WurstClient.MC.player.isInLava()))
 				return;
 			
 			// manually swim down if using Jesus
 			if(WurstClient.MC.player.getY() - nextPos.getY() > 0.5
-				&& (WurstClient.MC.player.isTouchingWater()
+				&& (WurstClient.MC.player.isInWater()
 					|| WurstClient.MC.player.isInLava()
 					|| WURST.getHax().jesusHack.isOverLiquid()))
-				MC.options.sneakKey.setPressed(true);
+				MC.options.keyShift.setDown(true);
 		}
 		
 		// horizontal movement
 		if(pos.getX() != nextPos.getX() || pos.getZ() != nextPos.getZ())
 		{
-			MC.options.forwardKey.setPressed(true);
+			MC.options.keyUp.setDown(true);
 			
 			if(index > 0 && path.get(index - 1).isJumping()
 				|| pos.getY() < nextPos.getY())
-				MC.options.jumpKey.setPressed(true);
+				MC.options.keyJump.setDown(true);
 			
 			// vertical movement
 		}else if(pos.getY() != nextPos.getY())
@@ -112,17 +111,17 @@ public class WalkPathProcessor extends PathProcessor
 					WURST.getRotationFaker().faceVectorClientIgnorePitch(
 						BlockUtils.getBoundingBox(pos).getCenter());
 					
-					MC.options.forwardKey.setPressed(true);
+					MC.options.keyUp.setDown(true);
 					
 				}else
 				{
 					// directional jump
 					if(index < path.size() - 1
-						&& !nextPos.up().equals(path.get(index + 1)))
+						&& !nextPos.above().equals(path.get(index + 1)))
 						index++;
 					
 					// jump up
-					MC.options.jumpKey.setPressed(true);
+					MC.options.keyJump.setDown(true);
 				}
 				
 				// go down
@@ -130,18 +129,18 @@ public class WalkPathProcessor extends PathProcessor
 			{
 				// skip mid-air nodes and go straight to the bottom
 				while(index < path.size() - 1
-					&& path.get(index).down().equals(path.get(index + 1)))
+					&& path.get(index).below().equals(path.get(index + 1)))
 					index++;
 				
 				// walk off the edge
-				if(WurstClient.MC.player.isOnGround())
-					MC.options.forwardKey.setPressed(true);
+				if(WurstClient.MC.player.onGround())
+					MC.options.keyUp.setDown(true);
 			}
 	}
 	
 	@Override
 	public boolean canBreakBlocks()
 	{
-		return MC.player.isOnGround();
+		return MC.player.onGround();
 	}
 }
diff --git a/src/main/java/net/wurstclient/altmanager/AltRenderer.java b/src/main/java/net/wurstclient/altmanager/AltRenderer.java
index 66bb2961e..a5348e086 100644
--- a/src/main/java/net/wurstclient/altmanager/AltRenderer.java
+++ b/src/main/java/net/wurstclient/altmanager/AltRenderer.java
@@ -17,16 +17,15 @@ import java.util.concurrent.Executors;
 
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.yggdrasil.ProfileResult;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gl.RenderPipelines;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.network.PlayerListEntry;
-import net.minecraft.client.util.DefaultSkinHelper;
-import net.minecraft.entity.player.PlayerSkinType;
-import net.minecraft.entity.player.SkinTextures;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.Uuids;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.client.renderer.RenderPipelines;
+import net.minecraft.client.resources.DefaultPlayerSkin;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.player.PlayerModelType;
+import net.minecraft.world.entity.player.PlayerSkin;
 import net.wurstclient.WurstClient;
 
 public final class AltRenderer
@@ -34,47 +33,47 @@ public final class AltRenderer
 	private static final ExecutorService BACKGROUND_THREAD =
 		Executors.newSingleThreadExecutor();
 	
-	private static final ConcurrentHashMap<String, Identifier> onlineSkins =
+	private static final ConcurrentHashMap<String, ResourceLocation> onlineSkins =
 		new ConcurrentHashMap<>();
 	
-	private static final HashMap<String, Identifier> offlineSkins =
+	private static final HashMap<String, ResourceLocation> offlineSkins =
 		new HashMap<>();
 	
-	private static Identifier getSkinTexture(String name)
+	private static ResourceLocation getSkinTexture(String name)
 	{
 		if(name.isEmpty())
 			name = "Steve";
 		
-		Identifier offlineSkin = offlineSkins.get(name);
+		ResourceLocation offlineSkin = offlineSkins.get(name);
 		if(offlineSkin == null)
 		{
 			queueOnlineSkinLoading(name);
 			offlineSkin = loadOfflineSkin(name);
 		}
 		
-		Identifier onlineSkin = onlineSkins.get(name);
+		ResourceLocation onlineSkin = onlineSkins.get(name);
 		return onlineSkin != null ? onlineSkin : offlineSkin;
 	}
 	
-	private static Identifier loadOfflineSkin(String name)
+	private static ResourceLocation loadOfflineSkin(String name)
 	{
-		UUID uuid = Uuids.getOfflinePlayerUuid(name);
+		UUID uuid = UUIDUtil.createOfflinePlayerUUID(name);
 		GameProfile profile = new GameProfile(uuid, name);
-		PlayerListEntry entry = new PlayerListEntry(profile, false);
-		Identifier texture = entry.getSkinTextures().body().texturePath();
+		PlayerInfo entry = new PlayerInfo(profile, false);
+		ResourceLocation texture = entry.getSkin().body().texturePath();
 		offlineSkins.put(name, texture);
 		return texture;
 	}
 	
 	private static void queueOnlineSkinLoading(String name)
 	{
-		MinecraftClient mc = WurstClient.MC;
+		Minecraft mc = WurstClient.MC;
 		
 		CompletableFuture.supplyAsync(() -> {
 			
 			UUID uuid = SkinStealer.getUUIDOrNull(name);
 			ProfileResult result =
-				mc.getApiServices().sessionService().fetchProfile(uuid, false);
+				mc.services().sessionService().fetchProfile(uuid, false);
 			
 			return result == null ? null : result.profile();
 			
@@ -83,8 +82,8 @@ public final class AltRenderer
 			if(profile == null)
 				return CompletableFuture.completedFuture(null);
 			
-			CompletableFuture<Optional<SkinTextures>> skinFuture =
-				mc.getSkinProvider().fetchSkinTextures(profile);
+			CompletableFuture<Optional<PlayerSkin>> skinFuture =
+				mc.getSkinManager().get(profile);
 			
 			return skinFuture.thenApplyAsync(opt -> opt.orElse(null));
 			
@@ -96,12 +95,12 @@ public final class AltRenderer
 		}, BACKGROUND_THREAD);
 	}
 	
-	public static void drawAltFace(DrawContext context, String name, int x,
+	public static void drawAltFace(GuiGraphics context, String name, int x,
 		int y, int w, int h, boolean selected)
 	{
 		try
 		{
-			Identifier texture = getSkinTexture(name);
+			ResourceLocation texture = getSkinTexture(name);
 			int color = selected ? 0xFFFFFFFF : 0xFFE0E0E0;
 			
 			// Face
@@ -109,16 +108,16 @@ public final class AltRenderer
 			int fh = 192;
 			float u = 24;
 			float v = 24;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh, color);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh, color);
 			
 			// Hat
 			fw = 192;
 			fh = 192;
 			u = 120;
 			v = 24;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh, color);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh, color);
 			
 		}catch(Exception e)
 		{
@@ -126,16 +125,16 @@ public final class AltRenderer
 		}
 	}
 	
-	public static void drawAltBody(DrawContext context, String name, int x,
+	public static void drawAltBody(GuiGraphics context, String name, int x,
 		int y, int width, int height)
 	{
 		try
 		{
-			Identifier texture = getSkinTexture(name);
+			ResourceLocation texture = getSkinTexture(name);
 			
-			boolean slim = DefaultSkinHelper
-				.getSkinTextures(Uuids.getOfflinePlayerUuid(name))
-				.model() == PlayerSkinType.SLIM;
+			boolean slim =
+				DefaultPlayerSkin.get(UUIDUtil.createOfflinePlayerUUID(name))
+					.model() == PlayerModelType.SLIM;
 			
 			// Face
 			x = x + width / 4;
@@ -146,8 +145,8 @@ public final class AltRenderer
 			int fh = height * 2;
 			float u = height / 4;
 			float v = height / 4;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Hat
 			x = x + 0;
@@ -156,8 +155,8 @@ public final class AltRenderer
 			h = height / 4;
 			u = height / 4 * 5;
 			v = height / 4;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Chest
 			x = x + 0;
@@ -166,8 +165,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 2.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Jacket
 			x = x + 0;
@@ -176,8 +175,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 2.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Arm
 			x = x - width / 16 * (slim ? 3 : 4);
@@ -186,8 +185,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 5.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Sleeve
 			x = x + 0;
@@ -196,8 +195,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 5.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Arm
 			x = x + width / 16 * (slim ? 11 : 12);
@@ -206,8 +205,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 5.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Sleeve
 			x = x + 0;
@@ -216,8 +215,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 5.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Leg
 			x = x - width / 2;
@@ -226,8 +225,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 0.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Pants
 			x = x + 0;
@@ -236,8 +235,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 0.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Leg
 			x = x + width / 4;
@@ -246,8 +245,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 0.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Pants
 			x = x + 0;
@@ -256,8 +255,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 0.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 		}catch(Exception e)
 		{
@@ -265,16 +264,16 @@ public final class AltRenderer
 		}
 	}
 	
-	public static void drawAltBack(DrawContext context, String name, int x,
+	public static void drawAltBack(GuiGraphics context, String name, int x,
 		int y, int width, int height)
 	{
 		try
 		{
-			Identifier texture = getSkinTexture(name);
+			ResourceLocation texture = getSkinTexture(name);
 			
-			boolean slim = DefaultSkinHelper
-				.getSkinTextures(Uuids.getOfflinePlayerUuid(name))
-				.model() == PlayerSkinType.SLIM;
+			boolean slim =
+				DefaultPlayerSkin.get(UUIDUtil.createOfflinePlayerUUID(name))
+					.model() == PlayerModelType.SLIM;
 			
 			// Face
 			x = x + width / 4;
@@ -285,8 +284,8 @@ public final class AltRenderer
 			int fh = height * 2;
 			float u = height / 4 * 3;
 			float v = height / 4;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Hat
 			x = x + 0;
@@ -295,8 +294,8 @@ public final class AltRenderer
 			h = height / 4;
 			u = height / 4 * 7;
 			v = height / 4;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Chest
 			x = x + 0;
@@ -305,8 +304,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 4;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Jacket
 			x = x + 0;
@@ -315,8 +314,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 4;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Arm
 			x = x - width / 16 * (slim ? 3 : 4);
@@ -325,8 +324,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * (slim ? 6.375F : 6.5F);
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Sleeve
 			x = x + 0;
@@ -335,8 +334,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * (slim ? 6.375F : 6.5F);
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Arm
 			x = x + width / 16 * (slim ? 11 : 12);
@@ -345,8 +344,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * (slim ? 6.375F : 6.5F);
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Sleeve
 			x = x + 0;
@@ -355,8 +354,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * (slim ? 6.375F : 6.5F);
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Leg
 			x = x - width / 2;
@@ -365,8 +364,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 1.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Left Pants
 			x = x + 0;
@@ -375,8 +374,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 1.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Leg
 			x = x + width / 4;
@@ -385,8 +384,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 1.5F;
 			v = height / 4 * 2.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 			// Right Pants
 			x = x + 0;
@@ -395,8 +394,8 @@ public final class AltRenderer
 			h = height / 8 * 3;
 			u = height / 4 * 1.5F;
 			v = height / 4 * 4.5F;
-			context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u,
-				v, w, h, fw, fh);
+			context.blit(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, w,
+				h, fw, fh);
 			
 		}catch(Exception e)
 		{
diff --git a/src/main/java/net/wurstclient/altmanager/Encryption.java b/src/main/java/net/wurstclient/altmanager/Encryption.java
index 402ca4cdf..20209c6cf 100644
--- a/src/main/java/net/wurstclient/altmanager/Encryption.java
+++ b/src/main/java/net/wurstclient/altmanager/Encryption.java
@@ -37,11 +37,10 @@ import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonParser;
-
-import net.minecraft.util.Util;
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
-import net.minecraft.util.crash.CrashReportSection;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportCategory;
+import net.minecraft.ReportedException;
+import net.minecraft.Util;
 import net.wurstclient.util.json.JsonException;
 import net.wurstclient.util.json.JsonUtils;
 import net.wurstclient.util.json.WsonArray;
@@ -77,15 +76,15 @@ public final class Encryption
 			
 		}catch(GeneralSecurityException e)
 		{
-			throw new CrashException(
-				CrashReport.create(e, "Creating AES ciphers"));
+			throw new ReportedException(
+				CrashReport.forThrowable(e, "Creating AES ciphers"));
 		}
 	}
 	
 	private Path createEncryptionFolder(Path encFolder) throws IOException
 	{
 		Files.createDirectories(encFolder);
-		if(Util.getOperatingSystem() == Util.OperatingSystem.WINDOWS)
+		if(Util.getPlatform() == Util.OS.WINDOWS)
 			Files.setAttribute(encFolder, "dos:hidden", true);
 		
 		Path readme = encFolder.resolve("READ ME I AM VERY IMPORTANT.txt");
@@ -144,12 +143,12 @@ public final class Encryption
 			
 		}catch(IOException e)
 		{
-			CrashReport report =
-				CrashReport.create(e, "Migrating Wurst encryption folder");
-			CrashReportSection section = report.addElement("Migration");
-			section.add("Old path", oldFolder);
-			section.add("New path", newFolder);
-			throw new CrashException(report);
+			CrashReport report = CrashReport.forThrowable(e,
+				"Migrating Wurst encryption folder");
+			CrashReportCategory section = report.addCategory("Migration");
+			section.setDetail("Old path", oldFolder);
+			section.setDetail("New path", newFolder);
+			throw new ReportedException(report);
 		}
 	}
 	
@@ -161,7 +160,8 @@ public final class Encryption
 			
 		}catch(IllegalArgumentException | GeneralSecurityException e)
 		{
-			throw new CrashException(CrashReport.create(e, "Decrypting bytes"));
+			throw new ReportedException(
+				CrashReport.forThrowable(e, "Decrypting bytes"));
 		}
 	}
 	
@@ -171,7 +171,7 @@ public final class Encryption
 		{
 			return new String(decrypt(Files.readAllBytes(path)), CHARSET);
 			
-		}catch(CrashException e)
+		}catch(ReportedException e)
 		{
 			throw new IOException(e);
 		}
@@ -219,7 +219,8 @@ public final class Encryption
 			
 		}catch(GeneralSecurityException e)
 		{
-			throw new CrashException(CrashReport.create(e, "Encrypting bytes"));
+			throw new ReportedException(
+				CrashReport.forThrowable(e, "Encrypting bytes"));
 		}
 	}
 	
@@ -229,7 +230,7 @@ public final class Encryption
 		{
 			Files.write(path, encrypt(content.getBytes(CHARSET)));
 			
-		}catch(CrashException e)
+		}catch(ReportedException e)
 		{
 			throw new IOException(e);
 		}
@@ -326,8 +327,8 @@ public final class Encryption
 			
 		}catch(GeneralSecurityException e)
 		{
-			throw new CrashException(
-				CrashReport.create(e, "Creating RSA keypair"));
+			throw new ReportedException(
+				CrashReport.forThrowable(e, "Creating RSA keypair"));
 		}
 	}
 	
@@ -351,7 +352,8 @@ public final class Encryption
 			
 		}catch(GeneralSecurityException e)
 		{
-			throw new CrashException(CrashReport.create(e, "Creating AES key"));
+			throw new ReportedException(
+				CrashReport.forThrowable(e, "Creating AES key"));
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/altmanager/LoginManager.java b/src/main/java/net/wurstclient/altmanager/LoginManager.java
index 2daa00e33..be92050b7 100644
--- a/src/main/java/net/wurstclient/altmanager/LoginManager.java
+++ b/src/main/java/net/wurstclient/altmanager/LoginManager.java
@@ -8,9 +8,8 @@
 package net.wurstclient.altmanager;
 
 import java.util.Optional;
-
-import net.minecraft.client.session.Session;
-import net.minecraft.util.Uuids;
+import net.minecraft.client.User;
+import net.minecraft.core.UUIDUtil;
 import net.wurstclient.WurstClient;
 
 public enum LoginManager
@@ -19,8 +18,8 @@ public enum LoginManager
 	
 	public static void changeCrackedName(String newName)
 	{
-		Session session =
-			new Session(newName, Uuids.getOfflinePlayerUuid(newName), "",
+		User session =
+			new User(newName, UUIDUtil.createOfflinePlayerUUID(newName), "",
 				Optional.empty(), Optional.empty());
 		
 		WurstClient.IMC.setWurstSession(session);
diff --git a/src/main/java/net/wurstclient/altmanager/MicrosoftLoginManager.java b/src/main/java/net/wurstclient/altmanager/MicrosoftLoginManager.java
index f53cacaf8..8102229ba 100644
--- a/src/main/java/net/wurstclient/altmanager/MicrosoftLoginManager.java
+++ b/src/main/java/net/wurstclient/altmanager/MicrosoftLoginManager.java
@@ -32,8 +32,7 @@ import java.util.stream.Collectors;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
-
-import net.minecraft.client.session.Session;
+import net.minecraft.client.User;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.json.JsonException;
 import net.wurstclient.util.json.JsonUtils;
@@ -102,7 +101,7 @@ public enum MicrosoftLoginManager
 	{
 		MinecraftProfile mcProfile = getAccount(email, password);
 		
-		Session session = new Session(mcProfile.getName(), mcProfile.getUUID(),
+		User session = new User(mcProfile.getName(), mcProfile.getUUID(),
 			mcProfile.getAccessToken(), Optional.empty(), Optional.empty());
 		
 		WurstClient.IMC.setWurstSession(session);
diff --git a/src/main/java/net/wurstclient/altmanager/MojangAlt.java b/src/main/java/net/wurstclient/altmanager/MojangAlt.java
index 0bf0796ae..24b33c2f7 100644
--- a/src/main/java/net/wurstclient/altmanager/MojangAlt.java
+++ b/src/main/java/net/wurstclient/altmanager/MojangAlt.java
@@ -67,7 +67,7 @@ public final class MojangAlt extends Alt
 	
 	private String getNameFromSession()
 	{
-		String name = WurstClient.MC.getSession().getUsername();
+		String name = WurstClient.MC.getUser().getName();
 		
 		if(name == null || name.isEmpty())
 			throw new RuntimeException(
diff --git a/src/main/java/net/wurstclient/altmanager/screens/AddAltScreen.java b/src/main/java/net/wurstclient/altmanager/screens/AddAltScreen.java
index c4f34f51c..208fcbe82 100644
--- a/src/main/java/net/wurstclient/altmanager/screens/AddAltScreen.java
+++ b/src/main/java/net/wurstclient/altmanager/screens/AddAltScreen.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.altmanager.screens;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.altmanager.AltManager;
 import net.wurstclient.altmanager.CrackedAlt;
 import net.wurstclient.altmanager.MojangAlt;
@@ -19,7 +19,7 @@ public final class AddAltScreen extends AltEditorScreen
 	
 	public AddAltScreen(Screen prevScreen, AltManager altManager)
 	{
-		super(prevScreen, Text.literal("New Alt"));
+		super(prevScreen, Component.literal("New Alt"));
 		this.altManager = altManager;
 	}
 	
@@ -40,6 +40,6 @@ public final class AddAltScreen extends AltEditorScreen
 		else
 			altManager.add(new MojangAlt(nameOrEmail, password));
 		
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 }
diff --git a/src/main/java/net/wurstclient/altmanager/screens/AltEditorScreen.java b/src/main/java/net/wurstclient/altmanager/screens/AltEditorScreen.java
index 55d2c9b90..b6209266c 100644
--- a/src/main/java/net/wurstclient/altmanager/screens/AltEditorScreen.java
+++ b/src/main/java/net/wurstclient/altmanager/screens/AltEditorScreen.java
@@ -15,19 +15,18 @@ import java.nio.file.Path;
 import java.nio.file.StandardCopyOption;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.OrderedText;
-import net.minecraft.text.Style;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.Style;
+import net.minecraft.util.CommonColors;
+import net.minecraft.util.FormattedCharSequence;
 import net.wurstclient.WurstClient;
 import net.wurstclient.altmanager.AltRenderer;
 import net.wurstclient.altmanager.NameGenerator;
@@ -40,16 +39,16 @@ public abstract class AltEditorScreen extends Screen
 	
 	protected final Screen prevScreen;
 	
-	private TextFieldWidget nameOrEmailBox;
-	private TextFieldWidget passwordBox;
+	private EditBox nameOrEmailBox;
+	private EditBox passwordBox;
 	
-	private ButtonWidget doneButton;
-	private ButtonWidget stealSkinButton;
+	private Button doneButton;
+	private Button stealSkinButton;
 	
 	protected String message = "";
 	private int errorTimer;
 	
-	public AltEditorScreen(Screen prevScreen, Text title)
+	public AltEditorScreen(Screen prevScreen, Component title)
 	{
 		super(title);
 		this.prevScreen = prevScreen;
@@ -58,49 +57,45 @@ public abstract class AltEditorScreen extends Screen
 	@Override
 	public final void init()
 	{
-		nameOrEmailBox = new TextFieldWidget(textRenderer, width / 2 - 100, 60,
-			200, 20, Text.literal(""));
+		nameOrEmailBox = new EditBox(font, width / 2 - 100, 60, 200, 20,
+			Component.literal(""));
 		nameOrEmailBox.setMaxLength(48);
 		nameOrEmailBox.setFocused(true);
-		nameOrEmailBox.setText(getDefaultNameOrEmail());
-		addSelectableChild(nameOrEmailBox);
+		nameOrEmailBox.setValue(getDefaultNameOrEmail());
+		addWidget(nameOrEmailBox);
 		
-		passwordBox = new TextFieldWidget(textRenderer, width / 2 - 100, 100,
-			200, 20, Text.literal(""));
-		passwordBox.setText(getDefaultPassword());
-		passwordBox.addFormatter(
-			(text, startIndex) -> OrderedText.styledForwardsVisitedString(
-				"*".repeat(text.length()), Style.EMPTY));
+		passwordBox = new EditBox(font, width / 2 - 100, 100, 200, 20,
+			Component.literal(""));
+		passwordBox.setValue(getDefaultPassword());
+		passwordBox.addFormatter((text, startIndex) -> FormattedCharSequence
+			.forward("*".repeat(text.length()), Style.EMPTY));
 		passwordBox.setMaxLength(256);
-		addSelectableChild(passwordBox);
+		addWidget(passwordBox);
 		
-		addDrawableChild(doneButton = ButtonWidget
-			.builder(Text.literal(getDoneButtonText()), b -> pressDoneButton())
-			.dimensions(width / 2 - 100, height / 4 + 72 + 12, 200, 20)
-			.build());
+		addRenderableWidget(doneButton = Button
+			.builder(Component.literal(getDoneButtonText()),
+				b -> pressDoneButton())
+			.bounds(width / 2 - 100, height / 4 + 72 + 12, 200, 20).build());
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Cancel"), b -> close())
-				.dimensions(width / 2 - 100, height / 4 + 120 + 12, 200, 20)
-				.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"), b -> onClose())
+			.bounds(width / 2 - 100, height / 4 + 120 + 12, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Random Name"),
-				b -> nameOrEmailBox.setText(NameGenerator.generateName()))
-			.dimensions(width / 2 - 100, height / 4 + 96 + 12, 200, 20)
-			.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Random Name"),
+				b -> nameOrEmailBox.setValue(NameGenerator.generateName()))
+			.bounds(width / 2 - 100, height / 4 + 96 + 12, 200, 20).build());
 		
-		addDrawableChild(stealSkinButton = ButtonWidget
-			.builder(Text.literal("Steal Skin"),
+		addRenderableWidget(stealSkinButton = Button
+			.builder(Component.literal("Steal Skin"),
 				b -> message = stealSkin(getNameOrEmail()))
-			.dimensions(width - (width / 2 - 100) / 2 - 64, height - 32, 128,
-				20)
+			.bounds(width - (width / 2 - 100) / 2 - 64, height - 32, 128, 20)
 			.build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Open Skin Folder"), b -> openSkinFolder())
-			.dimensions((width / 2 - 100) / 2 - 64, height - 32, 128, 20)
-			.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Open Skin Folder"),
+				b -> openSkinFolder())
+			.bounds((width / 2 - 100) / 2 - 64, height - 32, 128, 20).build());
 		
 		setFocused(nameOrEmailBox);
 	}
@@ -108,7 +103,7 @@ public abstract class AltEditorScreen extends Screen
 	private void openSkinFolder()
 	{
 		createSkinFolder();
-		Util.getOperatingSystem().open(skinFolder.toFile());
+		Util.getPlatform().openFile(skinFolder.toFile());
 	}
 	
 	private void createSkinFolder()
@@ -127,12 +122,12 @@ public abstract class AltEditorScreen extends Screen
 	@Override
 	public final void tick()
 	{
-		String nameOrEmail = nameOrEmailBox.getText().trim();
+		String nameOrEmail = nameOrEmailBox.getValue().trim();
 		boolean alex = nameOrEmail.equalsIgnoreCase("Alexander01998");
 		
 		doneButton.active = !nameOrEmail.isEmpty()
-			&& !(alex && passwordBox.getText().isEmpty());
-		doneButton.setMessage(Text.literal(getDoneButtonText()));
+			&& !(alex && passwordBox.getValue().isEmpty());
+		doneButton.setMessage(Component.literal(getDoneButtonText()));
 		
 		stealSkinButton.active = !alex;
 	}
@@ -143,7 +138,7 @@ public abstract class AltEditorScreen extends Screen
 	 */
 	protected final String getNameOrEmail()
 	{
-		return nameOrEmailBox.getText();
+		return nameOrEmailBox.getValue();
 	}
 	
 	/**
@@ -151,12 +146,12 @@ public abstract class AltEditorScreen extends Screen
 	 */
 	protected final String getPassword()
 	{
-		return passwordBox.getText();
+		return passwordBox.getValue();
 	}
 	
 	protected String getDefaultNameOrEmail()
 	{
-		return client.getSession().getUsername();
+		return minecraft.getUser().getName();
 	}
 	
 	protected String getDefaultPassword()
@@ -202,7 +197,7 @@ public abstract class AltEditorScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ENTER)
 			doneButton.onPress(context);
@@ -211,7 +206,7 @@ public abstract class AltEditorScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		nameOrEmailBox.mouseClicked(context, doubleClick);
 		passwordBox.mouseClicked(context, doubleClick);
@@ -221,7 +216,7 @@ public abstract class AltEditorScreen extends Screen
 		
 		if(context.button() == GLFW.GLFW_MOUSE_BUTTON_4)
 		{
-			close();
+			onClose();
 			return true;
 		}
 		
@@ -229,31 +224,31 @@ public abstract class AltEditorScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		// skin preview
-		AltRenderer.drawAltBack(context, nameOrEmailBox.getText(),
+		AltRenderer.drawAltBack(context, nameOrEmailBox.getValue(),
 			(width / 2 - 100) / 2 - 64, height / 2 - 128, 128, 256);
-		AltRenderer.drawAltBody(context, nameOrEmailBox.getText(),
+		AltRenderer.drawAltBody(context, nameOrEmailBox.getValue(),
 			width - (width / 2 - 100) / 2 - 64, height / 2 - 128, 128, 256);
 		
 		String accountType = getPassword().isEmpty() ? "cracked" : "premium";
 		
 		// text
-		context.drawTextWithShadow(textRenderer, "Name (for cracked alts), or",
-			width / 2 - 100, 37, Colors.LIGHT_GRAY);
-		context.drawTextWithShadow(textRenderer, "E-Mail (for premium alts)",
-			width / 2 - 100, 47, Colors.LIGHT_GRAY);
-		context.drawTextWithShadow(textRenderer, "Password (for premium alts)",
-			width / 2 - 100, 87, Colors.LIGHT_GRAY);
-		context.drawTextWithShadow(textRenderer, "Account type: " + accountType,
-			width / 2 - 100, 127, Colors.LIGHT_GRAY);
+		context.drawString(font, "Name (for cracked alts), or", width / 2 - 100,
+			37, CommonColors.LIGHT_GRAY);
+		context.drawString(font, "E-Mail (for premium alts)", width / 2 - 100,
+			47, CommonColors.LIGHT_GRAY);
+		context.drawString(font, "Password (for premium alts)", width / 2 - 100,
+			87, CommonColors.LIGHT_GRAY);
+		context.drawString(font, "Account type: " + accountType,
+			width / 2 - 100, 127, CommonColors.LIGHT_GRAY);
 		
 		String[] lines = message.split("\n");
 		for(int i = 0; i < lines.length; i++)
-			context.drawCenteredTextWithShadow(textRenderer, lines[i],
-				width / 2, 142 + 10 * i, Colors.WHITE);
+			context.drawCenteredString(font, lines[i], width / 2, 142 + 10 * i,
+				CommonColors.WHITE);
 		
 		// text boxes
 		nameOrEmailBox.render(context, mouseX, mouseY, partialTicks);
@@ -268,13 +263,13 @@ public abstract class AltEditorScreen extends Screen
 			errorTimer--;
 		}
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public final void close()
+	public final void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 }
diff --git a/src/main/java/net/wurstclient/altmanager/screens/AltManagerScreen.java b/src/main/java/net/wurstclient/altmanager/screens/AltManagerScreen.java
index fd34c9afa..ce6dca6bf 100644
--- a/src/main/java/net/wurstclient/altmanager/screens/AltManagerScreen.java
+++ b/src/main/java/net/wurstclient/altmanager/screens/AltManagerScreen.java
@@ -29,26 +29,26 @@ import com.google.gson.JsonObject;
 
 import it.unimi.dsi.fastutil.booleans.BooleanConsumer;
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.Element;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.NoticeScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.StringVisitable;
-import net.minecraft.text.Style;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.StringHelper;
-import net.minecraft.util.Util;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.ObjectSelectionList;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.components.events.GuiEventListener;
+import net.minecraft.client.gui.screens.AlertScreen;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.FormattedText;
+import net.minecraft.network.chat.Style;
+import net.minecraft.util.CommonColors;
+import net.minecraft.util.Mth;
+import net.minecraft.util.StringUtil;
 import net.wurstclient.WurstClient;
 import net.wurstclient.altmanager.*;
 import net.wurstclient.mixinterface.IMinecraftClient;
@@ -68,18 +68,18 @@ public final class AltManagerScreen extends Screen
 	private boolean shouldAsk = true;
 	private int errorTimer;
 	
-	private ButtonWidget useButton;
-	private ButtonWidget starButton;
-	private ButtonWidget editButton;
-	private ButtonWidget deleteButton;
+	private Button useButton;
+	private Button starButton;
+	private Button editButton;
+	private Button deleteButton;
 	
-	private ButtonWidget importButton;
-	private ButtonWidget exportButton;
-	private ButtonWidget logoutButton;
+	private Button importButton;
+	private Button exportButton;
+	private Button logoutButton;
 	
 	public AltManagerScreen(Screen prevScreen, AltManager altManager)
 	{
-		super(Text.literal("Alt Manager"));
+		super(Component.literal("Alt Manager"));
 		this.prevScreen = prevScreen;
 		this.altManager = altManager;
 	}
@@ -87,101 +87,104 @@ public final class AltManagerScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, altManager.getList());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, altManager.getList());
+		addWidget(listGui);
 		
 		WurstClient wurst = WurstClient.INSTANCE;
 		
 		Exception folderException = altManager.getFolderException();
 		if(folderException != null && shouldAsk)
 		{
-			Text title = Text.literal(
+			Component title = Component.literal(
 				wurst.translate("gui.wurst.altmanager.folder_error.title"));
-			Text message = Text.literal(wurst.translate(
+			Component message = Component.literal(wurst.translate(
 				"gui.wurst.altmanager.folder_error.message", folderException));
-			Text buttonText = Text.translatable("gui.done");
+			Component buttonText = Component.translatable("gui.done");
 			
 			// This just sets shouldAsk to false and closes the message.
 			Runnable action = () -> confirmGenerate(false);
 			
-			NoticeScreen screen =
-				new NoticeScreen(action, title, message, buttonText, false);
-			client.setScreen(screen);
+			AlertScreen screen =
+				new AlertScreen(action, title, message, buttonText, false);
+			minecraft.setScreen(screen);
 			
 		}else if(altManager.getList().isEmpty() && shouldAsk)
 		{
-			Text title = Text
+			Component title = Component
 				.literal(wurst.translate("gui.wurst.altmanager.empty.title"));
-			Text message = Text
+			Component message = Component
 				.literal(wurst.translate("gui.wurst.altmanager.empty.message"));
 			BooleanConsumer callback = this::confirmGenerate;
 			
 			ConfirmScreen screen = new ConfirmScreen(callback, title, message);
-			client.setScreen(screen);
+			minecraft.setScreen(screen);
 		}
 		
-		addDrawableChild(useButton =
-			ButtonWidget.builder(Text.literal("Login"), b -> pressLogin())
-				.dimensions(width / 2 - 154, height - 52, 100, 20).build());
+		addRenderableWidget(useButton =
+			Button.builder(Component.literal("Login"), b -> pressLogin())
+				.bounds(width / 2 - 154, height - 52, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Direct Login"),
-				b -> client.setScreen(new DirectLoginScreen(this)))
-			.dimensions(width / 2 - 50, height - 52, 100, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Direct Login"),
+				b -> minecraft.setScreen(new DirectLoginScreen(this)))
+			.bounds(width / 2 - 50, height - 52, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Add"),
-				b -> client.setScreen(new AddAltScreen(this, altManager)))
-			.dimensions(width / 2 + 54, height - 52, 100, 20).build());
+		addRenderableWidget(
+			Button
+				.builder(Component.literal("Add"),
+					b -> minecraft
+						.setScreen(new AddAltScreen(this, altManager)))
+				.bounds(width / 2 + 54, height - 52, 100, 20).build());
 		
-		addDrawableChild(starButton =
-			ButtonWidget.builder(Text.literal("Favorite"), b -> pressFavorite())
-				.dimensions(width / 2 - 154, height - 28, 75, 20).build());
+		addRenderableWidget(starButton =
+			Button.builder(Component.literal("Favorite"), b -> pressFavorite())
+				.bounds(width / 2 - 154, height - 28, 75, 20).build());
 		
-		addDrawableChild(editButton =
-			ButtonWidget.builder(Text.literal("Edit"), b -> pressEdit())
-				.dimensions(width / 2 - 76, height - 28, 74, 20).build());
+		addRenderableWidget(editButton =
+			Button.builder(Component.literal("Edit"), b -> pressEdit())
+				.bounds(width / 2 - 76, height - 28, 74, 20).build());
 		
-		addDrawableChild(deleteButton =
-			ButtonWidget.builder(Text.literal("Delete"), b -> pressDelete())
-				.dimensions(width / 2 + 2, height - 28, 74, 20).build());
+		addRenderableWidget(deleteButton =
+			Button.builder(Component.literal("Delete"), b -> pressDelete())
+				.bounds(width / 2 + 2, height - 28, 74, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 + 80, height - 28, 75, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 + 80, height - 28, 75, 20).build());
 		
-		addDrawableChild(importButton =
-			ButtonWidget.builder(Text.literal("Import"), b -> pressImportAlts())
-				.dimensions(8, 8, 50, 20).build());
+		addRenderableWidget(importButton =
+			Button.builder(Component.literal("Import"), b -> pressImportAlts())
+				.bounds(8, 8, 50, 20).build());
 		
-		addDrawableChild(exportButton =
-			ButtonWidget.builder(Text.literal("Export"), b -> pressExportAlts())
-				.dimensions(58, 8, 50, 20).build());
+		addRenderableWidget(exportButton =
+			Button.builder(Component.literal("Export"), b -> pressExportAlts())
+				.bounds(58, 8, 50, 20).build());
 		
-		addDrawableChild(logoutButton =
-			ButtonWidget.builder(Text.literal("Logout"), b -> pressLogout())
-				.dimensions(width - 50 - 8, 8, 50, 20).build());
+		addRenderableWidget(logoutButton =
+			Button.builder(Component.literal("Logout"), b -> pressLogout())
+				.bounds(width - 50 - 8, 8, 50, 20).build());
 		
 		updateAltButtons();
-		boolean windowMode = !client.options.getFullscreen().getValue();
+		boolean windowMode = !minecraft.options.fullscreen().get();
 		importButton.active = windowMode;
 		exportButton.active = windowMode;
 	}
 	
 	private void updateAltButtons()
 	{
-		boolean altSelected = listGui.getSelectedOrNull() != null;
+		boolean altSelected = listGui.getSelected() != null;
 		useButton.active = altSelected;
 		starButton.active = altSelected;
 		editButton.active = altSelected;
 		deleteButton.active = altSelected;
 		
 		logoutButton.active =
-			((IMinecraftClient)client).getWurstSession() != null;
+			((IMinecraftClient)minecraft).getWurstSession() != null;
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ENTER)
 			useButton.onPress(context);
@@ -190,11 +193,11 @@ public final class AltManagerScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		if(context.button() == GLFW.GLFW_MOUSE_BUTTON_4)
 		{
-			close();
+			onClose();
 			return true;
 		}
 		
@@ -211,7 +214,7 @@ public final class AltManagerScreen extends Screen
 		{
 			altManager.login(alt);
 			failedLogins.remove(alt);
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			
 		}catch(LoginException e)
 		{
@@ -222,7 +225,7 @@ public final class AltManagerScreen extends Screen
 	
 	private void pressLogout()
 	{
-		((IMinecraftClient)client).setWurstSession(null);
+		((IMinecraftClient)minecraft).setWurstSession(null);
 		updateAltButtons();
 	}
 	
@@ -242,7 +245,7 @@ public final class AltManagerScreen extends Screen
 		if(alt == null)
 			return;
 		
-		client.setScreen(new EditAltScreen(this, altManager, alt));
+		minecraft.setScreen(new EditAltScreen(this, altManager, alt));
 	}
 	
 	private void pressDelete()
@@ -251,15 +254,16 @@ public final class AltManagerScreen extends Screen
 		if(alt == null)
 			return;
 		
-		Text text = Text.literal("Are you sure you want to remove this alt?");
+		Component text =
+			Component.literal("Are you sure you want to remove this alt?");
 		
 		String altName = alt.getDisplayName();
-		Text message = Text.literal(
+		Component message = Component.literal(
 			"\"" + altName + "\" will be lost forever! (A long time!)");
 		
 		ConfirmScreen screen = new ConfirmScreen(this::confirmRemove, text,
-			message, Text.literal("Delete"), Text.literal("Cancel"));
-		client.setScreen(screen);
+			message, Component.literal("Delete"), Component.literal("Cancel"));
+		minecraft.setScreen(screen);
 	}
 	
 	private void pressImportAlts()
@@ -389,7 +393,7 @@ public final class AltManagerScreen extends Screen
 		}
 		
 		shouldAsk = false;
-		client.setScreen(this);
+		minecraft.setScreen(this);
 	}
 	
 	private void confirmRemove(boolean confirmed)
@@ -401,11 +405,11 @@ public final class AltManagerScreen extends Screen
 		if(confirmed)
 			altManager.remove(alt);
 		
-		client.setScreen(this);
+		minecraft.setScreen(this);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		listGui.render(context, mouseX, mouseY, partialTicks);
@@ -422,15 +426,14 @@ public final class AltManagerScreen extends Screen
 		}
 		
 		// title text
-		context.drawCenteredTextWithShadow(textRenderer, "Alt Manager",
-			width / 2, 4, Colors.WHITE);
-		context.drawCenteredTextWithShadow(textRenderer,
-			"Alts: " + altManager.getList().size(), width / 2, 14,
-			Colors.LIGHT_GRAY);
-		context.drawCenteredTextWithShadow(
-			textRenderer, "premium: " + altManager.getNumPremium()
-				+ ", cracked: " + altManager.getNumCracked(),
-			width / 2, 24, Colors.LIGHT_GRAY);
+		context.drawCenteredString(font, "Alt Manager", width / 2, 4,
+			CommonColors.WHITE);
+		context.drawCenteredString(font, "Alts: " + altManager.getList().size(),
+			width / 2, 14, CommonColors.LIGHT_GRAY);
+		context.drawCenteredString(font,
+			"premium: " + altManager.getNumPremium() + ", cracked: "
+				+ altManager.getNumCracked(),
+			width / 2, 24, CommonColors.LIGHT_GRAY);
 		
 		// red flash for errors
 		if(errorTimer > 0)
@@ -441,14 +444,14 @@ public final class AltManagerScreen extends Screen
 			errorTimer--;
 		}
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		renderButtonTooltip(context, mouseX, mouseY);
 		renderAltTooltip(context, mouseX, mouseY);
 	}
 	
-	private void renderAltTooltip(DrawContext context, int mouseX, int mouseY)
+	private void renderAltTooltip(GuiGraphics context, int mouseX, int mouseY)
 	{
 		if(!listGui.isMouseOver(mouseX, mouseY))
 			return;
@@ -465,9 +468,9 @@ public final class AltManagerScreen extends Screen
 			return;
 		
 		Alt alt = hoveredEntry.alt;
-		ArrayList<Text> tooltip = new ArrayList<>();
+		ArrayList<Component> tooltip = new ArrayList<>();
 		
-		if(itemX >= 31 + textRenderer.getWidth(hoveredEntry.getBottomText()))
+		if(itemX >= 31 + font.width(hoveredEntry.getBottomText()))
 			return;
 		
 		if(alt.isCracked())
@@ -488,34 +491,35 @@ public final class AltManagerScreen extends Screen
 		if(alt.isFavorite())
 			addTooltip(tooltip, "favorite");
 		
-		context.drawTooltip(textRenderer, tooltip, mouseX, mouseY);
+		context.setComponentTooltipForNextFrame(font, tooltip, mouseX, mouseY);
 	}
 	
-	private void renderButtonTooltip(DrawContext context, int mouseX,
+	private void renderButtonTooltip(GuiGraphics context, int mouseX,
 		int mouseY)
 	{
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
-			if(!button.isSelected())
+			if(!button.isHoveredOrFocused())
 				continue;
 			
 			if(button != importButton && button != exportButton)
 				continue;
 			
-			ArrayList<Text> tooltip = new ArrayList<>();
+			ArrayList<Component> tooltip = new ArrayList<>();
 			addTooltip(tooltip, "window");
 			
-			if(client.options.getFullscreen().getValue())
+			if(minecraft.options.fullscreen().get())
 				addTooltip(tooltip, "fullscreen");
 			else
 				addTooltip(tooltip, "window_freeze");
 			
-			context.drawTooltip(textRenderer, tooltip, mouseX, mouseY);
+			context.setComponentTooltipForNextFrame(font, tooltip, mouseX,
+				mouseY);
 			break;
 		}
 	}
 	
-	private void addTooltip(ArrayList<Text> tooltip, String trKey)
+	private void addTooltip(ArrayList<Component> tooltip, String trKey)
 	{
 		// translate
 		String translated = WurstClient.INSTANCE
@@ -523,24 +527,23 @@ public final class AltManagerScreen extends Screen
 		
 		// line-wrap
 		StringJoiner joiner = new StringJoiner("\n");
-		textRenderer.getTextHandler().wrapLines(translated, 200, Style.EMPTY)
-			.stream().map(StringVisitable::getString)
-			.forEach(s -> joiner.add(s));
+		font.getSplitter().splitLines(translated, 200, Style.EMPTY).stream()
+			.map(FormattedText::getString).forEach(s -> joiner.add(s));
 		String wrapped = joiner.toString();
 		
 		// add to tooltip
 		for(String line : wrapped.split("\n"))
-			tooltip.add(Text.literal(line));
+			tooltip.add(Component.literal(line));
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	private final class Entry
-		extends AlwaysSelectedEntryListWidget.Entry<AltManagerScreen.Entry>
+		extends ObjectSelectionList.Entry<AltManagerScreen.Entry>
 	{
 		private final Alt alt;
 		private long lastClickTime;
@@ -551,20 +554,21 @@ public final class AltManagerScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			return Text.translatable("narrator.select", "Alt " + alt + ", "
-				+ StringHelper.stripTextFormat(getBottomText()));
+			return Component.translatable("narrator.select",
+				"Alt " + alt + ", " + StringUtil.stripColor(getBottomText()));
 		}
 		
 		@Override
-		public boolean mouseClicked(Click context, boolean doubleClick)
+		public boolean mouseClicked(MouseButtonEvent context,
+			boolean doubleClick)
 		{
 			if(context.button() != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 				return false;
 			
-			long timeSinceLastClick = Util.getMeasuringTimeMs() - lastClickTime;
-			lastClickTime = Util.getMeasuringTimeMs();
+			long timeSinceLastClick = Util.getMillis() - lastClickTime;
+			lastClickTime = Util.getMillis();
 			
 			if(timeSinceLastClick < 250)
 				pressLogin();
@@ -573,18 +577,18 @@ public final class AltManagerScreen extends Screen
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
 			// green glow when logged in
-			if(client.getSession().getUsername().equals(alt.getName()))
+			if(minecraft.getUser().getName().equals(alt.getName()))
 			{
 				float opacity =
-					0.3F - Math.abs(MathHelper.sin(System.currentTimeMillis()
-						% 10000L / 10000F * (float)Math.PI * 2.0F) * 0.15F);
+					0.3F - Math.abs(Mth.sin(System.currentTimeMillis() % 10000L
+						/ 10000F * (float)Math.PI * 2.0F) * 0.15F);
 				
 				int color = 0x00FF00 | (int)(opacity * 255) << 24;
 				context.fill(x - 2, y - 2, x + 218, y + 28, color);
@@ -592,17 +596,17 @@ public final class AltManagerScreen extends Screen
 			
 			// face
 			AltRenderer.drawAltFace(context, alt.getName(), x + 1, y + 1, 24,
-				24, listGui.getSelectedOrNull() == this);
+				24, listGui.getSelected() == this);
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			// name / email
-			context.drawText(tr, "Name: " + alt.getDisplayName(), x + 31, y + 3,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, "Name: " + alt.getDisplayName(), x + 31,
+				y + 3, CommonColors.LIGHT_GRAY, false);
 			
 			// status
-			context.drawText(tr, getBottomText(), x + 31, y + 15,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, getBottomText(), x + 31, y + 15,
+				CommonColors.LIGHT_GRAY, false);
 		}
 		
 		private String getBottomText()
@@ -622,9 +626,9 @@ public final class AltManagerScreen extends Screen
 	}
 	
 	private final class ListGui
-		extends AlwaysSelectedEntryListWidget<AltManagerScreen.Entry>
+		extends ObjectSelectionList<AltManagerScreen.Entry>
 	{
-		public ListGui(MinecraftClient minecraft, AltManagerScreen screen,
+		public ListGui(Minecraft minecraft, AltManagerScreen screen,
 			List<Alt> list)
 		{
 			super(minecraft, screen.width, screen.height - 96, 36, 30);
@@ -653,7 +657,7 @@ public final class AltManagerScreen extends Screen
 		 */
 		public Alt getSelectedAlt()
 		{
-			AltManagerScreen.Entry selected = getSelectedOrNull();
+			AltManagerScreen.Entry selected = getSelected();
 			return selected != null ? selected.alt : null;
 		}
 		
@@ -663,7 +667,7 @@ public final class AltManagerScreen extends Screen
 		public AltManagerScreen.Entry getHoveredEntry(double mouseX,
 			double mouseY)
 		{
-			Optional<Element> hovered = hoveredElement(mouseX, mouseY);
+			Optional<GuiEventListener> hovered = getChildAt(mouseX, mouseY);
 			return hovered.map(e -> ((AltManagerScreen.Entry)e)).orElse(null);
 		}
 	}
diff --git a/src/main/java/net/wurstclient/altmanager/screens/DirectLoginScreen.java b/src/main/java/net/wurstclient/altmanager/screens/DirectLoginScreen.java
index 57a8218b2..a94c0dade 100644
--- a/src/main/java/net/wurstclient/altmanager/screens/DirectLoginScreen.java
+++ b/src/main/java/net/wurstclient/altmanager/screens/DirectLoginScreen.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.altmanager.screens;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.TitleScreen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.TitleScreen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.altmanager.LoginException;
 import net.wurstclient.altmanager.LoginManager;
 import net.wurstclient.altmanager.MicrosoftLoginManager;
@@ -18,7 +18,7 @@ public final class DirectLoginScreen extends AltEditorScreen
 {
 	public DirectLoginScreen(Screen prevScreen)
 	{
-		super(prevScreen, Text.literal("Direct Login"));
+		super(prevScreen, Component.literal("Direct Login"));
 	}
 	
 	@Override
@@ -49,6 +49,6 @@ public final class DirectLoginScreen extends AltEditorScreen
 			}
 		
 		message = "";
-		client.setScreen(new TitleScreen());
+		minecraft.setScreen(new TitleScreen());
 	}
 }
diff --git a/src/main/java/net/wurstclient/altmanager/screens/EditAltScreen.java b/src/main/java/net/wurstclient/altmanager/screens/EditAltScreen.java
index 8979487ec..d4e527e87 100644
--- a/src/main/java/net/wurstclient/altmanager/screens/EditAltScreen.java
+++ b/src/main/java/net/wurstclient/altmanager/screens/EditAltScreen.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.altmanager.screens;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.altmanager.Alt;
 import net.wurstclient.altmanager.AltManager;
 import net.wurstclient.altmanager.MojangAlt;
@@ -21,7 +21,7 @@ public final class EditAltScreen extends AltEditorScreen
 	public EditAltScreen(Screen prevScreen, AltManager altManager,
 		Alt editedAlt)
 	{
-		super(prevScreen, Text.literal("Edit Alt"));
+		super(prevScreen, Component.literal("Edit Alt"));
 		this.altManager = altManager;
 		this.editedAlt = editedAlt;
 	}
@@ -50,6 +50,6 @@ public final class EditAltScreen extends AltEditorScreen
 	protected void pressDoneButton()
 	{
 		altManager.edit(editedAlt, getNameOrEmail(), getPassword());
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 }
diff --git a/src/main/java/net/wurstclient/analytics/PlausibleAnalytics.java b/src/main/java/net/wurstclient/analytics/PlausibleAnalytics.java
index 7e9ed834d..b7ac4e31d 100644
--- a/src/main/java/net/wurstclient/analytics/PlausibleAnalytics.java
+++ b/src/main/java/net/wurstclient/analytics/PlausibleAnalytics.java
@@ -28,10 +28,10 @@ import net.fabricmc.loader.api.FabricLoader;
 import net.fabricmc.loader.api.ModContainer;
 import net.fabricmc.loader.api.Version;
 import net.fabricmc.loader.api.metadata.ModMetadata;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.client.resource.language.LanguageManager;
-import net.minecraft.client.world.ClientWorld;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.resources.language.LanguageManager;
 
 /**
  * An implementation of the Plausible Events API for privacy-friendly
@@ -100,26 +100,26 @@ public final class PlausibleAnalytics
 		return version;
 	}
 	
-	private void onWorldChange(MinecraftClient client, ClientWorld world)
+	private void onWorldChange(Minecraft client, ClientLevel world)
 	{
 		sessionProp("language", getLanguage(client));
 		sessionProp("game_type", getGameType(client));
 		pageview("/in-game");
 	}
 	
-	private String getLanguage(MinecraftClient client)
+	private String getLanguage(Minecraft client)
 	{
 		return Optional.ofNullable(client.getLanguageManager())
-			.map(LanguageManager::getLanguage).map(String::toLowerCase)
+			.map(LanguageManager::getSelected).map(String::toLowerCase)
 			.orElse(null);
 	}
 	
-	private String getGameType(MinecraftClient client)
+	private String getGameType(Minecraft client)
 	{
-		ServerInfo server = client.getCurrentServerEntry();
+		ServerData server = client.getCurrentServer();
 		if(server == null)
 			return "singleplayer";
-		if(server.isLocal())
+		if(server.isLan())
 			return "lan";
 		if(server.isRealm())
 			return "realms";
diff --git a/src/main/java/net/wurstclient/chestsearch/ChestCleaner.java b/src/main/java/net/wurstclient/chestsearch/ChestCleaner.java
index 462fbcc1d..cbd0f8280 100644
--- a/src/main/java/net/wurstclient/chestsearch/ChestCleaner.java
+++ b/src/main/java/net/wurstclient/chestsearch/ChestCleaner.java
@@ -8,8 +8,8 @@
 package net.wurstclient.chestsearch;
 
 import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.screens.ChestSearchScreen;
 
@@ -42,8 +42,8 @@ public class ChestCleaner
 					return; // check every ~5s (20 ticks/s)
 				tickCounter = 0;
 				
-				MinecraftClient mc = WurstClient.MC;
-				if(mc == null || mc.world == null)
+				Minecraft mc = WurstClient.MC;
+				if(mc == null || mc.level == null)
 					return;
 					
 				// update world/server observation ticks and detect join/world
@@ -51,15 +51,14 @@ public class ChestCleaner
 				String curServer = null;
 				try
 				{
-					if(mc.getCurrentServerEntry() != null)
-						curServer = mc.getCurrentServerEntry().address;
+					if(mc.getCurrentServer() != null)
+						curServer = mc.getCurrentServer().ip;
 				}catch(Throwable ignored)
 				{}
 				String curDimension = null;
 				try
 				{
-					curDimension =
-						mc.world.getRegistryKey().getValue().toString();
+					curDimension = mc.level.dimension().location().toString();
 				}catch(Throwable ignored)
 				{}
 				// reset grace timer on server/dimension change
@@ -80,14 +79,14 @@ public class ChestCleaner
 				String serverIp = null;
 				try
 				{
-					if(mc.getCurrentServerEntry() != null)
-						serverIp = mc.getCurrentServerEntry().address;
+					if(mc.getCurrentServer() != null)
+						serverIp = mc.getCurrentServer().ip;
 				}catch(Throwable ignored)
 				{}
 				String dimension = null;
 				try
 				{
-					dimension = mc.world.getRegistryKey().getValue().toString();
+					dimension = mc.level.dimension().location().toString();
 				}catch(Throwable ignored)
 				{}
 				
@@ -126,7 +125,7 @@ public class ChestCleaner
 						
 						// compute distance from player to nearest point in
 						// bounds
-						BlockPos playerPos = mc.player.getBlockPos();
+						BlockPos playerPos = mc.player.blockPosition();
 						int px = playerPos.getX();
 						int py = playerPos.getY();
 						int pz = playerPos.getZ();
@@ -167,15 +166,14 @@ public class ChestCleaner
 									try
 									{
 										@SuppressWarnings("deprecation")
-										boolean tmp =
-											mc.world.isChunkLoaded(pos);
+										boolean tmp = mc.level.hasChunkAt(pos);
 										chunkLoaded = tmp;
 									}catch(Throwable ignored)
 									{
 										try
 										{
 											Object cm =
-												mc.world.getChunkManager();
+												mc.level.getChunkSource();
 											java.lang.reflect.Method m =
 												cm.getClass().getMethod(
 													"isChunkLoaded", int.class,
@@ -193,18 +191,18 @@ public class ChestCleaner
 														// chunks loaded
 									}
 									
-									var state = mc.world.getBlockState(pos);
+									var state = mc.level.getBlockState(pos);
 									boolean containerBlock =
 										state != null && (state
-											.getBlock() instanceof net.minecraft.block.ChestBlock
+											.getBlock() instanceof net.minecraft.world.level.block.ChestBlock
 											|| state
-												.getBlock() instanceof net.minecraft.block.BarrelBlock
+												.getBlock() instanceof net.minecraft.world.level.block.BarrelBlock
 											|| state
-												.getBlock() instanceof net.minecraft.block.ShulkerBoxBlock
+												.getBlock() instanceof net.minecraft.world.level.block.ShulkerBoxBlock
 											|| state
-												.getBlock() instanceof net.minecraft.block.DecoratedPotBlock);
+												.getBlock() instanceof net.minecraft.world.level.block.DecoratedPotBlock);
 									boolean hasBe =
-										mc.world.getBlockEntity(pos) != null;
+										mc.level.getBlockEntity(pos) != null;
 									if(containerBlock && hasBe)
 									{
 										anyContainerPresent = true;
diff --git a/src/main/java/net/wurstclient/chestsearch/ChestEntry.java b/src/main/java/net/wurstclient/chestsearch/ChestEntry.java
index b485ec59a..94a127d71 100644
--- a/src/main/java/net/wurstclient/chestsearch/ChestEntry.java
+++ b/src/main/java/net/wurstclient/chestsearch/ChestEntry.java
@@ -10,8 +10,7 @@ package net.wurstclient.chestsearch;
 import com.google.gson.JsonElement;
 import java.time.Instant;
 import java.util.List;
-
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 
 public class ChestEntry
 {
diff --git a/src/main/java/net/wurstclient/chestsearch/ChestManager.java b/src/main/java/net/wurstclient/chestsearch/ChestManager.java
index 95297f497..e03f28739 100644
--- a/src/main/java/net/wurstclient/chestsearch/ChestManager.java
+++ b/src/main/java/net/wurstclient/chestsearch/ChestManager.java
@@ -143,8 +143,8 @@ public class ChestManager
 		try
 		{
 			if(WurstClient.MC != null
-				&& WurstClient.MC.getCurrentServerEntry() != null)
-				serverIp = WurstClient.MC.getCurrentServerEntry().address;
+				&& WurstClient.MC.getCurrentServer() != null)
+				serverIp = WurstClient.MC.getCurrentServer().ip;
 		}catch(Throwable ignored)
 		{}
 		return getDb(serverIp);
diff --git a/src/main/java/net/wurstclient/chestsearch/ChestRecorder.java b/src/main/java/net/wurstclient/chestsearch/ChestRecorder.java
index 3431116c6..0554321ec 100644
--- a/src/main/java/net/wurstclient/chestsearch/ChestRecorder.java
+++ b/src/main/java/net/wurstclient/chestsearch/ChestRecorder.java
@@ -8,23 +8,22 @@
 package net.wurstclient.chestsearch;
 
 import com.google.gson.JsonPrimitive;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.screen.ScreenHandler;
-import net.minecraft.screen.ScreenHandlerListener;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.ContainerListener;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.alchemy.PotionContents;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.wurstclient.clickgui.screens.ChestSearchScreen;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
-import net.minecraft.registry.entry.RegistryEntry;
 import java.util.Set;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.util.Identifier;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -90,14 +89,14 @@ public class ChestRecorder
 	 * Starts recording updates for the given handler.
 	 */
 	public void startListening(final String serverIp, final String dimension,
-		final int x, final int y, final int z, final ScreenHandler handler,
-		final int chestSlots, final List<Integer> chestSlotIndices,
-		final Bounds bounds)
+		final int x, final int y, final int z,
+		final AbstractContainerMenu handler, final int chestSlots,
+		final List<Integer> chestSlotIndices, final Bounds bounds)
 	{
 		if(config != null && !config.enabled)
 			return;
 		
-		final int syncId = handler.syncId;
+		final int syncId = handler.containerId;
 		final List<ItemStack> buf = new ArrayList<>(handler.slots.size());
 		for(int i = 0; i < handler.slots.size(); i++)
 			buf.add(ItemStack.EMPTY);
@@ -119,7 +118,7 @@ public class ChestRecorder
 		{
 			if(idx >= 0 && idx < handler.slots.size())
 			{
-				ItemStack st = handler.slots.get(idx).getStack();
+				ItemStack st = handler.slots.get(idx).getItem();
 				buf.set(idx, st == null ? ItemStack.EMPTY : st.copy());
 			}
 		}
@@ -166,10 +165,10 @@ public class ChestRecorder
 			new Timer(true).schedule(task, 40);
 		};
 		
-		ScreenHandlerListener listener = new ScreenHandlerListener()
+		ContainerListener listener = new ContainerListener()
 		{
 			@Override
-			public void onSlotUpdate(ScreenHandler sh, int slotId,
+			public void slotChanged(AbstractContainerMenu sh, int slotId,
 				ItemStack stack)
 			{
 				if(sh != handler)
@@ -183,14 +182,14 @@ public class ChestRecorder
 			}
 			
 			@Override
-			public void onPropertyUpdate(ScreenHandler handler, int property,
+			public void dataChanged(AbstractContainerMenu handler, int property,
 				int value)
 			{}
 		};
 		
 		try
 		{
-			handler.addListener(listener);
+			handler.addSlotListener(listener);
 		}catch(Throwable t)
 		{
 			t.printStackTrace();
@@ -227,7 +226,7 @@ public class ChestRecorder
 						}
 						try
 						{
-							handler.removeListener(listener);
+							handler.removeSlotListener(listener);
 						}catch(Throwable ignored)
 						{}
 						buffers.remove(syncId);
@@ -241,14 +240,14 @@ public class ChestRecorder
 	}
 	
 	public void onChestOpened(String serverIp, String dimension, int x, int y,
-		int z, ScreenHandler handler, int chestSlots, Bounds bounds)
+		int z, AbstractContainerMenu handler, int chestSlots, Bounds bounds)
 	{
 		startListening(serverIp, dimension, x, y, z, handler, chestSlots,
 			new ArrayList<>(), bounds);
 	}
 	
 	public void onChestOpened(String serverIp, String dimension, int x, int y,
-		int z, ScreenHandler handler, int chestSlots,
+		int z, AbstractContainerMenu handler, int chestSlots,
 		List<Integer> chestSlotIndices, Bounds bounds)
 	{
 		startListening(serverIp, dimension, x, y, z, handler, chestSlots,
@@ -313,14 +312,15 @@ public class ChestRecorder
 			it.count = copy.getCount();
 			try
 			{
-				it.itemId = Registries.ITEM.getId(copy.getItem()).toString();
+				it.itemId =
+					BuiltInRegistries.ITEM.getKey(copy.getItem()).toString();
 			}catch(Throwable t)
 			{
 				it.itemId = copy.getItem().toString();
 			}
 			try
 			{
-				it.displayName = copy.getName().getString();
+				it.displayName = copy.getHoverName().getString();
 			}catch(Throwable ignored)
 			{}
 			try
@@ -362,22 +362,22 @@ public class ChestRecorder
 				// Enchantments (including enchanted books)
 				try
 				{
-					Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchSet =
-						EnchantmentHelper.getEnchantments(copy)
-							.getEnchantmentEntries();
+					Set<Object2IntMap.Entry<Holder<Enchantment>>> enchSet =
+						EnchantmentHelper.getEnchantmentsForCrafting(copy)
+							.entrySet();
 					if(enchSet != null && !enchSet.isEmpty())
 					{
 						it.enchantments = new java.util.ArrayList<>();
 						it.enchantmentLevels = new java.util.ArrayList<>();
-						for(Object2IntMap.Entry<RegistryEntry<Enchantment>> e : enchSet)
+						for(Object2IntMap.Entry<Holder<Enchantment>> e : enchSet)
 						{
-							RegistryEntry<Enchantment> ren = e.getKey();
+							Holder<Enchantment> ren = e.getKey();
 							if(ren == null)
 								continue;
-							Identifier id = ren.getKey().map(k -> k.getValue())
-								.orElse(null);
+							ResourceLocation id = ren.unwrapKey()
+								.map(k -> k.location()).orElse(null);
 							String idStr = id != null ? id.toString()
-								: ren.getIdAsString();
+								: ren.getRegisteredName();
 							int lvl = e.getIntValue();
 							if(idStr != null && !idStr.isBlank())
 							{
@@ -392,22 +392,20 @@ public class ChestRecorder
 				// Potions / effects
 				try
 				{
-					PotionContentsComponent potionContents =
-						copy.getComponents().getOrDefault(
-							DataComponentTypes.POTION_CONTENTS,
-							PotionContentsComponent.DEFAULT);
+					PotionContents potionContents = copy.getComponents()
+						.getOrDefault(DataComponents.POTION_CONTENTS,
+							PotionContents.EMPTY);
 					if(potionContents != null)
 					{
 						java.util.List<String> pe = new java.util.ArrayList<>();
-						for(StatusEffectInstance sei : potionContents
-							.getEffects())
+						for(MobEffectInstance sei : potionContents
+							.getAllEffects())
 						{
-							RegistryEntry<StatusEffect> effEntry =
-								sei.getEffectType();
-							Identifier id = effEntry.getKey()
-								.map(k -> k.getValue()).orElse(null);
+							Holder<MobEffect> effEntry = sei.getEffect();
+							ResourceLocation id = effEntry.unwrapKey()
+								.map(k -> k.location()).orElse(null);
 							String idStr = id != null ? id.toString()
-								: effEntry.getIdAsString();
+								: effEntry.getRegisteredName();
 							if(idStr != null && !idStr.isBlank())
 								pe.add(idStr);
 						}
@@ -418,14 +416,15 @@ public class ChestRecorder
 						}else
 						{
 							// fallback to base potion id
-							java.util.Optional<net.minecraft.registry.entry.RegistryEntry<net.minecraft.potion.Potion>> basePotion =
+							java.util.Optional<net.minecraft.core.Holder<net.minecraft.world.item.alchemy.Potion>> basePotion =
 								potionContents.potion();
 							if(basePotion.isPresent())
 							{
-								Identifier id = basePotion.get().getKey()
-									.map(k -> k.getValue()).orElse(null);
+								ResourceLocation id =
+									basePotion.get().unwrapKey()
+										.map(k -> k.location()).orElse(null);
 								String idStr = id != null ? id.toString()
-									: basePotion.get().getIdAsString();
+									: basePotion.get().getRegisteredName();
 								it.primaryPotion = idStr;
 							}
 						}
@@ -470,7 +469,7 @@ public class ChestRecorder
 		try
 		{
 			Object screen = net.wurstclient.WurstClient.MC == null ? null
-				: net.wurstclient.WurstClient.MC.currentScreen;
+				: net.wurstclient.WurstClient.MC.screen;
 			if(screen != null)
 			{
 				try
diff --git a/src/main/java/net/wurstclient/chestsearch/TargetHighlighter.java b/src/main/java/net/wurstclient/chestsearch/TargetHighlighter.java
index b92e8cbba..4929e6e86 100644
--- a/src/main/java/net/wurstclient/chestsearch/TargetHighlighter.java
+++ b/src/main/java/net/wurstclient/chestsearch/TargetHighlighter.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.chestsearch;
 
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.RenderListener;
-import net.minecraft.client.util.math.MatrixStack;
 import net.wurstclient.util.RenderUtils;
-
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.*;
 
 /** Renders temporary highlight boxes at specific chest positions. */
@@ -98,15 +97,13 @@ public final class TargetHighlighter implements RenderListener
 	}
 	
 	@Override
-	public synchronized void onRender(MatrixStack matrixStack,
-		float partialTicks)
+	public synchronized void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		if(WurstClient.MC == null || WurstClient.MC.world == null)
+		if(WurstClient.MC == null || WurstClient.MC.level == null)
 			return;
-		String dim =
-			WurstClient.MC.world.getRegistryKey().getValue().toString();
+		String dim = WurstClient.MC.level.dimension().location().toString();
 		long now = System.currentTimeMillis();
-		List<Box> boxes = new ArrayList<>();
+		List<AABB> boxes = new ArrayList<>();
 		Iterator<Map.Entry<String, Target>> it = targets.entrySet().iterator();
 		while(it.hasNext())
 		{
@@ -125,7 +122,7 @@ public final class TargetHighlighter implements RenderListener
 			String k = e.getKey();
 			if(!k.startsWith(dim + "|"))
 				continue;
-			boxes.add(new Box(target.minX, target.minY, target.minZ,
+			boxes.add(new AABB(target.minX, target.minY, target.minZ,
 				target.maxX + 1, target.maxY + 1, target.maxZ + 1));
 		}
 		if(boxes.isEmpty())
diff --git a/src/main/java/net/wurstclient/clickgui/ClickGui.java b/src/main/java/net/wurstclient/clickgui/ClickGui.java
index afb3faf27..86d859f01 100644
--- a/src/main/java/net/wurstclient/clickgui/ClickGui.java
+++ b/src/main/java/net/wurstclient/clickgui/ClickGui.java
@@ -25,12 +25,10 @@ import org.lwjgl.glfw.GLFW;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParser;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.text.Text;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.Category;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
@@ -44,7 +42,7 @@ import net.wurstclient.util.json.JsonUtils;
 public final class ClickGui
 {
 	private static final WurstClient WURST = WurstClient.INSTANCE;
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final ArrayList<Window> windows = new ArrayList<>();
 	private final ArrayList<Popup> popups = new ArrayList<>();
@@ -155,7 +153,7 @@ public final class ClickGui
 		
 		int x = 5;
 		int y = 5;
-		int scaledWidth = MC.getWindow().getScaledWidth();
+		int scaledWidth = MC.getWindow().getGuiScaledWidth();
 		for(Window window : windows)
 		{
 			window.pack();
@@ -248,7 +246,7 @@ public final class ClickGui
 		}
 	}
 	
-	public void handleMouseClick(Click context)
+	public void handleMouseClick(MouseButtonEvent context)
 	{
 		int mouseX = (int)context.x();
 		int mouseY = (int)context.y();
@@ -347,7 +345,7 @@ public final class ClickGui
 	}
 	
 	public void handleNavigatorMouseClick(double cMouseX, double cMouseY,
-		int mouseButton, Window window, Click context)
+		int mouseButton, Window window, MouseButtonEvent context)
 	{
 		if(mouseButton == GLFW.GLFW_MOUSE_BUTTON_LEFT)
 			leftMouseButtonPressed = true;
@@ -435,7 +433,7 @@ public final class ClickGui
 	}
 	
 	private void handleWindowMouseClick(int mouseX, int mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		for(int i = windows.size() - 1; i >= 0; i--)
 		{
@@ -562,7 +560,7 @@ public final class ClickGui
 	}
 	
 	private void handleComponentMouseClick(Window window, double mouseX,
-		double mouseY, int mouseButton, Click context)
+		double mouseY, int mouseButton, MouseButtonEvent context)
 	{
 		for(int i2 = window.countChildren() - 1; i2 >= 0; i2--)
 		{
@@ -579,12 +577,12 @@ public final class ClickGui
 		}
 	}
 	
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		updateColors();
 		
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		matrixStack.pushMatrix();
 		
 		tooltip = "";
@@ -620,7 +618,7 @@ public final class ClickGui
 		else
 			for(Window window : visibleWindows)
 			{
-				context.state.goUpLayer();
+				context.guiRenderState.up();
 				renderWindow(context, window, mouseX, mouseY, partialTicks);
 			}
 		
@@ -630,9 +628,9 @@ public final class ClickGui
 		matrixStack.popMatrix();
 	}
 	
-	public void renderPopups(DrawContext context, int mouseX, int mouseY)
+	public void renderPopups(GuiGraphics context, int mouseX, int mouseY)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		for(Popup popup : popups)
 		{
 			Component owner = popup.getOwner();
@@ -644,7 +642,7 @@ public final class ClickGui
 			
 			matrixStack.pushMatrix();
 			matrixStack.translate(x1, y1);
-			context.state.goUpLayer();
+			context.guiRenderState.up();
 			
 			int cMouseX = mouseX - x1;
 			int cMouseY = mouseY - y1;
@@ -654,31 +652,31 @@ public final class ClickGui
 		}
 	}
 	
-	public void renderTooltip(DrawContext context, int mouseX, int mouseY)
+	public void renderTooltip(GuiGraphics context, int mouseX, int mouseY)
 	{
 		if(tooltip.isEmpty())
 			return;
 		
 		String[] lines = tooltip.split("\n");
-		TextRenderer tr = MC.textRenderer;
+		Font tr = MC.font;
 		
 		int tw = 0;
-		int th = lines.length * tr.fontHeight;
+		int th = lines.length * tr.lineHeight;
 		for(String line : lines)
 		{
-			int lw = tr.getWidth(line);
+			int lw = tr.width(line);
 			if(lw > tw)
 				tw = lw;
 		}
-		int sw = MC.currentScreen.width;
-		int sh = MC.currentScreen.height;
+		int sw = MC.screen.width;
+		int sh = MC.screen.height;
 		
 		int xt1 = mouseX + tw + 11 <= sw ? mouseX + 8 : mouseX - tw - 8;
 		int xt2 = xt1 + tw + 3;
 		int yt1 = mouseY + th - 2 <= sh ? mouseY - 4 : mouseY - th - 4;
 		int yt2 = yt1 + th + 2;
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// background
 		context.fill(xt1, yt1, xt2, yt2,
@@ -689,13 +687,13 @@ public final class ClickGui
 			RenderUtils.toIntColor(acColor, 0.5F));
 		
 		// text
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		for(int i = 0; i < lines.length; i++)
-			context.drawText(tr, lines[i], xt1 + 2, yt1 + 2 + i * tr.fontHeight,
-				txtColor, false);
+			context.drawString(tr, lines[i], xt1 + 2,
+				yt1 + 2 + i * tr.lineHeight, txtColor, false);
 	}
 	
-	public void renderPinnedWindows(DrawContext context, float partialTicks)
+	public void renderPinnedWindows(GuiGraphics context, float partialTicks)
 	{
 		ArrayList<Window> pinnedWindows = new ArrayList<>();
 		for(Window window : windows)
@@ -713,7 +711,7 @@ public final class ClickGui
 		else
 			for(Window window : pinnedWindows)
 			{
-				context.state.goUpLayer();
+				context.guiRenderState.up();
 				renderWindow(context, window, Integer.MIN_VALUE,
 					Integer.MIN_VALUE, partialTicks);
 			}
@@ -740,7 +738,7 @@ public final class ClickGui
 			acColor = clickGui.getAccentColor();
 	}
 	
-	private void renderWindow(DrawContext context, Window window, int mouseX,
+	private void renderWindow(GuiGraphics context, Window window, int mouseX,
 		int mouseY, float partialTicks)
 	{
 		int x1 = window.getX();
@@ -752,7 +750,7 @@ public final class ClickGui
 		int windowBgColor = RenderUtils.toIntColor(bgColor, opacity);
 		int outlineColor = RenderUtils.toIntColor(acColor, 0.5F);
 		
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		if(window.isMinimized())
 			y2 = y3;
@@ -907,14 +905,15 @@ public final class ClickGui
 		context.fill(x1, y1, x3, y3, titleBgColor);
 		
 		// window title
-		TextRenderer tr = MC.textRenderer;
-		String title = tr.trimToWidth(Text.literal(window.getTitle()), x3 - x1)
-			.getString();
-		context.state.goUpLayer();
-		context.drawText(tr, title, x1 + 2, y1 + 3, txtColor, false);
+		Font tr = MC.font;
+		String title = tr.substrByWidth(
+			net.minecraft.network.chat.Component.literal(window.getTitle()),
+			x3 - x1).getString();
+		context.guiRenderState.up();
+		context.drawString(tr, title, x1 + 2, y1 + 3, txtColor, false);
 	}
 	
-	private void renderTitleBarButton(DrawContext context, int x1, int y1,
+	private void renderTitleBarButton(GuiGraphics context, int x1, int y1,
 		int x2, int y2, boolean hovering)
 	{
 		int x3 = x2 + 2;
@@ -968,7 +967,7 @@ public final class ClickGui
 		return isolateWindows;
 	}
 	
-	private void renderWindowsWithIsolation(DrawContext context,
+	private void renderWindowsWithIsolation(GuiGraphics context,
 		List<Window> windowsToRender, int mouseX, int mouseY,
 		float partialTicks)
 	{
@@ -986,7 +985,7 @@ public final class ClickGui
 			for(Rect rect : visibleAreas)
 			{
 				context.enableScissor(rect.x1, rect.y1, rect.x2, rect.y2);
-				context.state.goUpLayer();
+				context.guiRenderState.up();
 				renderWindow(context, window, mouseX, mouseY, partialTicks);
 				context.disableScissor();
 			}
@@ -1136,7 +1135,7 @@ public final class ClickGui
 				// check existing
 				for(int i = 0; i < window.countChildren(); i++)
 				{
-					Component c = window.getChild(i);
+					net.wurstclient.clickgui.Component c = window.getChild(i);
 					if(c instanceof net.wurstclient.clickgui.components.FeatureButton)
 					{
 						net.wurstclient.clickgui.components.FeatureButton fb =
@@ -1163,7 +1162,7 @@ public final class ClickGui
 				continue;
 			for(int i = window.countChildren() - 1; i >= 0; i--)
 			{
-				Component c = window.getChild(i);
+				net.wurstclient.clickgui.Component c = window.getChild(i);
 				if(c instanceof net.wurstclient.clickgui.components.FeatureButton)
 				{
 					net.wurstclient.clickgui.components.FeatureButton fb =
@@ -1193,7 +1192,7 @@ public final class ClickGui
 		if(window == null)
 			return;
 		// collect children
-		ArrayList<Component> all = new ArrayList<>();
+		ArrayList<net.wurstclient.clickgui.Component> all = new ArrayList<>();
 		for(int i = 0; i < window.countChildren(); i++)
 			all.add(window.getChild(i));
 		// sort by feature name when possible
@@ -1209,7 +1208,7 @@ public final class ClickGui
 		// remove all children and re-add in sorted order
 		for(int i = window.countChildren() - 1; i >= 0; i--)
 			window.remove(i);
-		for(Component c : all)
+		for(net.wurstclient.clickgui.Component c : all)
 			window.add(c);
 		window.pack();
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/ClickGuiIcons.java b/src/main/java/net/wurstclient/clickgui/ClickGuiIcons.java
index cc661899c..1de75e2b5 100644
--- a/src/main/java/net/wurstclient/clickgui/ClickGuiIcons.java
+++ b/src/main/java/net/wurstclient/clickgui/ClickGuiIcons.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.clickgui;
 
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.RenderUtils;
 
@@ -15,7 +15,7 @@ public enum ClickGuiIcons
 {
 	;
 	
-	public static void drawMinimizeArrow(DrawContext context, float x1,
+	public static void drawMinimizeArrow(GuiGraphics context, float x1,
 		float y1, float x2, float y2, boolean hovering, boolean minimized)
 	{
 		ClickGui gui = WurstClient.INSTANCE.getGui();
@@ -53,7 +53,7 @@ public enum ClickGuiIcons
 		RenderUtils.drawLineStrip2D(context, arrowVertices, outlineColor);
 	}
 	
-	public static void drawRadarArrow(DrawContext context, float x1, float y1,
+	public static void drawRadarArrow(GuiGraphics context, float x1, float y1,
 		float x2, float y2)
 	{
 		float x3 = x1 + (x2 - x1) / 2;
@@ -71,7 +71,7 @@ public enum ClickGuiIcons
 		RenderUtils.drawLineStrip2D(context, arrowVertices, outlineColor);
 	}
 	
-	public static void drawPin(DrawContext context, float x1, float y1,
+	public static void drawPin(GuiGraphics context, float x1, float y1,
 		float x2, float y2, boolean hovering, boolean pinned)
 	{
 		int needleColor = hovering ? 0xFFFFFFFF : 0xFFD9D9D9;
@@ -155,7 +155,7 @@ public enum ClickGuiIcons
 		}
 	}
 	
-	public static void drawCheck(DrawContext context, float x1, float y1,
+	public static void drawCheck(GuiGraphics context, float x1, float y1,
 		float x2, float y2, boolean hovering, boolean grayedOut)
 	{
 		float xc1 = x1 + 2.5F;
@@ -184,7 +184,7 @@ public enum ClickGuiIcons
 		RenderUtils.drawLineStrip2D(context, outlineVertices, outlineColor);
 	}
 	
-	public static void drawIndeterminateCheck(DrawContext context, float x1,
+	public static void drawIndeterminateCheck(GuiGraphics context, float x1,
 		float y1, float x2, float y2, boolean hovering, boolean grayedOut)
 	{
 		float xc1 = x1 + 2.5F;
@@ -202,7 +202,7 @@ public enum ClickGuiIcons
 		RenderUtils.drawBorder2D(context, xc1, yc1, xc2, yc2, outlineColor);
 	}
 	
-	public static void drawCross(DrawContext context, float x1, float y1,
+	public static void drawCross(GuiGraphics context, float x1, float y1,
 		float x2, float y2, boolean hovering)
 	{
 		float xc1 = x1 + 2;
diff --git a/src/main/java/net/wurstclient/clickgui/ComboBoxPopup.java b/src/main/java/net/wurstclient/clickgui/ComboBoxPopup.java
index 7ea83d35c..add6362b4 100644
--- a/src/main/java/net/wurstclient/clickgui/ComboBoxPopup.java
+++ b/src/main/java/net/wurstclient/clickgui/ComboBoxPopup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.clickgui;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.EnumSetting;
 import net.wurstclient.util.RenderUtils;
@@ -18,7 +17,7 @@ import net.wurstclient.util.RenderUtils;
 public final class ComboBoxPopup<T extends Enum<T>> extends Popup
 {
 	private static final ClickGui GUI = WurstClient.INSTANCE.getGui();
-	private static final TextRenderer TR = WurstClient.MC.textRenderer;
+	private static final Font TR = WurstClient.MC.font;
 	private static final int ROW_HEIGHT = 11;
 	private static final int MAX_VISIBLE_ROWS = 8;
 	
@@ -82,7 +81,7 @@ public final class ComboBoxPopup<T extends Enum<T>> extends Popup
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY)
+	public void render(GuiGraphics context, int mouseX, int mouseY)
 	{
 		if(visibleRows <= 0)
 			return;
@@ -122,8 +121,8 @@ public final class ComboBoxPopup<T extends Enum<T>> extends Popup
 			context.fill(x1, yi1, x2, yi2, RenderUtils.toIntColor(
 				GUI.getBgColor(), GUI.getOpacity() * (hValue ? 1.5F : 1)));
 			
-			context.state.goUpLayer();
-			context.drawText(TR, value.toString(), x1 + 2, yi1 + 2,
+			context.guiRenderState.up();
+			context.drawString(TR, value.toString(), x1 + 2, yi1 + 2,
 				GUI.getTxtColor(), false);
 			
 			drawn++;
diff --git a/src/main/java/net/wurstclient/clickgui/Component.java b/src/main/java/net/wurstclient/clickgui/Component.java
index e1198f57b..36f6f7a59 100644
--- a/src/main/java/net/wurstclient/clickgui/Component.java
+++ b/src/main/java/net/wurstclient/clickgui/Component.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.clickgui;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.WurstClient;
 
 public abstract class Component
 {
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	protected static final WurstClient WURST = WurstClient.INSTANCE;
 	
 	private int x;
@@ -25,12 +25,12 @@ public abstract class Component
 	private Window parent;
 	
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		
 	}
 	
-	public abstract void render(DrawContext context, int mouseX, int mouseY,
+	public abstract void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks);
 	
 	public abstract int getDefaultWidth();
diff --git a/src/main/java/net/wurstclient/clickgui/Popup.java b/src/main/java/net/wurstclient/clickgui/Popup.java
index c9617d28f..0a6c3a129 100644
--- a/src/main/java/net/wurstclient/clickgui/Popup.java
+++ b/src/main/java/net/wurstclient/clickgui/Popup.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.clickgui;
 
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
 
 public abstract class Popup
 {
@@ -27,7 +27,7 @@ public abstract class Popup
 	public abstract void handleMouseClick(int mouseX, int mouseY,
 		int mouseButton);
 	
-	public abstract void render(DrawContext context, int mouseX, int mouseY);
+	public abstract void render(GuiGraphics context, int mouseX, int mouseY);
 	
 	public abstract int getDefaultWidth();
 	
diff --git a/src/main/java/net/wurstclient/clickgui/SettingsWindow.java b/src/main/java/net/wurstclient/clickgui/SettingsWindow.java
index 6e77c5933..c42b0ba0c 100644
--- a/src/main/java/net/wurstclient/clickgui/SettingsWindow.java
+++ b/src/main/java/net/wurstclient/clickgui/SettingsWindow.java
@@ -8,8 +8,7 @@
 package net.wurstclient.clickgui;
 
 import java.util.stream.Stream;
-
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.Setting;
@@ -37,14 +36,15 @@ public final class SettingsWindow extends Window
 		int x = parent.getX() + parent.getWidth() + 5;
 		int y = parent.getY() + 12 + buttonY + scroll;
 		
-		net.minecraft.client.util.Window mcWindow = WurstClient.MC.getWindow();
-		if(x + getWidth() > mcWindow.getScaledWidth())
+		com.mojang.blaze3d.platform.Window mcWindow =
+			WurstClient.MC.getWindow();
+		if(x + getWidth() > mcWindow.getGuiScaledWidth())
 			x = parent.getX() - getWidth() - 5;
-		if(y + getHeight() > mcWindow.getScaledHeight())
+		if(y + getHeight() > mcWindow.getGuiScaledHeight())
 			y -= getHeight() - 14;
 		
-		x = MathHelper.clamp(x, 0, mcWindow.getScaledWidth());
-		y = MathHelper.clamp(y, 0, mcWindow.getScaledHeight());
+		x = Mth.clamp(x, 0, mcWindow.getGuiScaledWidth());
+		y = Mth.clamp(y, 0, mcWindow.getGuiScaledHeight());
 		
 		setX(x);
 		setY(y);
diff --git a/src/main/java/net/wurstclient/clickgui/Window.java b/src/main/java/net/wurstclient/clickgui/Window.java
index 2fdc0edc6..8eb4f4e61 100644
--- a/src/main/java/net/wurstclient/clickgui/Window.java
+++ b/src/main/java/net/wurstclient/clickgui/Window.java
@@ -8,9 +8,8 @@
 package net.wurstclient.clickgui;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.gui.Font;
+import net.minecraft.util.Mth;
 import net.wurstclient.WurstClient;
 
 public class Window
@@ -72,8 +71,8 @@ public class Window
 		if(!clampPosition)
 			return x;
 		
-		int scaledWidth = WurstClient.MC.getWindow().getScaledWidth();
-		return MathHelper.clamp(x, -width + 1, scaledWidth - 1);
+		int scaledWidth = WurstClient.MC.getWindow().getGuiScaledWidth();
+		return Mth.clamp(x, -width + 1, scaledWidth - 1);
 	}
 	
 	/**
@@ -99,8 +98,8 @@ public class Window
 		if(!clampPosition)
 			return y;
 		
-		int scaledHeight = WurstClient.MC.getWindow().getScaledHeight();
-		return MathHelper.clamp(y, -12, scaledHeight - 1);
+		int scaledHeight = WurstClient.MC.getWindow().getGuiScaledHeight();
+		return Mth.clamp(y, -12, scaledHeight - 1);
 	}
 	
 	/**
@@ -160,8 +159,8 @@ public class Window
 				maxChildWidth = c.getDefaultWidth();
 		maxChildWidth += 4;
 		
-		TextRenderer tr = WurstClient.MC.textRenderer;
-		int titleBarWidth = tr.getWidth(title) + 4;
+		Font tr = WurstClient.MC.font;
+		int titleBarWidth = tr.width(title) + 4;
 		if(minimizable)
 			titleBarWidth += 11;
 		if(pinnable)
diff --git a/src/main/java/net/wurstclient/clickgui/components/AbstractListEditButton.java b/src/main/java/net/wurstclient/clickgui/components/AbstractListEditButton.java
index 25a85acb6..8b522083b 100644
--- a/src/main/java/net/wurstclient/clickgui/components/AbstractListEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/AbstractListEditButton.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.settings.Setting;
@@ -20,10 +19,10 @@ import net.wurstclient.util.RenderUtils;
 public abstract class AbstractListEditButton extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	
 	private final String buttonText = "Edit...";
-	private final int buttonWidth = TR.getWidth(buttonText);
+	private final int buttonWidth = TR.width(buttonText);
 	
 	protected abstract void openScreen();
 	
@@ -33,7 +32,7 @@ public abstract class AbstractListEditButton extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseButton != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 			return;
@@ -45,7 +44,7 @@ public abstract class AbstractListEditButton extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -71,9 +70,9 @@ public abstract class AbstractListEditButton extends Component
 		
 		// text
 		int txtColor = GUI.getTxtColor();
-		context.state.goUpLayer();
-		context.drawText(TR, getText(), x1, y1 + 2, txtColor, false);
-		context.drawText(TR, buttonText, x3 + 2, y1 + 2, txtColor, false);
+		context.guiRenderState.up();
+		context.drawString(TR, getText(), x1, y1 + 2, txtColor, false);
+		context.drawString(TR, buttonText, x3 + 2, y1 + 2, txtColor, false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -85,7 +84,7 @@ public abstract class AbstractListEditButton extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(getText()) + buttonWidth + 6;
+		return TR.width(getText()) + buttonWidth + 6;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/BlockComponent.java b/src/main/java/net/wurstclient/clickgui/components/BlockComponent.java
index 47737e648..ca98e0dd7 100644
--- a/src/main/java/net/wurstclient/clickgui/components/BlockComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/BlockComponent.java
@@ -8,13 +8,12 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.item.ItemStack;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.Window;
@@ -25,7 +24,7 @@ import net.wurstclient.util.RenderUtils;
 public final class BlockComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int BLOCK_WIDTH = 24;
 	
 	private final BlockSetting setting;
@@ -39,7 +38,7 @@ public final class BlockComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseX < getX() + getWidth() - BLOCK_WIDTH)
 			return;
@@ -47,7 +46,7 @@ public final class BlockComponent extends Component
 		switch(mouseButton)
 		{
 			case GLFW.GLFW_MOUSE_BUTTON_LEFT:
-			MC.setScreen(new EditBlockScreen(MC.currentScreen, setting));
+			MC.setScreen(new EditBlockScreen(MC.screen, setting));
 			break;
 			
 			case GLFW.GLFW_MOUSE_BUTTON_RIGHT:
@@ -57,7 +56,7 @@ public final class BlockComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -81,11 +80,11 @@ public final class BlockComponent extends Component
 			RenderUtils.toIntColor(GUI.getBgColor(), GUI.getOpacity());
 		context.fill(x1, y1, x2, y2, bgColor);
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// text
 		String name = setting.getName() + ":";
-		context.drawText(TR, name, x1, y1 + 2, GUI.getTxtColor(), false);
+		context.drawString(TR, name, x1, y1 + 2, GUI.getTxtColor(), false);
 		
 		// block
 		ItemStack stack = new ItemStack(setting.getBlock());
@@ -106,17 +105,17 @@ public final class BlockComponent extends Component
 	private String getBlockTooltip()
 	{
 		Block block = setting.getBlock();
-		BlockState state = block.getDefaultState();
+		BlockState state = block.defaultBlockState();
 		ItemStack stack = new ItemStack(block);
 		
 		String translatedName = stack.isEmpty() ? "\u00a7ounknown block\u00a7r"
-			: stack.getName().getString();
+			: stack.getHoverName().getString();
 		String tooltip = "\u00a76Name:\u00a7r " + translatedName;
 		
 		String blockId = setting.getBlockName();
 		tooltip += "\n\u00a76ID:\u00a7r " + blockId;
 		
-		int blockNumber = Block.getRawIdFromState(state);
+		int blockNumber = Block.getId(state);
 		tooltip += "\n\u00a76Block #:\u00a7r " + blockNumber;
 		
 		tooltip += "\n\n\u00a7e[left-click]\u00a7r to edit";
@@ -128,7 +127,7 @@ public final class BlockComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(setting.getName() + ":") + BLOCK_WIDTH + 4;
+		return TR.width(setting.getName() + ":") + BLOCK_WIDTH + 4;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/BlockListEditButton.java b/src/main/java/net/wurstclient/clickgui/components/BlockListEditButton.java
index 26392ea55..1b808660a 100644
--- a/src/main/java/net/wurstclient/clickgui/components/BlockListEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/BlockListEditButton.java
@@ -27,7 +27,7 @@ public final class BlockListEditButton extends AbstractListEditButton
 	@Override
 	protected void openScreen()
 	{
-		MC.setScreen(new EditBlockListScreen(MC.currentScreen, setting));
+		MC.setScreen(new EditBlockListScreen(MC.screen, setting));
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/BookOffersEditButton.java b/src/main/java/net/wurstclient/clickgui/components/BookOffersEditButton.java
index 24e4cb2f2..a2fcc9752 100644
--- a/src/main/java/net/wurstclient/clickgui/components/BookOffersEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/BookOffersEditButton.java
@@ -27,7 +27,7 @@ public final class BookOffersEditButton extends AbstractListEditButton
 	@Override
 	protected void openScreen()
 	{
-		MC.setScreen(new EditBookOffersScreen(MC.currentScreen, setting));
+		MC.setScreen(new EditBookOffersScreen(MC.screen, setting));
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/ButtonComponent.java b/src/main/java/net/wurstclient/clickgui/components/ButtonComponent.java
index 0c1692b7a..075c949e4 100644
--- a/src/main/java/net/wurstclient/clickgui/components/ButtonComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/ButtonComponent.java
@@ -8,9 +8,8 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.util.RenderUtils;
 
@@ -29,7 +28,7 @@ public final class ButtonComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseButton != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 			return;
@@ -38,7 +37,7 @@ public final class ButtonComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -49,14 +48,14 @@ public final class ButtonComponent extends Component
 		int color = RenderUtils.toIntColor(WURST.getGui().getBgColor(),
 			WURST.getGui().getOpacity() * (hover ? 1.2F : 1.0F));
 		context.fill(x1, y1, x2, y2, color);
-		context.drawCenteredTextWithShadow(MC.textRenderer, text, (x1 + x2) / 2,
-			y1 + 2, WURST.getGui().getTxtColor());
+		context.drawCenteredString(MC.font, text, (x1 + x2) / 2, y1 + 2,
+			WURST.getGui().getTxtColor());
 	}
 	
 	@Override
 	public int getDefaultWidth()
 	{
-		return MC.textRenderer.getWidth(text) + 8;
+		return MC.font.width(text) + 8;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/CheckboxComponent.java b/src/main/java/net/wurstclient/clickgui/components/CheckboxComponent.java
index 72e6467eb..3b0c31340 100644
--- a/src/main/java/net/wurstclient/clickgui/components/CheckboxComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/CheckboxComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.Component;
@@ -21,7 +20,7 @@ import net.wurstclient.util.RenderUtils;
 public final class CheckboxComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int BOX_SIZE = 11;
 	
 	private final CheckboxSetting setting;
@@ -35,7 +34,7 @@ public final class CheckboxComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		switch(mouseButton)
 		{
@@ -50,7 +49,7 @@ public final class CheckboxComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -76,7 +75,7 @@ public final class CheckboxComponent extends Component
 		int outlineColor = RenderUtils.toIntColor(GUI.getAcColor(), 0.5F);
 		RenderUtils.drawBorder2D(context, x1, y1, x3, y2, outlineColor);
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// check
 		if(setting.isChecked())
@@ -85,7 +84,7 @@ public final class CheckboxComponent extends Component
 		
 		// text
 		String name = setting.getName();
-		context.drawText(TR, name, x3 + 2, y1 + 2, GUI.getTxtColor(), false);
+		context.drawString(TR, name, x3 + 2, y1 + 2, GUI.getTxtColor(), false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -109,7 +108,7 @@ public final class CheckboxComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return BOX_SIZE + TR.getWidth(setting.getName()) + 2;
+		return BOX_SIZE + TR.width(setting.getName()) + 2;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/ColorComponent.java b/src/main/java/net/wurstclient/clickgui/components/ColorComponent.java
index a65f19c9f..78fcdff1f 100644
--- a/src/main/java/net/wurstclient/clickgui/components/ColorComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/ColorComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.screens.EditColorScreen;
@@ -22,7 +21,7 @@ import net.wurstclient.util.RenderUtils;
 public final class ColorComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int TEXT_HEIGHT = 11;
 	
 	private final ColorSetting setting;
@@ -36,7 +35,7 @@ public final class ColorComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseY < getY() + TEXT_HEIGHT)
 			return;
@@ -44,7 +43,7 @@ public final class ColorComponent extends Component
 		switch(mouseButton)
 		{
 			case GLFW.GLFW_MOUSE_BUTTON_LEFT:
-			MC.setScreen(new EditColorScreen(MC.currentScreen, setting));
+			MC.setScreen(new EditColorScreen(MC.screen, setting));
 			break;
 			
 			case GLFW.GLFW_MOUSE_BUTTON_RIGHT:
@@ -54,7 +53,7 @@ public final class ColorComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -86,11 +85,11 @@ public final class ColorComponent extends Component
 		// text
 		String name = setting.getName();
 		String value = ColorUtils.toHex(setting.getColor());
-		int valueWidth = TR.getWidth(value);
+		int valueWidth = TR.width(value);
 		int txtColor = GUI.getTxtColor();
-		context.state.goUpLayer();
-		context.drawText(TR, name, x1, y1 + 2, txtColor, false);
-		context.drawText(TR, value, x2 - valueWidth, y1 + 2, txtColor, false);
+		context.guiRenderState.up();
+		context.drawString(TR, name, x1, y1 + 2, txtColor, false);
+		context.drawString(TR, value, x2 - valueWidth, y1 + 2, txtColor, false);
 	}
 	
 	private String getColorTooltip()
@@ -106,7 +105,7 @@ public final class ColorComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(setting.getName() + "#FFFFFF") + 6;
+		return TR.width(setting.getName() + "#FFFFFF") + 6;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/ComboBoxComponent.java b/src/main/java/net/wurstclient/clickgui/components/ComboBoxComponent.java
index 482873b46..4276b7668 100644
--- a/src/main/java/net/wurstclient/clickgui/components/ComboBoxComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/ComboBoxComponent.java
@@ -10,10 +10,9 @@ package net.wurstclient.clickgui.components;
 import java.util.Arrays;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.ComboBoxPopup;
@@ -24,7 +23,7 @@ import net.wurstclient.util.RenderUtils;
 public final class ComboBoxComponent<T extends Enum<T>> extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int ARROW_SIZE = 11;
 	
 	private final EnumSetting<T> setting;
@@ -36,7 +35,7 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 	{
 		this.setting = setting;
 		popupWidth = Arrays.stream(setting.getValues()).map(T::toString)
-			.mapToInt(s -> TR.getWidth(s)).max().getAsInt();
+			.mapToInt(s -> TR.width(s)).max().getAsInt();
 		
 		setWidth(getDefaultWidth());
 		setHeight(getDefaultHeight());
@@ -44,7 +43,7 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseX < getX() + getWidth() - popupWidth - ARROW_SIZE - 4)
 			return;
@@ -88,7 +87,7 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -112,7 +111,7 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 		// box
 		context.fill(x4, y1, x2, y2, getFillColor(hBox));
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// outlines
 		int outlineColor = RenderUtils.toIntColor(GUI.getAcColor(), 0.5F);
@@ -127,8 +126,8 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 		String name = setting.getName();
 		String value = "" + setting.getSelected();
 		int txtColor = GUI.getTxtColor();
-		context.drawText(TR, name, x1, y1 + 2, txtColor, false);
-		context.drawText(TR, value, x4 + 2, y1 + 2, txtColor, false);
+		context.drawString(TR, name, x1, y1 + 2, txtColor, false);
+		context.drawString(TR, value, x4 + 2, y1 + 2, txtColor, false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -140,7 +139,7 @@ public final class ComboBoxComponent<T extends Enum<T>> extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(setting.getName()) + popupWidth + ARROW_SIZE + 6;
+		return TR.width(setting.getName()) + popupWidth + ARROW_SIZE + 6;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/EntityTypeListEditButton.java b/src/main/java/net/wurstclient/clickgui/components/EntityTypeListEditButton.java
index 364391bbc..ac810b803 100644
--- a/src/main/java/net/wurstclient/clickgui/components/EntityTypeListEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/EntityTypeListEditButton.java
@@ -28,7 +28,7 @@ public final class EntityTypeListEditButton extends AbstractListEditButton
 	{
 		MC.setScreen(
 			new net.wurstclient.clickgui.screens.EditEntityTypeListScreen(
-				MC.currentScreen, setting));
+				MC.screen, setting));
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/FeatureButton.java b/src/main/java/net/wurstclient/clickgui/components/FeatureButton.java
index eee065db1..9884b9a6f 100644
--- a/src/main/java/net/wurstclient/clickgui/components/FeatureButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/FeatureButton.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import java.util.Objects;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.Feature;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
@@ -26,7 +25,7 @@ import org.lwjgl.glfw.GLFW;
 public final class FeatureButton extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	
 	private final Feature feature;
 	private final boolean hasSettings;
@@ -48,7 +47,7 @@ public final class FeatureButton extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		// middle click toggles favorites
 		if(mouseButton == GLFW.GLFW_MOUSE_BUTTON_MIDDLE)
@@ -102,7 +101,7 @@ public final class FeatureButton extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -124,7 +123,7 @@ public final class FeatureButton extends Component
 		if(hasSettings)
 			context.fill(x3, y1, x2, y2, getButtonColor(false, hSettings));
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// outlines
 		int outlineColor = RenderUtils.toIntColor(GUI.getAcColor(), 0.5F);
@@ -139,9 +138,9 @@ public final class FeatureButton extends Component
 		
 		// text
 		String name = feature.getName();
-		int tx = x1 + (x3 - x1 - TR.getWidth(name)) / 2;
+		int tx = x1 + (x3 - x1 - TR.width(name)) / 2;
 		int ty = y1 + 2;
-		context.drawText(TR, name, tx, ty, GUI.getTxtColor(), false);
+		context.drawString(TR, name, tx, ty, GUI.getTxtColor(), false);
 	}
 	
 	private int getButtonColor(boolean enabled, boolean hovering)
@@ -154,7 +153,7 @@ public final class FeatureButton extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		int width = TR.getWidth(feature.getName());
+		int width = TR.width(feature.getName());
 		width += hasSettings ? 15 : 4;
 		return width;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/components/FileComponent.java b/src/main/java/net/wurstclient/clickgui/components/FileComponent.java
index 4bc94bf1a..268b079e1 100644
--- a/src/main/java/net/wurstclient/clickgui/components/FileComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/FileComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.screens.SelectFileScreen;
@@ -21,7 +20,7 @@ import net.wurstclient.util.RenderUtils;
 public final class FileComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	
 	private final FileSetting setting;
 	
@@ -34,7 +33,7 @@ public final class FileComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseButton != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 			return;
@@ -42,11 +41,11 @@ public final class FileComponent extends Component
 		if(mouseX < getX() + getWidth() - getButtonWidth() - 4)
 			return;
 		
-		MC.setScreen(new SelectFileScreen(MC.currentScreen, setting));
+		MC.setScreen(new SelectFileScreen(MC.screen, setting));
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -77,9 +76,9 @@ public final class FileComponent extends Component
 		int txtColor = GUI.getTxtColor();
 		String labelText = setting.getName() + ":";
 		String buttonText = setting.getSelectedFileName();
-		context.state.goUpLayer();
-		context.drawText(TR, labelText, x1, y1 + 2, txtColor, false);
-		context.drawText(TR, buttonText, x3 + 2, y1 + 2, txtColor, false);
+		context.guiRenderState.up();
+		context.drawString(TR, labelText, x1, y1 + 2, txtColor, false);
+		context.drawString(TR, buttonText, x3 + 2, y1 + 2, txtColor, false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -90,14 +89,14 @@ public final class FileComponent extends Component
 	
 	private int getButtonWidth()
 	{
-		return TR.getWidth(setting.getSelectedFileName());
+		return TR.width(setting.getSelectedFileName());
 	}
 	
 	@Override
 	public int getDefaultWidth()
 	{
 		String text = setting.getName() + ":";
-		return TR.getWidth(text) + getButtonWidth() + 6;
+		return TR.width(text) + getButtonWidth() + 6;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/ItemListEditButton.java b/src/main/java/net/wurstclient/clickgui/components/ItemListEditButton.java
index db4c72f44..66365bd3b 100644
--- a/src/main/java/net/wurstclient/clickgui/components/ItemListEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/ItemListEditButton.java
@@ -27,7 +27,7 @@ public final class ItemListEditButton extends AbstractListEditButton
 	@Override
 	protected void openScreen()
 	{
-		MC.setScreen(new EditItemListScreen(MC.currentScreen, setting));
+		MC.setScreen(new EditItemListScreen(MC.screen, setting));
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/MobWeaponRuleComponent.java b/src/main/java/net/wurstclient/clickgui/components/MobWeaponRuleComponent.java
index 723a90b78..97c190def 100644
--- a/src/main/java/net/wurstclient/clickgui/components/MobWeaponRuleComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/MobWeaponRuleComponent.java
@@ -14,10 +14,9 @@ import java.util.function.Function;
 import java.util.function.Supplier;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.Component;
@@ -30,7 +29,7 @@ import net.wurstclient.util.RenderUtils;
 public final class MobWeaponRuleComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int BOX_HEIGHT = 11;
 	private static final int ARROW_SIZE = 11;
 	private static final int BOX_GAP = 4;
@@ -50,7 +49,7 @@ public final class MobWeaponRuleComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		Box mobBox = getMobBox();
 		Box weaponBox = getWeaponBox();
@@ -117,7 +116,7 @@ public final class MobWeaponRuleComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -127,7 +126,7 @@ public final class MobWeaponRuleComponent extends Component
 		
 		int txtColor = GUI.getTxtColor();
 		
-		context.drawText(TR, setting.getName(), x1, y1, txtColor, false);
+		context.drawString(TR, setting.getName(), x1, y1, txtColor, false);
 		
 		Box mobBox = getMobBox();
 		Box weaponBox = getWeaponBox();
@@ -145,7 +144,7 @@ public final class MobWeaponRuleComponent extends Component
 			disabled, weaponPopup != null && !weaponPopup.isClosing());
 	}
 	
-	private void drawDropdown(DrawContext context, Box box, String value,
+	private void drawDropdown(GuiGraphics context, Box box, String value,
 		int mouseX, int mouseY, String tooltip, boolean dimmed,
 		boolean expanded)
 	{
@@ -166,7 +165,7 @@ public final class MobWeaponRuleComponent extends Component
 			RenderUtils.toIntColor(GUI.getBgColor(),
 				GUI.getOpacity() * (hovering ? 1.5F : 1F)));
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// outlines
 		int outlineColor = RenderUtils.toIntColor(GUI.getAcColor(), 0.5F);
@@ -181,7 +180,7 @@ public final class MobWeaponRuleComponent extends Component
 		
 		// value
 		int color = dimmed ? 0xFFAAAAAA : GUI.getTxtColor();
-		context.drawText(TR, value, box.x1 + 2, box.y1 + 2, color, false);
+		context.drawString(TR, value, box.x1 + 2, box.y1 + 2, color, false);
 	}
 	
 	private Box getMobBox()
@@ -189,7 +188,7 @@ public final class MobWeaponRuleComponent extends Component
 		int width = getWidth() - PADDING * 2 - BOX_GAP;
 		int boxWidth = width / 2;
 		int x1 = getX() + PADDING;
-		int y = getY() + TR.fontHeight + 2;
+		int y = getY() + TR.lineHeight + 2;
 		return new Box(x1, y, x1 + boxWidth, y + BOX_HEIGHT);
 	}
 	
@@ -205,7 +204,7 @@ public final class MobWeaponRuleComponent extends Component
 	{
 		int max = 0;
 		for(T value : values)
-			max = Math.max(max, TR.getWidth(labelGetter.apply(value)));
+			max = Math.max(max, TR.width(labelGetter.apply(value)));
 		
 		return max;
 	}
@@ -213,13 +212,13 @@ public final class MobWeaponRuleComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(setting.getName()) + 40;
+		return TR.width(setting.getName()) + 40;
 	}
 	
 	@Override
 	public int getDefaultHeight()
 	{
-		return TR.fontHeight + BOX_HEIGHT + 3;
+		return TR.lineHeight + BOX_HEIGHT + 3;
 	}
 	
 	private record Box(int x1, int y1, int x2, int y2)
@@ -301,7 +300,7 @@ public final class MobWeaponRuleComponent extends Component
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY)
+		public void render(GuiGraphics context, int mouseX, int mouseY)
 		{
 			if(visibleRows <= 0)
 				return;
@@ -338,8 +337,8 @@ public final class MobWeaponRuleComponent extends Component
 					RenderUtils.toIntColor(GUI.getBgColor(),
 						GUI.getOpacity() * (hovering ? 1.5F : 1F)));
 				
-				context.state.goUpLayer();
-				context.drawText(TR, labelGetter.apply(option), x1 + 2,
+				context.guiRenderState.up();
+				context.drawString(TR, labelGetter.apply(option), x1 + 2,
 					currentY + 2, GUI.getTxtColor(), false);
 				
 				drawn++;
diff --git a/src/main/java/net/wurstclient/clickgui/components/PlantTypeComponent.java b/src/main/java/net/wurstclient/clickgui/components/PlantTypeComponent.java
index 50cb2c231..ebb2259f8 100644
--- a/src/main/java/net/wurstclient/clickgui/components/PlantTypeComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/PlantTypeComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.Component;
@@ -22,7 +21,7 @@ import net.wurstclient.util.text.WText;
 public final class PlantTypeComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int BOX_SIZE = 11;
 	private static final int ICON_SIZE = 24;
 	private static final String HARVEST = "Harvest";
@@ -39,7 +38,7 @@ public final class PlantTypeComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseX < getX() + ICON_SIZE)
 			return;
@@ -48,7 +47,7 @@ public final class PlantTypeComponent extends Component
 			return;
 		
 		boolean hHarvest =
-			mouseX < getX() + ICON_SIZE + BOX_SIZE + TR.getWidth(HARVEST) + 4;
+			mouseX < getX() + ICON_SIZE + BOX_SIZE + TR.width(HARVEST) + 4;
 		
 		switch(mouseButton)
 		{
@@ -69,10 +68,10 @@ public final class PlantTypeComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		int harvestWidth = TR.getWidth(HARVEST);
+		int harvestWidth = TR.width(HARVEST);
 		
 		int x1 = getX();
 		int x2 = x1 + getWidth();
@@ -92,7 +91,7 @@ public final class PlantTypeComponent extends Component
 		boolean hReplant = hovering && mouseX >= x5 && mouseY >= y3;
 		
 		if(hIcon)
-			GUI.setTooltip(setting.getIcon().getName().getString());
+			GUI.setTooltip(setting.getIcon().getHoverName().getString());
 		else if(hName)
 			GUI.setTooltip(setting.getWrappedDescription(200));
 		else if(hHarvest)
@@ -125,9 +124,11 @@ public final class PlantTypeComponent extends Component
 		
 		// text
 		String name = setting.getName();
-		context.drawText(TR, name, x3 + 2, y1 + 3, GUI.getTxtColor(), false);
-		context.drawText(TR, HARVEST, x4 + 2, y3 + 2, GUI.getTxtColor(), false);
-		context.drawText(TR, REPLANT, x6 + 2, y3 + 2, GUI.getTxtColor(), false);
+		context.drawString(TR, name, x3 + 2, y1 + 3, GUI.getTxtColor(), false);
+		context.drawString(TR, HARVEST, x4 + 2, y3 + 2, GUI.getTxtColor(),
+			false);
+		context.drawString(TR, REPLANT, x6 + 2, y3 + 2, GUI.getTxtColor(),
+			false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -139,9 +140,9 @@ public final class PlantTypeComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		int nameWidth = TR.getWidth(setting.getName());
+		int nameWidth = TR.width(setting.getName());
 		int boxesWidth =
-			2 * BOX_SIZE + TR.getWidth(HARVEST) + TR.getWidth(REPLANT) + 6;
+			2 * BOX_SIZE + TR.width(HARVEST) + TR.width(REPLANT) + 6;
 		return ICON_SIZE + Math.max(nameWidth, boxesWidth);
 	}
 	
diff --git a/src/main/java/net/wurstclient/clickgui/components/RadarComponent.java b/src/main/java/net/wurstclient/clickgui/components/RadarComponent.java
index 4d8165613..e9d1f634b 100644
--- a/src/main/java/net/wurstclient/clickgui/components/RadarComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/RadarComponent.java
@@ -8,18 +8,17 @@
 package net.wurstclient.clickgui.components;
 
 import org.joml.Matrix3x2fStack;
-
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.AmbientEntity;
-import net.minecraft.entity.mob.Monster;
-import net.minecraft.entity.mob.WaterCreatureEntity;
-import net.minecraft.entity.passive.AnimalEntity;
-import net.minecraft.entity.passive.WaterAnimalEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.ambient.AmbientCreature;
+import net.minecraft.world.entity.animal.AgeableWaterCreature;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.monster.Enemy;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.Component;
@@ -39,7 +38,7 @@ public final class RadarComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		// Can't make this a field because RadarComponent is initialized earlier
@@ -61,25 +60,24 @@ public final class RadarComponent extends Component
 		context.fill(x1, y1, x2, y2,
 			RenderUtils.toIntColor(gui.getBgColor(), gui.getOpacity()));
 		
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		matrixStack.pushMatrix();
 		matrixStack.translate(middleX, middleY);
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(!hack.isRotateEnabled())
-			matrixStack.rotate(
-				(180 + player.getYaw()) * MathHelper.RADIANS_PER_DEGREE);
+			matrixStack.rotate((180 + player.getYRot()) * Mth.DEG_TO_RAD);
 		
 		// arrow
 		ClickGuiIcons.drawRadarArrow(context, -2, -2, 2, 2);
 		
 		matrixStack.popMatrix();
-		Vec3d lerpedPlayerPos = EntityUtils.getLerpedPos(player, partialTicks);
+		Vec3 lerpedPlayerPos = EntityUtils.getLerpedPos(player, partialTicks);
 		
 		// points
 		for(Entity e : hack.getEntities())
 		{
-			Vec3d lerpedEntityPos = EntityUtils.getLerpedPos(e, partialTicks);
+			Vec3 lerpedEntityPos = EntityUtils.getLerpedPos(e, partialTicks);
 			double diffX = lerpedEntityPos.x - lerpedPlayerPos.x;
 			double diffZ = lerpedEntityPos.z - lerpedPlayerPos.z;
 			double distance = Math.sqrt(diffX * diffX + diffZ * diffZ)
@@ -87,7 +85,7 @@ public final class RadarComponent extends Component
 			double neededRotation = Math.toDegrees(Math.atan2(diffZ, diffX));
 			double angle;
 			if(hack.isRotateEnabled())
-				angle = Math.toRadians(player.getYaw() - neededRotation - 90);
+				angle = Math.toRadians(player.getYRot() - neededRotation - 90);
 			else
 				angle = Math.toRadians(180 - neededRotation - 90);
 			double renderX = Math.sin(angle) * distance;
@@ -109,13 +107,12 @@ public final class RadarComponent extends Component
 	{
 		if(WURST.getFriends().isFriend(e))
 			return 0xFF0000FF;
-		if(e instanceof PlayerEntity)
+		if(e instanceof Player)
 			return 0xFFFF0000;
-		if(e instanceof Monster)
+		if(e instanceof Enemy)
 			return 0xFFFF8000;
-		if(e instanceof AnimalEntity || e instanceof AmbientEntity
-			|| e instanceof WaterCreatureEntity
-			|| e instanceof WaterAnimalEntity)
+		if(e instanceof Animal || e instanceof AmbientCreature
+			|| e instanceof WaterAnimal || e instanceof AgeableWaterCreature)
 			return 0xFF00FF00;
 		return 0xFF808080;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/components/SliderComponent.java b/src/main/java/net/wurstclient/clickgui/components/SliderComponent.java
index d8ba46362..c2ff373de 100644
--- a/src/main/java/net/wurstclient/clickgui/components/SliderComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/SliderComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.screens.EditSliderScreen;
@@ -21,7 +20,7 @@ import net.wurstclient.util.RenderUtils;
 public final class SliderComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int TEXT_HEIGHT = 11;
 	
 	private final SliderSetting setting;
@@ -36,9 +35,9 @@ public final class SliderComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
-		boolean hasControlDown = context.hasCtrl();
+		boolean hasControlDown = context.hasControlDown();
 		if(mouseY < getY() + 11)
 			return;
 		
@@ -46,7 +45,7 @@ public final class SliderComponent extends Component
 		{
 			case GLFW.GLFW_MOUSE_BUTTON_LEFT:
 			if(hasControlDown)
-				MC.setScreen(new EditSliderScreen(MC.currentScreen, setting));
+				MC.setScreen(new EditSliderScreen(MC.screen, setting));
 			else
 				dragging = true;
 			break;
@@ -80,7 +79,7 @@ public final class SliderComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int x1 = getX();
@@ -142,7 +141,7 @@ public final class SliderComponent extends Component
 		RenderUtils.drawBorder2D(context, x3, y4, x4, y5,
 			RenderUtils.toIntColor(GUI.getAcColor(), 0.5F));
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// knob
 		float xk1 = x1 + (x2 - x1 - 8) * (float)setting.getPercentage();
@@ -157,10 +156,10 @@ public final class SliderComponent extends Component
 		// text
 		String name = setting.getName();
 		String value = setting.getValueString();
-		int valueWidth = TR.getWidth(value);
+		int valueWidth = TR.width(value);
 		int txtColor = GUI.getTxtColor();
-		context.drawText(TR, name, x1, y1 + 2, txtColor, false);
-		context.drawText(TR, value, x2 - valueWidth, y1 + 2, txtColor, false);
+		context.drawString(TR, name, x1, y1 + 2, txtColor, false);
+		context.drawString(TR, value, x2 - valueWidth, y1 + 2, txtColor, false);
 	}
 	
 	private String getTextTooltip()
@@ -189,8 +188,8 @@ public final class SliderComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		int nameWitdh = TR.getWidth(setting.getName());
-		int valueWidth = TR.getWidth(setting.getValueString());
+		int nameWitdh = TR.width(setting.getName());
+		int valueWidth = TR.width(setting.getValueString());
 		return nameWitdh + valueWidth + 6;
 	}
 	
diff --git a/src/main/java/net/wurstclient/clickgui/components/TextFieldEditButton.java b/src/main/java/net/wurstclient/clickgui/components/TextFieldEditButton.java
index 1af87c8f2..1e56cbbcf 100644
--- a/src/main/java/net/wurstclient/clickgui/components/TextFieldEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/TextFieldEditButton.java
@@ -10,11 +10,10 @@ package net.wurstclient.clickgui.components;
 import java.util.Objects;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.text.Style;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Style;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.screens.EditTextFieldScreen;
@@ -25,7 +24,7 @@ import net.wurstclient.util.RenderUtils;
 public final class TextFieldEditButton extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int TEXT_HEIGHT = 11;
 	
 	private final TextFieldSetting setting;
@@ -39,7 +38,7 @@ public final class TextFieldEditButton extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseY < getY() + TEXT_HEIGHT)
 			return;
@@ -47,7 +46,7 @@ public final class TextFieldEditButton extends Component
 		switch(mouseButton)
 		{
 			case GLFW.GLFW_MOUSE_BUTTON_LEFT:
-			MC.setScreen(new EditTextFieldScreen(MC.currentScreen, setting));
+			MC.setScreen(new EditTextFieldScreen(MC.screen, setting));
 			break;
 			
 			case GLFW.GLFW_MOUSE_BUTTON_RIGHT:
@@ -57,7 +56,7 @@ public final class TextFieldEditButton extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		float[] bgColor = GUI.getBgColor();
@@ -89,21 +88,21 @@ public final class TextFieldEditButton extends Component
 		
 		// text
 		int txtColor = GUI.getTxtColor();
-		context.state.goUpLayer();
-		context.drawText(TR, setting.getName(), x1, y1 + 2, txtColor, false);
+		context.guiRenderState.up();
+		context.drawString(TR, setting.getName(), x1, y1 + 2, txtColor, false);
 		String value = setting.getValue();
-		int maxWidth = getWidth() - TR.getWidth("...") - 2;
-		int maxLength = TR.getTextHandler().getLimitedStringLength(value,
-			maxWidth, Style.EMPTY);
+		int maxWidth = getWidth() - TR.width("...") - 2;
+		int maxLength = TR.getSplitter().formattedIndexByWidth(value, maxWidth,
+			Style.EMPTY);
 		if(maxLength < value.length())
 			value = value.substring(0, maxLength) + "...";
-		context.drawText(TR, value, x1 + 2, y3 + 2, txtColor, false);
+		context.drawString(TR, value, x1 + 2, y3 + 2, txtColor, false);
 	}
 	
 	@Override
 	public int getDefaultWidth()
 	{
-		return TR.getWidth(setting.getName()) + 4;
+		return TR.width(setting.getName()) + 4;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/components/ToggleAllPlantTypesComponent.java b/src/main/java/net/wurstclient/clickgui/components/ToggleAllPlantTypesComponent.java
index 785782789..c13ddb25b 100644
--- a/src/main/java/net/wurstclient/clickgui/components/ToggleAllPlantTypesComponent.java
+++ b/src/main/java/net/wurstclient/clickgui/components/ToggleAllPlantTypesComponent.java
@@ -8,10 +8,9 @@
 package net.wurstclient.clickgui.components;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.ClickGuiIcons;
 import net.wurstclient.clickgui.Component;
@@ -22,7 +21,7 @@ import net.wurstclient.util.text.WText;
 public final class ToggleAllPlantTypesComponent extends Component
 {
 	private static final ClickGui GUI = WURST.getGui();
-	private static final TextRenderer TR = MC.textRenderer;
+	private static final Font TR = MC.font;
 	private static final int BOX_SIZE = 11;
 	private static final int ICON_SIZE = 24;
 	private static final String HARVEST = "Harvest";
@@ -39,7 +38,7 @@ public final class ToggleAllPlantTypesComponent extends Component
 	
 	@Override
 	public void handleMouseClick(double mouseX, double mouseY, int mouseButton,
-		Click context)
+		MouseButtonEvent context)
 	{
 		if(mouseX < getX() + ICON_SIZE)
 			return;
@@ -48,7 +47,7 @@ public final class ToggleAllPlantTypesComponent extends Component
 			return;
 		
 		boolean hHarvest =
-			mouseX < getX() + ICON_SIZE + BOX_SIZE + TR.getWidth(HARVEST) + 4;
+			mouseX < getX() + ICON_SIZE + BOX_SIZE + TR.width(HARVEST) + 4;
 		
 		switch(mouseButton)
 		{
@@ -69,10 +68,10 @@ public final class ToggleAllPlantTypesComponent extends Component
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		int harvestWidth = TR.getWidth(HARVEST);
+		int harvestWidth = TR.width(HARVEST);
 		
 		int x1 = getX();
 		int x2 = x1 + getWidth();
@@ -129,9 +128,11 @@ public final class ToggleAllPlantTypesComponent extends Component
 		
 		// text
 		String name = setting.getName();
-		context.drawText(TR, name, x3 + 2, y1 + 3, GUI.getTxtColor(), false);
-		context.drawText(TR, HARVEST, x4 + 2, y3 + 2, GUI.getTxtColor(), false);
-		context.drawText(TR, REPLANT, x6 + 2, y3 + 2, GUI.getTxtColor(), false);
+		context.drawString(TR, name, x3 + 2, y1 + 3, GUI.getTxtColor(), false);
+		context.drawString(TR, HARVEST, x4 + 2, y3 + 2, GUI.getTxtColor(),
+			false);
+		context.drawString(TR, REPLANT, x6 + 2, y3 + 2, GUI.getTxtColor(),
+			false);
 	}
 	
 	private int getFillColor(boolean hovering)
@@ -143,9 +144,9 @@ public final class ToggleAllPlantTypesComponent extends Component
 	@Override
 	public int getDefaultWidth()
 	{
-		int nameWidth = TR.getWidth(setting.getName());
+		int nameWidth = TR.width(setting.getName());
 		int boxesWidth =
-			2 * BOX_SIZE + TR.getWidth(HARVEST) + TR.getWidth(REPLANT) + 6;
+			2 * BOX_SIZE + TR.width(HARVEST) + TR.width(REPLANT) + 6;
 		return ICON_SIZE + Math.max(nameWidth, boxesWidth);
 	}
 	
diff --git a/src/main/java/net/wurstclient/clickgui/components/WaypointsEditButton.java b/src/main/java/net/wurstclient/clickgui/components/WaypointsEditButton.java
index 3e4f303c7..5d6e37383 100644
--- a/src/main/java/net/wurstclient/clickgui/components/WaypointsEditButton.java
+++ b/src/main/java/net/wurstclient/clickgui/components/WaypointsEditButton.java
@@ -27,8 +27,7 @@ public final class WaypointsEditButton extends AbstractListEditButton
 	@Override
 	protected void openScreen()
 	{
-		MC.setScreen(
-			new WaypointsScreen(MC.currentScreen, setting.getManager()));
+		MC.setScreen(new WaypointsScreen(MC.screen, setting.getManager()));
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/clickgui/screens/AddBookOfferScreen.java b/src/main/java/net/wurstclient/clickgui/screens/AddBookOfferScreen.java
index d546031a8..b7163369c 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/AddBookOfferScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/AddBookOfferScreen.java
@@ -14,29 +14,28 @@ import java.util.Objects;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.tag.EnchantmentTags;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.EnchantmentTags;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
 import net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget;
 import net.wurstclient.hacks.autolibrarian.BookOffer;
 import net.wurstclient.settings.BookOffersSetting;
@@ -51,17 +50,17 @@ public final class AddBookOfferScreen extends Screen
 	
 	private ListGui listGui;
 	
-	private TextFieldWidget searchField;
-	private TextFieldWidget levelField;
-	private ButtonWidget levelPlusButton;
-	private ButtonWidget levelMinusButton;
+	private EditBox searchField;
+	private EditBox levelField;
+	private Button levelPlusButton;
+	private Button levelMinusButton;
 	
-	private TextFieldWidget priceField;
-	private ButtonWidget pricePlusButton;
-	private ButtonWidget priceMinusButton;
+	private EditBox priceField;
+	private Button pricePlusButton;
+	private Button priceMinusButton;
 	
-	private ButtonWidget addButton;
-	private ButtonWidget cancelButton;
+	private Button addButton;
+	private Button cancelButton;
 	
 	private BookOffer offerToAdd;
 	private boolean alreadyAdded;
@@ -69,7 +68,7 @@ public final class AddBookOfferScreen extends Screen
 	
 	public AddBookOfferScreen(Screen prevScreen, BookOffersSetting bookOffers)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.bookOffers = bookOffers;
 	}
@@ -77,23 +76,22 @@ public final class AddBookOfferScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this);
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this);
+		addWidget(listGui);
 		
 		int searchWidth = 200;
 		int searchTop = 44;
-		searchField = new TextFieldWidget(client.textRenderer,
-			width / 2 - searchWidth / 2, searchTop, searchWidth, 18,
-			Text.literal(""));
-		addSelectableChild(searchField);
+		searchField = new EditBox(minecraft.font, width / 2 - searchWidth / 2,
+			searchTop, searchWidth, 18, Component.literal(""));
+		addWidget(searchField);
 		searchField.setMaxLength(256);
-		searchField.setChangedListener(this::onSearchChanged);
+		searchField.setResponder(this::onSearchChanged);
 		
-		levelField = new TextFieldWidget(client.textRenderer, width / 2 - 32,
-			height - 74, 28, 12, Text.literal(""));
-		addSelectableChild(levelField);
+		levelField = new EditBox(minecraft.font, width / 2 - 32, height - 74,
+			28, 12, Component.literal(""));
+		addWidget(levelField);
 		levelField.setMaxLength(2);
-		levelField.setTextPredicate(t -> {
+		levelField.setFilter(t -> {
 			if(t.isEmpty())
 				return true;
 			
@@ -110,7 +108,7 @@ public final class AddBookOfferScreen extends Screen
 			Enchantment enchantment = offerToAdd.getEnchantment();
 			return enchantment == null || level <= enchantment.getMaxLevel();
 		});
-		levelField.setChangedListener(t -> {
+		levelField.setResponder(t -> {
 			if(!MathUtils.isInteger(t))
 				return;
 			
@@ -118,13 +116,13 @@ public final class AddBookOfferScreen extends Screen
 			updateLevel(level, false);
 		});
 		
-		priceField = new TextFieldWidget(client.textRenderer, width / 2 - 32,
-			height - 58, 28, 12, Text.literal(""));
-		addSelectableChild(priceField);
+		priceField = new EditBox(minecraft.font, width / 2 - 32, height - 58,
+			28, 12, Component.literal(""));
+		addWidget(priceField);
 		priceField.setMaxLength(2);
-		priceField.setTextPredicate(t -> t.isEmpty() || MathUtils.isInteger(t)
+		priceField.setFilter(t -> t.isEmpty() || MathUtils.isInteger(t)
 			&& Integer.parseInt(t) >= 1 && Integer.parseInt(t) <= 64);
-		priceField.setChangedListener(t -> {
+		priceField.setResponder(t -> {
 			if(!MathUtils.isInteger(t))
 				return;
 			
@@ -132,52 +130,53 @@ public final class AddBookOfferScreen extends Screen
 			updatePrice(price, false);
 		});
 		
-		addDrawableChild(levelPlusButton =
-			ButtonWidget.builder(Text.literal("+"), b -> updateLevel(1, true))
-				.dimensions(width / 2 + 2, height - 74, 20, 12)
-				.narrationSupplier(sup -> Text
-					.translatable("gui.narrate.button", "increase level")
-					.append(", current value: " + levelField.getText()))
-				.build());
+		addRenderableWidget(levelPlusButton = Button
+			.builder(Component.literal("+"), b -> updateLevel(1, true))
+			.bounds(width / 2 + 2, height - 74, 20, 12)
+			.createNarration(sup -> Component
+				.translatable("gui.narrate.button", "increase level")
+				.append(", current value: " + levelField.getValue()))
+			.build());
 		levelPlusButton.active = false;
 		
-		addDrawableChild(levelMinusButton =
-			ButtonWidget.builder(Text.literal("-"), b -> updateLevel(-1, true))
-				.dimensions(width / 2 + 26, height - 74, 20, 12)
-				.narrationSupplier(sup -> Text
-					.translatable("gui.narrate.button", "decrease level")
-					.append(", current value: " + levelField.getText()))
-				.build());
+		addRenderableWidget(levelMinusButton = Button
+			.builder(Component.literal("-"), b -> updateLevel(-1, true))
+			.bounds(width / 2 + 26, height - 74, 20, 12)
+			.createNarration(sup -> Component
+				.translatable("gui.narrate.button", "decrease level")
+				.append(", current value: " + levelField.getValue()))
+			.build());
 		levelMinusButton.active = false;
 		
-		addDrawableChild(pricePlusButton = ButtonWidget
-			.builder(Text.literal("+"), b -> updatePrice(1, true))
-			.dimensions(width / 2 + 2, height - 58, 20, 12)
-			.narrationSupplier(sup -> Text
+		addRenderableWidget(pricePlusButton = Button
+			.builder(Component.literal("+"), b -> updatePrice(1, true))
+			.bounds(width / 2 + 2, height - 58, 20, 12)
+			.createNarration(sup -> Component
 				.translatable("gui.narrate.button", "increase max price")
-				.append(", current value: " + priceField.getText()))
+				.append(", current value: " + priceField.getValue()))
 			.build());
 		pricePlusButton.active = false;
 		
-		addDrawableChild(priceMinusButton = ButtonWidget
-			.builder(Text.literal("-"), b -> updatePrice(-1, true))
-			.dimensions(width / 2 + 26, height - 58, 20, 12)
-			.narrationSupplier(sup -> Text
+		addRenderableWidget(priceMinusButton = Button
+			.builder(Component.literal("-"), b -> updatePrice(-1, true))
+			.bounds(width / 2 + 26, height - 58, 20, 12)
+			.createNarration(sup -> Component
 				.translatable("gui.narrate.button", "decrease max price")
-				.append(", current value: " + priceField.getText()))
+				.append(", current value: " + priceField.getValue()))
 			.build());
 		priceMinusButton.active = false;
 		
-		addDrawableChild(
-			addButton = ButtonWidget.builder(Text.literal("Add"), b -> {
+		addRenderableWidget(
+			addButton = Button.builder(Component.literal("Add"), b -> {
 				bookOffers.add(offerToAdd);
-				client.setScreen(prevScreen);
-			}).dimensions(width / 2 - 102, height - 28, 100, 20).build());
+				minecraft.setScreen(prevScreen);
+			}).bounds(width / 2 - 102, height - 28, 100, 20).build());
 		addButton.active = false;
 		
-		addDrawableChild(cancelButton = ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 + 2, height - 28, 100, 20).build());
+		addRenderableWidget(cancelButton = Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 + 2, height - 28, 100, 20).build());
 	}
 	
 	private void updateLevel(int i, boolean offset)
@@ -255,16 +254,16 @@ public final class AddBookOfferScreen extends Screen
 			return;
 		}
 		
-		Identifier id = Identifier.tryParse(query);
+		ResourceLocation id = ResourceLocation.tryParse(query);
 		if(id == null)
 		{
 			updateSelectedOffer(null);
 			return;
 		}
 		
-		int level = parseLevel(levelField.getText(),
+		int level = parseLevel(levelField.getValue(),
 			offerToAdd != null ? offerToAdd.level() : 1);
-		int price = parsePrice(priceField.getText(),
+		int price = parsePrice(priceField.getValue(),
 			offerToAdd != null ? offerToAdd.price() : 64);
 		updateSelectedOffer(new BookOffer(query, level, price));
 	}
@@ -289,26 +288,26 @@ public final class AddBookOfferScreen extends Screen
 		
 		if(offer == null)
 		{
-			if(levelField != null && !levelField.getText().isEmpty())
-				levelField.setText("");
+			if(levelField != null && !levelField.getValue().isEmpty())
+				levelField.setValue("");
 			
-			if(priceField != null && !priceField.getText().isEmpty())
-				priceField.setText("");
+			if(priceField != null && !priceField.getValue().isEmpty())
+				priceField.setValue("");
 			
 		}else
 		{
 			String level = "" + offer.level();
-			if(levelField != null && !levelField.getText().equals(level))
-				levelField.setText(level);
+			if(levelField != null && !levelField.getValue().equals(level))
+				levelField.setValue(level);
 			
 			String price = "" + offer.price();
-			if(priceField != null && !priceField.getText().equals(price))
-				priceField.setText(price);
+			if(priceField != null && !priceField.getValue().equals(price))
+				priceField.setValue(price);
 		}
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		if(searchField.mouseClicked(context, doubleClick))
 		{
@@ -328,7 +327,7 @@ public final class AddBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -363,44 +362,45 @@ public final class AddBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
 		matrixStack.pushMatrix();
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		String titleText =
 			"Available Books (" + listGui.children().size() + ")";
-		context.drawCenteredTextWithShadow(tr, titleText, width / 2, 12,
-			Colors.WHITE);
+		context.drawCenteredString(tr, titleText, width / 2, 12,
+			CommonColors.WHITE);
 		
 		searchField.render(context, mouseX, mouseY, partialTicks);
-		if(searchField.getText().isEmpty() && !searchField.isFocused())
-			context.drawTextWithShadow(tr, "search or custom ID",
-				searchField.getX() + 4, searchField.getY() + 5, Colors.GRAY);
+		if(searchField.getValue().isEmpty() && !searchField.isFocused())
+			context.drawString(tr, "search or custom ID",
+				searchField.getX() + 4, searchField.getY() + 5,
+				CommonColors.GRAY);
 		
 		levelField.render(context, mouseX, mouseY, partialTicks);
 		priceField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		matrixStack.translate(width / 2 - 100, 0);
 		
-		context.drawTextWithShadow(tr, "Level:", 0, height - 72,
+		context.drawString(tr, "Level:", 0, height - 72,
 			WurstColors.VERY_LIGHT_GRAY);
-		context.drawTextWithShadow(tr, "Max price:", 0, height - 56,
+		context.drawString(tr, "Max price:", 0, height - 56,
 			WurstColors.VERY_LIGHT_GRAY);
 		
 		if(alreadyAdded && offerToAdd != null)
 		{
 			String errorText = offerToAdd.getEnchantmentNameWithLevel()
 				+ " is already on your list!";
-			context.drawTextWithShadow(tr, errorText, 0, height - 40,
+			context.drawString(tr, errorText, 0, height - 40,
 				WurstColors.LIGHT_RED);
 		}
 		
@@ -411,7 +411,7 @@ public final class AddBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -435,26 +435,27 @@ public final class AddBookOfferScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
 			int maxLevel = bookOffer.getEnchantmentEntry()
 				.map(entry -> entry.value().getMaxLevel())
 				.orElse(bookOffer.level());
 			String levels = maxLevel + (maxLevel == 1 ? " level" : " levels");
 			
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"Enchantment " + bookOffer.getEnchantmentName() + ", ID "
 					+ bookOffer.id() + ", " + levels);
 		}
 		
 		@Override
-		public boolean mouseClicked(Click context, boolean doubleClick)
+		public boolean mouseClicked(MouseButtonEvent context,
+			boolean doubleClick)
 		{
 			if(!super.mouseClicked(context, doubleClick))
 				return false;
 			
-			long timeSinceLastClick = Util.getMeasuringTimeMs() - lastClickTime;
-			lastClickTime = Util.getMeasuringTimeMs();
+			long timeSinceLastClick = Util.getMillis() - lastClickTime;
+			lastClickTime = Util.getMillis();
 			
 			if(timeSinceLastClick < 250 && addButton.active)
 				addButton.onPress(context);
@@ -463,33 +464,34 @@ public final class AddBookOfferScreen extends Screen
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			Item item = Registries.ITEM.get(Identifier.of("enchanted_book"));
+			Item item = BuiltInRegistries.ITEM
+				.getValue(ResourceLocation.parse("enchanted_book"));
 			ItemStack stack = new ItemStack(item);
 			RenderUtils.drawItem(context, stack, x + 1, y + 1, true);
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			String name = bookOffer.getEnchantmentName();
 			boolean isCurse = bookOffer.getEnchantmentEntry()
-				.map(entry -> entry.isIn(EnchantmentTags.CURSE)).orElse(false);
+				.map(entry -> entry.is(EnchantmentTags.CURSE)).orElse(false);
 			int nameColor =
 				isCurse ? WurstColors.LIGHT_RED : WurstColors.VERY_LIGHT_GRAY;
-			context.drawText(tr, name, x + 28, y, nameColor, false);
+			context.drawString(tr, name, x + 28, y, nameColor, false);
 			
-			context.drawText(tr, bookOffer.id(), x + 28, y + 9,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, bookOffer.id(), x + 28, y + 9,
+				CommonColors.LIGHT_GRAY, false);
 			
 			int maxLevel = bookOffer.getEnchantmentEntry()
 				.map(entry -> entry.value().getMaxLevel())
 				.orElse(bookOffer.level());
 			String levels = maxLevel + (maxLevel == 1 ? " level" : " levels");
-			context.drawText(tr, levels, x + 28, y + 18, Colors.LIGHT_GRAY,
-				false);
+			context.drawString(tr, levels, x + 28, y + 18,
+				CommonColors.LIGHT_GRAY, false);
 		}
 		
 		@Override
@@ -505,15 +507,15 @@ public final class AddBookOfferScreen extends Screen
 		private final List<BookOffer> allOffers = new ArrayList<>();
 		private String filterText = "";
 		
-		public ListGui(MinecraftClient minecraft, AddBookOfferScreen screen)
+		public ListGui(Minecraft minecraft, AddBookOfferScreen screen)
 		{
 			super(minecraft, screen.width, screen.height - 152, 68, 30);
 			setSelectionListener(
 				() -> updateSelectedOfferFromList(getPrimarySelection()));
 			
-			DynamicRegistryManager drm = client.world.getRegistryManager();
+			RegistryAccess drm = minecraft.level.registryAccess();
 			Registry<Enchantment> registry =
-				drm.getOrThrow(RegistryKeys.ENCHANTMENT);
+				drm.lookupOrThrow(Registries.ENCHANTMENT);
 			
 			registry.stream().map(BookOffer::create)
 				.filter(BookOffer::isMostlyValid).sorted()
diff --git a/src/main/java/net/wurstclient/clickgui/screens/ChestSearchScreen.java b/src/main/java/net/wurstclient/clickgui/screens/ChestSearchScreen.java
index 8288243c6..3986a4a59 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/ChestSearchScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/ChestSearchScreen.java
@@ -11,15 +11,14 @@ import java.util.ArrayList;
 import java.time.Instant;
 import java.time.format.DateTimeParseException;
 import java.util.Locale;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.ItemNameUtils;
 import net.wurstclient.util.RenderUtils;
@@ -34,9 +33,9 @@ public final class ChestSearchScreen extends Screen
 	private final Screen prev;
 	private ChestManager chestManager = new ChestManager();
 	
-	private TextFieldWidget searchField;
+	private EditBox searchField;
 	private java.util.List<ChestEntry> results = new ArrayList<>();
-	private final java.util.List<ButtonWidget> rowButtons =
+	private final java.util.List<Button> rowButtons =
 		new java.util.ArrayList<>();
 	private int totalChestsLogged = 0;
 	private long totalItemsLogged = 0;
@@ -47,8 +46,8 @@ public final class ChestSearchScreen extends Screen
 	private int radiusFilteredOut = 0;
 	private boolean limitedResults = false;
 	private double scrollOffset = 0.0;
-	private ButtonWidget scrollUpButton;
-	private ButtonWidget scrollDownButton;
+	private Button scrollUpButton;
+	private Button scrollDownButton;
 	private boolean draggingScrollbar = false;
 	private double scrollbarDragStartY = 0.0;
 	private double scrollbarStartOffset = 0.0;
@@ -167,7 +166,7 @@ public final class ChestSearchScreen extends Screen
 			try
 			{
 				WurstClient.MC.execute(() -> {
-					if(WurstClient.MC.currentScreen instanceof ChestSearchScreen screen)
+					if(WurstClient.MC.screen instanceof ChestSearchScreen screen)
 						screen.refreshPins();
 				});
 			}catch(Throwable ignored)
@@ -197,7 +196,7 @@ public final class ChestSearchScreen extends Screen
 	
 	public ChestSearchScreen(Screen prev, Object ignored)
 	{
-		super(Text.literal("Chest Search"));
+		super(Component.literal("Chest Search"));
 		this.prev = prev;
 		this.openedByKeybind = (ignored instanceof Boolean && (Boolean)ignored);
 	}
@@ -207,16 +206,16 @@ public final class ChestSearchScreen extends Screen
 	{
 		int mid = this.width / 2;
 		int controlsY = 18;
-		searchField = new TextFieldWidget(this.textRenderer, mid - 150,
-			controlsY, 220, 20, Text.literal("Search"));
+		searchField = new EditBox(this.font, mid - 150, controlsY, 220, 20,
+			Component.literal("Search"));
 		searchField.setVisible(true);
 		searchField.setEditable(true);
-		addDrawableChild(searchField);
-		searchField.setChangedListener(this::onSearchChanged);
-		searchField.setTextPredicate(s -> true);
+		addRenderableWidget(searchField);
+		searchField.setResponder(this::onSearchChanged);
+		searchField.setFilter(s -> true);
 		searchField.setMaxLength(100);
 		searchField.setMessage(
-			Text.literal("Type item name or id, e.g. minecraft:stone"));
+			Component.literal("Type item name or id, e.g. minecraft:stone"));
 		if(!openedByKeybind)
 		{
 			this.setInitialFocus(searchField);
@@ -228,37 +227,37 @@ public final class ChestSearchScreen extends Screen
 		// opening.
 		if(openedByKeybind)
 		{
-			searchField.setText("");
+			searchField.setValue("");
 			ignoreNextSearchChange = true;
 		}
-		addDrawableChild(ButtonWidget.builder(Text.literal("Search"), b -> {
-			onSearchChanged(searchField.getText());
+		addRenderableWidget(Button.builder(Component.literal("Search"), b -> {
+			onSearchChanged(searchField.getValue());
 			rebuildRowButtons();
-		}).dimensions(mid + 80, controlsY, 70, 20).build());
+		}).bounds(mid + 80, controlsY, 70, 20).build());
 		// Removed Refresh button (it recreated the ChestManager and re-run the
 		// query which is redundant since Search already does the same).
 		// removed Scan Open button per user request
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Back"), b -> client.setScreen(prev))
-			.dimensions(mid - 150, this.height - 28, 300, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Back"), b -> minecraft.setScreen(prev))
+			.bounds(mid - 150, this.height - 28, 300, 20).build());
 		
 		scrollOffset = 0;
 		draggingScrollbar = false;
 		onSearchChanged("");
 		rebuildRowButtons();
 		scrollUpButton =
-			addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+			addRenderableWidget(Button.builder(Component.literal(""), b -> {
 				scrollOffset = 0;
 				clampScroll();
 				rebuildRowButtons();
-			}).dimensions(0, 0, 20, 16).build());
+			}).bounds(0, 0, 20, 16).build());
 		scrollDownButton =
-			addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+			addRenderableWidget(Button.builder(Component.literal(""), b -> {
 				scrollOffset = scrollMaxOffset;
 				clampScroll();
 				rebuildRowButtons();
-			}).dimensions(0, 0, 20, 16).build());
+			}).bounds(0, 0, 20, 16).build());
 		scrollUpButton.visible = false;
 		scrollDownButton.visible = false;
 	}
@@ -272,7 +271,7 @@ public final class ChestSearchScreen extends Screen
 			ignoreNextSearchChange = false;
 			if(q != null && q.length() <= 1)
 			{
-				searchField.setText("");
+				searchField.setValue("");
 				q = "";
 			}
 		}
@@ -411,7 +410,7 @@ public final class ChestSearchScreen extends Screen
 		if(entries == null || entries.isEmpty())
 			return entries;
 		
-		net.minecraft.client.MinecraftClient mc = WurstClient.MC;
+		net.minecraft.client.Minecraft mc = WurstClient.MC;
 		if(mc == null || mc.player == null)
 			return entries;
 		
@@ -433,13 +432,13 @@ public final class ChestSearchScreen extends Screen
 		radiusFilterActive = true;
 		radiusLimitBlocks = radiusBlocks;
 		double radiusSq = (double)radiusBlocks * (double)radiusBlocks;
-		Vec3d playerPos =
-			new Vec3d(mc.player.getX(), mc.player.getY(), mc.player.getZ());
+		Vec3 playerPos =
+			new Vec3(mc.player.getX(), mc.player.getY(), mc.player.getZ());
 		String playerDim = "";
 		try
 		{
-			if(mc.world != null)
-				playerDim = mc.world.getRegistryKey().getValue().toString();
+			if(mc.level != null)
+				playerDim = mc.level.dimension().location().toString();
 		}catch(Throwable ignored)
 		{}
 		String playerDimKey = canonicalDimension(playerDim);
@@ -460,8 +459,8 @@ public final class ChestSearchScreen extends Screen
 			if(include)
 			{
 				BlockPos pos = entry.getClickedPos();
-				Vec3d chestPos = Vec3d.ofCenter(pos);
-				if(chestPos.squaredDistanceTo(playerPos) > radiusSq)
+				Vec3 chestPos = Vec3.atCenterOf(pos);
+				if(chestPos.distanceToSqr(playerPos) > radiusSq)
 					include = false;
 			}
 			
@@ -476,9 +475,9 @@ public final class ChestSearchScreen extends Screen
 	
 	private void rebuildRowButtons()
 	{
-		for(ButtonWidget btn : rowButtons)
+		for(Button btn : rowButtons)
 		{
-			this.remove(btn);
+			this.removeWidget(btn);
 		}
 		rowButtons.clear();
 		
@@ -502,7 +501,7 @@ public final class ChestSearchScreen extends Screen
 			boolean espActive = isEspActive(dim, minPos);
 			boolean pinnedEntry = waypointActive || espActive;
 			String query =
-				searchField.getText() == null ? "" : searchField.getText();
+				searchField.getValue() == null ? "" : searchField.getValue();
 			java.util.List<ChestEntry.ItemEntry> matches =
 				collectMatches(e, query);
 			int matchLines = matches.isEmpty() ? 1 : matches.size();
@@ -515,12 +514,13 @@ public final class ChestSearchScreen extends Screen
 			if(y > visibleBottom)
 				break;
 			int btnY = y + 6;
-			Text espLabel = espActive
-				? Text.literal("ESP*")
-					.styled(style -> style
-						.withColor(net.minecraft.util.Formatting.GOLD))
-				: Text.literal("ESP");
-			ButtonWidget espBtn = ButtonWidget.builder(espLabel, b -> {
+			Component espLabel =
+				espActive
+					? Component.literal("ESP*")
+						.withStyle(style -> style
+							.withColor(net.minecraft.ChatFormatting.GOLD))
+					: Component.literal("ESP");
+			Button espBtn = Button.builder(espLabel, b -> {
 				try
 				{
 					String dimLocal = normalizeDimension(e.dimension);
@@ -529,20 +529,20 @@ public final class ChestSearchScreen extends Screen
 					// on the expected chest half.
 					BlockPos useMin = e.getClickedPos();
 					boolean exists = false;
-					if(WurstClient.MC != null && WurstClient.MC.world != null)
+					if(WurstClient.MC != null && WurstClient.MC.level != null)
 					{
-						var world = WurstClient.MC.world;
+						var world = WurstClient.MC.level;
 						var state = world.getBlockState(useMin);
 						boolean container = state != null && (state
-							.getBlock() instanceof net.minecraft.block.ChestBlock
+							.getBlock() instanceof net.minecraft.world.level.block.ChestBlock
 							|| state
-								.getBlock() instanceof net.minecraft.block.BarrelBlock
+								.getBlock() instanceof net.minecraft.world.level.block.BarrelBlock
 							|| state
-								.getBlock() instanceof net.minecraft.block.ShulkerBoxBlock
+								.getBlock() instanceof net.minecraft.world.level.block.ShulkerBoxBlock
 							|| state
-								.getBlock() instanceof net.minecraft.block.DecoratedPotBlock
+								.getBlock() instanceof net.minecraft.world.level.block.DecoratedPotBlock
 							|| state
-								.getBlock() instanceof net.minecraft.block.EnderChestBlock);
+								.getBlock() instanceof net.minecraft.world.level.block.EnderChestBlock);
 						boolean hasBe = world.getBlockEntity(useMin) != null;
 						exists = container && hasBe;
 					}
@@ -556,8 +556,8 @@ public final class ChestSearchScreen extends Screen
 						}catch(Throwable ignored)
 						{}
 						this.chestManager = new ChestManager();
-						onSearchChanged(searchField.getText());
-						client.execute(this::refreshPins);
+						onSearchChanged(searchField.getValue());
+						minecraft.execute(this::refreshPins);
 						return;
 					}
 					net.wurstclient.hacks.ChestSearchHack hack =
@@ -569,13 +569,13 @@ public final class ChestSearchScreen extends Screen
 					// position
 					net.wurstclient.chestsearch.TargetHighlighter.INSTANCE
 						.toggle(dimLocal, useMin, useMin, hack.getEspTimeMs());
-					client.execute(this::refreshPins);
+					minecraft.execute(this::refreshPins);
 				}catch(Throwable ignored)
 				{}
-			}).dimensions(0, btnY, 40, 16).build();
+			}).bounds(0, btnY, 40, 16).build();
 			if(espActive)
-				espBtn.setTooltip(net.minecraft.client.gui.tooltip.Tooltip
-					.of(Text.literal("ESP active")));
+				espBtn.setTooltip(net.minecraft.client.gui.components.Tooltip
+					.create(Component.literal("ESP active")));
 			// position esp and wp buttons to the right side of the result box
 			int boxRight = x + 340;
 			int wpWidth = 56;
@@ -588,15 +588,16 @@ public final class ChestSearchScreen extends Screen
 			int stackX = stackRight - stackWidth;
 			// place esp at top, wp below, delete below that
 			espBtn.setPosition(stackX + (stackWidth - espWidth) / 2, btnY);
-			addDrawableChild(espBtn);
+			addRenderableWidget(espBtn);
 			rowButtons.add(espBtn);
 			boolean hasWp = waypointActive;
-			Text wpLabel = hasWp
-				? Text.literal("Remove*")
-					.styled(style -> style
-						.withColor(net.minecraft.util.Formatting.GOLD))
-				: Text.literal("Waypoint");
-			ButtonWidget wpBtn = ButtonWidget.builder(wpLabel, b -> {
+			Component wpLabel =
+				hasWp
+					? Component.literal("Remove*")
+						.withStyle(style -> style
+							.withColor(net.minecraft.ChatFormatting.GOLD))
+					: Component.literal("Waypoint");
+			Button wpBtn = Button.builder(wpLabel, b -> {
 				WaypointsHack wh = WurstClient.INSTANCE.getHax().waypointsHack;
 				if(wh != null)
 				{
@@ -612,7 +613,7 @@ public final class ChestSearchScreen extends Screen
 							wh.removeTemporaryWaypoint(id);
 						}catch(Throwable ignored)
 						{}
-						client.execute(this::refreshPins);
+						minecraft.execute(this::refreshPins);
 						return;
 					}
 					net.wurstclient.hacks.ChestSearchHack hack =
@@ -639,7 +640,7 @@ public final class ChestSearchScreen extends Screen
 					int sleep = hack.getWaypointTimeMs();
 					TEMP_WP_BY_POS.put(posKey,
 						new TempWp(id, System.currentTimeMillis() + sleep));
-					client.execute(this::refreshPins);
+					minecraft.execute(this::refreshPins);
 					Thread.ofPlatform().start(() -> {
 						try
 						{
@@ -652,30 +653,29 @@ public final class ChestSearchScreen extends Screen
 						}catch(Throwable ignored)
 						{}
 						TEMP_WP_BY_POS.remove(posKey);
-						client.execute(this::refreshPins);
+						minecraft.execute(this::refreshPins);
 					});
 				}
-			}).dimensions(0, btnY, 56, 16).build();
+			}).bounds(0, btnY, 56, 16).build();
 			if(hasWp)
-				wpBtn.setTooltip(net.minecraft.client.gui.tooltip.Tooltip
-					.of(Text.literal("Waypoint active")));
+				wpBtn.setTooltip(net.minecraft.client.gui.components.Tooltip
+					.create(Component.literal("Waypoint active")));
 			wpBtn.setPosition(stackX + (stackWidth - wpWidth) / 2, btnY + 18);
-			addDrawableChild(wpBtn);
+			addRenderableWidget(wpBtn);
 			
 			// Delete (X) button to remove the recorded chest entry from disk
-			ButtonWidget delBtn =
-				ButtonWidget.builder(Text.literal("Delete"), b -> {
-					try
-					{
-						BlockPos delPos = e.getClickedPos();
-						new ChestManager().removeChest(e.serverIp, e.dimension,
-							delPos.getX(), delPos.getY(), delPos.getZ());
-					}catch(Throwable ignored)
-					{}
-					this.chestManager = new ChestManager();
-					onSearchChanged(searchField.getText());
-					client.execute(this::refreshPins);
-				}).dimensions(0, btnY, deleteWidth, 16).build();
+			Button delBtn = Button.builder(Component.literal("Delete"), b -> {
+				try
+				{
+					BlockPos delPos = e.getClickedPos();
+					new ChestManager().removeChest(e.serverIp, e.dimension,
+						delPos.getX(), delPos.getY(), delPos.getZ());
+				}catch(Throwable ignored)
+				{}
+				this.chestManager = new ChestManager();
+				onSearchChanged(searchField.getValue());
+				minecraft.execute(this::refreshPins);
+			}).bounds(0, btnY, deleteWidth, 16).build();
 			delBtn.setPosition(stackX + (stackWidth - deleteWidth) / 2,
 				btnY + 36);
 			// hide per-row buttons when their row is outside the visible
@@ -687,9 +687,9 @@ public final class ChestSearchScreen extends Screen
 			espBtn.active = rowVisible;
 			wpBtn.active = rowVisible;
 			delBtn.active = rowVisible;
-			delBtn.setTooltip(net.minecraft.client.gui.tooltip.Tooltip
-				.of(Text.literal("Delete entry")));
-			addDrawableChild(delBtn);
+			delBtn.setTooltip(net.minecraft.client.gui.components.Tooltip
+				.create(Component.literal("Delete entry")));
+			addRenderableWidget(delBtn);
 			rowButtons.add(delBtn);
 			rowButtons.add(wpBtn);
 			y += boxHeight + 6;
@@ -710,7 +710,7 @@ public final class ChestSearchScreen extends Screen
 	
 	private void clampScroll()
 	{
-		String query = searchField == null ? "" : searchField.getText();
+		String query = searchField == null ? "" : searchField.getValue();
 		int contentHeight = calculateContentHeight(query);
 		int visibleHeight = Math.max(0, getVisibleBottom() - getResultsTop());
 		double maxScroll = Math.max(0, contentHeight - visibleHeight);
@@ -765,7 +765,7 @@ public final class ChestSearchScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		double mouseX = context.x();
 		double mouseY = context.y();
@@ -800,7 +800,8 @@ public final class ChestSearchScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseDragged(Click context, double deltaX, double deltaY)
+	public boolean mouseDragged(MouseButtonEvent context, double deltaX,
+		double deltaY)
 	{
 		double mouseY = context.y();
 		int button = context.button();
@@ -823,7 +824,7 @@ public final class ChestSearchScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseReleased(Click context)
+	public boolean mouseReleased(MouseButtonEvent context)
 	{
 		if(context.button() == 0 && draggingScrollbar)
 		{
@@ -852,15 +853,15 @@ public final class ChestSearchScreen extends Screen
 	{
 		if(searchField == null)
 			return;
-		onSearchChanged(searchField.getText());
+		onSearchChanged(searchField.getValue());
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY, float delta)
+	public void render(GuiGraphics context, int mouseX, int mouseY, float delta)
 	{
 		context.fill(0, 0, this.width, this.height, 0x88000000);
-		context.drawCenteredTextWithShadow(this.textRenderer,
-			Text.literal("Chest Search"), this.width / 2, 4, 0xFFFFFFFF);
+		context.drawCenteredString(this.font, Component.literal("Chest Search"),
+			this.width / 2, 4, 0xFFFFFFFF);
 		int mid = this.width / 2;
 		int sfX = mid - 150;
 		int sfY = 18;
@@ -871,8 +872,8 @@ public final class ChestSearchScreen extends Screen
 		int visibleTop = getResultsTop();
 		int visibleBottom = getVisibleBottom();
 		int visibleHeight = Math.max(0, visibleBottom - visibleTop);
-		String q = searchField.getText() == null ? ""
-			: searchField.getText().toLowerCase();
+		String q = searchField.getValue() == null ? ""
+			: searchField.getValue().toLowerCase();
 		int contentHeight = calculateContentHeight(q);
 		float scale = 1.0f;
 		try
@@ -1001,9 +1002,8 @@ public final class ChestSearchScreen extends Screen
 				java.util.List<String> lines =
 					wrapText(header, availWidth, scale);
 				for(int i = 0; i < lines.size(); i++)
-					RenderUtils.drawScaledText(context, this.textRenderer,
-						lines.get(i), x, headerY + i * 12, 0xFFF8D866, false,
-						scale);
+					RenderUtils.drawScaledText(context, this.font, lines.get(i),
+						x, headerY + i * 12, 0xFFF8D866, false, scale);
 				// Omit the small "Active: ESP/Waypoint" status line to
 				// reduce clutter and avoid overlap with the location text.
 			}else
@@ -1013,9 +1013,8 @@ public final class ChestSearchScreen extends Screen
 				java.util.List<String> lines =
 					wrapText(header, availWidth, scale);
 				for(int i = 0; i < lines.size(); i++)
-					RenderUtils.drawScaledText(context, this.textRenderer,
-						lines.get(i), x, headerY + i * 12, 0xFFFFFFFF, false,
-						scale);
+					RenderUtils.drawScaledText(context, this.font, lines.get(i),
+						x, headerY + i * 12, 0xFFFFFFFF, false, scale);
 			}
 			int headerLines = headerLineCount(pinnedEntry);
 			int lineY = headerY + headerLines * 14;
@@ -1026,7 +1025,7 @@ public final class ChestSearchScreen extends Screen
 			{
 				String msg = q.isEmpty() ? "No items recorded."
 					: "No items match this search.";
-				RenderUtils.drawScaledText(context, this.textRenderer, msg, x,
+				RenderUtils.drawScaledText(context, this.font, msg, x,
 					lineY + 2, 0xFFBBBBBB, false, scale);
 				lineY += Math.round(18 * scale);
 			}else
@@ -1035,15 +1034,17 @@ public final class ChestSearchScreen extends Screen
 				{
 					try
 					{
-						net.minecraft.util.Identifier id =
-							net.minecraft.util.Identifier.tryParse(it.itemId);
+						net.minecraft.resources.ResourceLocation id =
+							net.minecraft.resources.ResourceLocation
+								.tryParse(it.itemId);
 						if(id != null)
 						{
-							net.minecraft.item.Item item =
-								net.minecraft.registry.Registries.ITEM.get(id);
-							net.minecraft.item.ItemStack stack =
-								new net.minecraft.item.ItemStack(item, 1);
-							context.drawItem(stack, x + 2, lineY - 2);
+							net.minecraft.world.item.Item item =
+								net.minecraft.core.registries.BuiltInRegistries.ITEM
+									.getValue(id);
+							net.minecraft.world.item.ItemStack stack =
+								new net.minecraft.world.item.ItemStack(item, 1);
+							context.renderItem(stack, x + 2, lineY - 2);
 						}
 					}catch(Throwable ignored)
 					{}
@@ -1062,11 +1063,13 @@ public final class ChestSearchScreen extends Screen
 							for(int ei = 0; ei < it.enchantments.size(); ei++)
 							{
 								String ench = it.enchantments.get(ei);
-								net.minecraft.util.Identifier eid = null;
+								net.minecraft.resources.ResourceLocation eid =
+									null;
 								try
 								{
-									eid = net.minecraft.util.Identifier
-										.tryParse(ench);
+									eid =
+										net.minecraft.resources.ResourceLocation
+											.tryParse(ench);
 								}catch(Throwable ignored)
 								{}
 								String path = eid != null ? eid.getPath()
@@ -1082,7 +1085,7 @@ public final class ChestSearchScreen extends Screen
 										int lvl = it.enchantmentLevels.get(ei)
 											.intValue();
 										if(lvl > 0)
-											levelText = " " + Text
+											levelText = " " + Component
 												.translatable(
 													"enchantment.level." + lvl)
 												.getString();
@@ -1096,10 +1099,10 @@ public final class ChestSearchScreen extends Screen
 						}else if(it.primaryPotion != null
 							&& !it.primaryPotion.isBlank())
 						{
-							net.minecraft.util.Identifier pid = null;
+							net.minecraft.resources.ResourceLocation pid = null;
 							try
 							{
-								pid = net.minecraft.util.Identifier
+								pid = net.minecraft.resources.ResourceLocation
 									.tryParse(it.primaryPotion);
 							}catch(Throwable ignored)
 							{}
@@ -1174,8 +1177,8 @@ public final class ChestSearchScreen extends Screen
 					
 					String line = name + extra + " x" + it.count + " (slot "
 						+ it.slot + ")";
-					RenderUtils.drawScaledText(context, this.textRenderer, line,
-						x + 20, lineY + 2, 0xFFEFEFEF, false, scale);
+					RenderUtils.drawScaledText(context, this.font, line, x + 20,
+						lineY + 2, 0xFFEFEFEF, false, scale);
 					lineY += Math.max(18, Math.round(18 * scale));
 				}
 			}
@@ -1211,8 +1214,7 @@ public final class ChestSearchScreen extends Screen
 				+ matchLabel + ": " + totalMatchingItems + " - Tracking "
 				+ totalChestsLogged + " chests, " + totalItemsLogged + " items";
 		int summaryPadding = 8;
-		int summaryWidth =
-			this.textRenderer.getWidth(summary) + summaryPadding * 2;
+		int summaryWidth = this.font.width(summary) + summaryPadding * 2;
 		if(summaryWidth > this.width - 4)
 			summaryWidth = this.width - 4;
 		int summaryHalf = summaryWidth / 2;
@@ -1221,8 +1223,8 @@ public final class ChestSearchScreen extends Screen
 		int summaryRight = Math.min(this.width, summaryCenter + summaryHalf);
 		context.fill(summaryLeft, summaryY - 2, summaryRight, summaryY + 18,
 			0xFF222222);
-		context.drawCenteredTextWithShadow(this.textRenderer,
-			Text.literal(summary), this.width / 2, summaryY + 2, 0xFFCCCCCC);
+		context.drawCenteredString(this.font, Component.literal(summary),
+			this.width / 2, summaryY + 2, 0xFFCCCCCC);
 		
 		if(shown == 0)
 		{
@@ -1232,8 +1234,8 @@ public final class ChestSearchScreen extends Screen
 						+ totalChestsLogged + " chests with " + totalItemsLogged
 						+ " items." + " Matching items: 0."
 					: "No chests recorded yet.";
-			context.drawCenteredTextWithShadow(this.textRenderer,
-				Text.literal(msg), this.width / 2, this.height / 2, 0xFFAAAAAA);
+			context.drawCenteredString(this.font, Component.literal(msg),
+				this.width / 2, this.height / 2, 0xFFAAAAAA);
 		}
 	}
 	
@@ -1427,23 +1429,22 @@ public final class ChestSearchScreen extends Screen
 		String remaining = text;
 		for(int line = 0; line < 2 && !remaining.isEmpty(); line++)
 		{
-			if(this.textRenderer.getWidth(remaining) * scale <= maxWidth)
+			if(this.font.width(remaining) * scale <= maxWidth)
 			{
 				lines.add(remaining);
 				break;
 			}
 			// find split point at last space that fits
 			int cut = remaining.length();
-			while(cut > 0
-				&& this.textRenderer.getWidth(remaining.substring(0, cut))
-					* scale > maxWidth)
+			while(cut > 0 && this.font.width(remaining.substring(0, cut))
+				* scale > maxWidth)
 				cut = remaining.lastIndexOf(' ', Math.max(0, cut - 1));
 			if(cut <= 0)
 			{
 				// can't find space - hard cut
 				int pos = 1;
 				while(pos < remaining.length()
-					&& this.textRenderer.getWidth(remaining.substring(0, pos))
+					&& this.font.width(remaining.substring(0, pos))
 						* scale <= maxWidth)
 					pos++;
 				lines.add(remaining.substring(0, pos - 1));
@@ -1470,7 +1471,7 @@ public final class ChestSearchScreen extends Screen
 	}
 	
 	@Override
-	public void resize(net.minecraft.client.MinecraftClient client, int width,
+	public void resize(net.minecraft.client.Minecraft client, int width,
 		int height)
 	{
 		super.resize(client, width, height);
diff --git a/src/main/java/net/wurstclient/clickgui/screens/ClickGuiScreen.java b/src/main/java/net/wurstclient/clickgui/screens/ClickGuiScreen.java
index ff6c009f5..11a7707ea 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/ClickGuiScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/ClickGuiScreen.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.clickgui.screens;
 
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.clickgui.ClickGui;
 
 public final class ClickGuiScreen extends Screen
@@ -20,25 +20,25 @@ public final class ClickGuiScreen extends Screen
 	
 	public ClickGuiScreen(ClickGui gui)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.gui = gui;
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		gui.handleMouseClick(context);
 		return super.mouseClicked(context, doubleClick);
 	}
 	
 	@Override
-	public boolean mouseReleased(Click context)
+	public boolean mouseReleased(MouseButtonEvent context)
 	{
 		gui.handleMouseRelease(context.x(), context.y(), context.button());
 		return super.mouseReleased(context);
@@ -54,17 +54,17 @@ public final class ClickGuiScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		gui.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public void renderBackground(DrawContext context, int mouseX, int mouseY,
+	public void renderBackground(GuiGraphics context, int mouseX, int mouseY,
 		float deltaTicks)
 	{
 		// Don't blur
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditBlockListScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditBlockListScreen.java
index 6cfd6eaee..7319480a5 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditBlockListScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditBlockListScreen.java
@@ -15,21 +15,20 @@ import java.util.Objects;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.block.Block;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.item.ItemStack;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget;
 import net.wurstclient.settings.BlockListSetting;
 import net.wurstclient.util.BlockUtils;
@@ -42,19 +41,19 @@ public final class EditBlockListScreen extends Screen
 	private final BlockListSetting blockList;
 	
 	private ListGui listGui;
-	private TextFieldWidget blockNameField;
-	private ButtonWidget addKeywordButton;
-	private ButtonWidget addButton;
-	private ButtonWidget removeButton;
-	private ButtonWidget doneButton;
+	private EditBox blockNameField;
+	private Button addKeywordButton;
+	private Button addButton;
+	private Button removeButton;
+	private Button doneButton;
 	
 	private Block blockToAdd;
-	private java.util.List<net.minecraft.block.Block> fuzzyMatches =
+	private java.util.List<net.minecraft.world.level.block.Block> fuzzyMatches =
 		java.util.Collections.emptyList();
 	
 	public EditBlockListScreen(Screen prevScreen, BlockListSetting blockList)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.blockList = blockList;
 	}
@@ -62,8 +61,8 @@ public final class EditBlockListScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, blockList.getBlockNames());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, blockList.getBlockNames());
+		addWidget(listGui);
 		
 		int rowY = height - 56;
 		int gap = 8;
@@ -75,18 +74,18 @@ public final class EditBlockListScreen extends Screen
 			fieldWidth + keywordWidth + addWidth + removeWidth + gap * 3;
 		int rowStart = width / 2 - totalWidth / 2;
 		
-		blockNameField = new TextFieldWidget(client.textRenderer, rowStart,
-			rowY, fieldWidth, 20, Text.literal(""));
-		addSelectableChild(blockNameField);
+		blockNameField = new EditBox(minecraft.font, rowStart, rowY, fieldWidth,
+			20, Component.literal(""));
+		addWidget(blockNameField);
 		blockNameField.setMaxLength(256);
 		
 		int keywordX = rowStart + fieldWidth + gap;
 		int addX = keywordX + keywordWidth + gap;
 		int removeX = addX + addWidth + gap;
 		
-		addDrawableChild(addKeywordButton =
-			ButtonWidget.builder(Text.literal("Add Keyword"), b -> {
-				String raw = blockNameField.getText();
+		addRenderableWidget(addKeywordButton =
+			Button.builder(Component.literal("Add Keyword"), b -> {
+				String raw = blockNameField.getValue();
 				if(raw != null)
 					raw = raw.trim();
 				if(raw == null || raw.isEmpty())
@@ -100,10 +99,10 @@ public final class EditBlockListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(keywordX, rowY, keywordWidth, 20).build());
+			}).bounds(keywordX, rowY, keywordWidth, 20).build());
 		
-		addDrawableChild(
-			addButton = ButtonWidget.builder(Text.literal("Add"), b -> {
+		addRenderableWidget(
+			addButton = Button.builder(Component.literal("Add"), b -> {
 				var prevState = listGui.captureState();
 				List<String> before =
 					new ArrayList<>(blockList.getBlockNames());
@@ -113,11 +112,11 @@ public final class EditBlockListScreen extends Screen
 					blockList.add(blockToAdd);
 				}else if(fuzzyMatches != null && !fuzzyMatches.isEmpty())
 				{
-					for(net.minecraft.block.Block bk : fuzzyMatches)
+					for(net.minecraft.world.level.block.Block bk : fuzzyMatches)
 						blockList.add(bk);
 				}else
 				{
-					String raw = blockNameField.getText();
+					String raw = blockNameField.getValue();
 					if(raw != null)
 						raw = raw.trim();
 					if(raw != null && !raw.isEmpty())
@@ -128,10 +127,10 @@ public final class EditBlockListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(addX, rowY, addWidth, 20).build());
+			}).bounds(addX, rowY, addWidth, 20).build());
 		
-		addDrawableChild(removeButton =
-			ButtonWidget.builder(Text.literal("Remove Selected"), b -> {
+		addRenderableWidget(removeButton =
+			Button.builder(Component.literal("Remove Selected"), b -> {
 				List<String> selected = listGui.getSelectedBlockNames();
 				if(selected.isEmpty())
 					return;
@@ -146,39 +145,42 @@ public final class EditBlockListScreen extends Screen
 				
 				refreshList(prevState, Collections.emptyList(),
 					prevState.scrollAmount());
-			}).dimensions(removeX, rowY, removeWidth, 20).build());
+			}).bounds(removeX, rowY, removeWidth, 20).build());
 		
 		listGui.setSelectionListener(this::updateButtons);
 		updateButtons();
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Reset to Defaults"),
-			b -> client.setScreen(new ConfirmScreen(b2 -> {
-				if(b2)
-					blockList.resetToDefaults();
-				client.setScreen(EditBlockListScreen.this);
-			}, Text.literal("Reset to Defaults"),
-				Text.literal("Are you sure?"))))
-			.dimensions(width - 328, 8, 150, 20).build());
-		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Clear List"), b -> {
-			blockList.clear();
-			client.setScreen(EditBlockListScreen.this);
-		}).dimensions(width - 168, 8, 150, 20).build());
-		
-		addDrawableChild(doneButton = ButtonWidget
-			.builder(Text.literal("Done"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height - 28, 200, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Reset to Defaults"),
+				b -> minecraft.setScreen(new ConfirmScreen(b2 -> {
+					if(b2)
+						blockList.resetToDefaults();
+					minecraft.setScreen(EditBlockListScreen.this);
+				}, Component.literal("Reset to Defaults"),
+					Component.literal("Are you sure?"))))
+				.bounds(width - 328, 8, 150, 20).build());
+		
+		addRenderableWidget(
+			Button.builder(Component.literal("Clear List"), b -> {
+				blockList.clear();
+				minecraft.setScreen(EditBlockListScreen.this);
+			}).bounds(width - 168, 8, 150, 20).build());
+		
+		addRenderableWidget(doneButton = Button
+			.builder(Component.literal("Done"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height - 28, 200, 20).build());
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		blockNameField.mouseClicked(context, doubleClick);
 		return super.mouseClicked(context, doubleClick);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -206,7 +208,7 @@ public final class EditBlockListScreen extends Screen
 	@Override
 	public void tick()
 	{
-		String nameOrId = blockNameField.getText();
+		String nameOrId = blockNameField.getValue();
 		String trimmed = nameOrId == null ? "" : nameOrId.trim();
 		boolean hasInput = !trimmed.isEmpty();
 		blockToAdd =
@@ -220,33 +222,34 @@ public final class EditBlockListScreen extends Screen
 				fuzzyMatches = java.util.Collections.emptyList();
 			}else
 			{
-				java.util.ArrayList<net.minecraft.block.Block> list =
+				java.util.ArrayList<net.minecraft.world.level.block.Block> list =
 					new java.util.ArrayList<>();
-				for(net.minecraft.util.Identifier id : net.minecraft.registry.Registries.BLOCK
-					.getIds())
+				for(net.minecraft.resources.ResourceLocation id : net.minecraft.core.registries.BuiltInRegistries.BLOCK
+					.keySet())
 				{
 					String s = id.toString().toLowerCase(java.util.Locale.ROOT);
 					if(s.contains(q))
 						list.add(
-							net.minecraft.registry.Registries.BLOCK.get(id));
+							net.minecraft.core.registries.BuiltInRegistries.BLOCK
+								.getValue(id));
 				}
 				// Deduplicate and sort by identifier
-				java.util.LinkedHashMap<String, net.minecraft.block.Block> map =
+				java.util.LinkedHashMap<String, net.minecraft.world.level.block.Block> map =
 					new java.util.LinkedHashMap<>();
-				for(net.minecraft.block.Block b : list)
+				for(net.minecraft.world.level.block.Block b : list)
 					map.put(net.wurstclient.util.BlockUtils.getName(b), b);
 				fuzzyMatches = new java.util.ArrayList<>(map.values());
 				fuzzyMatches.sort(java.util.Comparator
 					.comparing(net.wurstclient.util.BlockUtils::getName));
 			}
 			addButton.active = !fuzzyMatches.isEmpty() || hasInput;
-			addButton.setMessage(Text.literal(fuzzyMatches.isEmpty() ? "Add"
-				: ("Add Matches (" + fuzzyMatches.size() + ")")));
+			addButton.setMessage(Component.literal(fuzzyMatches.isEmpty()
+				? "Add" : ("Add Matches (" + fuzzyMatches.size() + ")")));
 		}else
 		{
 			fuzzyMatches = java.util.Collections.emptyList();
 			addButton.active = true;
-			addButton.setMessage(Text.literal("Add"));
+			addButton.setMessage(Component.literal("Add"));
 		}
 		
 		addKeywordButton.active = hasInput;
@@ -254,41 +257,41 @@ public final class EditBlockListScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
+		context.drawCenteredString(minecraft.font,
 			blockList.getName() + " (" + blockList.size() + ")", width / 2, 12,
-			Colors.WHITE);
+			CommonColors.WHITE);
 		
 		matrixStack.pushMatrix();
 		
 		blockNameField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 			
 		// Draw placeholder + decorative left icon frame using ABSOLUTE
 		// coordinates
 		// derived from the actual TextFieldWidget position/size (no matrix
 		// translate).
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		int x0 = blockNameField.getX();
 		int y0 = blockNameField.getY();
 		int y1 = y0 + blockNameField.getHeight();
 		
-		if(blockNameField.getText().isEmpty() && !blockNameField.isFocused())
-			context.drawTextWithShadow(client.textRenderer, "block name or ID",
-				x0 + 6, y0 + 6, Colors.GRAY);
+		if(blockNameField.getValue().isEmpty() && !blockNameField.isFocused())
+			context.drawString(minecraft.font, "block name or ID", x0 + 6,
+				y0 + 6, CommonColors.GRAY);
 		
-		int border =
-			blockNameField.isFocused() ? Colors.WHITE : Colors.LIGHT_GRAY;
-		int black = Colors.BLACK;
+		int border = blockNameField.isFocused() ? CommonColors.WHITE
+			: CommonColors.LIGHT_GRAY;
+		int black = CommonColors.BLACK;
 		int iconBoxLeft = x0 - 20;
 		
 		// Left decoration for the item icon, anchored to the field.
@@ -303,7 +306,7 @@ public final class EditBlockListScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -341,18 +344,18 @@ public final class EditBlockListScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
 			Block block = BlockUtils.getBlockFromName(blockName);
 			ItemStack stack = new ItemStack(block);
 			
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"Block " + getDisplayName(stack) + ", " + blockName + ", "
 					+ getIdText(block));
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
@@ -360,26 +363,26 @@ public final class EditBlockListScreen extends Screen
 			
 			Block block = BlockUtils.getBlockFromName(blockName);
 			ItemStack stack = new ItemStack(block);
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			RenderUtils.drawItem(context, stack, x + 1, y + 1, true);
-			context.drawText(tr, getDisplayName(stack), x + 28, y,
+			context.drawString(tr, getDisplayName(stack), x + 28, y,
 				WurstColors.VERY_LIGHT_GRAY, false);
-			context.drawText(tr, blockName, x + 28, y + 9, Colors.LIGHT_GRAY,
-				false);
-			context.drawText(tr, getIdText(block), x + 28, y + 18,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, blockName, x + 28, y + 9,
+				CommonColors.LIGHT_GRAY, false);
+			context.drawString(tr, getIdText(block), x + 28, y + 18,
+				CommonColors.LIGHT_GRAY, false);
 		}
 		
 		private String getDisplayName(ItemStack stack)
 		{
 			return stack.isEmpty() ? "\u00a7ounknown block\u00a7r"
-				: stack.getName().getString();
+				: stack.getHoverName().getString();
 		}
 		
 		private String getIdText(Block block)
 		{
-			return "ID: " + Block.getRawIdFromState(block.getDefaultState());
+			return "ID: " + Block.getId(block.defaultBlockState());
 		}
 		
 		@Override
@@ -392,7 +395,7 @@ public final class EditBlockListScreen extends Screen
 	private final class ListGui
 		extends MultiSelectEntryListWidget<EditBlockListScreen.Entry>
 	{
-		public ListGui(MinecraftClient minecraft, EditBlockListScreen screen,
+		public ListGui(Minecraft minecraft, EditBlockListScreen screen,
 			List<String> list)
 		{
 			super(minecraft, screen.width, screen.height - 96, 36, 30);
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditBlockScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditBlockScreen.java
index 5a6c7b17e..ccb944497 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditBlockScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditBlockScreen.java
@@ -9,19 +9,18 @@ package net.wurstclient.clickgui.screens;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.item.ItemStack;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.settings.BlockSetting;
 import net.wurstclient.util.BlockUtils;
 import net.wurstclient.util.RenderUtils;
@@ -32,12 +31,12 @@ public final class EditBlockScreen extends Screen
 	private final Screen prevScreen;
 	private final BlockSetting setting;
 	
-	private TextFieldWidget blockField;
-	private ButtonWidget doneButton;
+	private EditBox blockField;
+	private Button doneButton;
 	
 	public EditBlockScreen(Screen prevScreen, BlockSetting setting)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.setting = setting;
 	}
@@ -49,36 +48,36 @@ public final class EditBlockScreen extends Screen
 		int y1 = 59;
 		int y2 = height / 3 * 2;
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		String valueString = setting.getBlockName();
 		
-		blockField = new TextFieldWidget(tr, x1, y1, 178, 20, Text.literal(""));
-		blockField.setText(valueString);
-		blockField.setSelectionStart(0);
+		blockField = new EditBox(tr, x1, y1, 178, 20, Component.literal(""));
+		blockField.setValue(valueString);
+		blockField.setCursorPosition(0);
 		blockField.setMaxLength(256);
 		
-		addSelectableChild(blockField);
+		addWidget(blockField);
 		setFocused(blockField);
 		blockField.setFocused(true);
 		
-		doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-			.dimensions(x1, y2, 200, 20).build();
-		addDrawableChild(doneButton);
+		doneButton = Button.builder(Component.literal("Done"), b -> done())
+			.bounds(x1, y2, 200, 20).build();
+		addRenderableWidget(doneButton);
 	}
 	
 	private void done()
 	{
-		String nameOrId = blockField.getText();
+		String nameOrId = blockField.getValue();
 		Block block = BlockUtils.getBlockFromNameOrID(nameOrId);
 		
 		if(block != null)
 			setting.setBlock(block);
 		
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -87,7 +86,7 @@ public final class EditBlockScreen extends Screen
 			break;
 			
 			case GLFW.GLFW_KEY_ESCAPE:
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			break;
 		}
 		
@@ -95,35 +94,37 @@ public final class EditBlockScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
-		TextRenderer tr = client.textRenderer;
+		Matrix3x2fStack matrixStack = context.pose();
+		Font tr = minecraft.font;
 		
-		context.drawCenteredTextWithShadow(tr, setting.getName(), width / 2, 20,
-			Colors.WHITE);
+		context.drawCenteredString(tr, setting.getName(), width / 2, 20,
+			CommonColors.WHITE);
 		
 		blockField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		matrixStack.pushMatrix();
 		matrixStack.translate(-64 + width / 2 - 100, 115);
 		
 		boolean lblAbove =
-			!blockField.getText().isEmpty() || blockField.isFocused();
+			!blockField.getValue().isEmpty() || blockField.isFocused();
 		String lblText =
 			lblAbove ? "Block ID or number:" : "block ID or number";
 		int lblX = lblAbove ? 50 : 68;
 		int lblY = lblAbove ? -66 : -50;
-		int lblColor = lblAbove ? WurstColors.VERY_LIGHT_GRAY : Colors.GRAY;
-		context.drawTextWithShadow(tr, lblText, lblX, lblY, lblColor);
+		int lblColor =
+			lblAbove ? WurstColors.VERY_LIGHT_GRAY : CommonColors.GRAY;
+		context.drawString(tr, lblText, lblX, lblY, lblColor);
 		
-		int border = blockField.isFocused() ? Colors.WHITE : Colors.LIGHT_GRAY;
-		int black = Colors.BLACK;
+		int border = blockField.isFocused() ? CommonColors.WHITE
+			: CommonColors.LIGHT_GRAY;
+		int black = CommonColors.BLACK;
 		
 		context.fill(48, -56, 64, -36, border);
 		context.fill(49, -55, 65, -37, black);
@@ -132,7 +133,7 @@ public final class EditBlockScreen extends Screen
 		
 		matrixStack.popMatrix();
 		
-		String nameOrId = blockField.getText();
+		String nameOrId = blockField.getValue();
 		Block blockToAdd = BlockUtils.getBlockFromNameOrID(nameOrId);
 		
 		if(blockToAdd == null)
@@ -143,7 +144,7 @@ public final class EditBlockScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditBookOfferScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditBookOfferScreen.java
index 44867a0ac..3e8d1b598 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditBookOfferScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditBookOfferScreen.java
@@ -9,24 +9,23 @@ package net.wurstclient.clickgui.screens;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.tag.EnchantmentTags;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.EnchantmentTags;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
 import net.wurstclient.hacks.autolibrarian.BookOffer;
 import net.wurstclient.settings.BookOffersSetting;
 import net.wurstclient.util.MathUtils;
@@ -38,16 +37,16 @@ public final class EditBookOfferScreen extends Screen
 	private final Screen prevScreen;
 	private final BookOffersSetting bookOffers;
 	
-	private TextFieldWidget levelField;
-	private ButtonWidget levelPlusButton;
-	private ButtonWidget levelMinusButton;
+	private EditBox levelField;
+	private Button levelPlusButton;
+	private Button levelMinusButton;
 	
-	private TextFieldWidget priceField;
-	private ButtonWidget pricePlusButton;
-	private ButtonWidget priceMinusButton;
+	private EditBox priceField;
+	private Button pricePlusButton;
+	private Button priceMinusButton;
 	
-	private ButtonWidget saveButton;
-	private ButtonWidget cancelButton;
+	private Button saveButton;
+	private Button cancelButton;
 	
 	private BookOffer offerToSave;
 	private int index;
@@ -56,7 +55,7 @@ public final class EditBookOfferScreen extends Screen
 	public EditBookOfferScreen(Screen prevScreen, BookOffersSetting bookOffers,
 		int index)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.bookOffers = bookOffers;
 		this.index = index;
@@ -66,11 +65,11 @@ public final class EditBookOfferScreen extends Screen
 	@Override
 	public void init()
 	{
-		levelField = new TextFieldWidget(client.textRenderer, width / 2 - 32,
-			110, 28, 12, Text.literal(""));
-		addSelectableChild(levelField);
+		levelField = new EditBox(minecraft.font, width / 2 - 32, 110, 28, 12,
+			Component.literal(""));
+		addWidget(levelField);
 		levelField.setMaxLength(2);
-		levelField.setTextPredicate(t -> {
+		levelField.setFilter(t -> {
 			if(t.isEmpty())
 				return true;
 			
@@ -88,7 +87,7 @@ public final class EditBookOfferScreen extends Screen
 			int maxLevel = enchantment != null ? enchantment.getMaxLevel() : 10;
 			return level <= maxLevel;
 		});
-		levelField.setChangedListener(t -> {
+		levelField.setResponder(t -> {
 			if(!MathUtils.isInteger(t))
 				return;
 			
@@ -96,13 +95,13 @@ public final class EditBookOfferScreen extends Screen
 			updateLevel(level, false);
 		});
 		
-		priceField = new TextFieldWidget(client.textRenderer, width / 2 - 32,
-			126, 28, 12, Text.literal(""));
-		addSelectableChild(priceField);
+		priceField = new EditBox(minecraft.font, width / 2 - 32, 126, 28, 12,
+			Component.literal(""));
+		addWidget(priceField);
 		priceField.setMaxLength(2);
-		priceField.setTextPredicate(t -> t.isEmpty() || MathUtils.isInteger(t)
+		priceField.setFilter(t -> t.isEmpty() || MathUtils.isInteger(t)
 			&& Integer.parseInt(t) >= 1 && Integer.parseInt(t) <= 64);
-		priceField.setChangedListener(t -> {
+		priceField.setResponder(t -> {
 			if(!MathUtils.isInteger(t))
 				return;
 			
@@ -110,39 +109,40 @@ public final class EditBookOfferScreen extends Screen
 			updatePrice(price, false);
 		});
 		
-		addDrawableChild(levelPlusButton =
-			ButtonWidget.builder(Text.literal("+"), b -> updateLevel(1, true))
-				.dimensions(width / 2 + 2, 110, 20, 12).build());
+		addRenderableWidget(levelPlusButton =
+			Button.builder(Component.literal("+"), b -> updateLevel(1, true))
+				.bounds(width / 2 + 2, 110, 20, 12).build());
 		levelPlusButton.active = false;
 		
-		addDrawableChild(levelMinusButton =
-			ButtonWidget.builder(Text.literal("-"), b -> updateLevel(-1, true))
-				.dimensions(width / 2 + 26, 110, 20, 12).build());
+		addRenderableWidget(levelMinusButton =
+			Button.builder(Component.literal("-"), b -> updateLevel(-1, true))
+				.bounds(width / 2 + 26, 110, 20, 12).build());
 		levelMinusButton.active = false;
 		
-		addDrawableChild(pricePlusButton =
-			ButtonWidget.builder(Text.literal("+"), b -> updatePrice(1, true))
-				.dimensions(width / 2 + 2, 126, 20, 12).build());
+		addRenderableWidget(pricePlusButton =
+			Button.builder(Component.literal("+"), b -> updatePrice(1, true))
+				.bounds(width / 2 + 2, 126, 20, 12).build());
 		pricePlusButton.active = false;
 		
-		addDrawableChild(priceMinusButton =
-			ButtonWidget.builder(Text.literal("-"), b -> updatePrice(-1, true))
-				.dimensions(width / 2 + 26, 126, 20, 12).build());
+		addRenderableWidget(priceMinusButton =
+			Button.builder(Component.literal("-"), b -> updatePrice(-1, true))
+				.bounds(width / 2 + 26, 126, 20, 12).build());
 		priceMinusButton.active = false;
 		
-		addDrawableChild(
-			saveButton = ButtonWidget.builder(Text.literal("Save"), b -> {
+		addRenderableWidget(
+			saveButton = Button.builder(Component.literal("Save"), b -> {
 				if(offerToSave == null || !offerToSave.isMostlyValid())
 					return;
 				
 				bookOffers.replace(index, offerToSave);
-				client.setScreen(prevScreen);
-			}).dimensions(width / 2 - 102, height / 3 * 2, 100, 20).build());
+				minecraft.setScreen(prevScreen);
+			}).bounds(width / 2 - 102, height / 3 * 2, 100, 20).build());
 		saveButton.active = false;
 		
-		addDrawableChild(cancelButton = ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 + 2, height / 3 * 2, 100, 20).build());
+		addRenderableWidget(cancelButton = Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 + 2, height / 3 * 2, 100, 20).build());
 		
 		updateSelectedOffer(offerToSave);
 	}
@@ -190,26 +190,26 @@ public final class EditBookOfferScreen extends Screen
 		
 		if(offer == null)
 		{
-			if(!levelField.getText().isEmpty())
-				levelField.setText("");
+			if(!levelField.getValue().isEmpty())
+				levelField.setValue("");
 			
-			if(!priceField.getText().isEmpty())
-				priceField.setText("");
+			if(!priceField.getValue().isEmpty())
+				priceField.setValue("");
 			
 		}else
 		{
 			String level = "" + offer.level();
-			if(!levelField.getText().equals(level))
-				levelField.setText(level);
+			if(!levelField.getValue().equals(level))
+				levelField.setValue(level);
 			
 			String price = "" + offer.price();
-			if(!priceField.getText().equals(price))
-				priceField.setText(price);
+			if(!priceField.getValue().equals(price))
+				priceField.setValue(price);
 		}
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		boolean childClicked = super.mouseClicked(context, doubleClick);
 		
@@ -223,7 +223,7 @@ public final class EditBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -261,22 +261,23 @@ public final class EditBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		matrixStack.pushMatrix();
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		String titleText = "Edit Book Offer";
-		context.drawCenteredTextWithShadow(tr, titleText, width / 2, 12,
-			Colors.WHITE);
+		context.drawCenteredString(tr, titleText, width / 2, 12,
+			CommonColors.WHITE);
 		
 		int x = width / 2 - 100;
 		int y = 64;
 		
-		Item item = Registries.ITEM.get(Identifier.of("enchanted_book"));
+		Item item = BuiltInRegistries.ITEM
+			.getValue(ResourceLocation.parse("enchanted_book"));
 		ItemStack stack = new ItemStack(item);
 		RenderUtils.drawItem(context, stack, x + 1, y + 1, true);
 		
@@ -284,12 +285,12 @@ public final class EditBookOfferScreen extends Screen
 		String name = bookOffer.getEnchantmentNameWithLevel();
 		
 		boolean isCurse = bookOffer.getEnchantmentEntry()
-			.map(entry -> entry.isIn(EnchantmentTags.CURSE)).orElse(false);
-		int nameColor = isCurse ? WurstColors.LIGHT_RED : Colors.WHITE;
-		context.drawTextWithShadow(tr, name, x + 28, y, nameColor);
+			.map(entry -> entry.is(EnchantmentTags.CURSE)).orElse(false);
+		int nameColor = isCurse ? WurstColors.LIGHT_RED : CommonColors.WHITE;
+		context.drawString(tr, name, x + 28, y, nameColor);
 		
-		context.drawText(tr, bookOffer.id(), x + 28, y + 9, Colors.LIGHT_GRAY,
-			false);
+		context.drawString(tr, bookOffer.id(), x + 28, y + 9,
+			CommonColors.LIGHT_GRAY, false);
 		
 		String price;
 		if(bookOffer.price() >= 64)
@@ -298,30 +299,29 @@ public final class EditBookOfferScreen extends Screen
 		{
 			price = "max " + bookOffer.price();
 			RenderUtils.drawItem(context, new ItemStack(Items.EMERALD),
-				x + 28 + tr.getWidth(price), y + 16, false);
+				x + 28 + tr.width(price), y + 16, false);
 		}
 		
-		context.drawText(tr, price, x + 28, y + 18, Colors.LIGHT_GRAY, false);
+		context.drawString(tr, price, x + 28, y + 18, CommonColors.LIGHT_GRAY,
+			false);
 		
 		levelField.render(context, mouseX, mouseY, partialTicks);
 		priceField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		matrixStack.translate(width / 2 - 100, 112);
 		
-		context.drawTextWithShadow(tr, "Level:", 0, 0,
-			WurstColors.VERY_LIGHT_GRAY);
-		context.drawTextWithShadow(tr, "Max price:", 0, 16,
+		context.drawString(tr, "Level:", 0, 0, WurstColors.VERY_LIGHT_GRAY);
+		context.drawString(tr, "Max price:", 0, 16,
 			WurstColors.VERY_LIGHT_GRAY);
 		
 		if(alreadyAdded && offerToSave != null)
 		{
 			String errorText = offerToSave.getEnchantmentNameWithLevel()
 				+ " is already on your list!";
-			context.drawTextWithShadow(tr, errorText, 0, 32,
-				WurstColors.LIGHT_RED);
+			context.drawString(tr, errorText, 0, 32, WurstColors.LIGHT_RED);
 		}
 		
 		matrixStack.popMatrix();
@@ -331,7 +331,7 @@ public final class EditBookOfferScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditBookOffersScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditBookOffersScreen.java
index 034d3f1ef..35cf339ab 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditBookOffersScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditBookOffersScreen.java
@@ -14,28 +14,27 @@ import java.util.List;
 import java.util.Objects;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.registry.tag.EnchantmentTags;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
 import net.wurstclient.hacks.autolibrarian.BookOffer;
 import net.wurstclient.settings.BookOffersSetting;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.EnchantmentTags;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
 import net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget;
 import net.wurstclient.util.RenderUtils;
 import net.wurstclient.util.WurstColors;
@@ -46,13 +45,13 @@ public final class EditBookOffersScreen extends Screen
 	private final BookOffersSetting bookOffers;
 	
 	private ListGui listGui;
-	private ButtonWidget editButton;
-	private ButtonWidget removeButton;
-	private ButtonWidget doneButton;
+	private Button editButton;
+	private Button removeButton;
+	private Button doneButton;
 	
 	public EditBookOffersScreen(Screen prevScreen, BookOffersSetting bookOffers)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.bookOffers = bookOffers;
 	}
@@ -60,29 +59,28 @@ public final class EditBookOffersScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, bookOffers.getOffers());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, bookOffers.getOffers());
+		addWidget(listGui);
 		
-		addDrawableChild(
-			ButtonWidget
-				.builder(Text.literal("Add"),
-					b -> client
-						.setScreen(new AddBookOfferScreen(this, bookOffers)))
-				.dimensions(width / 2 - 154, height - 56, 100, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Add"),
+				b -> minecraft
+					.setScreen(new AddBookOfferScreen(this, bookOffers)))
+			.bounds(width / 2 - 154, height - 56, 100, 20).build());
 		
-		addDrawableChild(
-			editButton = ButtonWidget.builder(Text.literal("Edit"), b -> {
+		addRenderableWidget(
+			editButton = Button.builder(Component.literal("Edit"), b -> {
 				BookOffer selected = listGui.getPrimarySelectedOffer();
 				if(selected == null)
 					return;
 				
-				client.setScreen(new EditBookOfferScreen(this, bookOffers,
+				minecraft.setScreen(new EditBookOfferScreen(this, bookOffers,
 					bookOffers.indexOf(selected)));
-			}).dimensions(width / 2 - 50, height - 56, 100, 20).build());
+			}).bounds(width / 2 - 50, height - 56, 100, 20).build());
 		editButton.active = false;
 		
-		addDrawableChild(
-			removeButton = ButtonWidget.builder(Text.literal("Remove"), b -> {
+		addRenderableWidget(
+			removeButton = Button.builder(Component.literal("Remove"), b -> {
 				List<BookOffer> selected = listGui.getSelectedOffers();
 				if(selected.isEmpty())
 					return;
@@ -97,28 +95,30 @@ public final class EditBookOffersScreen extends Screen
 				
 				refreshList(prevState, Collections.emptyList(),
 					prevState.scrollAmount());
-			}).dimensions(width / 2 + 54, height - 56, 100, 20).build());
+			}).bounds(width / 2 + 54, height - 56, 100, 20).build());
 		removeButton.active = false;
 		
 		listGui.setSelectionListener(this::updateButtons);
 		updateButtons();
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Reset to Defaults"),
-			b -> client.setScreen(new ConfirmScreen(b2 -> {
-				if(b2)
-					bookOffers.resetToDefaults();
-				client.setScreen(EditBookOffersScreen.this);
-			}, Text.literal("Reset to Defaults"),
-				Text.literal("Are you sure?"))))
-			.dimensions(width - 106, 6, 100, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Reset to Defaults"),
+				b -> minecraft.setScreen(new ConfirmScreen(b2 -> {
+					if(b2)
+						bookOffers.resetToDefaults();
+					minecraft.setScreen(EditBookOffersScreen.this);
+				}, Component.literal("Reset to Defaults"),
+					Component.literal("Are you sure?"))))
+				.bounds(width - 106, 6, 100, 20).build());
 		
-		addDrawableChild(doneButton = ButtonWidget
-			.builder(Text.literal("Done"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height - 32, 200, 20).build());
+		addRenderableWidget(doneButton = Button
+			.builder(Component.literal("Done"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height - 32, 200, 20).build());
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		boolean childClicked = super.mouseClicked(context, doubleClick);
 		
@@ -129,7 +129,7 @@ public final class EditBookOffersScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -161,21 +161,21 @@ public final class EditBookOffersScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
+		context.drawCenteredString(minecraft.font,
 			bookOffers.getName() + " (" + bookOffers.getOffers().size() + ")",
-			width / 2, 12, Colors.WHITE);
+			width / 2, 12, CommonColors.WHITE);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -224,44 +224,45 @@ public final class EditBookOffersScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"Book offer " + bookOffer.getEnchantmentNameWithLevel()
 					+ ", ID " + bookOffer.id() + ", " + getPriceText());
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			Item item = Registries.ITEM.get(Identifier.of("enchanted_book"));
+			Item item = BuiltInRegistries.ITEM
+				.getValue(ResourceLocation.parse("enchanted_book"));
 			ItemStack stack = new ItemStack(item);
 			RenderUtils.drawItem(context, stack, x + 1, y + 1, true);
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			String name = bookOffer.getEnchantmentNameWithLevel();
 			
-			RegistryEntry<Enchantment> enchantment =
+			Holder<Enchantment> enchantment =
 				bookOffer.getEnchantmentEntry().orElse(null);
 			int nameColor =
-				enchantment != null && enchantment.isIn(EnchantmentTags.CURSE)
+				enchantment != null && enchantment.is(EnchantmentTags.CURSE)
 					? WurstColors.LIGHT_RED : WurstColors.VERY_LIGHT_GRAY;
-			context.drawText(tr, name, x + 28, y, nameColor, false);
+			context.drawString(tr, name, x + 28, y, nameColor, false);
 			
-			context.drawText(tr, bookOffer.id(), x + 28, y + 9,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, bookOffer.id(), x + 28, y + 9,
+				CommonColors.LIGHT_GRAY, false);
 			
 			String price = getPriceText();
-			context.drawText(tr, price, x + 28, y + 18, Colors.LIGHT_GRAY,
-				false);
+			context.drawString(tr, price, x + 28, y + 18,
+				CommonColors.LIGHT_GRAY, false);
 			
 			if(bookOffer.price() < 64)
 				RenderUtils.drawItem(context, new ItemStack(Items.EMERALD),
-					x + 28 + tr.getWidth(price), y + 16, false);
+					x + 28 + tr.width(price), y + 16, false);
 		}
 		
 		private String getPriceText()
@@ -282,7 +283,7 @@ public final class EditBookOffersScreen extends Screen
 	private final class ListGui
 		extends MultiSelectEntryListWidget<EditBookOffersScreen.Entry>
 	{
-		public ListGui(MinecraftClient minecraft, EditBookOffersScreen screen,
+		public ListGui(Minecraft minecraft, EditBookOffersScreen screen,
 			List<BookOffer> list)
 		{
 			super(minecraft, screen.width, screen.height - 108, 36, 30);
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditColorScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditColorScreen.java
index 35a5ff2a3..30f436aa9 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditColorScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditColorScreen.java
@@ -15,20 +15,19 @@ import java.io.InputStream;
 import javax.imageio.ImageIO;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gl.RenderPipelines;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.client.renderer.RenderPipelines;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.util.ColorUtils;
 import net.wurstclient.util.WurstColors;
@@ -39,15 +38,15 @@ public final class EditColorScreen extends Screen
 	private final ColorSetting colorSetting;
 	private Color color;
 	
-	private TextFieldWidget hexValueField;
-	private TextFieldWidget redValueField;
-	private TextFieldWidget greenValueField;
-	private TextFieldWidget blueValueField;
+	private EditBox hexValueField;
+	private EditBox redValueField;
+	private EditBox greenValueField;
+	private EditBox blueValueField;
 	
-	private ButtonWidget doneButton;
+	private Button doneButton;
 	
-	private final Identifier paletteIdentifier =
-		Identifier.of("wurst", "colorpalette.png");
+	private final ResourceLocation paletteIdentifier =
+		ResourceLocation.fromNamespaceAndPath("wurst", "colorpalette.png");
 	private BufferedImage paletteAsBufferedImage;
 	
 	private int paletteX = 0;
@@ -63,7 +62,7 @@ public final class EditColorScreen extends Screen
 	
 	public EditColorScreen(Screen prevScreen, ColorSetting colorSetting)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.colorSetting = colorSetting;
 		color = colorSetting.getColor();
@@ -73,8 +72,8 @@ public final class EditColorScreen extends Screen
 	public void init()
 	{
 		// Cache color palette
-		try(InputStream stream = client.getResourceManager()
-			.getResourceOrThrow(paletteIdentifier).getInputStream())
+		try(InputStream stream = minecraft.getResourceManager()
+			.getResourceOrThrow(paletteIdentifier).open())
 		{
 			paletteAsBufferedImage = ImageIO.read(stream);
 			
@@ -84,50 +83,50 @@ public final class EditColorScreen extends Screen
 			e.printStackTrace();
 		}
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		paletteX = width / 2 - 100;
 		paletteY = 32;
 		fieldsX = width / 2 - 100;
 		fieldsY = 129 + 5;
 		
 		hexValueField =
-			new TextFieldWidget(tr, fieldsX, fieldsY, 92, 20, Text.literal(""));
-		hexValueField.setText(ColorUtils.toHex(color).substring(1));
+			new EditBox(tr, fieldsX, fieldsY, 92, 20, Component.literal(""));
+		hexValueField.setValue(ColorUtils.toHex(color).substring(1));
 		hexValueField.setMaxLength(6);
-		hexValueField.setChangedListener(s -> updateColor(true));
+		hexValueField.setResponder(s -> updateColor(true));
 		
 		// RGB fields
-		redValueField = new TextFieldWidget(tr, fieldsX, fieldsY + 35, 50, 20,
-			Text.literal(""));
-		redValueField.setText("" + color.getRed());
+		redValueField = new EditBox(tr, fieldsX, fieldsY + 35, 50, 20,
+			Component.literal(""));
+		redValueField.setValue("" + color.getRed());
 		redValueField.setMaxLength(3);
-		redValueField.setChangedListener(s -> updateColor(false));
+		redValueField.setResponder(s -> updateColor(false));
 		
-		greenValueField = new TextFieldWidget(tr, fieldsX + 75, fieldsY + 35,
-			50, 20, Text.literal(""));
-		greenValueField.setText("" + color.getGreen());
+		greenValueField = new EditBox(tr, fieldsX + 75, fieldsY + 35, 50, 20,
+			Component.literal(""));
+		greenValueField.setValue("" + color.getGreen());
 		greenValueField.setMaxLength(3);
-		greenValueField.setChangedListener(s -> updateColor(false));
+		greenValueField.setResponder(s -> updateColor(false));
 		
-		blueValueField = new TextFieldWidget(tr, fieldsX + 150, fieldsY + 35,
-			50, 20, Text.literal(""));
-		blueValueField.setText("" + color.getBlue());
+		blueValueField = new EditBox(tr, fieldsX + 150, fieldsY + 35, 50, 20,
+			Component.literal(""));
+		blueValueField.setValue("" + color.getBlue());
 		blueValueField.setMaxLength(3);
-		blueValueField.setChangedListener(s -> updateColor(false));
+		blueValueField.setResponder(s -> updateColor(false));
 		
-		addSelectableChild(hexValueField);
-		addSelectableChild(redValueField);
-		addSelectableChild(greenValueField);
-		addSelectableChild(blueValueField);
+		addWidget(hexValueField);
+		addWidget(redValueField);
+		addWidget(greenValueField);
+		addWidget(blueValueField);
 		
 		setFocused(hexValueField);
 		hexValueField.setFocused(true);
-		hexValueField.setSelectionStart(0);
-		hexValueField.setSelectionEnd(6);
+		hexValueField.setCursorPosition(0);
+		hexValueField.setHighlightPos(6);
 		
-		doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-			.dimensions(fieldsX, height - 30, 200, 20).build();
-		addDrawableChild(doneButton);
+		doneButton = Button.builder(Component.literal("Done"), b -> done())
+			.bounds(fieldsX, height - 30, 200, 20).build();
+		addRenderableWidget(doneButton);
 	}
 	
 	private void updateColor(boolean hex)
@@ -138,37 +137,37 @@ public final class EditColorScreen extends Screen
 		Color newColor;
 		
 		if(hex)
-			newColor = ColorUtils.tryParseHex("#" + hexValueField.getText());
+			newColor = ColorUtils.tryParseHex("#" + hexValueField.getValue());
 		else
-			newColor = ColorUtils.tryParseRGB(redValueField.getText(),
-				greenValueField.getText(), blueValueField.getText());
+			newColor = ColorUtils.tryParseRGB(redValueField.getValue(),
+				greenValueField.getValue(), blueValueField.getValue());
 		
 		if(newColor == null || newColor.equals(color))
 			return;
 		
 		color = newColor;
 		ignoreChanges = true;
-		hexValueField.setText(ColorUtils.toHex(color).substring(1));
-		redValueField.setText("" + color.getRed());
-		greenValueField.setText("" + color.getGreen());
-		blueValueField.setText("" + color.getBlue());
+		hexValueField.setValue(ColorUtils.toHex(color).substring(1));
+		redValueField.setValue("" + color.getRed());
+		greenValueField.setValue("" + color.getGreen());
+		blueValueField.setValue("" + color.getBlue());
 		ignoreChanges = false;
 	}
 	
 	private void done()
 	{
 		colorSetting.setColor(color);
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			colorSetting.getName(), width / 2, 16, WurstColors.VERY_LIGHT_GRAY);
+		context.drawCenteredString(minecraft.font, colorSetting.getName(),
+			width / 2, 16, WurstColors.VERY_LIGHT_GRAY);
 		
 		// Draw palette
 		int x = paletteX;
@@ -179,18 +178,18 @@ public final class EditColorScreen extends Screen
 		int fh = paletteHeight;
 		float u = 0;
 		float v = 0;
-		context.drawTexture(RenderPipelines.GUI_TEXTURED, paletteIdentifier, x,
-			y, u, v, w, h, fw, fh);
+		context.blit(RenderPipelines.GUI_TEXTURED, paletteIdentifier, x, y, u,
+			v, w, h, fw, fh);
 		
 		// RGB letters
-		context.drawText(tr, "#", fieldsX - 3 - tr.getWidth("#"), fieldsY + 6,
+		context.drawString(tr, "#", fieldsX - 3 - tr.width("#"), fieldsY + 6,
 			WurstColors.VERY_LIGHT_GRAY, false);
-		context.drawText(tr, "R:", fieldsX - 3 - tr.getWidth("R:"),
-			fieldsY + 6 + 35, Colors.RED, false);
-		context.drawText(tr, "G:", fieldsX + 75 - 3 - tr.getWidth("G:"),
-			fieldsY + 6 + 35, Colors.GREEN, false);
-		context.drawText(tr, "B:", fieldsX + 150 - 3 - tr.getWidth("B:"),
-			fieldsY + 6 + 35, Colors.BLUE, false);
+		context.drawString(tr, "R:", fieldsX - 3 - tr.width("R:"),
+			fieldsY + 6 + 35, CommonColors.RED, false);
+		context.drawString(tr, "G:", fieldsX + 75 - 3 - tr.width("G:"),
+			fieldsY + 6 + 35, CommonColors.GREEN, false);
+		context.drawString(tr, "B:", fieldsX + 150 - 3 - tr.width("B:"),
+			fieldsY + 6 + 35, CommonColors.BLUE, false);
 		
 		hexValueField.render(context, mouseX, mouseY, partialTicks);
 		redValueField.render(context, mouseX, mouseY, partialTicks);
@@ -208,34 +207,34 @@ public final class EditColorScreen extends Screen
 		// Border
 		context.fill(boxX - borderSize, boxY - borderSize,
 			boxX + boxWidth + borderSize, boxY + boxHeight + borderSize,
-			Colors.LIGHT_GRAY);
+			CommonColors.LIGHT_GRAY);
 		
 		// Color box
 		context.fill(boxX, boxY, boxX + boxWidth, boxY + boxHeight,
 			color.getRGB());
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public void resize(MinecraftClient client, int width, int height)
+	public void resize(Minecraft client, int width, int height)
 	{
-		String hex = hexValueField.getText();
-		String r = redValueField.getText();
-		String g = greenValueField.getText();
-		String b = blueValueField.getText();
+		String hex = hexValueField.getValue();
+		String r = redValueField.getValue();
+		String g = greenValueField.getValue();
+		String b = blueValueField.getValue();
 		
 		init(client, width, height);
 		
-		hexValueField.setText(hex);
-		redValueField.setText(r);
-		greenValueField.setText(g);
-		blueValueField.setText(b);
+		hexValueField.setValue(hex);
+		redValueField.setValue(r);
+		greenValueField.setValue(g);
+		blueValueField.setValue(b);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -244,7 +243,7 @@ public final class EditColorScreen extends Screen
 			break;
 			
 			case GLFW.GLFW_KEY_ESCAPE:
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			break;
 		}
 		
@@ -252,7 +251,7 @@ public final class EditColorScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		double mouseX = context.x();
 		double mouseY = context.y();
@@ -285,14 +284,14 @@ public final class EditColorScreen extends Screen
 	
 	private void setColor(Color color)
 	{
-		hexValueField.setText(ColorUtils.toHex(color).substring(1));
-		redValueField.setText("" + color.getRed());
-		greenValueField.setText("" + color.getGreen());
-		blueValueField.setText("" + color.getBlue());
+		hexValueField.setValue(ColorUtils.toHex(color).substring(1));
+		redValueField.setValue("" + color.getRed());
+		greenValueField.setValue("" + color.getGreen());
+		blueValueField.setValue("" + color.getBlue());
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditEntityTypeListScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditEntityTypeListScreen.java
index 67b596c03..e4d6a69d7 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditEntityTypeListScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditEntityTypeListScreen.java
@@ -15,21 +15,20 @@ import java.util.Objects;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.registry.Registries;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget;
 import net.wurstclient.settings.EntityTypeListSetting;
 
@@ -39,20 +38,20 @@ public final class EditEntityTypeListScreen extends Screen
 	private final EntityTypeListSetting typeList;
 	
 	private ListGui listGui;
-	private TextFieldWidget typeNameField;
-	private ButtonWidget addKeywordButton;
-	private ButtonWidget addButton;
-	private ButtonWidget removeButton;
-	private ButtonWidget doneButton;
+	private EditBox typeNameField;
+	private Button addKeywordButton;
+	private Button addButton;
+	private Button removeButton;
+	private Button doneButton;
 	
-	private net.minecraft.entity.EntityType<?> typeToAdd;
-	private java.util.List<net.minecraft.entity.EntityType<?>> fuzzyMatches =
+	private net.minecraft.world.entity.EntityType<?> typeToAdd;
+	private java.util.List<net.minecraft.world.entity.EntityType<?>> fuzzyMatches =
 		java.util.Collections.emptyList();
 	
 	public EditEntityTypeListScreen(Screen prevScreen,
 		EntityTypeListSetting typeList)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.typeList = typeList;
 	}
@@ -60,8 +59,8 @@ public final class EditEntityTypeListScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, typeList.getTypeNames());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, typeList.getTypeNames());
+		addWidget(listGui);
 		
 		int rowY = height - 56;
 		int gap = 8;
@@ -73,18 +72,18 @@ public final class EditEntityTypeListScreen extends Screen
 			fieldWidth + keywordWidth + addWidth + removeWidth + gap * 3;
 		int rowStart = width / 2 - totalWidth / 2;
 		
-		typeNameField = new TextFieldWidget(client.textRenderer, rowStart, rowY,
-			fieldWidth, 20, Text.literal(""));
-		addSelectableChild(typeNameField);
+		typeNameField = new EditBox(minecraft.font, rowStart, rowY, fieldWidth,
+			20, Component.literal(""));
+		addWidget(typeNameField);
 		typeNameField.setMaxLength(256);
 		
 		int keywordX = rowStart + fieldWidth + gap;
 		int addX = keywordX + keywordWidth + gap;
 		int removeX = addX + addWidth + gap;
 		
-		addDrawableChild(addKeywordButton =
-			ButtonWidget.builder(Text.literal("Add Keyword"), b -> {
-				String raw = typeNameField.getText();
+		addRenderableWidget(addKeywordButton =
+			Button.builder(Component.literal("Add Keyword"), b -> {
+				String raw = typeNameField.getValue();
 				if(raw != null)
 					raw = raw.trim();
 				if(raw == null || raw.isEmpty())
@@ -97,10 +96,10 @@ public final class EditEntityTypeListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(keywordX, rowY, keywordWidth, 20).build());
+			}).bounds(keywordX, rowY, keywordWidth, 20).build());
 		
-		addDrawableChild(
-			addButton = ButtonWidget.builder(Text.literal("Add"), b -> {
+		addRenderableWidget(
+			addButton = Button.builder(Component.literal("Add"), b -> {
 				var prevState = listGui.captureState();
 				List<String> before = new ArrayList<>(typeList.getTypeNames());
 				
@@ -109,11 +108,11 @@ public final class EditEntityTypeListScreen extends Screen
 					typeList.add(typeToAdd);
 				}else if(fuzzyMatches != null && !fuzzyMatches.isEmpty())
 				{
-					for(net.minecraft.entity.EntityType<?> et : fuzzyMatches)
+					for(net.minecraft.world.entity.EntityType<?> et : fuzzyMatches)
 						typeList.add(et);
 				}else
 				{
-					String raw = typeNameField.getText();
+					String raw = typeNameField.getValue();
 					if(raw != null)
 						raw = raw.trim();
 					if(raw != null && !raw.isEmpty())
@@ -124,10 +123,10 @@ public final class EditEntityTypeListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(addX, rowY, addWidth, 20).build());
+			}).bounds(addX, rowY, addWidth, 20).build());
 		
-		addDrawableChild(removeButton =
-			ButtonWidget.builder(Text.literal("Remove Selected"), b -> {
+		addRenderableWidget(removeButton =
+			Button.builder(Component.literal("Remove Selected"), b -> {
 				List<String> selected = listGui.getSelectedTypeNames();
 				if(selected.isEmpty())
 					return;
@@ -142,39 +141,42 @@ public final class EditEntityTypeListScreen extends Screen
 				
 				refreshList(prevState, Collections.emptyList(),
 					prevState.scrollAmount());
-			}).dimensions(removeX, rowY, removeWidth, 20).build());
+			}).bounds(removeX, rowY, removeWidth, 20).build());
 		
 		listGui.setSelectionListener(this::updateButtons);
 		updateButtons();
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Reset to Defaults"),
-			b -> client.setScreen(new ConfirmScreen(b2 -> {
-				if(b2)
-					typeList.resetToDefaults();
-				client.setScreen(EditEntityTypeListScreen.this);
-			}, Text.literal("Reset to Defaults"),
-				Text.literal("Are you sure?"))))
-			.dimensions(width - 328, 8, 150, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Reset to Defaults"),
+				b -> minecraft.setScreen(new ConfirmScreen(b2 -> {
+					if(b2)
+						typeList.resetToDefaults();
+					minecraft.setScreen(EditEntityTypeListScreen.this);
+				}, Component.literal("Reset to Defaults"),
+					Component.literal("Are you sure?"))))
+				.bounds(width - 328, 8, 150, 20).build());
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Clear List"), b -> {
-			typeList.clear();
-			client.setScreen(EditEntityTypeListScreen.this);
-		}).dimensions(width - 168, 8, 150, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Clear List"), b -> {
+				typeList.clear();
+				minecraft.setScreen(EditEntityTypeListScreen.this);
+			}).bounds(width - 168, 8, 150, 20).build());
 		
-		addDrawableChild(doneButton = ButtonWidget
-			.builder(Text.literal("Done"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height - 28, 200, 20).build());
+		addRenderableWidget(doneButton = Button
+			.builder(Component.literal("Done"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height - 28, 200, 20).build());
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		typeNameField.mouseClicked(context, doubleClick);
 		return super.mouseClicked(context, doubleClick);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput keyInput)
+	public boolean keyPressed(KeyEvent keyInput)
 	{
 		int keyCode = keyInput.key();
 		switch(keyCode)
@@ -203,17 +205,19 @@ public final class EditEntityTypeListScreen extends Screen
 	@Override
 	public void tick()
 	{
-		String rawInput = typeNameField.getText();
+		String rawInput = typeNameField.getValue();
 		String nameOrId = rawInput == null ? "" : rawInput.toLowerCase();
 		String trimmed = rawInput == null ? "" : rawInput.trim();
 		boolean hasInput = !trimmed.isEmpty();
 		try
 		{
-			Identifier id = Identifier.of(nameOrId);
+			ResourceLocation id = ResourceLocation.parse(nameOrId);
 			typeToAdd =
-				net.minecraft.registry.Registries.ENTITY_TYPE.containsId(id)
-					? net.minecraft.registry.Registries.ENTITY_TYPE.get(id)
-					: null;
+				net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE
+					.containsKey(id)
+						? net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE
+							.getValue(id)
+						: null;
 		}catch(IllegalArgumentException e)
 		{
 			typeToAdd = null;
@@ -227,30 +231,32 @@ public final class EditEntityTypeListScreen extends Screen
 				fuzzyMatches = java.util.Collections.emptyList();
 			}else
 			{
-				java.util.ArrayList<net.minecraft.entity.EntityType<?>> list =
+				java.util.ArrayList<net.minecraft.world.entity.EntityType<?>> list =
 					new java.util.ArrayList<>();
-				for(Identifier id : Registries.ENTITY_TYPE.getIds())
+				for(ResourceLocation id : BuiltInRegistries.ENTITY_TYPE
+					.keySet())
 				{
 					String s = id.toString().toLowerCase(java.util.Locale.ROOT);
 					if(s.contains(q))
-						list.add(Registries.ENTITY_TYPE.get(id));
+						list.add(BuiltInRegistries.ENTITY_TYPE.getValue(id));
 				}
-				java.util.LinkedHashMap<String, net.minecraft.entity.EntityType<?>> map =
+				java.util.LinkedHashMap<String, net.minecraft.world.entity.EntityType<?>> map =
 					new java.util.LinkedHashMap<>();
-				for(net.minecraft.entity.EntityType<?> et : list)
-					map.put(Registries.ENTITY_TYPE.getId(et).toString(), et);
+				for(net.minecraft.world.entity.EntityType<?> et : list)
+					map.put(BuiltInRegistries.ENTITY_TYPE.getKey(et).toString(),
+						et);
 				fuzzyMatches = new java.util.ArrayList<>(map.values());
 				fuzzyMatches.sort(java.util.Comparator.comparing(
-					t -> Registries.ENTITY_TYPE.getId(t).toString()));
+					t -> BuiltInRegistries.ENTITY_TYPE.getKey(t).toString()));
 			}
 			addButton.active = !fuzzyMatches.isEmpty() || hasInput;
-			addButton.setMessage(Text.literal(fuzzyMatches.isEmpty() ? "Add"
-				: ("Add Matches (" + fuzzyMatches.size() + ")")));
+			addButton.setMessage(Component.literal(fuzzyMatches.isEmpty()
+				? "Add" : ("Add Matches (" + fuzzyMatches.size() + ")")));
 		}else
 		{
 			fuzzyMatches = java.util.Collections.emptyList();
 			addButton.active = true;
-			addButton.setMessage(Text.literal("Add"));
+			addButton.setMessage(Component.literal("Add"));
 		}
 		
 		addKeywordButton.active = hasInput;
@@ -258,41 +264,41 @@ public final class EditEntityTypeListScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
+		context.drawCenteredString(minecraft.font,
 			typeList.getName() + " (" + typeList.getTypeNames().size() + ")",
-			width / 2, 12, Colors.WHITE);
+			width / 2, 12, CommonColors.WHITE);
 		
 		matrixStack.pushMatrix();
 		
 		typeNameField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 			
 		// Draw placeholder + decorative left icon frame using ABSOLUTE
 		// coordinates
 		// derived from the actual TextFieldWidget position/size (no matrix
 		// translate).
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		int x0 = typeNameField.getX();
 		int y0 = typeNameField.getY();
 		int y1 = y0 + typeNameField.getHeight();
 		
-		if(typeNameField.getText().isEmpty() && !typeNameField.isFocused())
-			context.drawTextWithShadow(client.textRenderer, "entity type id",
-				x0 + 6, y0 + 6, Colors.GRAY);
+		if(typeNameField.getValue().isEmpty() && !typeNameField.isFocused())
+			context.drawString(minecraft.font, "entity type id", x0 + 6, y0 + 6,
+				CommonColors.GRAY);
 		
-		int border =
-			typeNameField.isFocused() ? Colors.WHITE : Colors.LIGHT_GRAY;
-		int black = Colors.BLACK;
+		int border = typeNameField.isFocused() ? CommonColors.WHITE
+			: CommonColors.LIGHT_GRAY;
+		int black = CommonColors.BLACK;
 		
 		context.fill(x0 - 16, y0, x0, y1, border);
 		context.fill(x0 - 15, y0 + 1, x0 - 1, y1 - 1, black);
@@ -301,7 +307,7 @@ public final class EditEntityTypeListScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -339,33 +345,35 @@ public final class EditEntityTypeListScreen extends Screen
 		}
 		
 		@Override
-		public net.minecraft.text.Text getNarration()
+		public net.minecraft.network.chat.Component getNarration()
 		{
-			return net.minecraft.text.Text.translatable("narrator.select",
-				"Entity " + typeName);
+			return net.minecraft.network.chat.Component
+				.translatable("narrator.select", "Entity " + typeName);
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			String display;
-			net.minecraft.util.Identifier id =
-				net.minecraft.util.Identifier.tryParse(typeName);
+			net.minecraft.resources.ResourceLocation id =
+				net.minecraft.resources.ResourceLocation.tryParse(typeName);
 			if(id != null
-				&& net.minecraft.registry.Registries.ENTITY_TYPE.containsId(id))
-				display = net.minecraft.registry.Registries.ENTITY_TYPE.get(id)
-					.getName().getString();
+				&& net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE
+					.containsKey(id))
+				display =
+					net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE
+						.getValue(id).getDescription().getString();
 			else
 				display = "\u00a7okeyword\u00a7r";
 			int x = getContentX();
 			int y = getContentY();
-			context.drawText(tr, display, x + 8, y,
+			context.drawString(tr, display, x + 8, y,
 				net.wurstclient.util.WurstColors.VERY_LIGHT_GRAY, false);
-			context.drawText(tr, typeName, x + 8, y + 10, Colors.LIGHT_GRAY,
-				false);
+			context.drawString(tr, typeName, x + 8, y + 10,
+				CommonColors.LIGHT_GRAY, false);
 		}
 		
 		@Override
@@ -378,8 +386,8 @@ public final class EditEntityTypeListScreen extends Screen
 	private final class ListGui
 		extends MultiSelectEntryListWidget<EditEntityTypeListScreen.Entry>
 	{
-		public ListGui(MinecraftClient minecraft,
-			EditEntityTypeListScreen screen, List<String> list)
+		public ListGui(Minecraft minecraft, EditEntityTypeListScreen screen,
+			List<String> list)
 		{
 			super(minecraft, screen.width, screen.height - 96, 36, 30);
 			reload(list);
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditItemListScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditItemListScreen.java
index 128f3d771..26fe1c239 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditItemListScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditItemListScreen.java
@@ -15,23 +15,22 @@ import java.util.Objects;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.CommonColors;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget;
 import net.wurstclient.settings.ItemListSetting;
 import net.wurstclient.util.ItemUtils;
@@ -44,19 +43,19 @@ public final class EditItemListScreen extends Screen
 	private final ItemListSetting itemList;
 	
 	private ListGui listGui;
-	private TextFieldWidget itemNameField;
-	private ButtonWidget addKeywordButton;
-	private ButtonWidget addButton;
-	private ButtonWidget removeButton;
-	private ButtonWidget doneButton;
+	private EditBox itemNameField;
+	private Button addKeywordButton;
+	private Button addButton;
+	private Button removeButton;
+	private Button doneButton;
 	
 	private Item itemToAdd;
-	private java.util.List<net.minecraft.item.Item> fuzzyMatches =
+	private java.util.List<net.minecraft.world.item.Item> fuzzyMatches =
 		java.util.Collections.emptyList();
 	
 	public EditItemListScreen(Screen prevScreen, ItemListSetting itemList)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.itemList = itemList;
 	}
@@ -64,8 +63,8 @@ public final class EditItemListScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, itemList.getItemNames());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, itemList.getItemNames());
+		addWidget(listGui);
 		
 		int rowY = height - 56;
 		int gap = 8;
@@ -77,18 +76,18 @@ public final class EditItemListScreen extends Screen
 			fieldWidth + keywordWidth + addWidth + removeWidth + gap * 3;
 		int rowStart = width / 2 - totalWidth / 2;
 		
-		itemNameField = new TextFieldWidget(client.textRenderer, rowStart, rowY,
-			fieldWidth, 20, Text.literal(""));
-		addSelectableChild(itemNameField);
+		itemNameField = new EditBox(minecraft.font, rowStart, rowY, fieldWidth,
+			20, Component.literal(""));
+		addWidget(itemNameField);
 		itemNameField.setMaxLength(256);
 		
 		int keywordX = rowStart + fieldWidth + gap;
 		int addX = keywordX + keywordWidth + gap;
 		int removeX = addX + addWidth + gap;
 		
-		addDrawableChild(addKeywordButton =
-			ButtonWidget.builder(Text.literal("Add Keyword"), b -> {
-				String raw = itemNameField.getText();
+		addRenderableWidget(addKeywordButton =
+			Button.builder(Component.literal("Add Keyword"), b -> {
+				String raw = itemNameField.getValue();
 				if(raw != null)
 					raw = raw.trim();
 				if(raw == null || raw.isEmpty())
@@ -101,10 +100,10 @@ public final class EditItemListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(keywordX, rowY, keywordWidth, 20).build());
+			}).bounds(keywordX, rowY, keywordWidth, 20).build());
 		
-		addDrawableChild(
-			addButton = ButtonWidget.builder(Text.literal("Add"), b -> {
+		addRenderableWidget(
+			addButton = Button.builder(Component.literal("Add"), b -> {
 				var prevState = listGui.captureState();
 				List<String> before = new ArrayList<>(itemList.getItemNames());
 				
@@ -113,11 +112,11 @@ public final class EditItemListScreen extends Screen
 					itemList.add(itemToAdd);
 				}else if(fuzzyMatches != null && !fuzzyMatches.isEmpty())
 				{
-					for(net.minecraft.item.Item it : fuzzyMatches)
+					for(net.minecraft.world.item.Item it : fuzzyMatches)
 						itemList.add(it);
 				}else
 				{
-					String raw = itemNameField.getText();
+					String raw = itemNameField.getValue();
 					if(raw != null)
 						raw = raw.trim();
 					if(raw != null && !raw.isEmpty())
@@ -128,10 +127,10 @@ public final class EditItemListScreen extends Screen
 				added.removeAll(before);
 				
 				refreshList(prevState, added, prevState.scrollAmount());
-			}).dimensions(addX, rowY, addWidth, 20).build());
+			}).bounds(addX, rowY, addWidth, 20).build());
 		
-		addDrawableChild(removeButton =
-			ButtonWidget.builder(Text.literal("Remove Selected"), b -> {
+		addRenderableWidget(removeButton =
+			Button.builder(Component.literal("Remove Selected"), b -> {
 				List<String> selected = listGui.getSelectedItemNames();
 				if(selected.isEmpty())
 					return;
@@ -146,39 +145,42 @@ public final class EditItemListScreen extends Screen
 				
 				refreshList(prevState, Collections.emptyList(),
 					prevState.scrollAmount());
-			}).dimensions(removeX, rowY, removeWidth, 20).build());
+			}).bounds(removeX, rowY, removeWidth, 20).build());
 		
 		listGui.setSelectionListener(this::updateButtons);
 		updateButtons();
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Reset to Defaults"),
-			b -> client.setScreen(new ConfirmScreen(b2 -> {
-				if(b2)
-					itemList.resetToDefaults();
-				client.setScreen(EditItemListScreen.this);
-			}, Text.literal("Reset to Defaults"),
-				Text.literal("Are you sure?"))))
-			.dimensions(width - 328, 8, 150, 20).build());
-		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Clear List"), b -> {
-			itemList.clear();
-			client.setScreen(EditItemListScreen.this);
-		}).dimensions(width - 168, 8, 150, 20).build());
-		
-		addDrawableChild(doneButton = ButtonWidget
-			.builder(Text.literal("Done"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height - 28, 200, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Reset to Defaults"),
+				b -> minecraft.setScreen(new ConfirmScreen(b2 -> {
+					if(b2)
+						itemList.resetToDefaults();
+					minecraft.setScreen(EditItemListScreen.this);
+				}, Component.literal("Reset to Defaults"),
+					Component.literal("Are you sure?"))))
+				.bounds(width - 328, 8, 150, 20).build());
+		
+		addRenderableWidget(
+			Button.builder(Component.literal("Clear List"), b -> {
+				itemList.clear();
+				minecraft.setScreen(EditItemListScreen.this);
+			}).bounds(width - 168, 8, 150, 20).build());
+		
+		addRenderableWidget(doneButton = Button
+			.builder(Component.literal("Done"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height - 28, 200, 20).build());
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		itemNameField.mouseClicked(context, doubleClick);
 		return super.mouseClicked(context, doubleClick);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -206,7 +208,7 @@ public final class EditItemListScreen extends Screen
 	@Override
 	public void tick()
 	{
-		String nameOrId = itemNameField.getText();
+		String nameOrId = itemNameField.getValue();
 		String trimmed = nameOrId == null ? "" : nameOrId.trim();
 		boolean hasInput = !trimmed.isEmpty();
 		itemToAdd = ItemUtils.getItemFromNameOrID(nameOrId);
@@ -219,35 +221,36 @@ public final class EditItemListScreen extends Screen
 				fuzzyMatches = java.util.Collections.emptyList();
 			}else
 			{
-				java.util.ArrayList<net.minecraft.item.Item> list =
+				java.util.ArrayList<net.minecraft.world.item.Item> list =
 					new java.util.ArrayList<>();
-				for(net.minecraft.util.Identifier id : net.minecraft.registry.Registries.ITEM
-					.getIds())
+				for(net.minecraft.resources.ResourceLocation id : net.minecraft.core.registries.BuiltInRegistries.ITEM
+					.keySet())
 				{
 					String s = id.toString().toLowerCase(java.util.Locale.ROOT);
 					if(s.contains(q))
 						list.add(
-							net.minecraft.registry.Registries.ITEM.get(id));
+							net.minecraft.core.registries.BuiltInRegistries.ITEM
+								.getValue(id));
 				}
 				// Deduplicate and sort by identifier
-				java.util.LinkedHashMap<String, net.minecraft.item.Item> map =
+				java.util.LinkedHashMap<String, net.minecraft.world.item.Item> map =
 					new java.util.LinkedHashMap<>();
-				for(net.minecraft.item.Item it : list)
-					map.put(net.minecraft.registry.Registries.ITEM.getId(it)
-						.toString(), it);
+				for(net.minecraft.world.item.Item it : list)
+					map.put(net.minecraft.core.registries.BuiltInRegistries.ITEM
+						.getKey(it).toString(), it);
 				fuzzyMatches = new java.util.ArrayList<>(map.values());
-				fuzzyMatches.sort(java.util.Comparator
-					.comparing(it -> net.minecraft.registry.Registries.ITEM
-						.getId(it).toString()));
+				fuzzyMatches.sort(java.util.Comparator.comparing(
+					it -> net.minecraft.core.registries.BuiltInRegistries.ITEM
+						.getKey(it).toString()));
 			}
 			addButton.active = !fuzzyMatches.isEmpty() || hasInput;
-			addButton.setMessage(Text.literal(fuzzyMatches.isEmpty() ? "Add"
-				: ("Add Matches (" + fuzzyMatches.size() + ")")));
+			addButton.setMessage(Component.literal(fuzzyMatches.isEmpty()
+				? "Add" : ("Add Matches (" + fuzzyMatches.size() + ")")));
 		}else
 		{
 			fuzzyMatches = java.util.Collections.emptyList();
 			addButton.active = true;
-			addButton.setMessage(Text.literal("Add"));
+			addButton.setMessage(Component.literal("Add"));
 		}
 		
 		addKeywordButton.active = hasInput;
@@ -255,38 +258,38 @@ public final class EditItemListScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
+		context.drawCenteredString(minecraft.font,
 			itemList.getName() + " (" + itemList.getItemNames().size() + ")",
-			width / 2, 12, Colors.WHITE);
+			width / 2, 12, CommonColors.WHITE);
 		
 		matrixStack.pushMatrix();
 		
 		itemNameField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		// Draw placeholder + decorative left icon frame anchored to the field
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		int x0 = itemNameField.getX();
 		int y0 = itemNameField.getY();
 		int y1 = y0 + itemNameField.getHeight();
 		
-		if(itemNameField.getText().isEmpty() && !itemNameField.isFocused())
-			context.drawTextWithShadow(client.textRenderer, "item name or ID",
-				x0 + 6, y0 + 6, Colors.GRAY);
+		if(itemNameField.getValue().isEmpty() && !itemNameField.isFocused())
+			context.drawString(minecraft.font, "item name or ID", x0 + 6,
+				y0 + 6, CommonColors.GRAY);
 		
-		int border =
-			itemNameField.isFocused() ? Colors.WHITE : Colors.LIGHT_GRAY;
-		int black = Colors.BLACK;
+		int border = itemNameField.isFocused() ? CommonColors.WHITE
+			: CommonColors.LIGHT_GRAY;
+		int black = CommonColors.BLACK;
 		int iconBoxLeft = x0 - 20;
 		
 		context.fill(iconBoxLeft, y0, x0, y1, border);
@@ -300,7 +303,7 @@ public final class EditItemListScreen extends Screen
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -338,45 +341,47 @@ public final class EditItemListScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			Item item = Registries.ITEM.get(Identifier.of(itemName));
+			Item item = BuiltInRegistries.ITEM
+				.getValue(ResourceLocation.parse(itemName));
 			ItemStack stack = new ItemStack(item);
 			
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"Item " + getDisplayName(stack) + ", " + itemName + ", "
 					+ getIdText(item));
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			Item item = Registries.ITEM.get(Identifier.of(itemName));
+			Item item = BuiltInRegistries.ITEM
+				.getValue(ResourceLocation.parse(itemName));
 			ItemStack stack = new ItemStack(item);
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			RenderUtils.drawItem(context, stack, x + 1, y + 1, true);
-			context.drawText(tr, getDisplayName(stack), x + 28, y,
+			context.drawString(tr, getDisplayName(stack), x + 28, y,
 				WurstColors.VERY_LIGHT_GRAY, false);
-			context.drawText(tr, itemName, x + 28, y + 9, Colors.LIGHT_GRAY,
-				false);
-			context.drawText(tr, getIdText(item), x + 28, y + 18,
-				Colors.LIGHT_GRAY, false);
+			context.drawString(tr, itemName, x + 28, y + 9,
+				CommonColors.LIGHT_GRAY, false);
+			context.drawString(tr, getIdText(item), x + 28, y + 18,
+				CommonColors.LIGHT_GRAY, false);
 		}
 		
 		private String getDisplayName(ItemStack stack)
 		{
 			return stack.isEmpty() ? "\u00a7ounknown item\u00a7r"
-				: stack.getName().getString();
+				: stack.getHoverName().getString();
 		}
 		
 		private String getIdText(Item item)
 		{
-			return "ID: " + Registries.ITEM.getRawId(item);
+			return "ID: " + BuiltInRegistries.ITEM.getId(item);
 		}
 		
 		@Override
@@ -389,7 +394,7 @@ public final class EditItemListScreen extends Screen
 	private final class ListGui
 		extends MultiSelectEntryListWidget<EditItemListScreen.Entry>
 	{
-		public ListGui(MinecraftClient minecraft, EditItemListScreen screen,
+		public ListGui(Minecraft minecraft, EditItemListScreen screen,
 			List<String> list)
 		{
 			super(minecraft, screen.width, screen.height - 96, 36, 30);
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditSliderScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditSliderScreen.java
index 9822cc06f..13f19493c 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditSliderScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditSliderScreen.java
@@ -8,16 +8,15 @@
 package net.wurstclient.clickgui.screens;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.settings.SliderSetting;
 import net.wurstclient.settings.SliderSetting.ValueDisplay;
 import net.wurstclient.util.MathUtils;
@@ -27,12 +26,12 @@ public final class EditSliderScreen extends Screen
 	private final Screen prevScreen;
 	private final SliderSetting slider;
 	
-	private TextFieldWidget valueField;
-	private ButtonWidget doneButton;
+	private EditBox valueField;
+	private Button doneButton;
 	
 	public EditSliderScreen(Screen prevScreen, SliderSetting slider)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.slider = slider;
 	}
@@ -44,35 +43,35 @@ public final class EditSliderScreen extends Screen
 		int y1 = 60;
 		int y2 = height / 3 * 2;
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		ValueDisplay vd = ValueDisplay.DECIMAL;
 		String valueString = vd.getValueString(slider.getValue());
 		
-		valueField = new TextFieldWidget(tr, x1, y1, 200, 20, Text.literal(""));
-		valueField.setText(valueString);
-		valueField.setSelectionStart(0);
+		valueField = new EditBox(tr, x1, y1, 200, 20, Component.literal(""));
+		valueField.setValue(valueString);
+		valueField.setCursorPosition(0);
 		
-		addSelectableChild(valueField);
+		addWidget(valueField);
 		setFocused(valueField);
 		valueField.setFocused(true);
 		
-		doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-			.dimensions(x1, y2, 200, 20).build();
-		addDrawableChild(doneButton);
+		doneButton = Button.builder(Component.literal("Done"), b -> done())
+			.bounds(x1, y2, 200, 20).build();
+		addRenderableWidget(doneButton);
 	}
 	
 	private void done()
 	{
-		String value = valueField.getText();
+		String value = valueField.getValue();
 		
 		if(MathUtils.isDouble(value))
 			slider.setValue(Double.parseDouble(value));
 		
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -81,7 +80,7 @@ public final class EditSliderScreen extends Screen
 			break;
 			
 			case GLFW.GLFW_KEY_ESCAPE:
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			break;
 		}
 		
@@ -89,20 +88,20 @@ public final class EditSliderScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			slider.getName(), width / 2, 20, Colors.WHITE);
+		context.drawCenteredString(minecraft.font, slider.getName(), width / 2,
+			20, CommonColors.WHITE);
 		
 		valueField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/EditTextFieldScreen.java b/src/main/java/net/wurstclient/clickgui/screens/EditTextFieldScreen.java
index f5bd95dae..3d866f8b2 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/EditTextFieldScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/EditTextFieldScreen.java
@@ -8,16 +8,15 @@
 package net.wurstclient.clickgui.screens;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.settings.TextFieldSetting;
 
 public final class EditTextFieldScreen extends Screen
@@ -25,12 +24,12 @@ public final class EditTextFieldScreen extends Screen
 	private final Screen prevScreen;
 	private final TextFieldSetting setting;
 	
-	private TextFieldWidget valueField;
-	private ButtonWidget doneButton;
+	private EditBox valueField;
+	private Button doneButton;
 	
 	public EditTextFieldScreen(Screen prevScreen, TextFieldSetting setting)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.setting = setting;
 	}
@@ -42,32 +41,32 @@ public final class EditTextFieldScreen extends Screen
 		int y1 = 60;
 		int y2 = height / 3 * 2;
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		
-		valueField = new TextFieldWidget(tr, x1, y1, 200, 20, Text.literal(""));
+		valueField = new EditBox(tr, x1, y1, 200, 20, Component.literal(""));
 		valueField.setMaxLength(Integer.MAX_VALUE);
-		valueField.setText(setting.getValue());
-		valueField.setSelectionStart(0);
+		valueField.setValue(setting.getValue());
+		valueField.setCursorPosition(0);
 		
-		addSelectableChild(valueField);
+		addWidget(valueField);
 		setFocused(valueField);
 		valueField.setFocused(true);
 		
-		doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-			.dimensions(x1, y2, 200, 20).build();
-		addDrawableChild(doneButton);
+		doneButton = Button.builder(Component.literal("Done"), b -> done())
+			.bounds(x1, y2, 200, 20).build();
+		addRenderableWidget(doneButton);
 	}
 	
 	private void done()
 	{
-		String value = valueField.getText();
+		String value = valueField.getValue();
 		setting.setValue(value);
 		
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -76,7 +75,7 @@ public final class EditTextFieldScreen extends Screen
 			break;
 			
 			case GLFW.GLFW_KEY_ESCAPE:
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			break;
 		}
 		
@@ -84,20 +83,20 @@ public final class EditTextFieldScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			setting.getName(), width / 2, 20, Colors.WHITE);
+		context.drawCenteredString(minecraft.font, setting.getName(), width / 2,
+			20, CommonColors.WHITE);
 		
 		valueField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/SelectFileScreen.java b/src/main/java/net/wurstclient/clickgui/screens/SelectFileScreen.java
index 391ac88fc..60c4d28a6 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/SelectFileScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/SelectFileScreen.java
@@ -13,19 +13,18 @@ import java.util.List;
 import java.util.Objects;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.ObjectSelectionList;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.settings.FileSetting;
 import net.wurstclient.util.WurstColors;
 
@@ -35,11 +34,11 @@ public final class SelectFileScreen extends Screen
 	private final FileSetting setting;
 	
 	private ListGui listGui;
-	private ButtonWidget doneButton;
+	private Button doneButton;
 	
 	public SelectFileScreen(Screen prevScreen, FileSetting blockList)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		setting = blockList;
 	}
@@ -47,35 +46,35 @@ public final class SelectFileScreen extends Screen
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this, setting.listFiles());
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this, setting.listFiles());
+		addWidget(listGui);
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Open Folder"), b -> openFolder())
-				.dimensions(8, 8, 100, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Open Folder"), b -> openFolder())
+				.bounds(8, 8, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Reset to Defaults"),
+		addRenderableWidget(Button
+			.builder(Component.literal("Reset to Defaults"),
 				b -> askToConfirmReset())
-			.dimensions(width - 108, 8, 100, 20).build());
+			.bounds(width - 108, 8, 100, 20).build());
 		
-		doneButton = addDrawableChild(
-			ButtonWidget.builder(Text.literal("Done"), b -> done())
-				.dimensions(width / 2 - 102, height - 48, 100, 20).build());
+		doneButton = addRenderableWidget(
+			Button.builder(Component.literal("Done"), b -> done())
+				.bounds(width / 2 - 102, height - 48, 100, 20).build());
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Cancel"), b -> openPrevScreen())
-				.dimensions(width / 2 + 2, height - 48, 100, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Cancel"), b -> openPrevScreen())
+				.bounds(width / 2 + 2, height - 48, 100, 20).build());
 	}
 	
 	private void openFolder()
 	{
-		Util.getOperatingSystem().open(setting.getFolder().toFile());
+		Util.getPlatform().openFile(setting.getFolder().toFile());
 	}
 	
 	private void openPrevScreen()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	private void done()
@@ -92,14 +91,15 @@ public final class SelectFileScreen extends Screen
 	
 	private void askToConfirmReset()
 	{
-		Text title = Text.literal("Reset Folder");
+		Component title = Component.literal("Reset Folder");
 		
-		Text message = Text
+		Component message = Component
 			.literal("This will empty the '" + setting.getFolder().getFileName()
 				+ "' folder and then re-generate the default files.\n"
 				+ "Are you sure you want to do this?");
 		
-		client.setScreen(new ConfirmScreen(this::confirmReset, title, message));
+		minecraft
+			.setScreen(new ConfirmScreen(this::confirmReset, title, message));
 	}
 	
 	private void confirmReset(boolean confirmed)
@@ -107,11 +107,11 @@ public final class SelectFileScreen extends Screen
 		if(confirmed)
 			setting.resetFolder();
 		
-		client.setScreen(SelectFileScreen.this);
+		minecraft.setScreen(SelectFileScreen.this);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ENTER)
 			done();
@@ -124,29 +124,30 @@ public final class SelectFileScreen extends Screen
 	@Override
 	public void tick()
 	{
-		doneButton.active = listGui.getSelectedOrNull() != null;
+		doneButton.active = listGui.getSelected() != null;
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			setting.getName(), width / 2, 12, Colors.WHITE);
+		context.drawCenteredString(minecraft.font, setting.getName(), width / 2,
+			12, CommonColors.WHITE);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
-		if(doneButton.isSelected() && !doneButton.active)
-			context.drawTooltip(textRenderer,
-				Arrays.asList(Text.literal("You must first select a file.")),
+		if(doneButton.isHoveredOrFocused() && !doneButton.active)
+			context.setComponentTooltipForNextFrame(font,
+				Arrays
+					.asList(Component.literal("You must first select a file.")),
 				mouseX, mouseY);
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
@@ -158,7 +159,7 @@ public final class SelectFileScreen extends Screen
 	}
 	
 	private final class Entry
-		extends AlwaysSelectedEntryListWidget.Entry<SelectFileScreen.Entry>
+		extends ObjectSelectionList.Entry<SelectFileScreen.Entry>
 	{
 		private final Path path;
 		
@@ -168,36 +169,36 @@ public final class SelectFileScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"File " + path.getFileName());
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			String fileName = "" + path.getFileName();
-			context.drawTextWithShadow(tr, fileName, x + 28, y,
+			context.drawString(tr, fileName, x + 28, y,
 				WurstColors.VERY_LIGHT_GRAY);
 			
-			String relPath = "" + client.runDirectory.toPath().relativize(path);
-			context.drawTextWithShadow(tr, relPath, x + 28, y + 9,
-				Colors.LIGHT_GRAY);
+			String relPath =
+				"" + minecraft.gameDirectory.toPath().relativize(path);
+			context.drawString(tr, relPath, x + 28, y + 9,
+				CommonColors.LIGHT_GRAY);
 		}
 	}
 	
 	private final class ListGui
-		extends AlwaysSelectedEntryListWidget<SelectFileScreen.Entry>
+		extends ObjectSelectionList<SelectFileScreen.Entry>
 	{
-		public ListGui(MinecraftClient mc, SelectFileScreen screen,
-			List<Path> list)
+		public ListGui(Minecraft mc, SelectFileScreen screen, List<Path> list)
 		{
 			super(mc, screen.width, screen.height - 96, 36, 20);
 			
@@ -207,7 +208,7 @@ public final class SelectFileScreen extends Screen
 		
 		public Path getSelectedPath()
 		{
-			SelectFileScreen.Entry selected = getSelectedOrNull();
+			SelectFileScreen.Entry selected = getSelected();
 			return selected != null ? selected.path : null;
 		}
 	}
diff --git a/src/main/java/net/wurstclient/clickgui/screens/WaypointEditScreen.java b/src/main/java/net/wurstclient/clickgui/screens/WaypointEditScreen.java
index 797d3dfd3..c4f546d28 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/WaypointEditScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/WaypointEditScreen.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.clickgui.screens;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.waypoints.Waypoint;
 import net.wurstclient.waypoints.WaypointDimension;
@@ -41,11 +41,11 @@ public final class WaypointEditScreen extends Screen
 	private boolean compactMode = false; // when true, show only name +
 											// Save/Cancel
 	
-	private TextFieldWidget nameField;
-	private TextFieldWidget xField;
-	private TextFieldWidget yField;
-	private TextFieldWidget zField;
-	private ButtonWidget colorButton;
+	private EditBox nameField;
+	private EditBox xField;
+	private EditBox yField;
+	private EditBox zField;
+	private Button colorButton;
 	private ColorSetting colorSetting;
 	private int alphaPercent = 100; // 1..100 persisted across picker
 	// Draft values to preserve user input across color picker navigation
@@ -55,7 +55,7 @@ public final class WaypointEditScreen extends Screen
 	private String draftZ;
 	
 	private int dimIndex;
-	private ButtonWidget dimButton;
+	private Button dimButton;
 	// Draft storage for dimension selection when navigating to child screens
 	private Integer draftDimIndex;
 	
@@ -70,17 +70,17 @@ public final class WaypointEditScreen extends Screen
 			ICONS[i] = iconChar(ICON_KEYS[i]) + " " + ICON_KEYS[i];
 	}
 	private int iconIndex;
-	private ButtonWidget iconButton;
+	private Button iconButton;
 	
-	private ButtonWidget oppositeButton;
-	private ButtonWidget visibleButton;
-	private ButtonWidget linesButton;
-	private ButtonWidget beaconButton;
+	private Button oppositeButton;
+	private Button visibleButton;
+	private Button linesButton;
+	private Button beaconButton;
 	
 	public WaypointEditScreen(Screen prev, WaypointsManager manager,
 		Waypoint waypoint, boolean isNew)
 	{
-		super(Text.literal("Edit Waypoint"));
+		super(Component.literal("Edit Waypoint"));
 		this.prev = prev;
 		this.manager = manager;
 		this.listScreen =
@@ -104,11 +104,11 @@ public final class WaypointEditScreen extends Screen
 		
 		// Name (always present)
 		yName = y;
-		nameField = new TextFieldWidget(client.textRenderer, x, y, cw, 20,
-			Text.literal(""));
+		nameField =
+			new EditBox(minecraft.font, x, y, cw, 20, Component.literal(""));
 		String baseName = waypoint.getName() == null ? "" : waypoint.getName();
-		nameField.setText(draftName != null ? draftName : baseName);
-		addDrawableChild(nameField);
+		nameField.setValue(draftName != null ? draftName : baseName);
+		addRenderableWidget(nameField);
 		setFocused(nameField);
 		// increased gap to avoid XYZ labels overlapping name field
 		y += 44;
@@ -123,21 +123,21 @@ public final class WaypointEditScreen extends Screen
 			xXYZ1 = x;
 			xXYZ2 = x + colW + gap;
 			xXYZ3 = x + (colW + gap) * 2;
-			xField = new TextFieldWidget(client.textRenderer, xXYZ1, y, colW,
-				20, Text.literal(""));
+			xField = new EditBox(minecraft.font, xXYZ1, y, colW, 20,
+				Component.literal(""));
 			xField
-				.setText(draftX != null ? draftX : Integer.toString(p.getX()));
-			addDrawableChild(xField);
-			yField = new TextFieldWidget(client.textRenderer, xXYZ2,
-				narrow ? y + 28 : y, colW, 20, Text.literal(""));
+				.setValue(draftX != null ? draftX : Integer.toString(p.getX()));
+			addRenderableWidget(xField);
+			yField = new EditBox(minecraft.font, xXYZ2, narrow ? y + 28 : y,
+				colW, 20, Component.literal(""));
 			yField
-				.setText(draftY != null ? draftY : Integer.toString(p.getY()));
-			addDrawableChild(yField);
-			zField = new TextFieldWidget(client.textRenderer, xXYZ3,
-				narrow ? y + 56 : y, colW, 20, Text.literal(""));
+				.setValue(draftY != null ? draftY : Integer.toString(p.getY()));
+			addRenderableWidget(yField);
+			zField = new EditBox(minecraft.font, xXYZ3, narrow ? y + 56 : y,
+				colW, 20, Component.literal(""));
 			zField
-				.setText(draftZ != null ? draftZ : Integer.toString(p.getZ()));
-			addDrawableChild(zField);
+				.setValue(draftZ != null ? draftZ : Integer.toString(p.getZ()));
+			addRenderableWidget(zField);
 			// Track individual field Y for labels
 			yYField = narrow ? y + 28 : y;
 			yZField = narrow ? y + 56 : y;
@@ -159,63 +159,62 @@ public final class WaypointEditScreen extends Screen
 				dimIndex = draftDimIndex;
 				draftDimIndex = null;
 			}
-			dimButton = ButtonWidget
-				.builder(Text.literal("Dimension: " + dims[dimIndex].name()),
-					b -> {
-						dimIndex = (dimIndex + 1) % dims.length;
-						b.setMessage(Text
-							.literal("Dimension: " + dims[dimIndex].name()));
-					})
-				.dimensions(x, y, cw, 20).build();
-			addDrawableChild(dimButton);
+			dimButton = Button.builder(
+				Component.literal("Dimension: " + dims[dimIndex].name()), b -> {
+					dimIndex = (dimIndex + 1) % dims.length;
+					b.setMessage(Component
+						.literal("Dimension: " + dims[dimIndex].name()));
+				}).bounds(x, y, cw, 20).build();
+			addRenderableWidget(dimButton);
 			y += 28;
 			
 			// Opposite / Visible toggles + Lines
 			yToggles = y;
 			int halfGap = 10;
 			int halfW = (cw - halfGap) / 2;
-			oppositeButton = ButtonWidget.builder(
-				Text.literal(buttonLabel("Opposite", waypoint.isOpposite())),
-				b -> {
-					waypoint.setOpposite(!waypoint.isOpposite());
-					b.setMessage(Text.literal(
-						buttonLabel("Opposite", waypoint.isOpposite())));
-				}).dimensions(x, y, halfW, 20).build();
-			addDrawableChild(oppositeButton);
+			oppositeButton =
+				Button
+					.builder(
+						Component.literal(
+							buttonLabel("Opposite", waypoint.isOpposite())),
+						b -> {
+							waypoint.setOpposite(!waypoint.isOpposite());
+							b.setMessage(Component.literal(buttonLabel(
+								"Opposite", waypoint.isOpposite())));
+						})
+					.bounds(x, y, halfW, 20).build();
+			addRenderableWidget(oppositeButton);
 			
-			visibleButton = ButtonWidget.builder(
-				Text.literal(buttonLabel("Visible", waypoint.isVisible())),
+			visibleButton = Button.builder(
+				Component.literal(buttonLabel("Visible", waypoint.isVisible())),
 				b -> {
 					waypoint.setVisible(!waypoint.isVisible());
-					b.setMessage(Text
+					b.setMessage(Component
 						.literal(buttonLabel("Visible", waypoint.isVisible())));
-				}).dimensions(x + halfW + halfGap, y, halfW, 20).build();
-			addDrawableChild(visibleButton);
+				}).bounds(x + halfW + halfGap, y, halfW, 20).build();
+			addRenderableWidget(visibleButton);
 			y += 28;
 			
 			// Reserve space for opposite preview text, then Lines/Beacon row
 			y += 16;
 			int toggleWidth = (cw - halfGap) / 2;
-			linesButton = ButtonWidget
-				.builder(Text.literal(buttonLabel("Lines", waypoint.isLines())),
-					b -> {
-						waypoint.setLines(!waypoint.isLines());
-						b.setMessage(Text
-							.literal(buttonLabel("Lines", waypoint.isLines())));
-					})
-				.dimensions(x, y, toggleWidth, 20).build();
-			addDrawableChild(linesButton);
-			beaconButton = ButtonWidget
-				.builder(Text.literal(beaconLabel(waypoint.getBeaconMode())),
-					b -> {
-						Waypoint.BeaconMode next =
-							nextBeaconMode(waypoint.getBeaconMode());
-						waypoint.setBeaconMode(next);
-						b.setMessage(Text.literal(beaconLabel(next)));
-					})
-				.dimensions(x + toggleWidth + halfGap, y, toggleWidth, 20)
+			linesButton = Button.builder(
+				Component.literal(buttonLabel("Lines", waypoint.isLines())),
+				b -> {
+					waypoint.setLines(!waypoint.isLines());
+					b.setMessage(Component
+						.literal(buttonLabel("Lines", waypoint.isLines())));
+				}).bounds(x, y, toggleWidth, 20).build();
+			addRenderableWidget(linesButton);
+			beaconButton = Button.builder(
+				Component.literal(beaconLabel(waypoint.getBeaconMode())), b -> {
+					Waypoint.BeaconMode next =
+						nextBeaconMode(waypoint.getBeaconMode());
+					waypoint.setBeaconMode(next);
+					b.setMessage(Component.literal(beaconLabel(next)));
+				}).bounds(x + toggleWidth + halfGap, y, toggleWidth, 20)
 				.build();
-			addDrawableChild(beaconButton);
+			addRenderableWidget(beaconButton);
 			y += 28;
 			
 			// Icon selector
@@ -227,12 +226,13 @@ public final class WaypointEditScreen extends Screen
 					iconIndex = i;
 					break;
 				}
-			iconButton = ButtonWidget
-				.builder(Text.literal("Icon: " + ICONS[iconIndex]), b -> {
+			iconButton = Button
+				.builder(Component.literal("Icon: " + ICONS[iconIndex]), b -> {
 					iconIndex = (iconIndex + 1) % ICONS.length;
-					b.setMessage(Text.literal("Icon: " + ICONS[iconIndex]));
-				}).dimensions(x, y, cw, 20).build();
-			addDrawableChild(iconButton);
+					b.setMessage(
+						Component.literal("Icon: " + ICONS[iconIndex]));
+				}).bounds(x, y, cw, 20).build();
+			addRenderableWidget(iconButton);
 			y += 28;
 			// extra spacing before color row
 			y += 8;
@@ -250,77 +250,80 @@ public final class WaypointEditScreen extends Screen
 					alphaPercent = Math.max(1,
 						Math.min(100, (int)Math.round(a / 255.0 * 100)));
 			}
-			colorButton = ButtonWidget.builder(
-				Text.literal(
+			colorButton = Button.builder(
+				Component.literal(
 					"Pick color (#" + toHex6(colorSetting.getColorI()) + ")"),
 				b -> {
-					draftName = nameField.getText();
-					draftX = xField.getText();
-					draftY = yField.getText();
-					draftZ = zField.getText();
+					draftName = nameField.getValue();
+					draftX = xField.getValue();
+					draftY = yField.getValue();
+					draftZ = zField.getValue();
 					// Preserve selected dimension index so it isn't lost when
 					// the child color screen re-initializes this screen.
 					draftDimIndex = dimIndex;
-					client.setScreen(new EditColorScreen(this, colorSetting));
-				}).dimensions(x, y, cw - 24, 20).build();
-			addDrawableChild(colorButton);
+					minecraft
+						.setScreen(new EditColorScreen(this, colorSetting));
+				}).bounds(x, y, cw - 24, 20).build();
+			addRenderableWidget(colorButton);
 			y += 28;
-			addDrawableChild(new net.minecraft.client.gui.widget.SliderWidget(x,
-				y, fieldsWidth, 20,
-				Text.literal("Transparency: " + alphaPercent + "%"),
-				(alphaPercent - 1) / 99.0)
-			{
-				@Override
-				protected void updateMessage()
+			addRenderableWidget(
+				new net.minecraft.client.gui.components.AbstractSliderButton(x,
+					y, fieldsWidth, 20,
+					Component.literal("Transparency: " + alphaPercent + "%"),
+					(alphaPercent - 1) / 99.0)
 				{
-					int val = 1 + (int)Math.round(value * 99.0);
-					alphaPercent = Math.max(1, Math.min(100, val));
-					setMessage(
-						Text.literal("Transparency: " + alphaPercent + "%"));
-				}
-				
-				@Override
-				protected void applyValue()
-				{
-					int val = 1 + (int)Math.round(value * 99.0);
-					alphaPercent = Math.max(1, Math.min(100, val));
-				}
-			});
+					@Override
+					protected void updateMessage()
+					{
+						int val = 1 + (int)Math.round(value * 99.0);
+						alphaPercent = Math.max(1, Math.min(100, val));
+						setMessage(Component
+							.literal("Transparency: " + alphaPercent + "%"));
+					}
+					
+					@Override
+					protected void applyValue()
+					{
+						int val = 1 + (int)Math.round(value * 99.0);
+						alphaPercent = Math.max(1, Math.min(100, val));
+					}
+				});
 			y += 28;
 			
 			// Use player pos & delete buttons
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Use player pos"), b -> usePlayerPos())
-				.dimensions(x, y, halfW, 20).build());
-			addDrawableChild(
-				ButtonWidget.builder(Text.literal("Delete"), b -> doDelete())
-					.dimensions(x + halfW + halfGap, y, halfW, 20).build());
+			addRenderableWidget(
+				Button.builder(Component.literal("Use player pos"),
+					b -> usePlayerPos()).bounds(x, y, halfW, 20).build());
+			addRenderableWidget(
+				Button.builder(Component.literal("Delete"), b -> doDelete())
+					.bounds(x + halfW + halfGap, y, halfW, 20).build());
 			y += 28;
 		}
 		
 		// Always add Save/Cancel anchored at bottom
 		int halfGap = 10;
 		int halfW = (fieldsWidth - halfGap) / 2;
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Save"), b -> saveAndBack())
-				.dimensions(fieldsBaseX, height - 52, halfW, 20).build());
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prev))
-			.dimensions(fieldsBaseX + halfW + halfGap, height - 52, halfW, 20)
+		addRenderableWidget(
+			Button.builder(Component.literal("Save"), b -> saveAndBack())
+				.bounds(fieldsBaseX, height - 52, halfW, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prev))
+			.bounds(fieldsBaseX + halfW + halfGap, height - 52, halfW, 20)
 			.build());
 	}
 	
 	@Override
-	public void resize(net.minecraft.client.MinecraftClient client, int width,
+	public void resize(net.minecraft.client.Minecraft client, int width,
 		int height)
 	{
 		// Preserve current edits before re-initializing layout for new size
 		if(nameField != null)
 		{
-			draftName = nameField.getText();
-			draftX = xField.getText();
-			draftY = yField.getText();
-			draftZ = zField.getText();
+			draftName = nameField.getValue();
+			draftX = xField.getValue();
+			draftY = yField.getValue();
+			draftZ = zField.getValue();
 			// Preserve dimension selection across resize/child screens
 			draftDimIndex = dimIndex;
 		}
@@ -359,13 +362,13 @@ public final class WaypointEditScreen extends Screen
 	
 	private void usePlayerPos()
 	{
-		if(client.player == null)
+		if(minecraft.player == null)
 			return;
-		BlockPos p = BlockPos.ofFloored(client.player.getX(),
-			client.player.getY(), client.player.getZ());
-		xField.setText(Integer.toString(p.getX()));
-		yField.setText(Integer.toString(p.getY()));
-		zField.setText(Integer.toString(p.getZ()));
+		BlockPos p = BlockPos.containing(minecraft.player.getX(),
+			minecraft.player.getY(), minecraft.player.getZ());
+		xField.setValue(Integer.toString(p.getX()));
+		yField.setValue(Integer.toString(p.getY()));
+		zField.setValue(Integer.toString(p.getZ()));
 	}
 	
 	private void doDelete()
@@ -373,22 +376,22 @@ public final class WaypointEditScreen extends Screen
 		manager.remove(waypoint);
 		if(listScreen != null)
 			listScreen.saveNow();
-		client.setScreen(prev);
+		minecraft.setScreen(prev);
 	}
 	
 	private void saveAndBack()
 	{
 		// Name
-		waypoint.setName(nameField.getText());
+		waypoint.setName(nameField.getValue());
 		
 		// Position
 		if(xField != null && yField != null && zField != null)
 		{
 			try
 			{
-				int x = Integer.parseInt(xField.getText());
-				int y = Integer.parseInt(yField.getText());
-				int z = Integer.parseInt(zField.getText());
+				int x = Integer.parseInt(xField.getValue());
+				int y = Integer.parseInt(yField.getValue());
+				int z = Integer.parseInt(zField.getValue());
 				waypoint.setPos(new BlockPos(x, y, z));
 			}catch(Exception ignored)
 			{}
@@ -408,7 +411,7 @@ public final class WaypointEditScreen extends Screen
 		manager.addOrUpdate(waypoint);
 		if(listScreen != null)
 			listScreen.saveNow();
-		client.setScreen(prev);
+		minecraft.setScreen(prev);
 	}
 	
 	private String toHex6(int argb)
@@ -458,28 +461,28 @@ public final class WaypointEditScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY, float delta)
+	public void render(GuiGraphics context, int mouseX, int mouseY, float delta)
 	{
 		context.fill(0, 0, this.width, this.height, 0x88000000);
 		super.render(context, mouseX, mouseY, delta);
 		
 		// Update color button label in case it changed in child screen
 		if(colorButton != null && colorSetting != null)
-			colorButton.setMessage(Text.literal(
+			colorButton.setMessage(Component.literal(
 				"Pick color (#" + toHex6(colorSetting.getColorI()) + ")"));
 		
 		// Labels
 		int x = fieldsBaseX;
-		context.drawText(client.textRenderer, "Name", x, yName - 18,
-			Colors.LIGHT_GRAY, false);
+		context.drawString(minecraft.font, "Name", x, yName - 18,
+			CommonColors.LIGHT_GRAY, false);
 		if(xField != null)
 		{
-			context.drawText(client.textRenderer, "X", xXYZ1, yXYZ - 18,
-				Colors.LIGHT_GRAY, false);
-			context.drawText(client.textRenderer, "Y", xXYZ2,
-				(narrow ? yYField : yXYZ) - 18, Colors.LIGHT_GRAY, false);
-			context.drawText(client.textRenderer, "Z", xXYZ3,
-				(narrow ? yZField : yXYZ) - 18, Colors.LIGHT_GRAY, false);
+			context.drawString(minecraft.font, "X", xXYZ1, yXYZ - 18,
+				CommonColors.LIGHT_GRAY, false);
+			context.drawString(minecraft.font, "Y", xXYZ2,
+				(narrow ? yYField : yXYZ) - 18, CommonColors.LIGHT_GRAY, false);
+			context.drawString(minecraft.font, "Z", xXYZ3,
+				(narrow ? yZField : yXYZ) - 18, CommonColors.LIGHT_GRAY, false);
 		}
 		// removed explicit "Color" text label to avoid redundancy and crowding
 		
@@ -489,13 +492,14 @@ public final class WaypointEditScreen extends Screen
 		int alpha = (int)Math
 			.round(Math.max(1, Math.min(100, alphaPercent)) / 100.0 * 255);
 		int color = colorSetting.getColorI(alpha);
-		context.fill(boxX - 1, boxY - 1, boxX + 18, boxY + 18, Colors.GRAY);
+		context.fill(boxX - 1, boxY - 1, boxX + 18, boxY + 18,
+			CommonColors.GRAY);
 		context.fill(boxX, boxY, boxX + 16, boxY + 16, color);
 		
 		// Opposite preview text  render below the toggles and lines rows
 		String opp = oppositePreview();
 		if(!opp.isEmpty())
-			context.drawText(client.textRenderer, opp, fieldsBaseX,
+			context.drawString(minecraft.font, opp, fieldsBaseX,
 				/* directly below the opposite/visible row */
 				yToggles + 28 + 8, 0xFFCCCCCC, false);
 	}
@@ -509,9 +513,9 @@ public final class WaypointEditScreen extends Screen
 			return "Opposite has no effect in the End";
 		try
 		{
-			int x = Integer.parseInt(xField.getText());
-			int z = Integer.parseInt(zField.getText());
-			int y = Integer.parseInt(yField.getText());
+			int x = Integer.parseInt(xField.getValue());
+			int z = Integer.parseInt(zField.getValue());
+			int y = Integer.parseInt(yField.getValue());
 			int ox = x;
 			int oz = z;
 			WaypointDimension td;
diff --git a/src/main/java/net/wurstclient/clickgui/screens/WaypointsScreen.java b/src/main/java/net/wurstclient/clickgui/screens/WaypointsScreen.java
index 85fdd31f8..11ed8cafc 100644
--- a/src/main/java/net/wurstclient/clickgui/screens/WaypointsScreen.java
+++ b/src/main/java/net/wurstclient/clickgui/screens/WaypointsScreen.java
@@ -10,12 +10,11 @@ package net.wurstclient.clickgui.screens;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Map;
-
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.waypoints.Waypoint;
 import net.wurstclient.waypoints.WaypointsManager;
 import net.wurstclient.waypoints.WaypointDimension;
@@ -52,10 +51,10 @@ public final class WaypointsScreen extends Screen
 	private static final class RowWidgets
 	{
 		Waypoint w;
-		ButtonWidget nameBtn;
-		ButtonWidget visBtn;
-		ButtonWidget delBtn;
-		ButtonWidget copyBtn;
+		Button nameBtn;
+		Button visBtn;
+		Button delBtn;
+		Button copyBtn;
 	}
 	
 	private final ArrayList<RowWidgets> rows = new ArrayList<>();
@@ -77,7 +76,7 @@ public final class WaypointsScreen extends Screen
 	
 	public WaypointsScreen(Screen prev, WaypointsManager manager)
 	{
-		super(Text.literal("Waypoints"));
+		super(Component.literal("Waypoints"));
 		this.prev = prev;
 		this.manager = manager;
 	}
@@ -104,64 +103,63 @@ public final class WaypointsScreen extends Screen
 		int fx = this.width / 2 - totalWidth / 2;
 		int fy = y; // top row for filters
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal(
+		addRenderableWidget(Button.builder(Component.literal(
 			(filterDim == net.wurstclient.waypoints.WaypointDimension.OVERWORLD)
 				? "[OW]" : "OW"),
 			b -> {
 				filterDim =
 					net.wurstclient.waypoints.WaypointDimension.OVERWORLD;
-				client.setScreen(this);
-			}).dimensions(fx, fy, filterBtnWidth, 20).build());
-		addDrawableChild(ButtonWidget.builder(Text.literal(
+				minecraft.setScreen(this);
+			}).bounds(fx, fy, filterBtnWidth, 20).build());
+		addRenderableWidget(Button.builder(Component.literal(
 			(filterDim == net.wurstclient.waypoints.WaypointDimension.NETHER)
 				? "[Nether]" : "Nether"),
 			b -> {
 				filterDim = net.wurstclient.waypoints.WaypointDimension.NETHER;
-				client.setScreen(this);
-			}).dimensions(fx + filterBtnWidth + spacing, fy, filterBtnWidth, 20)
+				minecraft.setScreen(this);
+			}).bounds(fx + filterBtnWidth + spacing, fy, filterBtnWidth, 20)
 			.build());
-		addDrawableChild(ButtonWidget.builder(Text.literal(
+		addRenderableWidget(Button.builder(Component.literal(
 			(filterDim == net.wurstclient.waypoints.WaypointDimension.END)
 				? "[End]" : "End"),
 			b -> {
 				filterDim = net.wurstclient.waypoints.WaypointDimension.END;
-				client.setScreen(this);
-			}).dimensions(fx + (filterBtnWidth + spacing) * 2, fy,
-				filterBtnWidth, 20)
+				minecraft.setScreen(this);
+			})
+			.bounds(fx + (filterBtnWidth + spacing) * 2, fy, filterBtnWidth, 20)
 			.build());
 		
 		// Move create button below the filters
 		int createY = y + 24; // 20 height + 4px gap
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Create waypoint"), b -> {
+		addRenderableWidget(
+			Button.builder(Component.literal("Create waypoint"), b -> {
 				Waypoint w = new Waypoint(java.util.UUID.randomUUID(),
 					System.currentTimeMillis());
 				w.setName("New Waypoint");
-				if(client.player != null)
-					w.setPos(BlockPos.ofFloored(client.player.getX(),
-						client.player.getY(), client.player.getZ()));
+				if(minecraft.player != null)
+					w.setPos(BlockPos.containing(minecraft.player.getX(),
+						minecraft.player.getY(), minecraft.player.getZ()));
 				else
-					w.setPos(BlockPos.ORIGIN);
+					w.setPos(BlockPos.ZERO);
 				w.setDimension(currentDim());
 				w.setMaxVisible(5000);
 				w.setLines(false); // default new waypoints without lines
-				client
+				minecraft
 					.setScreen(new WaypointEditScreen(this, manager, w, true));
-			}).dimensions(x, createY, 300, 20).build());
+			}).bounds(x, createY, 300, 20).build());
 		
 		// Xaero integration buttons sit right below the create button
 		int toolsY = createY + 24;
 		int toolGap = 10;
 		int toolWidth = (300 - toolGap) / 2;
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Import Xaero"), b -> {
+		addRenderableWidget(
+			Button.builder(Component.literal("Import Xaero"), b -> {
 				importFromXaero();
-			}).dimensions(x, toolsY, toolWidth, 20).build());
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Export Xaero"), b -> {
+			}).bounds(x, toolsY, toolWidth, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Export Xaero"), b -> {
 				exportToXaero();
-			}).dimensions(x + toolWidth + toolGap, toolsY, toolWidth, 20)
-				.build());
+			}).bounds(x + toolWidth + toolGap, toolsY, toolWidth, 20).build());
 		
 		// Advance y to start the list below the Xaero buttons (keep previous
 		// gap)
@@ -196,35 +194,37 @@ public final class WaypointsScreen extends Screen
 			Waypoint w = cachedList.get(i);
 			int rowY = y + i * ROW_HEIGHT;
 			
-			ButtonWidget nameBtn = addDrawableChild(
-				ButtonWidget.builder(Text.literal(w.getName()), b -> {
-					client.setScreen(
+			Button nameBtn = addRenderableWidget(
+				Button.builder(Component.literal(w.getName()), b -> {
+					minecraft.setScreen(
 						new WaypointEditScreen(this, manager, w, false));
-				}).dimensions(x, rowY, 140, 20).build());
+				}).bounds(x, rowY, 140, 20).build());
 			
-			ButtonWidget visBtn = addDrawableChild(ButtonWidget
-				.builder(Text.literal(w.isVisible() ? "Hide" : "Show"), b -> {
-					w.setVisible(!w.isVisible());
-					manager.addOrUpdate(w);
-					saveNow();
-					// Refresh in-place without stacking a new screen
-					client.setScreen(this);
-				}).dimensions(x + 145, rowY, 55, 20).build());
+			Button visBtn = addRenderableWidget(Button
+				.builder(Component.literal(w.isVisible() ? "Hide" : "Show"),
+					b -> {
+						w.setVisible(!w.isVisible());
+						manager.addOrUpdate(w);
+						saveNow();
+						// Refresh in-place without stacking a new screen
+						minecraft.setScreen(this);
+					})
+				.bounds(x + 145, rowY, 55, 20).build());
 			
-			ButtonWidget delBtn = addDrawableChild(
-				ButtonWidget.builder(Text.literal("Delete"), b -> {
+			Button delBtn = addRenderableWidget(
+				Button.builder(Component.literal("Delete"), b -> {
 					manager.remove(w);
 					saveNow();
 					// Refresh in-place without stacking a new screen
-					client.setScreen(this);
-				}).dimensions(x + 205, rowY, 55, 20).build());
+					minecraft.setScreen(this);
+				}).bounds(x + 205, rowY, 55, 20).build());
 			
-			ButtonWidget copyBtn = addDrawableChild(
-				ButtonWidget.builder(Text.literal("Copy"), b -> {
+			Button copyBtn = addRenderableWidget(
+				Button.builder(Component.literal("Copy"), b -> {
 					String s = w.getPos().getX() + ", " + w.getPos().getY()
 						+ ", " + w.getPos().getZ();
-					client.keyboard.setClipboard(s);
-				}).dimensions(x + 265, rowY, 35, 20).build());
+					minecraft.keyboardHandler.setClipboard(s);
+				}).bounds(x + 265, rowY, 35, 20).build());
 			
 			RowWidgets rw = new RowWidgets();
 			rw.w = w;
@@ -247,26 +247,25 @@ public final class WaypointsScreen extends Screen
 		// area
 		int arrowX = x + 305; // a little to the right of the list
 		// "Top" button above the up-arrow that jumps directly to the top
-		addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+		addRenderableWidget(Button.builder(Component.literal(""), b -> {
 			scrollToTop();
-		}).dimensions(arrowX + 20, Math.max(0, viewportTop - 20), 20, 20)
-			.build());
+		}).bounds(arrowX + 20, Math.max(0, viewportTop - 20), 20, 20).build());
 		// Up arrow (move up by a few rows)
-		addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+		addRenderableWidget(Button.builder(Component.literal(""), b -> {
 			scrollBy(-ROW_HEIGHT * 3);
-		}).dimensions(arrowX + 20, viewportTop, 20, 20).build());
+		}).bounds(arrowX + 20, viewportTop, 20, 20).build());
 		// Down arrow (move down by a few rows)
-		addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+		addRenderableWidget(Button.builder(Component.literal(""), b -> {
 			scrollBy(ROW_HEIGHT * 3);
-		}).dimensions(arrowX + 20, viewportBottom - 20, 20, 20).build());
+		}).bounds(arrowX + 20, viewportBottom - 20, 20, 20).build());
 		// "Bottom" button below the down-arrow that jumps directly to bottom
-		addDrawableChild(ButtonWidget.builder(Text.literal(""), b -> {
+		addRenderableWidget(Button.builder(Component.literal(""), b -> {
 			scrollToBottom();
-		}).dimensions(arrowX + 20, viewportBottom, 20, 20).build());
+		}).bounds(arrowX + 20, viewportBottom, 20, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Back"), b -> client.setScreen(prev))
-			.dimensions(x, this.height - 28, 300, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Back"), b -> minecraft.setScreen(prev))
+			.bounds(x, this.height - 28, 300, 20).build());
 	}
 	
 	private void scrollBy(int dy)
@@ -293,7 +292,8 @@ public final class WaypointsScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(net.minecraft.client.gui.Click context,
+	public boolean mouseClicked(
+		net.minecraft.client.input.MouseButtonEvent context,
 		boolean doubleClick)
 	{
 		double mouseX = context.x();
@@ -329,8 +329,9 @@ public final class WaypointsScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseDragged(net.minecraft.client.gui.Click context,
-		double deltaX, double deltaY)
+	public boolean mouseDragged(
+		net.minecraft.client.input.MouseButtonEvent context, double deltaX,
+		double deltaY)
 	{
 		double mouseY = context.y();
 		int button = context.button();
@@ -353,7 +354,8 @@ public final class WaypointsScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseReleased(net.minecraft.client.gui.Click context)
+	public boolean mouseReleased(
+		net.minecraft.client.input.MouseButtonEvent context)
 	{
 		if(context.button() == 0 && draggingScrollbar)
 		{
@@ -379,7 +381,7 @@ public final class WaypointsScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY, float delta)
+	public void render(GuiGraphics context, int mouseX, int mouseY, float delta)
 	{
 		// No blur - just a translucent background
 		context.fill(0, 0, this.width, this.height, 0x88000000);
@@ -413,8 +415,8 @@ public final class WaypointsScreen extends Screen
 		super.render(context, mouseX, mouseY, delta);
 		
 		// Title
-		context.drawCenteredTextWithShadow(client.textRenderer, "Waypoints",
-			this.width / 2, 12, 0xFFFFFFFF);
+		context.drawCenteredString(minecraft.font, "Waypoints", this.width / 2,
+			12, 0xFFFFFFFF);
 		
 		// Draw small color boxes for each saved waypoint next to the name
 		// Use the same filtered list as the rows to render color boxes and clip
@@ -506,9 +508,9 @@ public final class WaypointsScreen extends Screen
 	
 	private WaypointDimension currentDim()
 	{
-		if(client.world == null)
+		if(minecraft.level == null)
 			return WaypointDimension.OVERWORLD;
-		String key = client.world.getRegistryKey().getValue().getPath();
+		String key = minecraft.level.dimension().location().getPath();
 		switch(key)
 		{
 			case "the_nether":
@@ -522,10 +524,10 @@ public final class WaypointsScreen extends Screen
 	
 	private String resolveWorldId()
 	{
-		net.minecraft.client.network.ServerInfo s =
-			client.getCurrentServerEntry();
-		if(s != null && s.address != null && !s.address.isEmpty())
-			return s.address.replace(':', '_');
+		net.minecraft.client.multiplayer.ServerData s =
+			minecraft.getCurrentServer();
+		if(s != null && s.ip != null && !s.ip.isEmpty())
+			return s.ip.replace(':', '_');
 		return "singleplayer";
 	}
 	
@@ -551,18 +553,18 @@ public final class WaypointsScreen extends Screen
 	
 	private void refreshAfterDataChange()
 	{
-		init(client, this.width, this.height);
+		init(minecraft, this.width, this.height);
 	}
 	
 	private void sendXaeroMessage(String message)
 	{
-		if(message == null || message.isBlank() || client == null)
+		if(message == null || message.isBlank() || minecraft == null)
 			return;
-		Text text = Text.literal(message);
-		if(client.player != null)
-			client.player.sendMessage(text, false);
-		else if(client.inGameHud != null)
-			client.inGameHud.getChatHud().addMessage(text);
+		Component text = Component.literal(message);
+		if(minecraft.player != null)
+			minecraft.player.displayClientMessage(text, false);
+		else if(minecraft.gui != null)
+			minecraft.gui.getChat().addMessage(text);
 	}
 	
 	private String importSummary(WaypointsManager.XaeroSyncStats stats)
diff --git a/src/main/java/net/wurstclient/clickgui/widgets/MultiSelectEntryListWidget.java b/src/main/java/net/wurstclient/clickgui/widgets/MultiSelectEntryListWidget.java
index 2cd0e4a2d..207a54681 100644
--- a/src/main/java/net/wurstclient/clickgui/widgets/MultiSelectEntryListWidget.java
+++ b/src/main/java/net/wurstclient/clickgui/widgets/MultiSelectEntryListWidget.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.clickgui.widgets;
 
+import com.mojang.blaze3d.platform.Window;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashMap;
@@ -16,15 +17,13 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
-import net.minecraft.client.input.SystemKeycodes;
-import net.minecraft.client.util.Window;
-import net.minecraft.util.Util;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.ObjectSelectionList;
+import net.minecraft.client.input.InputQuirks;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.util.Mth;
 import org.lwjgl.glfw.GLFW;
 
 /**
@@ -33,13 +32,13 @@ import org.lwjgl.glfw.GLFW;
  * selection. Subclasses only need to provide entries that expose a stable key.
  */
 public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListWidget.Entry<E>>
-	extends AlwaysSelectedEntryListWidget<E>
+	extends ObjectSelectionList<E>
 {
 	private final LinkedHashSet<String> selectedKeys = new LinkedHashSet<>();
 	private String anchorKey;
 	private Runnable selectionListener = () -> {};
 	
-	protected MultiSelectEntryListWidget(MinecraftClient client, int width,
+	protected MultiSelectEntryListWidget(Minecraft client, int width,
 		int height, int top, int itemHeight)
 	{
 		super(client, width, height, top, itemHeight);
@@ -87,19 +86,19 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 	}
 	
 	@Override
-	protected void renderEntry(DrawContext context, int mouseX, int mouseY,
+	protected void renderItem(GuiGraphics context, int mouseX, int mouseY,
 		float delta, E entry)
 	{
-		if(isEntrySelectionAllowed()
+		if(entriesCanBeSelected()
 			&& selectedKeys.contains(getSelectionKey(entry)))
 		{
-			int color = this.getSelectedOrNull() == entry && this.isFocused()
-				? -1 : -8355712;
-			drawSelectionHighlight(context, entry, color);
+			int color =
+				this.getSelected() == entry && this.isFocused() ? -1 : -8355712;
+			renderSelection(context, entry, color);
 		}
 		
-		entry.render(context, mouseX, mouseY,
-			Objects.equals(getHoveredEntry(), entry), delta);
+		entry.renderContent(context, mouseX, mouseY,
+			Objects.equals(getHovered(), entry), delta);
 	}
 	
 	protected abstract String getSelectionKey(E entry);
@@ -273,9 +272,9 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 	{
 		boolean control = isKeyDown(GLFW.GLFW_KEY_LEFT_CONTROL)
 			|| isKeyDown(GLFW.GLFW_KEY_RIGHT_CONTROL)
-			|| isKeyDown(SystemKeycodes.LEFT_CTRL)
-			|| isKeyDown(SystemKeycodes.RIGHT_CTRL);
-		if(Util.getOperatingSystem() == Util.OperatingSystem.OSX)
+			|| isKeyDown(InputQuirks.EDIT_SHORTCUT_KEY_LEFT)
+			|| isKeyDown(InputQuirks.EDIT_SHORTCUT_KEY_RIGHT);
+		if(Util.getPlatform() == Util.OS.OSX)
 			control |= isKeyDown(GLFW.GLFW_KEY_LEFT_SUPER)
 				|| isKeyDown(GLFW.GLFW_KEY_RIGHT_SUPER);
 		return control;
@@ -283,8 +282,8 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 	
 	private boolean isKeyDown(int keyCode)
 	{
-		Window window = MinecraftClient.getInstance().getWindow();
-		return GLFW.glfwGetKey(window.getHandle(), keyCode) == GLFW.GLFW_PRESS;
+		Window window = Minecraft.getInstance().getWindow();
+		return GLFW.glfwGetKey(window.handle(), keyCode) == GLFW.GLFW_PRESS;
 	}
 	
 	public SelectionState captureState()
@@ -295,7 +294,7 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		int anchorIndex =
 			anchorEntry != null ? children().indexOf(anchorEntry) : -1;
 		return new SelectionState(new ArrayList<>(keys), anchorKey,
-			getScrollY(), anchorIndex);
+			scrollAmount(), anchorIndex);
 	}
 	
 	public void restoreState(SelectionState state)
@@ -314,8 +313,8 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		Map<String, E> byKey = buildEntryMap(entries);
 		
 		double targetScroll = state != null
-			? MathHelper.clamp(state.scrollAmount(), 0, getMaxScrollY())
-			: getScrollY();
+			? Mth.clamp(state.scrollAmount(), 0, maxScrollAmount())
+			: scrollAmount();
 		
 		if(state != null && !state.selectedKeys().isEmpty())
 		{
@@ -339,7 +338,7 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		if(selectedKeys.isEmpty())
 		{
 			int index = state != null ? state.anchorIndex() : -1;
-			index = MathHelper.clamp(index, 0, entries.size() - 1);
+			index = Mth.clamp(index, 0, entries.size() - 1);
 			E fallback = entries.get(index);
 			String key = getSelectionKey(fallback);
 			selectedKeys.add(key);
@@ -348,7 +347,7 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		
 		E anchorEntry = resolveAnchorEntry();
 		super.setSelected(anchorEntry);
-		setScrollY(targetScroll);
+		setScrollAmount(targetScroll);
 		notifySelectionChanged();
 	}
 	
@@ -383,8 +382,8 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		double scrollAmount, int anchorIndex)
 	{}
 	
-	public abstract static class Entry<E extends Entry<E>>
-		extends AlwaysSelectedEntryListWidget.Entry<E>
+	public abstract static class Entry<E extends net.wurstclient.clickgui.widgets.MultiSelectEntryListWidget.Entry<E>>
+		extends ObjectSelectionList.Entry<E>
 	{
 		private final MultiSelectEntryListWidget<E> parent;
 		
@@ -401,16 +400,17 @@ public abstract class MultiSelectEntryListWidget<E extends MultiSelectEntryListW
 		public abstract String selectionKey();
 		
 		@Override
-		public boolean mouseClicked(Click context, boolean doubleClick)
+		public boolean mouseClicked(MouseButtonEvent context,
+			boolean doubleClick)
 		{
 			if(context.button() != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 				return false;
 			
 			boolean shiftDown = (context.modifiers() & GLFW.GLFW_MOD_SHIFT) != 0
-				|| context.hasShift() || parent.isShiftDown();
+				|| context.hasShiftDown() || parent.isShiftDown();
 			boolean ctrlDown =
 				(context.modifiers() & GLFW.GLFW_MOD_CONTROL) != 0
-					|| context.hasCtrl() || parent.isControlDown();
+					|| context.hasControlDown() || parent.isControlDown();
 			
 			parent.onEntryClicked(self(), shiftDown, ctrlDown);
 			return true;
diff --git a/src/main/java/net/wurstclient/command/CmdList.java b/src/main/java/net/wurstclient/command/CmdList.java
index 5f9228749..9412bcdf2 100644
--- a/src/main/java/net/wurstclient/command/CmdList.java
+++ b/src/main/java/net/wurstclient/command/CmdList.java
@@ -10,9 +10,8 @@ package net.wurstclient.command;
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.TreeMap;
-
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
 import net.wurstclient.commands.*;
 
 public final class CmdList
@@ -94,8 +93,8 @@ public final class CmdList
 		}catch(Exception e)
 		{
 			String message = "Initializing Wurst commands";
-			CrashReport report = CrashReport.create(e, message);
-			throw new CrashException(report);
+			CrashReport report = CrashReport.forThrowable(e, message);
+			throw new ReportedException(report);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/command/CmdProcessor.java b/src/main/java/net/wurstclient/command/CmdProcessor.java
index d4ba9aa0e..dde37951b 100644
--- a/src/main/java/net/wurstclient/command/CmdProcessor.java
+++ b/src/main/java/net/wurstclient/command/CmdProcessor.java
@@ -8,10 +8,9 @@
 package net.wurstclient.command;
 
 import java.util.Arrays;
-
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
-import net.minecraft.util.crash.CrashReportSection;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportCategory;
+import net.minecraft.ReportedException;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.ChatOutputListener;
 import net.wurstclient.hacks.TooManyHaxHack;
@@ -88,10 +87,12 @@ public final class CmdProcessor implements ChatOutputListener
 			
 		}catch(Throwable e)
 		{
-			CrashReport report = CrashReport.create(e, "Running Wurst command");
-			CrashReportSection section = report.addElement("Affected command");
-			section.add("Command input", () -> input);
-			throw new CrashException(report);
+			CrashReport report =
+				CrashReport.forThrowable(e, "Running Wurst command");
+			CrashReportCategory section =
+				report.addCategory("Affected command");
+			section.setDetail("Command input", () -> input);
+			throw new ReportedException(report);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/commands/AddAltCmd.java b/src/main/java/net/wurstclient/commands/AddAltCmd.java
index 608490478..d44c00a52 100644
--- a/src/main/java/net/wurstclient/commands/AddAltCmd.java
+++ b/src/main/java/net/wurstclient/commands/AddAltCmd.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.PlayerListEntry;
-import net.minecraft.util.StringHelper;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.util.StringUtil;
 import net.wurstclient.altmanager.AltManager;
 import net.wurstclient.altmanager.CrackedAlt;
 import net.wurstclient.command.CmdException;
@@ -57,12 +57,12 @@ public final class AddAltCmd extends Command
 	{
 		int alts = 0;
 		AltManager altManager = WURST.getAltManager();
-		String playerName = MC.getSession().getUsername();
+		String playerName = MC.getUser().getName();
 		
-		for(PlayerListEntry entry : MC.player.networkHandler.getPlayerList())
+		for(PlayerInfo entry : MC.player.connection.getOnlinePlayers())
 		{
 			String name = entry.getProfile().name();
-			name = StringHelper.stripTextFormat(name);
+			name = StringUtil.stripColor(name);
 			
 			if(altManager.contains(name))
 				continue;
diff --git a/src/main/java/net/wurstclient/commands/AnnoyCmd.java b/src/main/java/net/wurstclient/commands/AnnoyCmd.java
index e00db606b..7c350ea16 100644
--- a/src/main/java/net/wurstclient/commands/AnnoyCmd.java
+++ b/src/main/java/net/wurstclient/commands/AnnoyCmd.java
@@ -8,8 +8,7 @@
 package net.wurstclient.commands;
 
 import org.apache.commons.lang3.StringUtils;
-
-import net.minecraft.client.network.ClientPlayerEntity;
+import net.minecraft.client.player.LocalPlayer;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -63,7 +62,7 @@ public final class AnnoyCmd extends Command implements ChatInputListener
 		target = String.join(" ", args);
 		ChatUtils.message("Now annoying " + target + ".");
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(player != null && target.equals(player.getName().getString()))
 			ChatUtils.warning("Annoying yourself is a bad idea!");
 		
@@ -112,6 +111,6 @@ public final class AnnoyCmd extends Command implements ChatInputListener
 		if(rcMode.isChecked() && repeated.startsWith("."))
 			WURST.getCmdProcessor().process(repeated.substring(1));
 		else
-			MC.getNetworkHandler().sendChatMessage(repeated);
+			MC.getConnection().sendChat(repeated);
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/AuthorCmd.java b/src/main/java/net/wurstclient/commands/AuthorCmd.java
index 3ef6a599c..6edafe582 100644
--- a/src/main/java/net/wurstclient/commands/AuthorCmd.java
+++ b/src/main/java/net/wurstclient/commands/AuthorCmd.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.WrittenBookContentComponent;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.component.WrittenBookContent;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -30,23 +30,22 @@ public final class AuthorCmd extends Command
 		if(args.length == 0)
 			throw new CmdSyntaxError();
 		
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
-		ItemStack heldStack = MC.player.getInventory().getSelectedStack();
-		if(!heldStack.isOf(Items.WRITTEN_BOOK))
+		ItemStack heldStack = MC.player.getInventory().getSelectedItem();
+		if(!heldStack.is(Items.WRITTEN_BOOK))
 			throw new CmdError(
 				"You must hold a written book in your main hand.");
 		
-		WrittenBookContentComponent oldData = heldStack.getComponents()
-			.get(DataComponentTypes.WRITTEN_BOOK_CONTENT);
+		WrittenBookContent oldData =
+			heldStack.getComponents().get(DataComponents.WRITTEN_BOOK_CONTENT);
 		if(oldData == null)
 			throw new CmdError("Can't find book data.");
 		
 		String author = String.join(" ", args);
-		WrittenBookContentComponent newData =
-			new WrittenBookContentComponent(oldData.title(), author,
-				oldData.generation(), oldData.pages(), oldData.resolved());
-		heldStack.set(DataComponentTypes.WRITTEN_BOOK_CONTENT, newData);
+		WrittenBookContent newData = new WrittenBookContent(oldData.title(),
+			author, oldData.generation(), oldData.pages(), oldData.resolved());
+		heldStack.set(DataComponents.WRITTEN_BOOK_CONTENT, newData);
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/BindsCmd.java b/src/main/java/net/wurstclient/commands/BindsCmd.java
index bff76f306..bf0fa7598 100644
--- a/src/main/java/net/wurstclient/commands/BindsCmd.java
+++ b/src/main/java/net/wurstclient/commands/BindsCmd.java
@@ -7,14 +7,13 @@
  */
 package net.wurstclient.commands;
 
+import com.mojang.blaze3d.platform.InputConstants;
 import java.io.IOException;
 import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-
-import net.minecraft.client.util.InputUtil;
 import net.wurstclient.DontBlock;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
@@ -125,7 +124,7 @@ public final class BindsCmd extends Command
 		
 		try
 		{
-			InputUtil.fromTranslationKey(key);
+			InputConstants.getKey(key);
 			return key;
 			
 		}catch(IllegalArgumentException e)
diff --git a/src/main/java/net/wurstclient/commands/BlockListCmd.java b/src/main/java/net/wurstclient/commands/BlockListCmd.java
index 17b538c73..5b38c82e8 100644
--- a/src/main/java/net/wurstclient/commands/BlockListCmd.java
+++ b/src/main/java/net/wurstclient/commands/BlockListCmd.java
@@ -8,8 +8,7 @@
 package net.wurstclient.commands;
 
 import java.util.List;
-
-import net.minecraft.block.Block;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.DontBlock;
 import net.wurstclient.Feature;
 import net.wurstclient.command.CmdError;
diff --git a/src/main/java/net/wurstclient/commands/ClearCmd.java b/src/main/java/net/wurstclient/commands/ClearCmd.java
index e1c6ce5d1..4330d1f59 100644
--- a/src/main/java/net/wurstclient/commands/ClearCmd.java
+++ b/src/main/java/net/wurstclient/commands/ClearCmd.java
@@ -24,6 +24,6 @@ public final class ClearCmd extends Command
 		if(args.length > 0)
 			throw new CmdSyntaxError();
 		
-		MC.inGameHud.getChatHud().clear(true);
+		MC.gui.getChat().clearMessages(true);
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/CopyItemCmd.java b/src/main/java/net/wurstclient/commands/CopyItemCmd.java
index 02ad6b5ff..9c5a6f930 100644
--- a/src/main/java/net/wurstclient/commands/CopyItemCmd.java
+++ b/src/main/java/net/wurstclient/commands/CopyItemCmd.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.AbstractClientPlayerEntity;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.item.ItemStack;
+import net.minecraft.client.player.AbstractClientPlayer;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -34,19 +34,19 @@ public final class CopyItemCmd extends Command
 		if(args.length != 2)
 			throw new CmdSyntaxError();
 		
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
-		AbstractClientPlayerEntity player = getPlayer(args[0]);
+		AbstractClientPlayer player = getPlayer(args[0]);
 		ItemStack item = getItem(player, args[1]);
 		CmdUtils.giveItem(item);
 		
 		ChatUtils.message("Item copied.");
 	}
 	
-	private AbstractClientPlayerEntity getPlayer(String name) throws CmdError
+	private AbstractClientPlayer getPlayer(String name) throws CmdError
 	{
-		for(AbstractClientPlayerEntity player : MC.world.getPlayers())
+		for(AbstractClientPlayer player : MC.level.players())
 		{
 			if(!player.getName().getString().equalsIgnoreCase(name))
 				continue;
@@ -57,25 +57,25 @@ public final class CopyItemCmd extends Command
 		throw new CmdError("Player \"" + name + "\" could not be found.");
 	}
 	
-	private ItemStack getItem(AbstractClientPlayerEntity player, String slot)
+	private ItemStack getItem(AbstractClientPlayer player, String slot)
 		throws CmdSyntaxError
 	{
 		switch(slot.toLowerCase())
 		{
 			case "hand":
-			return player.getMainHandStack();
+			return player.getMainHandItem();
 			
 			case "head":
-			return player.getEquippedStack(EquipmentSlot.HEAD);
+			return player.getItemBySlot(EquipmentSlot.HEAD);
 			
 			case "chest":
-			return player.getEquippedStack(EquipmentSlot.CHEST);
+			return player.getItemBySlot(EquipmentSlot.CHEST);
 			
 			case "legs":
-			return player.getEquippedStack(EquipmentSlot.LEGS);
+			return player.getItemBySlot(EquipmentSlot.LEGS);
 			
 			case "feet":
-			return player.getEquippedStack(EquipmentSlot.FEET);
+			return player.getItemBySlot(EquipmentSlot.FEET);
 			
 			default:
 			throw new CmdSyntaxError();
diff --git a/src/main/java/net/wurstclient/commands/DamageCmd.java b/src/main/java/net/wurstclient/commands/DamageCmd.java
index 0f7688571..830cb8958 100644
--- a/src/main/java/net/wurstclient/commands/DamageCmd.java
+++ b/src/main/java/net/wurstclient/commands/DamageCmd.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -31,7 +31,7 @@ public final class DamageCmd extends Command
 		if(args.length == 0)
 			throw new CmdSyntaxError();
 		
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 			throw new CmdError("Cannot damage in creative mode.");
 		
 		int amount = parseAmount(args[0]);
@@ -56,7 +56,7 @@ public final class DamageCmd extends Command
 	
 	private void applyDamage(int amount)
 	{
-		Vec3d pos = MC.player.getEntityPos();
+		Vec3 pos = MC.player.position();
 		
 		for(int i = 0; i < 80; i++)
 		{
@@ -69,8 +69,7 @@ public final class DamageCmd extends Command
 	
 	private void sendPosition(double x, double y, double z, boolean onGround)
 	{
-		MC.player.networkHandler
-			.sendPacket(new PlayerMoveC2SPacket.PositionAndOnGround(x, y, z,
-				onGround, MC.player.horizontalCollision));
+		MC.player.connection.send(new ServerboundMovePlayerPacket.Pos(x, y, z,
+			onGround, MC.player.horizontalCollision));
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/DigCmd.java b/src/main/java/net/wurstclient/commands/DigCmd.java
index 6d5081aaf..c014e575c 100644
--- a/src/main/java/net/wurstclient/commands/DigCmd.java
+++ b/src/main/java/net/wurstclient/commands/DigCmd.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -42,22 +42,22 @@ public final class DigCmd extends Command
 		int width = tryParseInt(args[1], "width");
 		int height = tryParseInt(args[2], "height");
 		
-		ClientPlayerEntity player = MC.player;
-		Direction direction = player.getHorizontalFacing();
+		LocalPlayer player = MC.player;
+		Direction direction = player.getDirection();
 		
-		BlockPos pos1 = BlockPos.ofFloored(player.getEntityPos().add(0,
-			player.getEyeHeight(player.getPose()), 0));
+		BlockPos pos1 = BlockPos.containing(
+			player.position().add(0, player.getEyeHeight(player.getPose()), 0));
 		
 		if(height < 0)
-			pos1 = pos1.down();
+			pos1 = pos1.below();
 		
 		BlockPos pos2 =
-			pos1.offset(direction, length > 0 ? length - 1 : length + 1);
+			pos1.relative(direction, length > 0 ? length - 1 : length + 1);
 		
-		pos2 = pos2.offset(direction.rotateYClockwise(),
+		pos2 = pos2.relative(direction.getClockWise(),
 			width > 0 ? width - 1 : width + 1);
 		
-		pos2 = pos2.down(height > 0 ? height - 1 : height + 1);
+		pos2 = pos2.below(height > 0 ? height - 1 : height + 1);
 		
 		WURST.getHax().excavatorHack.enableWithArea(pos1, pos2);
 	}
diff --git a/src/main/java/net/wurstclient/commands/DropCmd.java b/src/main/java/net/wurstclient/commands/DropCmd.java
index 4441fde40..64463e8ec 100644
--- a/src/main/java/net/wurstclient/commands/DropCmd.java
+++ b/src/main/java/net/wurstclient/commands/DropCmd.java
@@ -76,7 +76,7 @@ public final class DropCmd extends Command implements UpdateListener
 			if(adjustedSlot >= 36)
 				adjustedSlot -= 36;
 			
-			if(!MC.player.getInventory().getStack(adjustedSlot).isEmpty())
+			if(!MC.player.getInventory().getItem(adjustedSlot).isEmpty())
 				break;
 			
 			slowModeSlotCounter++;
diff --git a/src/main/java/net/wurstclient/commands/EnchantCmd.java b/src/main/java/net/wurstclient/commands/EnchantCmd.java
index 77c1b7919..72f67c8d6 100644
--- a/src/main/java/net/wurstclient/commands/EnchantCmd.java
+++ b/src/main/java/net/wurstclient/commands/EnchantCmd.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.Enchantments;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.registry.tag.EnchantmentTags;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.tags.EnchantmentTags;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.Enchantments;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -32,7 +32,7 @@ public final class EnchantCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
 		if(args.length > 1)
@@ -44,10 +44,10 @@ public final class EnchantCmd extends Command
 	
 	private ItemStack getHeldItem() throws CmdError
 	{
-		ItemStack stack = MC.player.getMainHandStack();
+		ItemStack stack = MC.player.getMainHandItem();
 		
 		if(stack.isEmpty())
-			stack = MC.player.getOffHandStack();
+			stack = MC.player.getOffhandItem();
 		
 		if(stack.isEmpty())
 			throw new CmdError("There is no item in your hand.");
@@ -57,28 +57,28 @@ public final class EnchantCmd extends Command
 	
 	private void enchant(ItemStack stack, int level)
 	{
-		DynamicRegistryManager drm = MC.world.getRegistryManager();
+		RegistryAccess drm = MC.level.registryAccess();
 		Registry<Enchantment> registry =
-			drm.getOrThrow(RegistryKeys.ENCHANTMENT);
+			drm.lookupOrThrow(Registries.ENCHANTMENT);
 		
-		for(RegistryEntry<Enchantment> entry : registry.getIndexedEntries())
+		for(Holder<Enchantment> entry : registry.asHolderIdMap())
 		{
 			// Skip curses
-			if(entry.isIn(EnchantmentTags.CURSE))
+			if(entry.is(EnchantmentTags.CURSE))
 				continue;
 			
 			// Skip Silk Touch so it doesn't remove Fortune
-			if(entry.getKey().orElse(null) == Enchantments.SILK_TOUCH)
+			if(entry.unwrapKey().orElse(null) == Enchantments.SILK_TOUCH)
 				continue;
 			
 			// Limit Quick Charge to level 5 so it doesn't break
-			if(entry.getKey().orElse(null) == Enchantments.QUICK_CHARGE)
+			if(entry.unwrapKey().orElse(null) == Enchantments.QUICK_CHARGE)
 			{
-				stack.addEnchantment(entry, Math.min(level, 5));
+				stack.enchant(entry, Math.min(level, 5));
 				continue;
 			}
 			
-			stack.addEnchantment(entry, level);
+			stack.enchant(entry, level);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/commands/ExcavateCmd.java b/src/main/java/net/wurstclient/commands/ExcavateCmd.java
index d6026a478..ca3c3b3eb 100644
--- a/src/main/java/net/wurstclient/commands/ExcavateCmd.java
+++ b/src/main/java/net/wurstclient/commands/ExcavateCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -35,7 +35,7 @@ public final class ExcavateCmd extends Command
 	
 	private BlockPos argsToXyzPos(String... xyz) throws CmdSyntaxError
 	{
-		BlockPos playerPos = BlockPos.ofFloored(MC.player.getEntityPos());
+		BlockPos playerPos = BlockPos.containing(MC.player.position());
 		int[] player = {playerPos.getX(), playerPos.getY(), playerPos.getZ()};
 		int[] pos = new int[3];
 		
diff --git a/src/main/java/net/wurstclient/commands/FollowCmd.java b/src/main/java/net/wurstclient/commands/FollowCmd.java
index 07e7ad2a0..b1b5f72d9 100644
--- a/src/main/java/net/wurstclient/commands/FollowCmd.java
+++ b/src/main/java/net/wurstclient/commands/FollowCmd.java
@@ -9,9 +9,8 @@ package net.wurstclient.commands;
 
 import java.util.Comparator;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -38,14 +37,13 @@ public final class FollowCmd extends Command
 			followHack.setEnabled(false);
 		
 		Entity entity = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), true)
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(LivingEntity.class::isInstance)
 			.filter(e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
 			.filter(e -> args[0].equalsIgnoreCase(e.getName().getString()))
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		if(entity == null)
diff --git a/src/main/java/net/wurstclient/commands/GetPosCmd.java b/src/main/java/net/wurstclient/commands/GetPosCmd.java
index 82b971094..03af9b3db 100644
--- a/src/main/java/net/wurstclient/commands/GetPosCmd.java
+++ b/src/main/java/net/wurstclient/commands/GetPosCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -24,7 +24,7 @@ public final class GetPosCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		BlockPos pos = BlockPos.ofFloored(MC.player.getEntityPos());
+		BlockPos pos = BlockPos.containing(MC.player.position());
 		String posString = pos.getX() + " " + pos.getY() + " " + pos.getZ();
 		
 		switch(String.join(" ", args).toLowerCase())
@@ -34,7 +34,7 @@ public final class GetPosCmd extends Command
 			break;
 			
 			case "copy":
-			MC.keyboard.setClipboard(posString);
+			MC.keyboardHandler.setClipboard(posString);
 			ChatUtils.message("Position copied to clipboard.");
 			break;
 			
diff --git a/src/main/java/net/wurstclient/commands/GiveCmd.java b/src/main/java/net/wurstclient/commands/GiveCmd.java
index 03eeeef3e..b182fc182 100644
--- a/src/main/java/net/wurstclient/commands/GiveCmd.java
+++ b/src/main/java/net/wurstclient/commands/GiveCmd.java
@@ -10,13 +10,12 @@ package net.wurstclient.commands;
 import java.util.Arrays;
 
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
-
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.NbtComponent;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NbtCompound;
-import net.minecraft.nbt.StringNbtReader;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.TagParser;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -42,7 +41,7 @@ public final class GiveCmd extends Command
 		if(args.length < 1)
 			throw new CmdSyntaxError();
 		
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
 		// id/name
@@ -74,8 +73,8 @@ public final class GiveCmd extends Command
 		if(nbt != null)
 			try
 			{
-				NbtCompound tag = StringNbtReader.readCompound(nbt);
-				NbtComponent.set(DataComponentTypes.CUSTOM_DATA, stack, tag);
+				CompoundTag tag = TagParser.parseCompoundFully(nbt);
+				CustomData.set(DataComponents.CUSTOM_DATA, stack, tag);
 				
 			}catch(CommandSyntaxException e)
 			{
diff --git a/src/main/java/net/wurstclient/commands/GmCmd.java b/src/main/java/net/wurstclient/commands/GmCmd.java
index 13d9fa658..aa8e51ad5 100644
--- a/src/main/java/net/wurstclient/commands/GmCmd.java
+++ b/src/main/java/net/wurstclient/commands/GmCmd.java
@@ -49,6 +49,6 @@ public final class GmCmd extends Command
 		}
 		
 		String message = "gamemode " + args2;
-		MC.getNetworkHandler().sendChatCommand(message);
+		MC.getConnection().sendCommand(message);
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/GoToCmd.java b/src/main/java/net/wurstclient/commands/GoToCmd.java
index 05c7e88e4..4bb9f1e53 100644
--- a/src/main/java/net/wurstclient/commands/GoToCmd.java
+++ b/src/main/java/net/wurstclient/commands/GoToCmd.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.commands;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Comparator;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.ai.PathFinder;
 import net.wurstclient.ai.PathProcessor;
 import net.wurstclient.command.CmdError;
@@ -88,25 +87,24 @@ public final class GoToCmd extends Command
 	private BlockPos argsToEntityPos(String name) throws CmdError
 	{
 		LivingEntity entity = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), true)
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(LivingEntity.class::isInstance).map(e -> (LivingEntity)e)
 			.filter(e -> !e.isRemoved() && e.getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
 			.filter(e -> name.equalsIgnoreCase(e.getDisplayName().getString()))
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		if(entity == null)
 			throw new CmdError("Entity \"" + name + "\" could not be found.");
 		
-		return BlockPos.ofFloored(entity.getEntityPos());
+		return BlockPos.containing(entity.position());
 	}
 	
 	private BlockPos argsToXyzPos(String... xyz) throws CmdSyntaxError
 	{
-		BlockPos playerPos = BlockPos.ofFloored(MC.player.getEntityPos());
+		BlockPos playerPos = BlockPos.containing(MC.player.position());
 		int[] player = {playerPos.getX(), playerPos.getY(), playerPos.getZ()};
 		int[] pos = new int[3];
 		
@@ -170,7 +168,7 @@ public final class GoToCmd extends Command
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		PathCmd pathCmd = WURST.getCmds().pathCmd;
 		pathFinder.renderPath(matrixStack, pathCmd.isDebugMode(),
diff --git a/src/main/java/net/wurstclient/commands/InvseeCmd.java b/src/main/java/net/wurstclient/commands/InvseeCmd.java
index 62c872ba3..db3928656 100644
--- a/src/main/java/net/wurstclient/commands/InvseeCmd.java
+++ b/src/main/java/net/wurstclient/commands/InvseeCmd.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.client.network.OtherClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.client.player.RemotePlayer;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -34,7 +34,7 @@ public final class InvseeCmd extends Command implements RenderListener
 		if(args.length != 1)
 			throw new CmdSyntaxError();
 		
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 		{
 			ChatUtils.error("Survival mode only.");
 			return;
@@ -45,16 +45,16 @@ public final class InvseeCmd extends Command implements RenderListener
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		boolean found = false;
 		
-		for(Entity entity : MC.world.getEntities())
+		for(Entity entity : MC.level.entitiesForRendering())
 		{
-			if(!(entity instanceof OtherClientPlayerEntity))
+			if(!(entity instanceof RemotePlayer))
 				continue;
 			
-			OtherClientPlayerEntity player = (OtherClientPlayerEntity)entity;
+			RemotePlayer player = (RemotePlayer)entity;
 			
 			String otherPlayerName = player.getName().getString();
 			if(!otherPlayerName.equalsIgnoreCase(targetName))
diff --git a/src/main/java/net/wurstclient/commands/IpCmd.java b/src/main/java/net/wurstclient/commands/IpCmd.java
index ab582f279..53b6a162c 100644
--- a/src/main/java/net/wurstclient/commands/IpCmd.java
+++ b/src/main/java/net/wurstclient/commands/IpCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ServerInfo;
+import net.minecraft.client.multiplayer.ServerData;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -36,7 +36,7 @@ public final class IpCmd extends Command
 			break;
 			
 			case "copy":
-			MC.keyboard.setClipboard(ip);
+			MC.keyboardHandler.setClipboard(ip);
 			ChatUtils.message("IP copied to clipboard.");
 			break;
 			
@@ -47,11 +47,11 @@ public final class IpCmd extends Command
 	
 	private String getIP()
 	{
-		ServerInfo lastServer = LastServerRememberer.getLastServer();
-		if(lastServer == null || MC.isIntegratedServerRunning())
+		ServerData lastServer = LastServerRememberer.getLastServer();
+		if(lastServer == null || MC.hasSingleplayerServer())
 			return "127.0.0.1:25565";
 		
-		String ip = lastServer.address;
+		String ip = lastServer.ip;
 		if(!ip.contains(":"))
 			ip += ":25565";
 		
diff --git a/src/main/java/net/wurstclient/commands/ItemListCmd.java b/src/main/java/net/wurstclient/commands/ItemListCmd.java
index 5f00b8f11..64b1c2aaa 100644
--- a/src/main/java/net/wurstclient/commands/ItemListCmd.java
+++ b/src/main/java/net/wurstclient/commands/ItemListCmd.java
@@ -9,9 +9,8 @@ package net.wurstclient.commands;
 
 import java.util.Collections;
 import java.util.List;
-
-import net.minecraft.item.Item;
-import net.minecraft.registry.Registries;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.item.Item;
 import net.wurstclient.DontBlock;
 import net.wurstclient.Feature;
 import net.wurstclient.command.CmdError;
@@ -82,7 +81,7 @@ public final class ItemListCmd extends Command
 		try
 		{
 			Item item = CmdUtils.parseItem(args[3]);
-			String itemName = Registries.ITEM.getId(item).toString();
+			String itemName = BuiltInRegistries.ITEM.getKey(item).toString();
 			int index =
 				Collections.binarySearch(setting.getItemNames(), itemName);
 			if(index >= 0)
@@ -112,7 +111,7 @@ public final class ItemListCmd extends Command
 		
 		Item item = CmdUtils.parseItem(args[3]);
 		
-		String itemName = Registries.ITEM.getId(item).toString();
+		String itemName = BuiltInRegistries.ITEM.getKey(item).toString();
 		int index = Collections.binarySearch(setting.getItemNames(), itemName);
 		if(index < 0)
 			throw new CmdError(feature.getName() + " " + setting.getName()
diff --git a/src/main/java/net/wurstclient/commands/JumpCmd.java b/src/main/java/net/wurstclient/commands/JumpCmd.java
index be8b0dfc8..96b68f6ea 100644
--- a/src/main/java/net/wurstclient/commands/JumpCmd.java
+++ b/src/main/java/net/wurstclient/commands/JumpCmd.java
@@ -25,10 +25,10 @@ public final class JumpCmd extends Command
 		if(args.length != 0)
 			throw new CmdSyntaxError();
 		
-		if(!MC.player.isOnGround() && !WURST.getHax().jetpackHack.isEnabled())
+		if(!MC.player.onGround() && !WURST.getHax().jetpackHack.isEnabled())
 			throw new CmdError("Can't jump in mid-air.");
 		
-		MC.player.jump();
+		MC.player.jumpFromGround();
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/commands/LeaveCmd.java b/src/main/java/net/wurstclient/commands/LeaveCmd.java
index 923c9e77d..dc4b99d0a 100644
--- a/src/main/java/net/wurstclient/commands/LeaveCmd.java
+++ b/src/main/java/net/wurstclient/commands/LeaveCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.world.ClientWorld;
+import net.minecraft.client.multiplayer.ClientLevel;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
 import net.wurstclient.command.Command;
@@ -24,11 +24,11 @@ public final class LeaveCmd extends Command
 	{
 		if(args.length == 1 && args[0].equalsIgnoreCase("taco"))
 			for(int i = 0; i < 128; i++)
-				MC.getNetworkHandler().sendChatMessage("Taco!");
+				MC.getConnection().sendChat("Taco!");
 		else if(args.length != 0)
 			throw new CmdSyntaxError();
 		
-		MC.world.disconnect(ClientWorld.QUITTING_MULTIPLAYER_TEXT);
+		MC.level.disconnect(ClientLevel.DEFAULT_QUIT_MESSAGE);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/commands/ModifyCmd.java b/src/main/java/net/wurstclient/commands/ModifyCmd.java
index 1558bcbd8..f4be8ae37 100644
--- a/src/main/java/net/wurstclient/commands/ModifyCmd.java
+++ b/src/main/java/net/wurstclient/commands/ModifyCmd.java
@@ -14,14 +14,13 @@ import com.google.gson.JsonParseException;
 import com.google.gson.JsonParser;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.component.ComponentMap;
-import net.minecraft.component.ComponentType;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.component.DataComponentMap;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -43,15 +42,15 @@ public final class ModifyCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		ClientPlayerEntity player = MC.player;
-		if(!player.getAbilities().creativeMode)
+		LocalPlayer player = MC.player;
+		if(!player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		if(args.length < 2)
 			throw new CmdSyntaxError();
 		
-		PlayerInventory inventory = player.getInventory();
+		Inventory inventory = player.getInventory();
 		int slot = inventory.getSelectedSlot();
-		ItemStack stack = inventory.getSelectedStack();
+		ItemStack stack = inventory.getSelectedItem();
 		if(stack == null)
 			throw new CmdError("You must hold an item in your main hand.");
 		
@@ -78,19 +77,20 @@ public final class ModifyCmd extends Command
 		if(args.length < 3)
 			throw new CmdSyntaxError();
 		
-		ComponentType<?> type = parseComponentType(args[1]);
+		DataComponentType<?> type = parseComponentType(args[1]);
 		
 		String valueString =
 			String.join(" ", Arrays.copyOfRange(args, 2, args.length))
 				.replace("$", "\u00a7").replace("\u00a7\u00a7", "$");
 		JsonElement valueJson = parseJson(valueString);
-		DataResult<?> valueResult = type.getCodec().parse(
-			MC.player.getRegistryManager().getOps(JsonOps.INSTANCE), valueJson);
+		DataResult<?> valueResult =
+			type.codec().parse(MC.player.registryAccess()
+				.createSerializationContext(JsonOps.INSTANCE), valueJson);
 		Object value = valueResult.resultOrPartial().orElse(null);
 		
-		ComponentMap.Builder builder = ComponentMap.builder();
-		builder.put(type, value);
-		stack.applyComponentsFrom(builder.build());
+		DataComponentMap.Builder builder = DataComponentMap.builder();
+		builder.setUnchecked(type, value);
+		stack.applyComponents(builder.build());
 	}
 	
 	private void remove(ItemStack stack, String[] args) throws CmdException
@@ -101,10 +101,11 @@ public final class ModifyCmd extends Command
 		stack.set(parseComponentType(args[1]), null);
 	}
 	
-	private ComponentType<?> parseComponentType(String typeName) throws CmdError
+	private DataComponentType<?> parseComponentType(String typeName)
+		throws CmdError
 	{
-		ComponentType<?> type =
-			Registries.DATA_COMPONENT_TYPE.get(Identifier.tryParse(typeName));
+		DataComponentType<?> type = BuiltInRegistries.DATA_COMPONENT_TYPE
+			.getValue(ResourceLocation.tryParse(typeName));
 		
 		if(type == null)
 			throw new CmdError(
diff --git a/src/main/java/net/wurstclient/commands/NecoCmd.java b/src/main/java/net/wurstclient/commands/NecoCmd.java
index 7ad5a9175..75e33f29c 100644
--- a/src/main/java/net/wurstclient/commands/NecoCmd.java
+++ b/src/main/java/net/wurstclient/commands/NecoCmd.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.gl.RenderPipelines;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.renderer.RenderPipelines;
+import net.minecraft.resources.ResourceLocation;
 import net.wurstclient.Category;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -21,7 +21,7 @@ import net.wurstclient.util.RenderUtils;
 public final class NecoCmd extends Command
 	implements GUIRenderListener, UpdateListener
 {
-	private final Identifier[] necos = buildNecoFrames();
+	private final ResourceLocation[] necos = buildNecoFrames();
 	
 	private static final int NECO_TEX_W = 200;
 	private static final int NECO_TEX_H = 200;
@@ -84,14 +84,14 @@ public final class NecoCmd extends Command
 	}
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
 		int color = WURST.getHax().rainbowUiHack.isEnabled()
 			? RenderUtils.toIntColor(WURST.getGui().getAcColor(), 1)
 			: 0xFFFFFFFF;
 		
-		int sw = context.getScaledWindowWidth();
-		int sh = context.getScaledWindowHeight();
+		int sw = context.guiWidth();
+		int sh = context.guiHeight();
 		int hungerBaselineY = sh - HUNGER_ROW_BASELINE;
 		
 		int x = sw - DRAW_W - RIGHT_MARGIN;
@@ -99,15 +99,16 @@ public final class NecoCmd extends Command
 		
 		int frameIndex = (ticks / TICKS_PER_FRAME) % 37;
 		
-		context.drawTexture(RenderPipelines.GUI_TEXTURED, necos[frameIndex], x,
-			y, 0, 0, DRAW_W, DRAW_H, NECO_TEX_W, NECO_TEX_H, color);
+		context.blit(RenderPipelines.GUI_TEXTURED, necos[frameIndex], x, y, 0,
+			0, DRAW_W, DRAW_H, NECO_TEX_W, NECO_TEX_H, color);
 	}
 	
-	private static Identifier[] buildNecoFrames()
+	private static ResourceLocation[] buildNecoFrames()
 	{
-		Identifier[] frames = new Identifier[37];
+		ResourceLocation[] frames = new ResourceLocation[37];
 		for(int i = 0; i < 37; i++)
-			frames[i] = Identifier.of("wurst", "neco" + (i + 1) + ".png");
+			frames[i] = ResourceLocation.fromNamespaceAndPath("wurst",
+				"neco" + (i + 1) + ".png");
 		return frames;
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/PathCmd.java b/src/main/java/net/wurstclient/commands/PathCmd.java
index cc67a9df7..91152c561 100644
--- a/src/main/java/net/wurstclient/commands/PathCmd.java
+++ b/src/main/java/net/wurstclient/commands/PathCmd.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.commands;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.ai.PathFinder;
 import net.wurstclient.ai.PathPos;
 import net.wurstclient.command.CmdError;
@@ -128,25 +127,24 @@ public final class PathCmd extends Command
 	private BlockPos argsToEntityPos(String name) throws CmdError
 	{
 		LivingEntity entity = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), true)
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(LivingEntity.class::isInstance).map(e -> (LivingEntity)e)
 			.filter(e -> !e.isRemoved() && e.getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
 			.filter(e -> name.equalsIgnoreCase(e.getDisplayName().getString()))
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		if(entity == null)
 			throw new CmdError("Entity \"" + name + "\" could not be found.");
 		
-		return BlockPos.ofFloored(entity.getEntityPos());
+		return BlockPos.containing(entity.position());
 	}
 	
 	private BlockPos argsToXyzPos(String... xyz) throws CmdSyntaxError
 	{
-		BlockPos playerPos = BlockPos.ofFloored(MC.player.getEntityPos());
+		BlockPos playerPos = BlockPos.containing(MC.player.position());
 		int[] player = {playerPos.getX(), playerPos.getY(), playerPos.getZ()};
 		int[] pos = new int[3];
 		
@@ -192,7 +190,7 @@ public final class PathCmd extends Command
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		pathFinder.renderPath(matrixStack, debugMode.isChecked(),
 			depthTest.isChecked());
diff --git a/src/main/java/net/wurstclient/commands/PotionCmd.java b/src/main/java/net/wurstclient/commands/PotionCmd.java
index 440333252..d5f5718dc 100644
--- a/src/main/java/net/wurstclient/commands/PotionCmd.java
+++ b/src/main/java/net/wurstclient/commands/PotionCmd.java
@@ -9,18 +9,17 @@ package net.wurstclient.commands;
 
 import java.util.ArrayList;
 import java.util.Optional;
-
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.PotionItem;
-import net.minecraft.potion.Potion;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.InvalidIdentifierException;
+import net.minecraft.ResourceLocationException;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.PotionItem;
+import net.minecraft.world.item.alchemy.Potion;
+import net.minecraft.world.item.alchemy.PotionContents;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -44,10 +43,10 @@ public final class PotionCmd extends Command
 		if(args.length == 0)
 			throw new CmdSyntaxError();
 		
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
-		ItemStack stack = MC.player.getInventory().getSelectedStack();
+		ItemStack stack = MC.player.getInventory().getSelectedItem();
 		if(!(stack.getItem() instanceof PotionItem))
 			throw new CmdError("You must hold a potion in your main hand.");
 		
@@ -61,13 +60,12 @@ public final class PotionCmd extends Command
 		if((args.length - 1) % 3 != 0)
 			throw new CmdSyntaxError();
 		
-		PotionContentsComponent oldContents = stack.getComponents()
-			.getOrDefault(DataComponentTypes.POTION_CONTENTS,
-				PotionContentsComponent.DEFAULT);
+		PotionContents oldContents = stack.getComponents()
+			.getOrDefault(DataComponents.POTION_CONTENTS, PotionContents.EMPTY);
 		
 		// get effects to start with
-		ArrayList<StatusEffectInstance> effects;
-		Optional<RegistryEntry<Potion>> potion;
+		ArrayList<MobEffectInstance> effects;
+		Optional<Holder<Potion>> potion;
 		switch(args[0].toLowerCase())
 		{
 			case "add":
@@ -87,16 +85,15 @@ public final class PotionCmd extends Command
 		// add new effects
 		for(int i = 0; i < (args.length - 1) / 3; i++)
 		{
-			RegistryEntry<StatusEffect> effect = parseEffect(args[1 + i * 3]);
+			Holder<MobEffect> effect = parseEffect(args[1 + i * 3]);
 			int amplifier = parseInt(args[2 + i * 3]) - 1;
 			int duration = parseInt(args[3 + i * 3]) * 20;
 			
-			effects.add(new StatusEffectInstance(effect, duration, amplifier));
+			effects.add(new MobEffectInstance(effect, duration, amplifier));
 		}
 		
-		stack.set(DataComponentTypes.POTION_CONTENTS,
-			new PotionContentsComponent(potion, oldContents.customColor(),
-				effects, oldContents.customName()));
+		stack.set(DataComponents.POTION_CONTENTS, new PotionContents(potion,
+			oldContents.customColor(), effects, oldContents.customName()));
 		ChatUtils.message("Potion modified.");
 	}
 	
@@ -105,48 +102,44 @@ public final class PotionCmd extends Command
 		if(args.length != 2)
 			throw new CmdSyntaxError();
 		
-		RegistryEntry<StatusEffect> targetEffect = parseEffect(args[1]);
+		Holder<MobEffect> targetEffect = parseEffect(args[1]);
 		
-		PotionContentsComponent oldContents = stack.getComponents()
-			.getOrDefault(DataComponentTypes.POTION_CONTENTS,
-				PotionContentsComponent.DEFAULT);
+		PotionContents oldContents = stack.getComponents()
+			.getOrDefault(DataComponents.POTION_CONTENTS, PotionContents.EMPTY);
 		
 		boolean mainPotionContainsTargetEffect =
 			oldContents.potion().isPresent()
 				&& oldContents.potion().get().value().getEffects().stream()
-					.anyMatch(effect -> effect.getEffectType() == targetEffect);
+					.anyMatch(effect -> effect.getEffect() == targetEffect);
 		
-		ArrayList<StatusEffectInstance> newEffects = new ArrayList<>();
+		ArrayList<MobEffectInstance> newEffects = new ArrayList<>();
 		if(mainPotionContainsTargetEffect)
-			oldContents.getEffects().forEach(newEffects::add);
+			oldContents.getAllEffects().forEach(newEffects::add);
 		else
 			oldContents.customEffects().forEach(newEffects::add);
-		newEffects.removeIf(effect -> effect.getEffectType() == targetEffect);
+		newEffects.removeIf(effect -> effect.getEffect() == targetEffect);
 		
-		Optional<RegistryEntry<Potion>> newPotion =
-			mainPotionContainsTargetEffect ? Optional.empty()
-				: oldContents.potion();
-		stack.set(DataComponentTypes.POTION_CONTENTS,
-			new PotionContentsComponent(newPotion, oldContents.customColor(),
-				newEffects, oldContents.customName()));
+		Optional<Holder<Potion>> newPotion = mainPotionContainsTargetEffect
+			? Optional.empty() : oldContents.potion();
+		stack.set(DataComponents.POTION_CONTENTS, new PotionContents(newPotion,
+			oldContents.customColor(), newEffects, oldContents.customName()));
 		
 		ChatUtils.message("Effect removed.");
 	}
 	
-	private RegistryEntry<StatusEffect> parseEffect(String input)
-		throws CmdSyntaxError
+	private Holder<MobEffect> parseEffect(String input) throws CmdSyntaxError
 	{
-		StatusEffect effect;
+		MobEffect effect;
 		
 		if(MathUtils.isInteger(input))
-			effect = Registries.STATUS_EFFECT.get(Integer.parseInt(input));
+			effect = BuiltInRegistries.MOB_EFFECT.byId(Integer.parseInt(input));
 		else
 			try
 			{
-				Identifier identifier = Identifier.of(input);
-				effect = Registries.STATUS_EFFECT.get(identifier);
+				ResourceLocation identifier = ResourceLocation.parse(input);
+				effect = BuiltInRegistries.MOB_EFFECT.getValue(identifier);
 				
-			}catch(InvalidIdentifierException e)
+			}catch(ResourceLocationException e)
 			{
 				throw new CmdSyntaxError("Invalid effect: " + input);
 			}
@@ -154,7 +147,7 @@ public final class PotionCmd extends Command
 		if(effect == null)
 			throw new CmdSyntaxError("Invalid effect: " + input);
 		
-		return Registries.STATUS_EFFECT.getEntry(effect);
+		return BuiltInRegistries.MOB_EFFECT.wrapAsHolder(effect);
 	}
 	
 	private int parseInt(String s) throws CmdSyntaxError
diff --git a/src/main/java/net/wurstclient/commands/ProtectCmd.java b/src/main/java/net/wurstclient/commands/ProtectCmd.java
index 8ff1cb8c8..2a3102bf9 100644
--- a/src/main/java/net/wurstclient/commands/ProtectCmd.java
+++ b/src/main/java/net/wurstclient/commands/ProtectCmd.java
@@ -9,9 +9,8 @@ package net.wurstclient.commands;
 
 import java.util.Comparator;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -39,14 +38,13 @@ public final class ProtectCmd extends Command
 			protectHack.setEnabled(false);
 		
 		Entity entity = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), true)
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(LivingEntity.class::isInstance)
 			.filter(e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
 			.filter(e -> args[0].equalsIgnoreCase(e.getName().getString()))
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		if(entity == null)
diff --git a/src/main/java/net/wurstclient/commands/RenameCmd.java b/src/main/java/net/wurstclient/commands/RenameCmd.java
index 9b5a03aa6..c0c6f389c 100644
--- a/src/main/java/net/wurstclient/commands/RenameCmd.java
+++ b/src/main/java/net/wurstclient/commands/RenameCmd.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.item.ItemStack;
-import net.minecraft.text.Text;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -28,7 +28,7 @@ public final class RenameCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
 		if(args.length == 0)
@@ -39,12 +39,12 @@ public final class RenameCmd extends Command
 			message += " " + args[i];
 		
 		message = message.replace("$", "\u00a7").replace("\u00a7\u00a7", "$");
-		ItemStack stack = MC.player.getInventory().getSelectedStack();
+		ItemStack stack = MC.player.getInventory().getSelectedItem();
 		
 		if(stack == null)
 			throw new CmdError("There is no item in your hand.");
 		
-		stack.set(DataComponentTypes.CUSTOM_NAME, Text.literal(message));
+		stack.set(DataComponents.CUSTOM_NAME, Component.literal(message));
 		ChatUtils.message("Renamed item to \"\u00a7o" + message + "\u00a7r\".");
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/RepairCmd.java b/src/main/java/net/wurstclient/commands/RepairCmd.java
index 799d99ffb..c0eb22bca 100644
--- a/src/main/java/net/wurstclient/commands/RepairCmd.java
+++ b/src/main/java/net/wurstclient/commands/RepairCmd.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.item.ItemStack;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -30,27 +30,27 @@ public final class RepairCmd extends Command
 		if(args.length > 0)
 			throw new CmdSyntaxError();
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		if(!player.getAbilities().creativeMode)
+		if(!player.getAbilities().instabuild)
 			throw new CmdError("Creative mode only.");
 		
 		int slot = player.getInventory().getSelectedSlot();
 		ItemStack stack = getHeldStack(player);
-		stack.setDamage(0);
+		stack.setDamageValue(0);
 		InventoryUtils.setCreativeStack(slot, stack);
 		
 		ChatUtils.message("Item repaired.");
 	}
 	
-	private ItemStack getHeldStack(ClientPlayerEntity player) throws CmdError
+	private ItemStack getHeldStack(LocalPlayer player) throws CmdError
 	{
-		ItemStack stack = player.getInventory().getSelectedStack();
+		ItemStack stack = player.getInventory().getSelectedItem();
 		
 		if(stack.isEmpty())
 			throw new CmdError("You need an item in your hand.");
 		
-		if(!stack.isDamageable())
+		if(!stack.isDamageableItem())
 			throw new CmdError("This item can't take damage.");
 		
 		if(!stack.isDamaged())
diff --git a/src/main/java/net/wurstclient/commands/SayCmd.java b/src/main/java/net/wurstclient/commands/SayCmd.java
index d097a02fd..705ccf167 100644
--- a/src/main/java/net/wurstclient/commands/SayCmd.java
+++ b/src/main/java/net/wurstclient/commands/SayCmd.java
@@ -30,8 +30,8 @@ public final class SayCmd extends Command
 		
 		String message = String.join(" ", args);
 		if(message.startsWith("/"))
-			MC.getNetworkHandler().sendChatCommand(message.substring(1));
+			MC.getConnection().sendCommand(message.substring(1));
 		else
-			MC.getNetworkHandler().sendChatMessage(message);
+			MC.getConnection().sendChat(message);
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/SetBlockCmd.java b/src/main/java/net/wurstclient/commands/SetBlockCmd.java
index 9da4a359a..478ff88c7 100644
--- a/src/main/java/net/wurstclient/commands/SetBlockCmd.java
+++ b/src/main/java/net/wurstclient/commands/SetBlockCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.block.Block;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.DontBlock;
 import net.wurstclient.Feature;
 import net.wurstclient.command.CmdError;
diff --git a/src/main/java/net/wurstclient/commands/SvCmd.java b/src/main/java/net/wurstclient/commands/SvCmd.java
index cee108b98..f2a315498 100644
--- a/src/main/java/net/wurstclient/commands/SvCmd.java
+++ b/src/main/java/net/wurstclient/commands/SvCmd.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ServerInfo;
+import net.minecraft.client.multiplayer.ServerData;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -34,10 +34,10 @@ public final class SvCmd extends Command
 	
 	private String getVersion() throws CmdError
 	{
-		if(MC.isIntegratedServerRunning())
+		if(MC.hasSingleplayerServer())
 			throw new CmdError("Can't check server version in singleplayer.");
 		
-		ServerInfo lastServer = LastServerRememberer.getLastServer();
+		ServerData lastServer = LastServerRememberer.getLastServer();
 		if(lastServer == null)
 			throw new IllegalStateException(
 				"LastServerRememberer doesn't remember the last server!");
diff --git a/src/main/java/net/wurstclient/commands/TpCmd.java b/src/main/java/net/wurstclient/commands/TpCmd.java
index 62a2bd1d5..190023f6b 100644
--- a/src/main/java/net/wurstclient/commands/TpCmd.java
+++ b/src/main/java/net/wurstclient/commands/TpCmd.java
@@ -9,9 +9,8 @@ package net.wurstclient.commands;
 
 import java.util.Comparator;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -45,7 +44,7 @@ public final class TpCmd extends Command
 		if(disableFreecam.isChecked() && WURST.getHax().freecamHack.isEnabled())
 			WURST.getHax().freecamHack.setEnabled(false);
 		
-		MC.player.setPosition(pos.getX() + 0.5, pos.getY(), pos.getZ() + 0.5);
+		MC.player.setPos(pos.getX() + 0.5, pos.getY(), pos.getZ() + 0.5);
 	}
 	
 	private BlockPos argsToPos(String... args) throws CmdException
@@ -66,25 +65,24 @@ public final class TpCmd extends Command
 	private BlockPos argsToEntityPos(String name) throws CmdError
 	{
 		LivingEntity entity = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), true)
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(LivingEntity.class::isInstance).map(e -> (LivingEntity)e)
 			.filter(e -> !e.isRemoved() && e.getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
 			.filter(e -> name.equalsIgnoreCase(e.getDisplayName().getString()))
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		if(entity == null)
 			throw new CmdError("Entity \"" + name + "\" could not be found.");
 		
-		return BlockPos.ofFloored(entity.getEntityPos());
+		return BlockPos.containing(entity.position());
 	}
 	
 	private BlockPos argsToXyzPos(String... xyz) throws CmdSyntaxError
 	{
-		BlockPos playerPos = BlockPos.ofFloored(MC.player.getEntityPos());
+		BlockPos playerPos = BlockPos.containing(MC.player.position());
 		int[] player = {playerPos.getX(), playerPos.getY(), playerPos.getZ()};
 		int[] pos = new int[3];
 		
diff --git a/src/main/java/net/wurstclient/commands/VClipCmd.java b/src/main/java/net/wurstclient/commands/VClipCmd.java
index 793a2a48d..391b00f75 100644
--- a/src/main/java/net/wurstclient/commands/VClipCmd.java
+++ b/src/main/java/net/wurstclient/commands/VClipCmd.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.Direction;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
 import net.wurstclient.command.CmdSyntaxError;
@@ -56,16 +56,16 @@ public final class VClipCmd extends Command
 	
 	private double calculateHeight(Direction direction) throws CmdError
 	{
-		Box box = MC.player.getBoundingBox();
+		AABB box = MC.player.getBoundingBox();
 		
-		Box maxOffsetBox = box.offset(0, direction.getOffsetY() * 10, 0);
-		if(!hasCollisions(box.union(maxOffsetBox)))
+		AABB maxOffsetBox = box.move(0, direction.getStepY() * 10, 0);
+		if(!hasCollisions(box.minmax(maxOffsetBox)))
 			throw new CmdError("There is nothing to clip through!");
 		
 		for(int i = 1; i <= 10; i++)
 		{
-			double height = direction.getOffsetY() * i;
-			Box offsetBox = box.offset(0, height, 0);
+			double height = direction.getStepY() * i;
+			AABB offsetBox = box.move(0, height, 0);
 			
 			if(hasCollisions(offsetBox))
 			{
@@ -73,7 +73,7 @@ public final class VClipCmd extends Command
 				if(subBlockOffset >= 1 || height + subBlockOffset > 10)
 					continue;
 				
-				Box newOffsetBox = offsetBox.offset(0, subBlockOffset, 0);
+				AABB newOffsetBox = offsetBox.move(0, subBlockOffset, 0);
 				if(hasCollisions(newOffsetBox))
 					continue;
 				
@@ -81,7 +81,7 @@ public final class VClipCmd extends Command
 				offsetBox = newOffsetBox;
 			}
 			
-			if(!hasCollisions(box.union(offsetBox)))
+			if(!hasCollisions(box.minmax(offsetBox)))
 				continue;
 			
 			return height;
@@ -90,12 +90,12 @@ public final class VClipCmd extends Command
 		throw new CmdError("There are no free blocks where you can fit!");
 	}
 	
-	private boolean hasCollisions(Box box)
+	private boolean hasCollisions(AABB box)
 	{
 		return BlockUtils.getBlockCollisions(box).findAny().isPresent();
 	}
 	
-	private double getSubBlockOffset(Box offsetBox)
+	private double getSubBlockOffset(AABB offsetBox)
 	{
 		return BlockUtils.getBlockCollisions(offsetBox)
 			.mapToDouble(box -> box.maxY).max().getAsDouble() - offsetBox.minY;
@@ -103,7 +103,7 @@ public final class VClipCmd extends Command
 	
 	private void vclip(double height)
 	{
-		ClientPlayerEntity p = MC.player;
-		p.setPosition(p.getX(), p.getY() + height, p.getZ());
+		LocalPlayer p = MC.player;
+		p.setPos(p.getX(), p.getY() + height, p.getZ());
 	}
 }
diff --git a/src/main/java/net/wurstclient/commands/ViewCompCmd.java b/src/main/java/net/wurstclient/commands/ViewCompCmd.java
index 30ccb8d5b..74e51e509 100644
--- a/src/main/java/net/wurstclient/commands/ViewCompCmd.java
+++ b/src/main/java/net/wurstclient/commands/ViewCompCmd.java
@@ -13,10 +13,9 @@ import com.google.gson.JsonElement;
 import com.google.gson.JsonNull;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.component.Component;
-import net.minecraft.item.ItemStack;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.component.TypedDataComponent;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.SearchTags;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
@@ -39,8 +38,8 @@ public final class ViewCompCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		ClientPlayerEntity player = MC.player;
-		ItemStack stack = player.getInventory().getSelectedStack();
+		LocalPlayer player = MC.player;
+		ItemStack stack = player.getInventory().getSelectedItem();
 		if(stack.isEmpty())
 			throw new CmdError("You must hold an item in your main hand.");
 		
@@ -69,7 +68,7 @@ public final class ViewCompCmd extends Command
 		String compString = getComponentString(stack, query);
 		if(copy)
 		{
-			MC.keyboard.setClipboard(compString);
+			MC.keyboardHandler.setClipboard(compString);
 			ChatUtils.message("Component data copied to clipboard.");
 		}else
 			ChatUtils.message("Components: " + compString);
@@ -78,12 +77,12 @@ public final class ViewCompCmd extends Command
 	private String getComponentString(ItemStack stack, String query)
 	{
 		String compString = "";
-		for(Component<?> c : getMatchingComponents(stack, query))
+		for(TypedDataComponent<?> c : getMatchingComponents(stack, query))
 		{
 			compString +=
 				"\n" + c.type().toString().replace("minecraft:", "") + " => ";
-			DataResult<JsonElement> result = c.encode(
-				MC.player.getRegistryManager().getOps(JsonOps.INSTANCE));
+			DataResult<JsonElement> result = c.encodeValue(MC.player
+				.registryAccess().createSerializationContext(JsonOps.INSTANCE));
 			JsonElement json =
 				result.resultOrPartial().orElse(JsonNull.INSTANCE);
 			compString += JsonUtils.GSON.toJson(json).replace("$", "$$")
@@ -92,7 +91,7 @@ public final class ViewCompCmd extends Command
 		return compString;
 	}
 	
-	private List<Component<?>> getMatchingComponents(ItemStack stack,
+	private List<TypedDataComponent<?>> getMatchingComponents(ItemStack stack,
 		String query)
 	{
 		if(query == null)
diff --git a/src/main/java/net/wurstclient/commands/ViewNbtCmd.java b/src/main/java/net/wurstclient/commands/ViewNbtCmd.java
index ec8de4809..f90e18134 100644
--- a/src/main/java/net/wurstclient/commands/ViewNbtCmd.java
+++ b/src/main/java/net/wurstclient/commands/ViewNbtCmd.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.commands;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.NbtComponent;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NbtCompound;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
 import net.wurstclient.SearchTags;
 import net.wurstclient.command.CmdError;
 import net.wurstclient.command.CmdException;
@@ -31,14 +31,14 @@ public final class ViewNbtCmd extends Command
 	@Override
 	public void call(String[] args) throws CmdException
 	{
-		ClientPlayerEntity player = MC.player;
-		ItemStack stack = player.getInventory().getSelectedStack();
+		LocalPlayer player = MC.player;
+		ItemStack stack = player.getInventory().getSelectedItem();
 		if(stack.isEmpty())
 			throw new CmdError("You must hold an item in your main hand.");
 		
-		NbtCompound tag = stack
-			.getOrDefault(DataComponentTypes.CUSTOM_DATA, NbtComponent.DEFAULT)
-			.copyNbt();
+		CompoundTag tag =
+			stack.getOrDefault(DataComponents.CUSTOM_DATA, CustomData.EMPTY)
+				.copyTag();
 		String nbtString = tag.toString();
 		
 		switch(String.join(" ", args).toLowerCase())
@@ -48,7 +48,7 @@ public final class ViewNbtCmd extends Command
 			break;
 			
 			case "copy":
-			MC.keyboard.setClipboard(nbtString);
+			MC.keyboardHandler.setClipboard(nbtString);
 			ChatUtils.message("NBT data copied to clipboard.");
 			break;
 			
diff --git a/src/main/java/net/wurstclient/event/EventManager.java b/src/main/java/net/wurstclient/event/EventManager.java
index 925bde11b..cf4ac0b8b 100644
--- a/src/main/java/net/wurstclient/event/EventManager.java
+++ b/src/main/java/net/wurstclient/event/EventManager.java
@@ -11,10 +11,9 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Objects;
-
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
-import net.minecraft.util.crash.CrashReportSection;
+import net.minecraft.CrashReport;
+import net.minecraft.CrashReportCategory;
+import net.minecraft.ReportedException;
 import net.wurstclient.WurstClient;
 
 public final class EventManager
@@ -72,11 +71,12 @@ public final class EventManager
 		{
 			e.printStackTrace();
 			
-			CrashReport report = CrashReport.create(e, "Firing Wurst event");
-			CrashReportSection section = report.addElement("Affected event");
-			section.add("Event class", () -> event.getClass().getName());
+			CrashReport report =
+				CrashReport.forThrowable(e, "Firing Wurst event");
+			CrashReportCategory section = report.addCategory("Affected event");
+			section.setDetail("Event class", () -> event.getClass().getName());
 			
-			throw new CrashException(report);
+			throw new ReportedException(report);
 		}
 	}
 	
@@ -101,12 +101,14 @@ public final class EventManager
 			e.printStackTrace();
 			
 			CrashReport report =
-				CrashReport.create(e, "Adding Wurst event listener");
-			CrashReportSection section = report.addElement("Affected listener");
-			section.add("Listener type", () -> type.getName());
-			section.add("Listener class", () -> listener.getClass().getName());
+				CrashReport.forThrowable(e, "Adding Wurst event listener");
+			CrashReportCategory section =
+				report.addCategory("Affected listener");
+			section.setDetail("Listener type", () -> type.getName());
+			section.setDetail("Listener class",
+				() -> listener.getClass().getName());
 			
-			throw new CrashException(report);
+			throw new ReportedException(report);
 		}
 	}
 	
@@ -125,12 +127,14 @@ public final class EventManager
 			e.printStackTrace();
 			
 			CrashReport report =
-				CrashReport.create(e, "Removing Wurst event listener");
-			CrashReportSection section = report.addElement("Affected listener");
-			section.add("Listener type", () -> type.getName());
-			section.add("Listener class", () -> listener.getClass().getName());
+				CrashReport.forThrowable(e, "Removing Wurst event listener");
+			CrashReportCategory section =
+				report.addCategory("Affected listener");
+			section.setDetail("Listener type", () -> type.getName());
+			section.setDetail("Listener class",
+				() -> listener.getClass().getName());
 			
-			throw new CrashException(report);
+			throw new ReportedException(report);
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/events/BlockBreakingProgressListener.java b/src/main/java/net/wurstclient/events/BlockBreakingProgressListener.java
index ce334f038..9280a2a87 100644
--- a/src/main/java/net/wurstclient/events/BlockBreakingProgressListener.java
+++ b/src/main/java/net/wurstclient/events/BlockBreakingProgressListener.java
@@ -8,9 +8,8 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/CactusCollisionShapeListener.java b/src/main/java/net/wurstclient/events/CactusCollisionShapeListener.java
index d30e42f58..a625012bf 100644
--- a/src/main/java/net/wurstclient/events/CactusCollisionShapeListener.java
+++ b/src/main/java/net/wurstclient/events/CactusCollisionShapeListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.util.shape.VoxelShape;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/ChatInputListener.java b/src/main/java/net/wurstclient/events/ChatInputListener.java
index 4bb22440e..ae11370a5 100644
--- a/src/main/java/net/wurstclient/events/ChatInputListener.java
+++ b/src/main/java/net/wurstclient/events/ChatInputListener.java
@@ -9,9 +9,8 @@ package net.wurstclient.events;
 
 import java.util.ArrayList;
 import java.util.List;
-
-import net.minecraft.client.gui.hud.ChatHudLine;
-import net.minecraft.text.Text;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
@@ -22,27 +21,27 @@ public interface ChatInputListener extends Listener
 	public static class ChatInputEvent
 		extends CancellableEvent<ChatInputListener>
 	{
-		private Text component;
-		private List<ChatHudLine.Visible> chatLines;
+		private Component component;
+		private List<GuiMessage.Line> chatLines;
 		
-		public ChatInputEvent(Text component,
-			List<ChatHudLine.Visible> visibleMessages)
+		public ChatInputEvent(Component component,
+			List<GuiMessage.Line> visibleMessages)
 		{
 			this.component = component;
 			chatLines = visibleMessages;
 		}
 		
-		public Text getComponent()
+		public Component getComponent()
 		{
 			return component;
 		}
 		
-		public void setComponent(Text component)
+		public void setComponent(Component component)
 		{
 			this.component = component;
 		}
 		
-		public List<ChatHudLine.Visible> getChatLines()
+		public List<GuiMessage.Line> getChatLines()
 		{
 			return chatLines;
 		}
diff --git a/src/main/java/net/wurstclient/events/ConnectionPacketOutputListener.java b/src/main/java/net/wurstclient/events/ConnectionPacketOutputListener.java
index ad4ffc2cd..385d00348 100644
--- a/src/main/java/net/wurstclient/events/ConnectionPacketOutputListener.java
+++ b/src/main/java/net/wurstclient/events/ConnectionPacketOutputListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.network.packet.Packet;
+import net.minecraft.network.protocol.Packet;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 import net.wurstclient.events.PacketOutputListener.PacketOutputEvent;
diff --git a/src/main/java/net/wurstclient/events/GUIRenderListener.java b/src/main/java/net/wurstclient/events/GUIRenderListener.java
index 5dbbb3f77..dd0dc3768 100644
--- a/src/main/java/net/wurstclient/events/GUIRenderListener.java
+++ b/src/main/java/net/wurstclient/events/GUIRenderListener.java
@@ -8,21 +8,20 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
 public interface GUIRenderListener extends Listener
 {
-	public void onRenderGUI(DrawContext context, float partialTicks);
+	public void onRenderGUI(GuiGraphics context, float partialTicks);
 	
 	public static class GUIRenderEvent extends Event<GUIRenderListener>
 	{
 		private final float partialTicks;
-		private final DrawContext context;
+		private final GuiGraphics context;
 		
-		public GUIRenderEvent(DrawContext context, float partialTicks)
+		public GUIRenderEvent(GuiGraphics context, float partialTicks)
 		{
 			this.context = context;
 			this.partialTicks = partialTicks;
diff --git a/src/main/java/net/wurstclient/events/GetAmbientOcclusionLightLevelListener.java b/src/main/java/net/wurstclient/events/GetAmbientOcclusionLightLevelListener.java
index 05e490aea..dbac5e2e5 100644
--- a/src/main/java/net/wurstclient/events/GetAmbientOcclusionLightLevelListener.java
+++ b/src/main/java/net/wurstclient/events/GetAmbientOcclusionLightLevelListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.block.BlockState;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/HandleBlockBreakingListener.java b/src/main/java/net/wurstclient/events/HandleBlockBreakingListener.java
index 9e7a15097..a88dcbb21 100644
--- a/src/main/java/net/wurstclient/events/HandleBlockBreakingListener.java
+++ b/src/main/java/net/wurstclient/events/HandleBlockBreakingListener.java
@@ -8,28 +8,27 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
 /**
  * Fired at the beginning of
- * {@link MinecraftClient#handleBlockBreaking(boolean)}.
+ * {@link Minecraft#continueAttack(boolean)}.
  * Allows you to cancel vanilla block breaking and replace it with your own.
  */
 public interface HandleBlockBreakingListener extends Listener
 {
 	/**
 	 * Fired at the beginning of
-	 * {@link MinecraftClient#handleBlockBreaking(boolean)}.
+	 * {@link Minecraft#continueAttack(boolean)}.
 	 * Allows you to cancel vanilla block breaking and replace it with your own.
 	 */
 	public void onHandleBlockBreaking(HandleBlockBreakingEvent event);
 	
 	/**
 	 * Fired at the beginning of
-	 * {@link MinecraftClient#handleBlockBreaking(boolean)}.
+	 * {@link Minecraft#continueAttack(boolean)}.
 	 * Allows you to cancel vanilla block breaking and replace it with your own.
 	 */
 	public static class HandleBlockBreakingEvent
diff --git a/src/main/java/net/wurstclient/events/HandleInputListener.java b/src/main/java/net/wurstclient/events/HandleInputListener.java
index 0a5e12c7c..44621bc21 100644
--- a/src/main/java/net/wurstclient/events/HandleInputListener.java
+++ b/src/main/java/net/wurstclient/events/HandleInputListener.java
@@ -8,25 +8,24 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
 /**
- * Fired at the beginning of {@link MinecraftClient#handleInputEvents()}.
+ * Fired at the beginning of {@link Minecraft#handleKeybinds()}.
  * This is the ideal time to simulate keyboard input.
  */
 public interface HandleInputListener extends Listener
 {
 	/**
-	 * Fired at the beginning of {@link MinecraftClient#handleInputEvents()}.
+	 * Fired at the beginning of {@link Minecraft#handleKeybinds()}.
 	 * This is the ideal time to simulate keyboard input.
 	 */
 	public void onHandleInput();
 	
 	/**
-	 * Fired at the beginning of {@link MinecraftClient#handleInputEvents()}.
+	 * Fired at the beginning of {@link Minecraft#handleKeybinds()}.
 	 * This is the ideal time to simulate keyboard input.
 	 */
 	public static class HandleInputEvent extends Event<HandleInputListener>
diff --git a/src/main/java/net/wurstclient/events/MouseUpdateListener.java b/src/main/java/net/wurstclient/events/MouseUpdateListener.java
index 8066f0917..efc0e58d3 100644
--- a/src/main/java/net/wurstclient/events/MouseUpdateListener.java
+++ b/src/main/java/net/wurstclient/events/MouseUpdateListener.java
@@ -8,25 +8,26 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.Mouse;
+import net.minecraft.client.MouseHandler;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
 /**
- * Fired at the beginning of {@link Mouse#tick()}.
+ * Fired at the beginning of {@link MouseHandler#handleAccumulatedMovement()}.
  * This is the ideal time to simulate mouse input.
  */
 public interface MouseUpdateListener extends Listener
 {
 	/**
-	 * Fired at the beginning of {@link Mouse#tick()}.
+	 * Fired at the beginning of
+	 * {@link MouseHandler#handleAccumulatedMovement()}.
 	 * This is the ideal time to simulate mouse input.
 	 */
 	public void onMouseUpdate(MouseUpdateEvent event);
 	
 	/**
-	 * Fired at the beginning of {@link Mouse#tick()}.
+	 * Fired at the beginning of
+	 * {@link MouseHandler#handleAccumulatedMovement()}.
 	 * This is the ideal time to simulate mouse input.
 	 */
 	public static class MouseUpdateEvent extends Event<MouseUpdateListener>
diff --git a/src/main/java/net/wurstclient/events/PacketInputListener.java b/src/main/java/net/wurstclient/events/PacketInputListener.java
index 96d03a612..1343eb644 100644
--- a/src/main/java/net/wurstclient/events/PacketInputListener.java
+++ b/src/main/java/net/wurstclient/events/PacketInputListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.network.packet.Packet;
+import net.minecraft.network.protocol.Packet;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/PacketOutputListener.java b/src/main/java/net/wurstclient/events/PacketOutputListener.java
index 88b2daafc..dab64dbfd 100644
--- a/src/main/java/net/wurstclient/events/PacketOutputListener.java
+++ b/src/main/java/net/wurstclient/events/PacketOutputListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.network.packet.Packet;
+import net.minecraft.network.protocol.Packet;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/PlayerAttacksEntityListener.java b/src/main/java/net/wurstclient/events/PlayerAttacksEntityListener.java
index bbd63b171..54b91183e 100644
--- a/src/main/java/net/wurstclient/events/PlayerAttacksEntityListener.java
+++ b/src/main/java/net/wurstclient/events/PlayerAttacksEntityListener.java
@@ -8,28 +8,27 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
 /**
  * Fired at the beginning of
- * {@link ClientPlayerInteractionManager#attackEntity(PlayerEntity, Entity)}.
+ * {@link MultiPlayerGameMode#attack(Player, Entity)}.
  */
 public interface PlayerAttacksEntityListener extends Listener
 {
 	/**
 	 * Fired at the beginning of
-	 * {@link ClientPlayerInteractionManager#attackEntity(PlayerEntity, Entity)}.
+	 * {@link MultiPlayerGameMode#attack(Player, Entity)}.
 	 */
 	public void onPlayerAttacksEntity(Entity target);
 	
 	/**
 	 * Fired at the beginning of
-	 * {@link ClientPlayerInteractionManager#attackEntity(PlayerEntity, Entity)}.
+	 * {@link MultiPlayerGameMode#attack(Player, Entity)}.
 	 */
 	public static class PlayerAttacksEntityEvent
 		extends Event<PlayerAttacksEntityListener>
diff --git a/src/main/java/net/wurstclient/events/RenderBlockEntityListener.java b/src/main/java/net/wurstclient/events/RenderBlockEntityListener.java
index 580d22f8d..cc3874155 100644
--- a/src/main/java/net/wurstclient/events/RenderBlockEntityListener.java
+++ b/src/main/java/net/wurstclient/events/RenderBlockEntityListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.render.block.entity.state.BlockEntityRenderState;
+import net.minecraft.client.renderer.blockentity.state.BlockEntityRenderState;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/RenderListener.java b/src/main/java/net/wurstclient/events/RenderListener.java
index b55ef476e..14ecc88dc 100644
--- a/src/main/java/net/wurstclient/events/RenderListener.java
+++ b/src/main/java/net/wurstclient/events/RenderListener.java
@@ -7,22 +7,21 @@
  */
 package net.wurstclient.events;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
-
-import net.minecraft.client.util.math.MatrixStack;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
 public interface RenderListener extends Listener
 {
-	public void onRender(MatrixStack matrixStack, float partialTicks);
+	public void onRender(PoseStack matrixStack, float partialTicks);
 	
 	public static class RenderEvent extends Event<RenderListener>
 	{
-		private final MatrixStack matrixStack;
+		private final PoseStack matrixStack;
 		private final float partialTicks;
 		
-		public RenderEvent(MatrixStack matrixStack, float partialTicks)
+		public RenderEvent(PoseStack matrixStack, float partialTicks)
 		{
 			this.matrixStack = matrixStack;
 			this.partialTicks = partialTicks;
diff --git a/src/main/java/net/wurstclient/events/RightClickListener.java b/src/main/java/net/wurstclient/events/RightClickListener.java
index 24bbf676f..4c7eea666 100644
--- a/src/main/java/net/wurstclient/events/RightClickListener.java
+++ b/src/main/java/net/wurstclient/events/RightClickListener.java
@@ -8,15 +8,14 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
 public interface RightClickListener extends Listener
 {
 	/**
-	 * Fired in {@link MinecraftClient#doItemUse()} after the
+	 * Fired in {@link Minecraft#startUseItem()} after the
 	 * {@code interactionManager.isBreakingBlock()} check, but before the
 	 * item use cooldown is increased.
 	 */
diff --git a/src/main/java/net/wurstclient/events/ShouldDrawSideListener.java b/src/main/java/net/wurstclient/events/ShouldDrawSideListener.java
index dad339fc4..72b49f78d 100644
--- a/src/main/java/net/wurstclient/events/ShouldDrawSideListener.java
+++ b/src/main/java/net/wurstclient/events/ShouldDrawSideListener.java
@@ -9,9 +9,8 @@ package net.wurstclient.events;
 
 import java.util.ArrayList;
 import java.util.Objects;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.event.Event;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/VelocityFromEntityCollisionListener.java b/src/main/java/net/wurstclient/events/VelocityFromEntityCollisionListener.java
index 121d8e948..8c0e74604 100644
--- a/src/main/java/net/wurstclient/events/VelocityFromEntityCollisionListener.java
+++ b/src/main/java/net/wurstclient/events/VelocityFromEntityCollisionListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/events/VelocityFromFluidListener.java b/src/main/java/net/wurstclient/events/VelocityFromFluidListener.java
index e26e2c7f0..7f4faa3f3 100644
--- a/src/main/java/net/wurstclient/events/VelocityFromFluidListener.java
+++ b/src/main/java/net/wurstclient/events/VelocityFromFluidListener.java
@@ -8,8 +8,7 @@
 package net.wurstclient.events;
 
 import java.util.ArrayList;
-
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.event.CancellableEvent;
 import net.wurstclient.event.Listener;
 
diff --git a/src/main/java/net/wurstclient/hack/HackList.java b/src/main/java/net/wurstclient/hack/HackList.java
index 6026a3f61..32eb20544 100644
--- a/src/main/java/net/wurstclient/hack/HackList.java
+++ b/src/main/java/net/wurstclient/hack/HackList.java
@@ -17,9 +17,8 @@ import java.util.Collections;
 import java.util.TreeMap;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.UpdateListener;
@@ -252,8 +251,8 @@ public final class HackList implements UpdateListener
 		}catch(Exception e)
 		{
 			String message = "Initializing Wurst hacks";
-			CrashReport report = CrashReport.create(e, message);
-			throw new CrashException(report);
+			CrashReport report = CrashReport.forThrowable(e, message);
+			throw new ReportedException(report);
 		}
 		
 		eventManager.add(UpdateListener.class, this);
diff --git a/src/main/java/net/wurstclient/hacks/AimAssistHack.java b/src/main/java/net/wurstclient/hacks/AimAssistHack.java
index 78a2155a1..e84496b1d 100644
--- a/src/main/java/net/wurstclient/hacks/AimAssistHack.java
+++ b/src/main/java/net/wurstclient/hacks/AimAssistHack.java
@@ -10,11 +10,10 @@ package net.wurstclient.hacks;
 import java.util.Comparator;
 import java.util.function.Function;
 import java.util.stream.Stream;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.MouseUpdateListener;
 import net.wurstclient.events.UpdateListener;
@@ -92,7 +91,7 @@ public final class AimAssistHack extends Hack
 	private Entity target;
 	private float nextYaw;
 	private float nextPitch;
-	private Function<Entity, Vec3d> overrideAimPoint;
+	private Function<Entity, Vec3> overrideAimPoint;
 	private Entity externalTarget;
 	
 	public AimAssistHack()
@@ -145,7 +144,7 @@ public final class AimAssistHack extends Hack
 		target = null;
 		
 		// don't aim when a container/inventory screen is open
-		if(MC.currentScreen instanceof HandledScreen)
+		if(MC.screen instanceof AbstractContainerScreen)
 			return;
 		
 		if(!aimWhileBlocking.isChecked() && MC.player.isUsingItem())
@@ -163,7 +162,7 @@ public final class AimAssistHack extends Hack
 		if(target == null)
 			return;
 		
-		Vec3d hitVec = getAimPoint(target);
+		Vec3 hitVec = getAimPoint(target);
 		if(checkLOS.isChecked() && !BlockUtils.hasLineOfSight(hitVec))
 		{
 			target = null;
@@ -187,7 +186,7 @@ public final class AimAssistHack extends Hack
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		
 		double rangeSq = range.getValueSq();
-		stream = stream.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		if(fov.getValue() < 360.0)
 			stream = stream.filter(e -> RotationUtils
@@ -207,8 +206,8 @@ public final class AimAssistHack extends Hack
 		if(target == null || MC.player == null)
 			return;
 		
-		float curYaw = MC.player.getYaw();
-		float curPitch = MC.player.getPitch();
+		float curYaw = MC.player.getYRot();
+		float curPitch = MC.player.getXRot();
 		int diffYaw = (int)(nextYaw - curYaw);
 		int diffPitch = (int)(nextPitch - curPitch);
 		
@@ -229,7 +228,7 @@ public final class AimAssistHack extends Hack
 		event.setDeltaY(mouseInputY + diffPitch);
 	}
 	
-	private Vec3d getAimPoint(Entity entity)
+	private Vec3 getAimPoint(Entity entity)
 	{
 		if(overrideAimPoint != null)
 			return overrideAimPoint.apply(entity);
@@ -237,7 +236,7 @@ public final class AimAssistHack extends Hack
 		return aimAt.getAimPoint(entity);
 	}
 	
-	public void setOverrideAimPoint(Function<Entity, Vec3d> override)
+	public void setOverrideAimPoint(Function<Entity, Vec3> override)
 	{
 		overrideAimPoint = override;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/AirPlaceHack.java b/src/main/java/net/wurstclient/hacks/AirPlaceHack.java
index 52a0dda18..eda18318f 100644
--- a/src/main/java/net/wurstclient/hacks/AirPlaceHack.java
+++ b/src/main/java/net/wurstclient/hacks/AirPlaceHack.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -75,8 +74,8 @@ public final class AirPlaceHack extends Hack
 		if(hitResult == null)
 			return;
 		
-		MC.itemUseCooldown = 4;
-		if(MC.player.isRiding())
+		MC.rightClickDelay = 4;
+		if(MC.player.isHandsBusy())
 			return;
 		
 		InteractionSimulator.rightClickBlock(hitResult);
@@ -91,11 +90,11 @@ public final class AirPlaceHack extends Hack
 		if(!guide.isChecked())
 			return;
 		
-		if(MC.player.getMainHandStack().isEmpty()
-			&& MC.player.getOffHandStack().isEmpty())
+		if(MC.player.getMainHandItem().isEmpty()
+			&& MC.player.getOffhandItem().isEmpty())
 			return;
 		
-		if(MC.player.isRiding())
+		if(MC.player.isHandsBusy())
 			return;
 		
 		BlockHitResult hitResult = getHitResultIfMissed();
@@ -105,7 +104,7 @@ public final class AirPlaceHack extends Hack
 	
 	private BlockHitResult getHitResultIfMissed()
 	{
-		HitResult hitResult = MC.player.raycast(range.getValue(), 0, false);
+		HitResult hitResult = MC.player.pick(range.getValue(), 0, false);
 		if(hitResult.getType() != HitResult.Type.MISS)
 			return null;
 		
@@ -116,12 +115,12 @@ public final class AirPlaceHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(renderPos == null)
 			return;
 		
-		Box box = new Box(renderPos);
+		AABB box = new AABB(renderPos);
 		
 		int quadColor = guideColor.getColorI(0x1A);
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
diff --git a/src/main/java/net/wurstclient/hacks/AnchorAuraHack.java b/src/main/java/net/wurstclient/hacks/AnchorAuraHack.java
index f9f3f0219..57090bde5 100644
--- a/src/main/java/net/wurstclient/hacks/AnchorAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/AnchorAuraHack.java
@@ -13,18 +13,17 @@ import java.util.Map;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.block.Blocks;
-import net.minecraft.block.RespawnAnchorBlock;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.item.Items;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.util.Mth;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.RespawnAnchorBlock;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -104,7 +103,7 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.world.getDimension().respawnAnchorWorks())
+		if(MC.level.dimensionType().respawnAnchorWorks())
 		{
 			ChatUtils.error("Respawn anchors don't explode in this dimension.");
 			setEnabled(false);
@@ -173,7 +172,7 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 		}
 		
 		if(shouldSwing)
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 		
 		return newAnchors;
 	}
@@ -183,7 +182,7 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 		if(isSneaking())
 			return;
 		
-		InventoryUtils.selectItem(stack -> !stack.isOf(Items.GLOWSTONE),
+		InventoryUtils.selectItem(stack -> !stack.is(Items.GLOWSTONE),
 			takeItemsFrom.getSelected().maxInvSlot);
 		if(MC.player.isHolding(Items.GLOWSTONE))
 			return;
@@ -195,7 +194,7 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 				shouldSwing = true;
 			
 		if(shouldSwing)
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 	}
 	
 	private void charge(ArrayList<BlockPos> unchargedAnchors)
@@ -215,19 +214,20 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 				shouldSwing = true;
 			
 		if(shouldSwing)
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 	}
 	
 	private boolean rightClickBlock(BlockPos pos)
 	{
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		Vec3d posVec = Vec3d.ofCenter(pos);
-		double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		Vec3 posVec = Vec3.atCenterOf(pos);
+		double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 		
 		for(Direction side : Direction.values())
 		{
-			Vec3d hitVec = posVec.add(Vec3d.of(side.getVector()).multiply(0.5));
-			double distanceSqHitVec = eyesPos.squaredDistanceTo(hitVec);
+			Vec3 hitVec = posVec
+				.add(Vec3.atLowerCornerOf(side.getUnitVec3i()).scale(0.5));
+			double distanceSqHitVec = eyesPos.distanceToSqr(hitVec);
 			
 			// check if hitVec is within range (6 blocks)
 			if(distanceSqHitVec > 36)
@@ -254,28 +254,28 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	
 	private boolean placeAnchor(BlockPos pos)
 	{
-		Vec3d eyesPos = RotationUtils.getEyesPos();
+		Vec3 eyesPos = RotationUtils.getEyesPos();
 		double rangeSq = range.getValueSq();
-		Vec3d posVec = Vec3d.ofCenter(pos);
-		double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+		Vec3 posVec = Vec3.atCenterOf(pos);
+		double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 		
 		for(Direction side : Direction.values())
 		{
-			BlockPos neighbor = pos.offset(side);
+			BlockPos neighbor = pos.relative(side);
 			
 			// check if neighbor can be right clicked
 			if(!isClickableNeighbor(neighbor))
 				continue;
 			
-			Vec3d dirVec = Vec3d.of(side.getVector());
-			Vec3d hitVec = posVec.add(dirVec.multiply(0.5));
+			Vec3 dirVec = Vec3.atLowerCornerOf(side.getUnitVec3i());
+			Vec3 hitVec = posVec.add(dirVec.scale(0.5));
 			
 			// check if hitVec is within range
-			if(eyesPos.squaredDistanceTo(hitVec) > rangeSq)
+			if(eyesPos.distanceToSqr(hitVec) > rangeSq)
 				continue;
 			
 			// check if side is visible (facing away from player)
-			if(distanceSqPosVec > eyesPos.squaredDistanceTo(posVec.add(dirVec)))
+			if(distanceSqPosVec > eyesPos.distanceToSqr(posVec.add(dirVec)))
 				continue;
 			
 			if(checkLOS.isChecked()
@@ -301,17 +301,18 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	
 	private ArrayList<BlockPos> getNearbyAnchors()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
-		BlockPos center = BlockPos.ofFloored(RotationUtils.getEyesPos());
+		Vec3 eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
+		BlockPos center = BlockPos.containing(RotationUtils.getEyesPos());
 		int rangeI = range.getValueCeil();
-		double rangeSq = MathHelper.square(range.getValue() + 0.5);
+		double rangeSq = Mth.square(range.getValue() + 0.5);
 		
-		Comparator<BlockPos> furthestFromPlayer =
-			Comparator.<BlockPos> comparingDouble(
-				pos -> eyesVec.squaredDistanceTo(Vec3d.of(pos))).reversed();
+		Comparator<BlockPos> furthestFromPlayer = Comparator
+			.<BlockPos> comparingDouble(
+				pos -> eyesVec.distanceToSqr(Vec3.atLowerCornerOf(pos)))
+			.reversed();
 		
-		return BlockUtils.getAllInBoxStream(center, rangeI)
-			.filter(pos -> eyesVec.squaredDistanceTo(Vec3d.of(pos)) <= rangeSq)
+		return BlockUtils.getAllInBoxStream(center, rangeI).filter(
+			pos -> eyesVec.distanceToSqr(Vec3.atLowerCornerOf(pos)) <= rangeSq)
 			.filter(pos -> BlockUtils.getBlock(pos) == Blocks.RESPAWN_ANCHOR)
 			.sorted(furthestFromPlayer)
 			.collect(Collectors.toCollection(ArrayList::new));
@@ -321,20 +322,19 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	{
 		double rangeSq = range.getValueSq();
 		
-		Comparator<Entity> furthestFromPlayer = Comparator
-			.<Entity> comparingDouble(e -> MC.player.squaredDistanceTo(e))
-			.reversed();
+		Comparator<Entity> furthestFromPlayer =
+			Comparator.<Entity> comparingDouble(e -> MC.player.distanceToSqr(e))
+				.reversed();
 		
-		Stream<Entity> stream =
-			StreamSupport.stream(MC.world.getEntities().spliterator(), false)
-				.filter(e -> !e.isRemoved())
-				.filter(e -> e instanceof LivingEntity
-					&& ((LivingEntity)e).getHealth() > 0)
-				.filter(e -> e != MC.player)
-				.filter(e -> !(e instanceof FakePlayerEntity))
-				.filter(
-					e -> !WURST.getFriends().contains(e.getName().getString()))
-				.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		Stream<Entity> stream = StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), false)
+			.filter(e -> !e.isRemoved())
+			.filter(e -> e instanceof LivingEntity
+				&& ((LivingEntity)e).getHealth() > 0)
+			.filter(e -> e != MC.player)
+			.filter(e -> !(e instanceof FakePlayerEntity))
+			.filter(e -> !WURST.getFriends().contains(e.getName().getString()))
+			.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		stream = entityFilters.applyTo(stream);
 		
@@ -344,36 +344,37 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	
 	private ArrayList<BlockPos> getFreeBlocksNear(Entity target)
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
-		double rangeSq = MathHelper.square(range.getValue() + 0.5);
+		Vec3 eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
+		double rangeSq = Mth.square(range.getValue() + 0.5);
 		
-		BlockPos center = target.getBlockPos();
+		BlockPos center = target.blockPosition();
 		int rangeI = 2;
 		
-		Box targetBB = target.getBoundingBox();
-		Vec3d targetEyesVec = target.getEntityPos().add(0,
-			target.getEyeHeight(target.getPose()), 0);
+		AABB targetBB = target.getBoundingBox();
+		Vec3 targetEyesVec =
+			target.position().add(0, target.getEyeHeight(target.getPose()), 0);
 		
 		Comparator<BlockPos> closestToTarget =
 			Comparator.<BlockPos> comparingDouble(
-				pos -> targetEyesVec.squaredDistanceTo(Vec3d.ofCenter(pos)));
+				pos -> targetEyesVec.distanceToSqr(Vec3.atCenterOf(pos)));
 		
-		return BlockUtils.getAllInBoxStream(center, rangeI)
-			.filter(pos -> eyesVec.squaredDistanceTo(Vec3d.of(pos)) <= rangeSq)
+		return BlockUtils.getAllInBoxStream(center, rangeI).filter(
+			pos -> eyesVec.distanceToSqr(Vec3.atLowerCornerOf(pos)) <= rangeSq)
 			.filter(this::isReplaceable).filter(this::hasClickableNeighbor)
-			.filter(pos -> !targetBB.intersects(new Box(pos)))
+			.filter(pos -> !targetBB.intersects(new AABB(pos)))
 			.sorted(closestToTarget)
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
 	
 	private boolean isReplaceable(BlockPos pos)
 	{
-		return BlockUtils.getState(pos).isReplaceable();
+		return BlockUtils.getState(pos).canBeReplaced();
 	}
 	
 	private boolean hasClickableNeighbor(BlockPos pos)
 	{
-		return isClickableNeighbor(pos.up()) || isClickableNeighbor(pos.down())
+		return isClickableNeighbor(pos.above())
+			|| isClickableNeighbor(pos.below())
 			|| isClickableNeighbor(pos.north())
 			|| isClickableNeighbor(pos.east())
 			|| isClickableNeighbor(pos.south())
@@ -383,18 +384,19 @@ public final class AnchorAuraHack extends Hack implements UpdateListener
 	private boolean isClickableNeighbor(BlockPos pos)
 	{
 		return BlockUtils.canBeClicked(pos)
-			&& !BlockUtils.getState(pos).isReplaceable();
+			&& !BlockUtils.getState(pos).canBeReplaced();
 	}
 	
 	private boolean isChargedAnchor(BlockPos pos)
 	{
-		return BlockUtils.getState(pos).getOrEmpty(RespawnAnchorBlock.CHARGES)
-			.orElse(0) > 0;
+		return BlockUtils.getState(pos)
+			.getOptionalValue(RespawnAnchorBlock.CHARGE).orElse(0) > 0;
 	}
 	
 	private boolean isSneaking()
 	{
-		return MC.player.isSneaking() || WURST.getHax().sneakHack.isEnabled();
+		return MC.player.isShiftKeyDown()
+			|| WURST.getHax().sneakHack.isEnabled();
 	}
 	
 	private enum TakeItemsFrom
diff --git a/src/main/java/net/wurstclient/hacks/AntiAfkHack.java b/src/main/java/net/wurstclient/hacks/AntiAfkHack.java
index 9cfdea7c6..77c24fb2e 100644
--- a/src/main/java/net/wurstclient/hacks/AntiAfkHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiAfkHack.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.random.Random;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.ai.PathFinder;
@@ -57,7 +56,7 @@ public final class AntiAfkHack extends Hack
 			"description.wurst.setting.antiafk.show_wait_time", true);
 	
 	private int timer;
-	private Random random = Random.createLocal();
+	private RandomSource random = RandomSource.createNewThreadLocalInstance();
 	private BlockPos start;
 	private BlockPos nextBlock;
 	
@@ -90,7 +89,7 @@ public final class AntiAfkHack extends Hack
 	@Override
 	protected void onEnable()
 	{
-		start = BlockPos.ofFloored(MC.player.getEntityPos());
+		start = BlockPos.containing(MC.player.position());
 		nextBlock = null;
 		pathFinder =
 			new RandomPathFinder(randomize(start, aiRange.getValueI(), true));
@@ -127,10 +126,10 @@ public final class AntiAfkHack extends Hack
 		if(useAi.isChecked())
 		{
 			// prevent drowning
-			if(MC.player.isSubmergedInWater()
+			if(MC.player.isUnderWater()
 				&& !WURST.getHax().jesusHack.isEnabled())
 			{
-				MC.options.jumpKey.setPressed(true);
+				MC.options.keyJump.setDown(true);
 				return;
 			}
 			
@@ -188,16 +187,16 @@ public final class AntiAfkHack extends Hack
 			
 			// face block
 			WURST.getRotationFaker()
-				.faceVectorClientIgnorePitch(Vec3d.ofCenter(nextBlock));
+				.faceVectorClientIgnorePitch(Vec3.atCenterOf(nextBlock));
 			
 			// walk
-			if(MC.player.squaredDistanceTo(Vec3d.ofCenter(nextBlock)) > 0.5)
-				MC.options.forwardKey.setPressed(true);
+			if(MC.player.distanceToSqr(Vec3.atCenterOf(nextBlock)) > 0.5)
+				MC.options.keyUp.setDown(true);
 			else
-				MC.options.forwardKey.setPressed(false);
+				MC.options.keyUp.setDown(false);
 			
 			// swim up
-			MC.options.jumpKey.setPressed(MC.player.isTouchingWater());
+			MC.options.keyJump.setDown(MC.player.isInWater());
 			
 			// update timer
 			if(timer > 0)
@@ -206,7 +205,7 @@ public final class AntiAfkHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(!useAi.isChecked())
 			return;
@@ -230,7 +229,7 @@ public final class AntiAfkHack extends Hack
 		int x = random.nextInt(2 * range + 1) - range;
 		int y = includeY ? random.nextInt(2 * range + 1) - range : 0;
 		int z = random.nextInt(2 * range + 1) - range;
-		return pos.add(x, y, z);
+		return pos.offset(x, y, z);
 	}
 	
 	private class RandomPathFinder extends PathFinder
diff --git a/src/main/java/net/wurstclient/hacks/AntiBlastHack.java b/src/main/java/net/wurstclient/hacks/AntiBlastHack.java
index f5fde8303..8c0165ab0 100644
--- a/src/main/java/net/wurstclient/hacks/AntiBlastHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiBlastHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -40,16 +40,16 @@ public final class AntiBlastHack extends Hack
 		addSetting(vStrength);
 	}
 	
-	public Vec3d modifyKnockback(double defaultX, double defaultY,
+	public Vec3 modifyKnockback(double defaultX, double defaultY,
 		double defaultZ)
 	{
 		if(!isEnabled())
-			return new Vec3d(defaultX, defaultY, defaultZ);
+			return new Vec3(defaultX, defaultY, defaultZ);
 		
 		double horizontalMultiplier = 1 - hStrength.getValue();
 		double verticalMultiplier = 1 - vStrength.getValue();
 		
-		return new Vec3d(defaultX * horizontalMultiplier,
+		return new Vec3(defaultX * horizontalMultiplier,
 			defaultY * verticalMultiplier, defaultZ * horizontalMultiplier);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/AntiCactusHack.java b/src/main/java/net/wurstclient/hacks/AntiCactusHack.java
index 01e4fce7f..afb9097c8 100644
--- a/src/main/java/net/wurstclient/hacks/AntiCactusHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiCactusHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.shape.VoxelShapes;
+import net.minecraft.world.phys.shapes.Shapes;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CactusCollisionShapeListener;
@@ -38,6 +38,6 @@ public final class AntiCactusHack extends Hack
 	@Override
 	public void onCactusCollisionShape(CactusCollisionShapeEvent event)
 	{
-		event.setCollisionShape(VoxelShapes.fullCube());
+		event.setCollisionShape(Shapes.block());
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/AntiDropHack.java b/src/main/java/net/wurstclient/hacks/AntiDropHack.java
index 2ea92429c..f4935f9d7 100644
--- a/src/main/java/net/wurstclient/hacks/AntiDropHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiDropHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -80,7 +80,8 @@ public final class AntiDropHack extends Hack
 		if(stack == null || stack.isEmpty())
 			return false;
 		
-		String itemName = Registries.ITEM.getId(stack.getItem()).toString();
+		String itemName =
+			BuiltInRegistries.ITEM.getKey(stack.getItem()).toString();
 		return items.getItemNames().contains(itemName);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/AntiHungerHack.java b/src/main/java/net/wurstclient/hacks/AntiHungerHack.java
index a6b64f5d5..008bd15b8 100644
--- a/src/main/java/net/wurstclient/hacks/AntiHungerHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiHungerHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -41,13 +41,13 @@ public final class AntiHungerHack extends Hack implements PacketOutputListener
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(!(event.getPacket() instanceof PlayerMoveC2SPacket packet))
+		if(!(event.getPacket() instanceof ServerboundMovePlayerPacket packet))
 			return;
 		
-		if(!MC.player.isOnGround() || MC.player.fallDistance > 0.5)
+		if(!MC.player.onGround() || MC.player.fallDistance > 0.5)
 			return;
 		
-		if(MC.interactionManager.isBreakingBlock())
+		if(MC.gameMode.isDestroying())
 			return;
 		
 		event.setPacket(PacketUtils.modifyOnGround(packet, false));
diff --git a/src/main/java/net/wurstclient/hacks/AntiSpamHack.java b/src/main/java/net/wurstclient/hacks/AntiSpamHack.java
index 16cd2ddee..c44e0b44e 100644
--- a/src/main/java/net/wurstclient/hacks/AntiSpamHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiSpamHack.java
@@ -8,13 +8,12 @@
 package net.wurstclient.hacks;
 
 import java.util.List;
-
-import net.minecraft.client.gui.hud.ChatHud;
-import net.minecraft.client.gui.hud.ChatHudLine;
-import net.minecraft.client.util.ChatMessages;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.OrderedText;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.client.gui.components.ChatComponent;
+import net.minecraft.client.gui.components.ComponentRenderUtils;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.util.FormattedCharSequence;
+import net.minecraft.util.Mth;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.ChatInputListener;
@@ -46,15 +45,14 @@ public final class AntiSpamHack extends Hack implements ChatInputListener
 	@Override
 	public void onReceivedMessage(ChatInputEvent event)
 	{
-		List<ChatHudLine.Visible> chatLines = event.getChatLines();
+		List<GuiMessage.Line> chatLines = event.getChatLines();
 		if(chatLines.isEmpty())
 			return;
 		
-		ChatHud chat = MC.inGameHud.getChatHud();
-		int maxTextLength =
-			MathHelper.floor(chat.getWidth() / chat.getChatScale());
-		List<OrderedText> newLines = ChatMessages.breakRenderedChatMessageLines(
-			event.getComponent(), maxTextLength, MC.textRenderer);
+		ChatComponent chat = MC.gui.getChat();
+		int maxTextLength = Mth.floor(chat.getWidth() / chat.getScale());
+		List<FormattedCharSequence> newLines = ComponentRenderUtils
+			.wrapComponents(event.getComponent(), maxTextLength, MC.font);
 		
 		int spamCounter = 1;
 		int matchingLines = 0;
@@ -140,8 +138,9 @@ public final class AntiSpamHack extends Hack implements ChatInputListener
 			// immutable List<Text> siblings parameter, which causes the game to
 			// crash when calling append(). So we always have to create a new
 			// MutableText object to avoid that.
-			MutableText oldText = (MutableText)event.getComponent();
-			MutableText newText = MutableText.of(oldText.getContent());
+			MutableComponent oldText = (MutableComponent)event.getComponent();
+			MutableComponent newText =
+				MutableComponent.create(oldText.getContents());
 			newText.setStyle(oldText.getStyle());
 			oldText.getSiblings().forEach(newText::append);
 			
diff --git a/src/main/java/net/wurstclient/hacks/AntiWaterPushHack.java b/src/main/java/net/wurstclient/hacks/AntiWaterPushHack.java
index 03315b1cb..f75e15988 100644
--- a/src/main/java/net/wurstclient/hacks/AntiWaterPushHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntiWaterPushHack.java
@@ -53,16 +53,16 @@ public final class AntiWaterPushHack extends Hack implements UpdateListener,
 		if(!preventSlowdown.isChecked())
 			return;
 		
-		if(!MC.options.jumpKey.isPressed())
+		if(!MC.options.keyJump.isDown())
 			return;
 		
-		if(!MC.player.isOnGround())
+		if(!MC.player.onGround())
 			return;
 		
 		if(!IMC.getPlayer().isTouchingWaterBypass())
 			return;
 		
-		MC.player.jump();
+		MC.player.jumpFromGround();
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/AntisocialHack.java b/src/main/java/net/wurstclient/hacks/AntisocialHack.java
index 52c0c45d5..eaacee1be 100644
--- a/src/main/java/net/wurstclient/hacks/AntisocialHack.java
+++ b/src/main/java/net/wurstclient/hacks/AntisocialHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.world.entity.player.Player;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -69,7 +69,7 @@ public final class AntisocialHack extends Hack
 	}
 	
 	@Override
-	public void onPlayerEnter(PlayerEntity player,
+	public void onPlayerEnter(Player player,
 		PlayerRangeAlertManager.PlayerInfo info)
 	{
 		if(triggered)
diff --git a/src/main/java/net/wurstclient/hacks/ArrowDmgHack.java b/src/main/java/net/wurstclient/hacks/ArrowDmgHack.java
index 0fdbeb6c9..9d172d2b9 100644
--- a/src/main/java/net/wurstclient/hacks/ArrowDmgHack.java
+++ b/src/main/java/net/wurstclient/hacks/ArrowDmgHack.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket;
-import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket.Mode;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionAndOnGround;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Pos;
+import net.minecraft.network.protocol.game.ServerboundPlayerCommandPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerCommandPacket.Action;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.StopUsingItemListener;
@@ -57,14 +57,14 @@ public final class ArrowDmgHack extends Hack implements StopUsingItemListener
 	@Override
 	public void onStopUsingItem()
 	{
-		ClientPlayerEntity player = MC.player;
-		ClientPlayNetworkHandler netHandler = player.networkHandler;
+		LocalPlayer player = MC.player;
+		ClientPacketListener netHandler = player.connection;
 		
-		if(!isValidItem(player.getMainHandStack().getItem()))
+		if(!isValidItem(player.getMainHandItem().getItem()))
 			return;
 		
-		netHandler.sendPacket(
-			new ClientCommandC2SPacket(player, Mode.START_SPRINTING));
+		netHandler.send(
+			new ServerboundPlayerCommandPacket(player, Action.START_SPRINTING));
 		
 		double x = player.getX();
 		double y = player.getY();
@@ -74,7 +74,7 @@ public final class ArrowDmgHack extends Hack implements StopUsingItemListener
 		// for why it's using these numbers.
 		// Also, let me know if you find a way to bypass that check in 1.21.
 		double adjustedStrength = strength.getValue() / 10.0 * Math.sqrt(500);
-		Vec3d lookVec = player.getRotationVec(1).multiply(adjustedStrength);
+		Vec3 lookVec = player.getViewVector(1).scale(adjustedStrength);
 		for(int i = 0; i < 4; i++)
 			sendPos(x, y, z, true);
 		sendPos(x - lookVec.x, y, z - lookVec.z, true);
@@ -83,9 +83,9 @@ public final class ArrowDmgHack extends Hack implements StopUsingItemListener
 	
 	private void sendPos(double x, double y, double z, boolean onGround)
 	{
-		ClientPlayNetworkHandler netHandler = MC.player.networkHandler;
-		netHandler.sendPacket(new PositionAndOnGround(x, y, z, onGround,
-			MC.player.horizontalCollision));
+		ClientPacketListener netHandler = MC.player.connection;
+		netHandler
+			.send(new Pos(x, y, z, onGround, MC.player.horizontalCollision));
 	}
 	
 	private boolean isValidItem(Item item)
diff --git a/src/main/java/net/wurstclient/hacks/AutoArmorHack.java b/src/main/java/net/wurstclient/hacks/AutoArmorHack.java
index 9fbc540d8..ccc9295da 100644
--- a/src/main/java/net/wurstclient/hacks/AutoArmorHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoArmorHack.java
@@ -12,22 +12,21 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.Optional;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.enchantment.Enchantments;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.network.packet.c2s.play.ClickSlotC2SPacket;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.entry.RegistryEntry.Reference;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.Holder.Reference;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -96,15 +95,15 @@ public final class AutoArmorHack extends Hack
 		}
 		
 		// check screen
-		if(MC.currentScreen instanceof HandledScreen
-			&& !(MC.currentScreen instanceof InventoryScreen))
+		if(MC.screen instanceof AbstractContainerScreen
+			&& !(MC.screen instanceof InventoryScreen))
 			return;
 		
-		ClientPlayerEntity player = MC.player;
-		PlayerInventory inventory = player.getInventory();
+		LocalPlayer player = MC.player;
+		Inventory inventory = player.getInventory();
 		
 		if(!swapWhileMoving.isChecked()
-			&& player.input.getMovementInput().length() > 1e-5F)
+			&& player.input.getMoveVector().length() > 1e-5F)
 			return;
 		
 		// store slots and values of best armor pieces
@@ -119,8 +118,8 @@ public final class AutoArmorHack extends Hack
 		{
 			bestArmor.put(type, new ArmorData(-1, 0));
 			
-			ItemStack stack = player.getEquippedStack(type);
-			if(!MC.player.canEquip(stack, type))
+			ItemStack stack = player.getItemBySlot(type);
+			if(!MC.player.isEquippableInSlot(stack, type))
 				continue;
 			
 			bestArmor.put(type, new ArmorData(-1, getArmorValue(stack)));
@@ -129,7 +128,7 @@ public final class AutoArmorHack extends Hack
 		// search inventory for better armor
 		for(int slot = 0; slot < 36; slot++)
 		{
-			ItemStack stack = inventory.getStack(slot);
+			ItemStack stack = inventory.getItem(slot);
 			
 			EquipmentSlot armorType = ItemUtils.getArmorSlot(stack.getItem());
 			if(armorType == null)
@@ -153,14 +152,14 @@ public final class AutoArmorHack extends Hack
 				
 			// check if armor can be swapped
 			// needs 1 free slot where it can put the old armor
-			ItemStack oldArmor = player.getEquippedStack(type);
-			if(!oldArmor.isEmpty() && inventory.getEmptySlot() == -1)
+			ItemStack oldArmor = player.getItemBySlot(type);
+			if(!oldArmor.isEmpty() && inventory.getFreeSlot() == -1)
 				continue;
 			
 			// swap armor
 			if(!oldArmor.isEmpty())
 				IMC.getInteractionManager()
-					.windowClick_QUICK_MOVE(8 - type.getEntitySlotId());
+					.windowClick_QUICK_MOVE(8 - type.getIndex());
 			IMC.getInteractionManager().windowClick_QUICK_MOVE(
 				InventoryUtils.toNetworkSlot(data.invSlot()));
 			
@@ -171,7 +170,7 @@ public final class AutoArmorHack extends Hack
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(event.getPacket() instanceof ClickSlotC2SPacket)
+		if(event.getPacket() instanceof ServerboundContainerClickPacket)
 			timer = delay.getValueI();
 	}
 	
@@ -184,16 +183,14 @@ public final class AutoArmorHack extends Hack
 		
 		if(useEnchantments.isChecked())
 		{
-			DynamicRegistryManager drm =
-				WurstClient.MC.world.getRegistryManager();
+			RegistryAccess drm = WurstClient.MC.level.registryAccess();
 			Registry<Enchantment> registry =
-				drm.getOrThrow(RegistryKeys.ENCHANTMENT);
+				drm.lookupOrThrow(Registries.ENCHANTMENT);
 			
 			Optional<Reference<Enchantment>> protection =
-				registry.getOptional(Enchantments.PROTECTION);
-			prtPoints = protection
-				.map(entry -> EnchantmentHelper.getLevel(entry, stack))
-				.orElse(0);
+				registry.get(Enchantments.PROTECTION);
+			prtPoints = protection.map(entry -> EnchantmentHelper
+				.getItemEnchantmentLevel(entry, stack)).orElse(0);
 		}
 		
 		return armorPoints * 5 + prtPoints * 3 + armorToughness;
diff --git a/src/main/java/net/wurstclient/hacks/AutoBuildHack.java b/src/main/java/net/wurstclient/hacks/AutoBuildHack.java
index b53442672..c6d866b49 100644
--- a/src/main/java/net/wurstclient/hacks/AutoBuildHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoBuildHack.java
@@ -7,23 +7,22 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.io.IOException;
 import java.nio.file.Path;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.RenderListener;
 import net.wurstclient.events.RightClickListener;
@@ -40,8 +39,8 @@ import net.wurstclient.util.json.JsonException;
 public final class AutoBuildHack extends Hack
 	implements UpdateListener, RightClickListener, RenderListener
 {
-	private static final Box BLOCK_BOX =
-		new Box(1 / 16.0, 1 / 16.0, 1 / 16.0, 15 / 16.0, 15 / 16.0, 15 / 16.0);
+	private static final AABB BLOCK_BOX =
+		new AABB(1 / 16.0, 1 / 16.0, 1 / 16.0, 15 / 16.0, 15 / 16.0, 15 / 16.0);
 	
 	private final FileSetting templateSetting = new FileSetting("Template",
 		"Determines what to build.\n\n"
@@ -154,7 +153,7 @@ public final class AutoBuildHack extends Hack
 		if(status != Status.IDLE)
 			return;
 		
-		HitResult hitResult = MC.crosshairTarget;
+		HitResult hitResult = MC.hitResult;
 		if(hitResult == null || hitResult.getType() != HitResult.Type.BLOCK
 			|| !(hitResult instanceof BlockHitResult blockHitResult))
 			return;
@@ -163,8 +162,9 @@ public final class AutoBuildHack extends Hack
 		if(!BlockUtils.canBeClicked(hitResultPos))
 			return;
 		
-		BlockPos startPos = hitResultPos.offset(blockHitResult.getSide());
-		Direction direction = MC.player.getHorizontalFacing();
+		BlockPos startPos =
+			hitResultPos.relative(blockHitResult.getDirection());
+		Direction direction = MC.player.getDirection();
 		remainingBlocks = template.getBlocksToPlace(startPos, direction);
 		
 		status = Status.BUILDING;
@@ -194,33 +194,33 @@ public final class AutoBuildHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(status != Status.BUILDING)
 			return;
 		
 		List<BlockPos> blocksToDraw = remainingBlocks.keySet().stream()
-			.filter(pos -> BlockUtils.getState(pos).isReplaceable()).limit(1024)
+			.filter(pos -> BlockUtils.getState(pos).canBeReplaced()).limit(1024)
 			.toList();
 		
 		int black = 0x80000000;
-		List<Box> outlineBoxes =
-			blocksToDraw.stream().map(pos -> BLOCK_BOX.offset(pos)).toList();
+		List<AABB> outlineBoxes =
+			blocksToDraw.stream().map(pos -> BLOCK_BOX.move(pos)).toList();
 		RenderUtils.drawOutlinedBoxes(matrixStack, outlineBoxes, black, true);
 		
 		int green = 0x2600FF00;
-		Vec3d eyesPos = RotationUtils.getEyesPos();
+		Vec3 eyesPos = RotationUtils.getEyesPos();
 		double rangeSq = range.getValueSq();
-		List<Box> greenBoxes = blocksToDraw.stream()
-			.filter(pos -> pos.getSquaredDistance(eyesPos) <= rangeSq)
-			.map(pos -> BLOCK_BOX.offset(pos)).toList();
+		List<AABB> greenBoxes = blocksToDraw.stream()
+			.filter(pos -> pos.distToCenterSqr(eyesPos) <= rangeSq)
+			.map(pos -> BLOCK_BOX.move(pos)).toList();
 		RenderUtils.drawSolidBoxes(matrixStack, greenBoxes, green, true);
 	}
 	
 	private void buildNormally()
 	{
 		remainingBlocks.keySet()
-			.removeIf(pos -> !BlockUtils.getState(pos).isReplaceable());
+			.removeIf(pos -> !BlockUtils.getState(pos).canBeReplaced());
 		
 		if(remainingBlocks.isEmpty())
 		{
@@ -228,7 +228,7 @@ public final class AutoBuildHack extends Hack
 			return;
 		}
 		
-		if(!fastPlace.isChecked() && MC.itemUseCooldown > 0)
+		if(!fastPlace.isChecked() && MC.rightClickDelay > 0)
 			return;
 		
 		double rangeSq = range.getValueSq();
@@ -246,13 +246,13 @@ public final class AutoBuildHack extends Hack
 					continue;
 				
 			if(useSavedBlocks.isChecked() && item != Items.AIR
-				&& !MC.player.getMainHandStack().isOf(item))
+				&& !MC.player.getMainHandItem().is(item))
 			{
 				giveOrSelectItem(item);
 				return;
 			}
 			
-			MC.itemUseCooldown = 4;
+			MC.rightClickDelay = 4;
 			RotationUtils.getNeededRotations(params.hitVec())
 				.sendPlayerLookPacket();
 			InteractionSimulator.rightClickBlock(params.toHitResult());
@@ -265,11 +265,11 @@ public final class AutoBuildHack extends Hack
 		if(InventoryUtils.selectItem(item, 36, true))
 			return;
 		
-		if(!MC.player.isInCreativeMode())
+		if(!MC.player.hasInfiniteMaterials())
 			return;
 		
-		PlayerInventory inventory = MC.player.getInventory();
-		int slot = inventory.getEmptySlot();
+		Inventory inventory = MC.player.getInventory();
+		int slot = inventory.getFreeSlot();
 		if(slot < 0)
 			slot = inventory.getSelectedSlot();
 		
diff --git a/src/main/java/net/wurstclient/hacks/AutoCompleteHack.java b/src/main/java/net/wurstclient/hacks/AutoCompleteHack.java
index edaaf8995..d12fca8f7 100644
--- a/src/main/java/net/wurstclient/hacks/AutoCompleteHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoCompleteHack.java
@@ -10,8 +10,7 @@ package net.wurstclient.hacks;
 import java.util.function.BiConsumer;
 
 import com.mojang.brigadier.suggestion.SuggestionsBuilder;
-
-import net.minecraft.client.gui.screen.ChatScreen;
+import net.minecraft.client.gui.screens.ChatScreen;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.ChatOutputListener;
@@ -97,7 +96,7 @@ public final class AutoCompleteHack extends Hack
 			return;
 		
 		// check if the chat is open
-		if(!(MC.currentScreen instanceof ChatScreen))
+		if(!(MC.screen instanceof ChatScreen))
 			return;
 		
 		// check if we have a draft message and suggestions updater
diff --git a/src/main/java/net/wurstclient/hacks/AutoDisenchantHack.java b/src/main/java/net/wurstclient/hacks/AutoDisenchantHack.java
index 6f79a23d6..93235c50a 100644
--- a/src/main/java/net/wurstclient/hacks/AutoDisenchantHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoDisenchantHack.java
@@ -11,14 +11,14 @@ import java.util.ArrayList;
 import java.util.List;
 
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
-import net.minecraft.client.gui.screen.ingame.GrindstoneScreen;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.registry.tag.EnchantmentTags;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
+import net.minecraft.client.gui.screens.inventory.GrindstoneScreen;
+import net.minecraft.core.Holder;
+import net.minecraft.tags.EnchantmentTags;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -77,12 +77,12 @@ public final class AutoDisenchantHack extends Hack
 			if(!isScreenValid(screen))
 				return;
 			
-			var handler = screen.getScreenHandler();
+			var handler = screen.getMenu();
 			List<Slot> slots = handler.slots;
 			if(slots.size() <= OUTPUT_SLOT)
 				return;
 			
-			if(!handler.getCursorStack().isEmpty())
+			if(!handler.getCarried().isEmpty())
 				return;
 			
 			clearInputSlots(screen);
@@ -95,7 +95,7 @@ public final class AutoDisenchantHack extends Hack
 					break;
 				
 				Slot slot = handler.slots.get(slotIndex);
-				ItemStack stack = slot.getStack();
+				ItemStack stack = slot.getItem();
 				if(stack.isEmpty())
 					continue;
 				
@@ -133,7 +133,7 @@ public final class AutoDisenchantHack extends Hack
 		for(int i = start; i < end; i++)
 		{
 			Slot slot = slots.get(i);
-			if(slot.getStack().isEmpty())
+			if(slot.getItem().isEmpty())
 				continue;
 			targets.add(i);
 		}
@@ -143,24 +143,24 @@ public final class AutoDisenchantHack extends Hack
 	private void disenchantSlot(GrindstoneScreen screen, int slotIndex)
 		throws InterruptedException
 	{
-		var handler = screen.getScreenHandler();
+		var handler = screen.getMenu();
 		Slot inventorySlot = handler.slots.get(slotIndex);
-		if(inventorySlot.getStack().isEmpty())
+		if(inventorySlot.getItem().isEmpty())
 			return;
 		
-		clickAndWait(screen, inventorySlot, SlotActionType.PICKUP);
+		clickAndWait(screen, inventorySlot, ClickType.PICKUP);
 		clickAndWait(screen, handler.slots.get(INPUT_TOP_SLOT),
-			SlotActionType.PICKUP);
+			ClickType.PICKUP);
 		
 		if(waitForOutput(screen))
 		{
 			Slot outputSlot = handler.slots.get(OUTPUT_SLOT);
-			if(outputSlot.hasStack())
-				clickAndWait(screen, outputSlot, SlotActionType.QUICK_MOVE);
+			if(outputSlot.hasItem())
+				clickAndWait(screen, outputSlot, ClickType.QUICK_MOVE);
 		}else
 		{
 			clickAndWait(screen, handler.slots.get(INPUT_TOP_SLOT),
-				SlotActionType.QUICK_MOVE);
+				ClickType.QUICK_MOVE);
 		}
 		
 		clearInputSlots(screen);
@@ -175,12 +175,12 @@ public final class AutoDisenchantHack extends Hack
 		// because the latter returns false for enchanted books.
 		
 		var enchantments =
-			EnchantmentHelper.getEnchantments(stack).getEnchantmentEntries();
+			EnchantmentHelper.getEnchantmentsForCrafting(stack).entrySet();
 		if(enchantments.isEmpty())
 			return false;
 		
-		for(Object2IntMap.Entry<RegistryEntry<Enchantment>> entry : enchantments)
-			if(!entry.getKey().isIn(EnchantmentTags.CURSE))
+		for(Object2IntMap.Entry<Holder<Enchantment>> entry : enchantments)
+			if(!entry.getKey().is(EnchantmentTags.CURSE))
 				return true;
 			
 		return false;
@@ -189,21 +189,21 @@ public final class AutoDisenchantHack extends Hack
 	private void clearInputSlots(GrindstoneScreen screen)
 		throws InterruptedException
 	{
-		var handler = screen.getScreenHandler();
+		var handler = screen.getMenu();
 		List<Slot> slots = handler.slots;
 		for(int i = INPUT_TOP_SLOT; i <= INPUT_BOTTOM_SLOT
 			&& i < slots.size(); i++)
 		{
 			Slot slot = slots.get(i);
-			if(slot.getStack().isEmpty())
+			if(slot.getItem().isEmpty())
 				continue;
 			
-			clickAndWait(screen, slot, SlotActionType.QUICK_MOVE);
+			clickAndWait(screen, slot, ClickType.QUICK_MOVE);
 		}
 	}
 	
 	private void clickAndWait(GrindstoneScreen screen, Slot slot,
-		SlotActionType action) throws InterruptedException
+		ClickType action) throws InterruptedException
 	{
 		if(slot == null)
 			return;
@@ -211,7 +211,7 @@ public final class AutoDisenchantHack extends Hack
 		if(Thread.currentThread().isInterrupted())
 			throw new InterruptedException();
 		
-		screen.onMouseClick(slot, slot.id, 0, action);
+		screen.slotClicked(slot, slot.index, 0, action);
 		sleep(clickDelay.getValueI());
 	}
 	
@@ -222,21 +222,21 @@ public final class AutoDisenchantHack extends Hack
 		long waited = 0;
 		while(waited < timeout && isScreenValid(screen))
 		{
-			Slot outputSlot = screen.getScreenHandler().slots.get(OUTPUT_SLOT);
-			if(outputSlot.hasStack())
+			Slot outputSlot = screen.getMenu().slots.get(OUTPUT_SLOT);
+			if(outputSlot.hasItem())
 				return true;
 			
 			Thread.sleep(50);
 			waited += 50;
 		}
 		
-		Slot outputSlot = screen.getScreenHandler().slots.get(OUTPUT_SLOT);
-		return outputSlot.hasStack();
+		Slot outputSlot = screen.getMenu().slots.get(OUTPUT_SLOT);
+		return outputSlot.hasItem();
 	}
 	
 	private boolean isScreenValid(GrindstoneScreen screen)
 	{
-		return MC.currentScreen == screen;
+		return MC.screen == screen;
 	}
 	
 	private void sleep(long millis) throws InterruptedException
diff --git a/src/main/java/net/wurstclient/hacks/AutoDropHack.java b/src/main/java/net/wurstclient/hacks/AutoDropHack.java
index a5e0cb536..6cafba51a 100644
--- a/src/main/java/net/wurstclient/hacks/AutoDropHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoDropHack.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -64,8 +64,8 @@ public final class AutoDropHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// check screen
-		if(MC.currentScreen instanceof HandledScreen
-			&& !(MC.currentScreen instanceof InventoryScreen))
+		if(MC.screen instanceof AbstractContainerScreen
+			&& !(MC.screen instanceof InventoryScreen))
 			return;
 		
 		for(int slot = 9; slot < 45; slot++)
@@ -73,13 +73,13 @@ public final class AutoDropHack extends Hack implements UpdateListener
 			int adjustedSlot = slot;
 			if(adjustedSlot >= 36)
 				adjustedSlot -= 36;
-			ItemStack stack = MC.player.getInventory().getStack(adjustedSlot);
+			ItemStack stack = MC.player.getInventory().getItem(adjustedSlot);
 			
 			if(stack.isEmpty())
 				continue;
 			
 			Item item = stack.getItem();
-			String itemName = Registries.ITEM.getId(item).toString();
+			String itemName = BuiltInRegistries.ITEM.getKey(item).toString();
 			
 			if(!items.getItemNames().contains(itemName))
 				continue;
diff --git a/src/main/java/net/wurstclient/hacks/AutoEatHack.java b/src/main/java/net/wurstclient/hacks/AutoEatHack.java
index 05ce07f15..3b54d83fd 100644
--- a/src/main/java/net/wurstclient/hacks/AutoEatHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoEatHack.java
@@ -10,31 +10,30 @@ package net.wurstclient.hacks;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockWithEntity;
-import net.minecraft.block.CraftingTableBlock;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.ConsumableComponent;
-import net.minecraft.component.type.FoodComponent;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.entity.passive.TameableEntity;
-import net.minecraft.entity.passive.VillagerEntity;
-import net.minecraft.entity.player.HungerManager;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.consume.ApplyEffectsConsumeEffect;
-import net.minecraft.item.consume.ConsumeEffect;
-import net.minecraft.item.consume.TeleportRandomlyConsumeEffect;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.food.FoodData;
+import net.minecraft.world.food.FoodProperties;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.Consumable;
+import net.minecraft.world.item.consume_effects.ApplyStatusEffectsConsumeEffect;
+import net.minecraft.world.item.consume_effects.ConsumeEffect;
+import net.minecraft.world.item.consume_effects.TeleportRandomlyConsumeEffect;
+import net.minecraft.world.level.block.BaseEntityBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.CraftingTableBlock;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -129,7 +128,7 @@ public final class AutoEatHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		if(!shouldEat())
 		{
@@ -139,7 +138,7 @@ public final class AutoEatHack extends Hack implements UpdateListener
 			return;
 		}
 		
-		HungerManager hungerManager = player.getHungerManager();
+		FoodData hungerManager = player.getFoodData();
 		int foodLevel = hungerManager.getFoodLevel();
 		int targetHungerI = (int)(targetHunger.getValue() * 2);
 		int minHungerI = (int)(minHunger.getValue() * 2);
@@ -166,7 +165,7 @@ public final class AutoEatHack extends Hack implements UpdateListener
 	
 	private void eat(int maxPoints)
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		int foodSlot = findBestFoodSlot(maxPoints);
 		
 		if(foodSlot == -1)
@@ -199,14 +198,14 @@ public final class AutoEatHack extends Hack implements UpdateListener
 		}
 		
 		// eat food
-		MC.options.useKey.setPressed(true);
+		MC.options.keyUse.setDown(true);
 		IMC.getInteractionManager().rightClickItem();
 	}
 	
 	private int findBestFoodSlot(int maxPoints)
 	{
-		PlayerInventory inventory = MC.player.getInventory();
-		FoodComponent bestFood = null;
+		Inventory inventory = MC.player.getInventory();
+		FoodProperties bestFood = null;
 		int bestSlot = -1;
 		
 		int maxInvSlot = takeItemsFrom.getSelected().maxInvSlot;
@@ -219,21 +218,21 @@ public final class AutoEatHack extends Hack implements UpdateListener
 		Stream.iterate(0, i -> i < maxInvSlot, i -> i + 1)
 			.forEach(i -> slots.add(i));
 		
-		Comparator<FoodComponent> comparator =
-			Comparator.comparingDouble(FoodComponent::saturation);
+		Comparator<FoodProperties> comparator =
+			Comparator.comparingDouble(FoodProperties::saturation);
 		
 		for(int slot : slots)
 		{
-			ItemStack stack = inventory.getStack(slot);
+			ItemStack stack = inventory.getItem(slot);
 			
 			// filter out non-food items
-			if(!stack.contains(DataComponentTypes.FOOD))
+			if(!stack.has(DataComponents.FOOD))
 				continue;
 			
-			if(!isAllowedFood(stack.get(DataComponentTypes.CONSUMABLE)))
+			if(!isAllowedFood(stack.get(DataComponents.CONSUMABLE)))
 				continue;
 			
-			FoodComponent food = stack.get(DataComponentTypes.FOOD);
+			FoodProperties food = stack.get(DataComponents.FOOD);
 			if(maxPoints >= 0 && food.nutrition() > maxPoints)
 				continue;
 			
@@ -250,17 +249,17 @@ public final class AutoEatHack extends Hack implements UpdateListener
 	
 	private boolean shouldEat()
 	{
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 			return false;
 		
-		if(!MC.player.canConsume(false))
+		if(!MC.player.canEat(false))
 			return false;
 		
 		if(!eatWhileWalking.isChecked()
-			&& (MC.player.forwardSpeed != 0 || MC.player.sidewaysSpeed != 0))
+			&& (MC.player.zza != 0 || MC.player.xxa != 0))
 			return false;
 		
-		if(isClickable(MC.crosshairTarget))
+		if(isClickable(MC.hitResult))
 			return false;
 		
 		return true;
@@ -268,12 +267,12 @@ public final class AutoEatHack extends Hack implements UpdateListener
 	
 	private void stopEating()
 	{
-		MC.options.useKey.setPressed(false);
+		MC.options.keyUse.setDown(false);
 		MC.player.getInventory().setSelectedSlot(oldSlot);
 		oldSlot = -1;
 	}
 	
-	private boolean isAllowedFood(ConsumableComponent consumable)
+	private boolean isAllowedFood(Consumable consumable)
 	{
 		for(ConsumeEffect consumeEffect : consumable.onConsumeEffects())
 		{
@@ -281,18 +280,17 @@ public final class AutoEatHack extends Hack implements UpdateListener
 				&& consumeEffect instanceof TeleportRandomlyConsumeEffect)
 				return false;
 			
-			if(!(consumeEffect instanceof ApplyEffectsConsumeEffect applyEffectsConsumeEffect))
+			if(!(consumeEffect instanceof ApplyStatusEffectsConsumeEffect applyEffectsConsumeEffect))
 				continue;
 			
-			for(StatusEffectInstance effect : applyEffectsConsumeEffect
-				.effects())
+			for(MobEffectInstance effect : applyEffectsConsumeEffect.effects())
 			{
-				RegistryEntry<StatusEffect> entry = effect.getEffectType();
+				Holder<MobEffect> entry = effect.getEffect();
 				
-				if(!allowHunger.isChecked() && entry == StatusEffects.HUNGER)
+				if(!allowHunger.isChecked() && entry == MobEffects.HUNGER)
 					return false;
 				
-				if(!allowPoison.isChecked() && entry == StatusEffects.POISON)
+				if(!allowPoison.isChecked() && entry == MobEffects.POISON)
 					return false;
 			}
 		}
@@ -313,8 +311,8 @@ public final class AutoEatHack extends Hack implements UpdateListener
 		if(hitResult instanceof EntityHitResult)
 		{
 			Entity entity = ((EntityHitResult)hitResult).getEntity();
-			return entity instanceof VillagerEntity
-				|| entity instanceof TameableEntity;
+			return entity instanceof Villager
+				|| entity instanceof TamableAnimal;
 		}
 		
 		if(hitResult instanceof BlockHitResult)
@@ -323,15 +321,15 @@ public final class AutoEatHack extends Hack implements UpdateListener
 			if(pos == null)
 				return false;
 			
-			Block block = MC.world.getBlockState(pos).getBlock();
-			return block instanceof BlockWithEntity
+			Block block = MC.level.getBlockState(pos).getBlock();
+			return block instanceof BaseEntityBlock
 				|| block instanceof CraftingTableBlock;
 		}
 		
 		return false;
 	}
 	
-	private boolean isInjured(ClientPlayerEntity player)
+	private boolean isInjured(LocalPlayer player)
 	{
 		int injuryThresholdI = (int)(injuryThreshold.getValue() * 2);
 		return player.getHealth() < player.getMaxHealth() - injuryThresholdI;
diff --git a/src/main/java/net/wurstclient/hacks/AutoFarmHack.java b/src/main/java/net/wurstclient/hacks/AutoFarmHack.java
index 6db62f11e..ab2a4da79 100644
--- a/src/main/java/net/wurstclient/hacks/AutoFarmHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoFarmHack.java
@@ -7,19 +7,18 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -98,8 +97,8 @@ public final class AutoFarmHack extends Hack
 		
 		if(currentlyMining != null)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			currentlyMining = null;
 		}
 		
@@ -112,14 +111,14 @@ public final class AutoFarmHack extends Hack
 	public void onUpdate()
 	{
 		currentlyMining = null;
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
 		List<BlockPos> nonEmptyBlocks =
 			BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-				.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
+				.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
 				.filter(BlockUtils::canBeClicked).toList();
 		
 		for(BlockPos pos : nonEmptyBlocks)
@@ -138,26 +137,27 @@ public final class AutoFarmHack extends Hack
 			blocksToMine = nonEmptyBlocks.stream()
 				.filter(plantTypes::shouldHarvestByMining)
 				.sorted(Comparator
-					.comparingDouble(pos -> pos.getSquaredDistance(eyesVec)))
+					.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 				.toList();
 			
 			blocksToInteract = nonEmptyBlocks.stream()
 				.filter(plantTypes::shouldHarvestByInteracting)
 				.sorted(Comparator
-					.comparingDouble(pos -> pos.getSquaredDistance(eyesVec)))
+					.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 				.toList();
 			
 			blocksToReplant =
 				BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-					.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
-					.filter(pos -> BlockUtils.getState(pos).isReplaceable())
+					.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
+					.filter(pos -> BlockUtils.getState(pos).canBeReplaced())
 					.filter(pos -> {
 						AutoFarmPlantType plantType = replantingSpots.get(pos);
 						return plantType != null
 							&& plantType.isReplantingEnabled()
 							&& plantType.hasPlantingSurface(pos);
-					}).sorted(Comparator.comparingDouble(
-						pos -> pos.getSquaredDistance(eyesVec)))
+					})
+					.sorted(Comparator
+						.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 					.toList();
 		}
 		
@@ -176,7 +176,7 @@ public final class AutoFarmHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		renderer.render(matrixStack);
 		
@@ -194,10 +194,10 @@ public final class AutoFarmHack extends Hack
 	
 	private boolean replant(List<BlockPos> blocksToReplant)
 	{
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return false;
 		
-		if(MC.interactionManager.isBreakingBlock() || MC.player.isRiding())
+		if(MC.gameMode.isDestroying() || MC.player.isHandsBusy())
 			return false;
 		
 		Optional<Item> heldSeed =
@@ -208,8 +208,8 @@ public final class AutoFarmHack extends Hack
 		if(heldSeed.isPresent())
 		{
 			Item item = heldSeed.get();
-			Hand hand = MC.player.getMainHandStack().isOf(item) ? Hand.MAIN_HAND
-				: Hand.OFF_HAND;
+			InteractionHand hand = MC.player.getMainHandItem().is(item)
+				? InteractionHand.MAIN_HAND : InteractionHand.OFF_HAND;
 			
 			for(BlockPos pos : blocksToReplant)
 			{
@@ -225,7 +225,7 @@ public final class AutoFarmHack extends Hack
 				if(checkLOS.isChecked() && !params.lineOfSight())
 					continue;
 				
-				MC.itemUseCooldown = 4;
+				MC.rightClickDelay = 4;
 				faceTarget.face(params.hitVec());
 				InteractionSimulator.rightClickBlock(params.toHitResult(), hand,
 					swingHand.getSelected());
@@ -253,10 +253,10 @@ public final class AutoFarmHack extends Hack
 	
 	private boolean harvestByInteracting(List<BlockPos> blocksToInteract)
 	{
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return false;
 		
-		if(MC.interactionManager.isBreakingBlock() || MC.player.isRiding())
+		if(MC.gameMode.isDestroying() || MC.player.isHandsBusy())
 			return false;
 		
 		for(BlockPos pos : blocksToInteract)
@@ -269,10 +269,10 @@ public final class AutoFarmHack extends Hack
 			if(checkLOS.isChecked() && !params.lineOfSight())
 				continue;
 			
-			if(MC.player.getMainHandStack().isOf(Items.BONE_MEAL))
-				return InventoryUtils.selectItem(s -> !s.isOf(Items.BONE_MEAL));
+			if(MC.player.getMainHandItem().is(Items.BONE_MEAL))
+				return InventoryUtils.selectItem(s -> !s.is(Items.BONE_MEAL));
 			
-			MC.itemUseCooldown = 4;
+			MC.rightClickDelay = 4;
 			faceTarget.face(params.hitVec());
 			InteractionSimulator.rightClickBlock(params.toHitResult(),
 				swingHand.getSelected());
@@ -295,10 +295,10 @@ public final class AutoFarmHack extends Hack
 		stream = stream.sorted(BlockBreaker.comparingParams());
 		
 		// Break all blocks in creative mode
-		if(MC.player.getAbilities().creativeMode
+		if(MC.player.getAbilities().instabuild
 			&& faceTarget.getSelected() == FaceTarget.OFF)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			
 			List<BlockPos> blocks = cache
@@ -308,7 +308,7 @@ public final class AutoFarmHack extends Hack
 			
 			currentlyMining = blocks.get(0);
 			BlockBreaker.breakBlocksWithPacketSpam(blocks);
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 			return;
 		}
 		
@@ -318,7 +318,7 @@ public final class AutoFarmHack extends Hack
 		
 		if(currentlyMining == null)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			return;
 		}
@@ -330,11 +330,10 @@ public final class AutoFarmHack extends Hack
 	{
 		faceTarget.face(params.hitVec());
 		
-		if(!MC.interactionManager.updateBlockBreakingProgress(params.pos(),
-			params.side()))
+		if(!MC.gameMode.continueDestroyBlock(params.pos(), params.side()))
 			return false;
 		
-		swingHand.swing(Hand.MAIN_HAND);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		return true;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/AutoFishHack.java b/src/main/java/net/wurstclient/hacks/AutoFishHack.java
index bc4bb7153..09179c53c 100644
--- a/src/main/java/net/wurstclient/hacks/AutoFishHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoFishHack.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.projectile.FishingBobberEntity;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.s2c.play.EntityTrackerUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.PlaySoundS2CPacket;
-import net.minecraft.sound.SoundEvents;
-import net.minecraft.util.math.Vec3d;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundSoundPacket;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketInputListener;
@@ -153,7 +153,7 @@ public final class AutoFishHack extends Hack
 			if(!fishingSpots.onCast())
 				return;
 			
-			MC.doItemUse();
+			MC.startUseItem();
 			castRodTimer = retryDelay.getValueI();
 			return;
 		}
@@ -163,17 +163,17 @@ public final class AutoFishHack extends Hack
 		{
 			shallowWaterWarning.checkWaterType();
 			reelInTimer = catchDelay.getValueI();
-			fishingSpots.onBite(MC.player.fishHook);
+			fishingSpots.onBite(MC.player.fishing);
 			biteDetected = false;
 			
 			// also reel in if an entity was hooked
-		}else if(MC.player.fishHook.getHookedEntity() != null)
+		}else if(MC.player.fishing.getHookedIn() != null)
 			reelInTimer = catchDelay.getValueI();
 		
 		// otherwise, reel in when the timer runs out
 		if(reelInTimer == 0)
 		{
-			MC.doItemUse();
+			MC.startUseItem();
 			reelInTimer = retryDelay.getValueI();
 			castRodTimer = retryDelay.getValueI();
 		}
@@ -192,12 +192,11 @@ public final class AutoFishHack extends Hack
 	private void processSoundUpdate(PacketInputEvent event)
 	{
 		// check packet type
-		if(!(event.getPacket() instanceof PlaySoundS2CPacket sound))
+		if(!(event.getPacket() instanceof ClientboundSoundPacket sound))
 			return;
 		
 		// check sound type
-		if(!SoundEvents.ENTITY_FISHING_BOBBER_SPLASH
-			.equals(sound.getSound().value()))
+		if(!SoundEvents.FISHING_BOBBER_SPLASH.equals(sound.getSound().value()))
 			return;
 		
 		// check if player is fishing
@@ -208,9 +207,9 @@ public final class AutoFishHack extends Hack
 		debugDraw.updateSoundPos(sound);
 		
 		// check sound position (Chebyshev distance)
-		Vec3d bobber = MC.player.fishHook.getEntityPos();
-		double dx = Math.abs(sound.getX() - bobber.getX());
-		double dz = Math.abs(sound.getZ() - bobber.getZ());
+		Vec3 bobber = MC.player.fishing.position();
+		double dx = Math.abs(sound.getX() - bobber.x());
+		double dz = Math.abs(sound.getZ() - bobber.z());
 		if(Math.max(dx, dz) > validRange.getValue())
 			return;
 		
@@ -220,16 +219,16 @@ public final class AutoFishHack extends Hack
 	private void processEntityUpdate(PacketInputEvent event)
 	{
 		// check packet type
-		if(!(event.getPacket() instanceof EntityTrackerUpdateS2CPacket update))
+		if(!(event
+			.getPacket() instanceof ClientboundSetEntityDataPacket update))
 			return;
 		
 		// check if the entity is a bobber
-		if(!(MC.world
-			.getEntityById(update.id()) instanceof FishingBobberEntity bobber))
+		if(!(MC.level.getEntity(update.id()) instanceof FishingHook bobber))
 			return;
 		
 		// check if it's our bobber
-		if(bobber != MC.player.fishHook)
+		if(bobber != MC.player.fishing)
 			return;
 		
 		// check if player is fishing
@@ -240,17 +239,17 @@ public final class AutoFishHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		debugDraw.render(matrixStack, partialTicks);
 	}
 	
 	private boolean isFishing()
 	{
-		ClientPlayerEntity player = MC.player;
-		return player != null && player.fishHook != null
-			&& !player.fishHook.isRemoved()
-			&& player.getMainHandStack().isOf(Items.FISHING_ROD);
+		LocalPlayer player = MC.player;
+		return player != null && player.fishing != null
+			&& !player.fishing.isRemoved()
+			&& player.getMainHandItem().is(Items.FISHING_ROD);
 	}
 	
 	private enum BiteMode
diff --git a/src/main/java/net/wurstclient/hacks/AutoLeaveHack.java b/src/main/java/net/wurstclient/hacks/AutoLeaveHack.java
index 9c0c23347..1d26a59e0 100644
--- a/src/main/java/net/wurstclient/hacks/AutoLeaveHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoLeaveHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.network.protocol.game.ServerboundInteractPacket;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -65,7 +65,7 @@ public final class AutoLeaveHack extends Hack implements UpdateListener
 	@Override
 	public String getRenderName()
 	{
-		if(MC.player != null && MC.player.getAbilities().creativeMode)
+		if(MC.player != null && MC.player.getAbilities().instabuild)
 			return getName() + " (paused)";
 		
 		return getName() + " [" + mode.getSelected() + "]";
@@ -87,7 +87,7 @@ public final class AutoLeaveHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// check gamemode
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 			return;
 		
 		// check health
@@ -113,14 +113,13 @@ public final class AutoLeaveHack extends Hack implements UpdateListener
 	public static enum Mode
 	{
 		QUIT("Quit",
-			() -> MC.world.disconnect(ClientWorld.QUITTING_MULTIPLAYER_TEXT)),
+			() -> MC.level.disconnect(ClientLevel.DEFAULT_QUIT_MESSAGE)),
 		
-		CHARS("Chars", () -> MC.getNetworkHandler().sendChatMessage("\u00a7")),
+		CHARS("Chars", () -> MC.getConnection().sendChat("\u00a7")),
 		
 		SELFHURT("SelfHurt",
-			() -> MC.getNetworkHandler()
-				.sendPacket(PlayerInteractEntityC2SPacket.attack(MC.player,
-					MC.player.isSneaking())));
+			() -> MC.getConnection().send(ServerboundInteractPacket
+				.createAttackPacket(MC.player, MC.player.isShiftKeyDown())));
 		
 		private final String name;
 		private final Runnable leave;
diff --git a/src/main/java/net/wurstclient/hacks/AutoLibrarianHack.java b/src/main/java/net/wurstclient/hacks/AutoLibrarianHack.java
index 643646238..70211fd93 100644
--- a/src/main/java/net/wurstclient/hacks/AutoLibrarianHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoLibrarianHack.java
@@ -13,31 +13,30 @@ import java.util.List;
 import java.util.Set;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
+import com.mojang.blaze3d.vertex.PoseStack;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.gui.screen.ingame.MerchantScreen;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.entity.passive.VillagerEntity;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.SelectMerchantTradeC2SPacket;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.screen.slot.SlotActionType;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.village.TradeOffer;
-import net.minecraft.village.TradeOfferList;
-import net.minecraft.village.VillagerProfession;
+import net.minecraft.client.gui.screens.inventory.MerchantScreen;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.network.protocol.game.ServerboundSelectTradePacket;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.entity.npc.VillagerProfession;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.trading.MerchantOffer;
+import net.minecraft.world.item.trading.MerchantOffers;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -106,10 +105,9 @@ public final class AutoLibrarianHack extends Hack
 		1, 0, 100, 1, ValueDisplay.INTEGER.withLabel(0, "off"));
 	
 	private final OverlayRenderer overlay = new OverlayRenderer();
-	private final HashSet<VillagerEntity> experiencedVillagers =
-		new HashSet<>();
+	private final HashSet<Villager> experiencedVillagers = new HashSet<>();
 	
-	private VillagerEntity villager;
+	private Villager villager;
 	private BlockPos jobSite;
 	
 	private boolean placingJobSite;
@@ -143,8 +141,8 @@ public final class AutoLibrarianHack extends Hack
 		
 		if(breakingJobSite)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			breakingJobSite = false;
 		}
 		
@@ -187,7 +185,7 @@ public final class AutoLibrarianHack extends Hack
 			return;
 		}
 		
-		if(!(MC.currentScreen instanceof MerchantScreen tradeScreen))
+		if(!(MC.screen instanceof MerchantScreen tradeScreen))
 		{
 			openTradeScreen();
 			return;
@@ -195,11 +193,11 @@ public final class AutoLibrarianHack extends Hack
 		
 		// Can't see experience until the trade screen is open, so we have to
 		// check it here and start over if the villager is already experienced.
-		int experience = tradeScreen.getScreenHandler().getExperience();
+		int experience = tradeScreen.getMenu().getTraderXp();
 		if(experience > 0)
 		{
 			ChatUtils.warning("Villager at "
-				+ villager.getBlockPos().toShortString()
+				+ villager.blockPosition().toShortString()
 				+ " is already experienced, meaning it can't be trained anymore.");
 			ChatUtils.message("Looking for another villager...");
 			experiencedVillagers.add(villager);
@@ -211,7 +209,7 @@ public final class AutoLibrarianHack extends Hack
 		
 		// check which book the villager is selling
 		BookOffer bookOffer =
-			findEnchantedBookOffer(tradeScreen.getScreenHandler().getRecipes());
+			findEnchantedBookOffer(tradeScreen.getMenu().getOffers());
 		
 		if(bookOffer == null)
 		{
@@ -239,15 +237,14 @@ public final class AutoLibrarianHack extends Hack
 		if(lockInTrade.isChecked())
 		{
 			// select the first valid trade
-			tradeScreen.getScreenHandler().setRecipeIndex(0);
-			tradeScreen.getScreenHandler().switchTo(0);
-			MC.getNetworkHandler()
-				.sendPacket(new SelectMerchantTradeC2SPacket(0));
+			tradeScreen.getMenu().setSelectionHint(0);
+			tradeScreen.getMenu().tryMoveItems(0);
+			MC.getConnection().send(new ServerboundSelectTradePacket(0));
 			
 			// buy whatever the villager is selling
-			MC.interactionManager.clickSlot(
-				tradeScreen.getScreenHandler().syncId, 2, 0,
-				SlotActionType.PICKUP, MC.player);
+			MC.gameMode.handleInventoryMouseClick(
+				tradeScreen.getMenu().containerId, 2, 0, ClickType.PICKUP,
+				MC.player);
 			
 			// close the trade screen
 			closeTradeScreen();
@@ -268,7 +265,7 @@ public final class AutoLibrarianHack extends Hack
 		BlockBreakingParams params =
 			BlockBreaker.getBlockBreakingParams(jobSite);
 		
-		if(params == null || BlockUtils.getState(jobSite).isReplaceable())
+		if(params == null || BlockUtils.getState(jobSite).canBeReplaced())
 		{
 			System.out.println("Job site has been broken. Replacing...");
 			breakingJobSite = false;
@@ -284,9 +281,8 @@ public final class AutoLibrarianHack extends Hack
 		faceTarget.face(params.hitVec());
 		
 		// damage block and swing hand
-		if(MC.interactionManager.updateBlockBreakingProgress(jobSite,
-			params.side()))
-			swingHand.swing(Hand.MAIN_HAND);
+		if(MC.gameMode.continueDestroyBlock(jobSite, params.side()))
+			swingHand.swing(InteractionHand.MAIN_HAND);
 		
 		// update progress
 		overlay.updateProgress();
@@ -297,7 +293,7 @@ public final class AutoLibrarianHack extends Hack
 		if(jobSite == null)
 			throw new IllegalStateException("Job site is null.");
 		
-		if(!BlockUtils.getState(jobSite).isReplaceable())
+		if(!BlockUtils.getState(jobSite).canBeReplaced())
 		{
 			if(BlockUtils.getBlock(jobSite) == Blocks.LECTERN)
 			{
@@ -323,13 +319,13 @@ public final class AutoLibrarianHack extends Hack
 		}
 		
 		// get the hand that is holding the lectern
-		Hand hand = MC.player.getMainHandStack().isOf(Items.LECTERN)
-			? Hand.MAIN_HAND : Hand.OFF_HAND;
+		InteractionHand hand = MC.player.getMainHandItem().is(Items.LECTERN)
+			? InteractionHand.MAIN_HAND : InteractionHand.OFF_HAND;
 		
 		// sneak-place to avoid activating trapdoors/chests/etc.
-		IKeyBinding sneakKey = IKeyBinding.get(MC.options.sneakKey);
+		IKeyBinding sneakKey = IKeyBinding.get(MC.options.keyShift);
 		sneakKey.setPressed(true);
-		if(!MC.player.isSneaking())
+		if(!MC.player.isShiftKeyDown())
 			return;
 		
 		// get block placing params
@@ -344,12 +340,12 @@ public final class AutoLibrarianHack extends Hack
 		faceTarget.face(params.hitVec());
 		
 		// place block
-		ActionResult result = MC.interactionManager.interactBlock(MC.player,
-			hand, params.toHitResult());
+		InteractionResult result =
+			MC.gameMode.useItemOn(MC.player, hand, params.toHitResult());
 		
 		// swing hand
-		if(result instanceof ActionResult.Success success
-			&& success.swingSource() == ActionResult.SwingSource.CLIENT)
+		if(result instanceof InteractionResult.Success success
+			&& success.swingSource() == InteractionResult.SwingSource.CLIENT)
 			swingHand.swing(hand);
 		
 		// reset sneak
@@ -358,13 +354,13 @@ public final class AutoLibrarianHack extends Hack
 	
 	private void openTradeScreen()
 	{
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
-		ClientPlayerInteractionManager im = MC.interactionManager;
-		ClientPlayerEntity player = MC.player;
+		MultiPlayerGameMode im = MC.gameMode;
+		LocalPlayer player = MC.player;
 		
-		if(player.squaredDistanceTo(villager) > range.getValueSq())
+		if(player.distanceToSqr(villager) > range.getValueSq())
 		{
 			ChatUtils.error("Villager is out of range. Consider trapping"
 				+ " the villager so it doesn't wander away.");
@@ -373,58 +369,57 @@ public final class AutoLibrarianHack extends Hack
 		}
 		
 		// create realistic hit result
-		Box box = villager.getBoundingBox();
-		Vec3d start = RotationUtils.getEyesPos();
-		Vec3d end = box.getCenter();
-		Vec3d hitVec = box.raycast(start, end).orElse(start);
+		AABB box = villager.getBoundingBox();
+		Vec3 start = RotationUtils.getEyesPos();
+		Vec3 end = box.getCenter();
+		Vec3 hitVec = box.clip(start, end).orElse(start);
 		EntityHitResult hitResult = new EntityHitResult(villager, hitVec);
 		
 		// face end vector
 		faceTarget.face(end);
 		
 		// click on villager
-		Hand hand = Hand.MAIN_HAND;
-		ActionResult actionResult =
-			im.interactEntityAtLocation(player, villager, hitResult, hand);
+		InteractionHand hand = InteractionHand.MAIN_HAND;
+		InteractionResult actionResult =
+			im.interactAt(player, villager, hitResult, hand);
 		
-		if(!actionResult.isAccepted())
-			im.interactEntity(player, villager, hand);
+		if(!actionResult.consumesAction())
+			im.interact(player, villager, hand);
 		
 		// swing hand
-		if(actionResult instanceof ActionResult.Success success
-			&& success.swingSource() == ActionResult.SwingSource.CLIENT)
+		if(actionResult instanceof InteractionResult.Success success
+			&& success.swingSource() == InteractionResult.SwingSource.CLIENT)
 			swingHand.swing(hand);
 		
 		// set cooldown
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 	}
 	
 	private void closeTradeScreen()
 	{
-		MC.player.closeHandledScreen();
-		MC.itemUseCooldown = 4;
+		MC.player.closeContainer();
+		MC.rightClickDelay = 4;
 	}
 	
-	private BookOffer findEnchantedBookOffer(TradeOfferList tradeOffers)
+	private BookOffer findEnchantedBookOffer(MerchantOffers tradeOffers)
 	{
-		for(TradeOffer tradeOffer : tradeOffers)
+		for(MerchantOffer tradeOffer : tradeOffers)
 		{
-			ItemStack stack = tradeOffer.getSellItem();
+			ItemStack stack = tradeOffer.getResult();
 			if(stack.getItem() != Items.ENCHANTED_BOOK)
 				continue;
 			
-			Set<Entry<RegistryEntry<Enchantment>>> enchantmentLevelMap =
-				EnchantmentHelper.getEnchantments(stack)
-					.getEnchantmentEntries();
+			Set<Entry<Holder<Enchantment>>> enchantmentLevelMap =
+				EnchantmentHelper.getEnchantmentsForCrafting(stack).entrySet();
 			if(enchantmentLevelMap.isEmpty())
 				continue;
 			
-			Object2IntMap.Entry<RegistryEntry<Enchantment>> firstEntry =
+			Object2IntMap.Entry<Holder<Enchantment>> firstEntry =
 				enchantmentLevelMap.stream().findFirst().orElseThrow();
 			
-			String enchantment = firstEntry.getKey().getIdAsString();
+			String enchantment = firstEntry.getKey().getRegisteredName();
 			int level = firstEntry.getIntValue();
-			int price = tradeOffer.getDisplayedFirstBuyItem().getCount();
+			int price = tradeOffer.getCostA().getCount();
 			BookOffer bookOffer = new BookOffer(enchantment, level, price);
 			
 			if(!bookOffer.isMostlyValid())
@@ -442,23 +437,22 @@ public final class AutoLibrarianHack extends Hack
 	
 	private void setTargetVillager()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		double rangeSq = range.getValueSq();
 		
-		Stream<VillagerEntity> stream =
-			StreamSupport.stream(MC.world.getEntities().spliterator(), true)
-				.filter(e -> !e.isRemoved())
-				.filter(VillagerEntity.class::isInstance)
-				.map(e -> (VillagerEntity)e).filter(e -> e.getHealth() > 0)
-				.filter(e -> player.squaredDistanceTo(e) <= rangeSq)
-				.filter(e -> e.getVillagerData().profession().getKey()
-					.orElse(null) == VillagerProfession.LIBRARIAN)
-				.filter(e -> e.getVillagerData().level() == 1)
-				.filter(e -> !experiencedVillagers.contains(e));
-		
-		villager = stream
-			.min(Comparator.comparingDouble(e -> player.squaredDistanceTo(e)))
-			.orElse(null);
+		Stream<Villager> stream = StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
+			.filter(e -> !e.isRemoved()).filter(Villager.class::isInstance)
+			.map(e -> (Villager)e).filter(e -> e.getHealth() > 0)
+			.filter(e -> player.distanceToSqr(e) <= rangeSq)
+			.filter(e -> e.getVillagerData().profession().unwrapKey()
+				.orElse(null) == VillagerProfession.LIBRARIAN)
+			.filter(e -> e.getVillagerData().level() == 1)
+			.filter(e -> !experiencedVillagers.contains(e));
+		
+		villager =
+			stream.min(Comparator.comparingDouble(e -> player.distanceToSqr(e)))
+				.orElse(null);
 		
 		if(villager == null)
 		{
@@ -476,24 +470,24 @@ public final class AutoLibrarianHack extends Hack
 			return;
 		}
 		
-		System.out.println("Found villager at " + villager.getBlockPos());
+		System.out.println("Found villager at " + villager.blockPosition());
 	}
 	
 	private void setTargetJobSite()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos();
+		Vec3 eyesVec = RotationUtils.getEyesPos();
 		double rangeSq = range.getValueSq();
 		
 		Stream<BlockPos> stream = BlockUtils
-			.getAllInBoxStream(BlockPos.ofFloored(eyesVec),
+			.getAllInBoxStream(BlockPos.containing(eyesVec),
 				range.getValueCeil())
-			.filter(pos -> eyesVec
-				.squaredDistanceTo(Vec3d.ofCenter(pos)) <= rangeSq)
+			.filter(
+				pos -> eyesVec.distanceToSqr(Vec3.atCenterOf(pos)) <= rangeSq)
 			.filter(pos -> BlockUtils.getBlock(pos) == Blocks.LECTERN);
 		
 		jobSite = stream
 			.min(Comparator.comparingDouble(
-				pos -> villager.squaredDistanceTo(Vec3d.ofCenter(pos))))
+				pos -> villager.distanceToSqr(Vec3.atCenterOf(pos))))
 			.orElse(null);
 		
 		if(jobSite == null)
@@ -509,7 +503,7 @@ public final class AutoLibrarianHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		int green = 0xC000FF00;
 		int red = 0xC0FF0000;
@@ -519,11 +513,11 @@ public final class AutoLibrarianHack extends Hack
 				green, false);
 		
 		if(jobSite != null)
-			RenderUtils.drawOutlinedBox(matrixStack, new Box(jobSite), green,
+			RenderUtils.drawOutlinedBox(matrixStack, new AABB(jobSite), green,
 				false);
 		
-		List<Box> expVilBoxes = experiencedVillagers.stream()
-			.map(VillagerEntity::getBoundingBox).toList();
+		List<AABB> expVilBoxes = experiencedVillagers.stream()
+			.map(Villager::getBoundingBox).toList();
 		RenderUtils.drawOutlinedBoxes(matrixStack, expVilBoxes, red, false);
 		RenderUtils.drawCrossBoxes(matrixStack, expVilBoxes, red, false);
 		
diff --git a/src/main/java/net/wurstclient/hacks/AutoMaceHack.java b/src/main/java/net/wurstclient/hacks/AutoMaceHack.java
index 9e6c4e3cc..ec05942a9 100644
--- a/src/main/java/net/wurstclient/hacks/AutoMaceHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoMaceHack.java
@@ -10,21 +10,20 @@ package net.wurstclient.hacks;
 import java.util.Comparator;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.Function;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.passive.PassiveEntity;
-import net.minecraft.entity.passive.TameableEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.UpdateSelectedSlotC2SPacket;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
+import net.minecraft.util.Mth;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.AgeableMob;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -105,7 +104,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	private final CheckboxSetting debugLogs = new CheckboxSetting("Debug logs",
 		"Prints status messages that can help diagnose timing issues.", false);
 	
-	private static final Function<Entity, Vec3d> TOP_HITBOX_AIM =
+	private static final Function<Entity, Vec3> TOP_HITBOX_AIM =
 		AutoMaceHack::getTopAimPoint;
 	private static final long POST_SWITCH_ATTACK_BUFFER_MS = 75;
 	
@@ -175,15 +174,15 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.player == null || MC.world == null)
+		if(MC.player == null || MC.level == null)
 			return;
 		
 		enforceSliderBounds();
 		updateFallTracking();
 		updateCurrentTarget();
 		
-		boolean airborne = !MC.player.isOnGround();
-		Vec3d velocity = MC.player.getVelocity();
+		boolean airborne = !MC.player.onGround();
+		Vec3 velocity = MC.player.getDeltaMovement();
 		boolean falling = velocity.y < -0.1;
 		double currentFallDistance = getCurrentFallDistance();
 		boolean fallingWindow = airborne && falling
@@ -218,7 +217,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			}else
 				handleNoTarget();
 			
-		}else if(MC.player.isOnGround())
+		}else if(MC.player.onGround())
 			handleLanding();
 		else if(airborne && !falling)
 			handleNotFalling();
@@ -257,10 +256,10 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			return;
 		
 		Entity candidate = null;
-		if(MC.crosshairTarget != null
-			&& MC.crosshairTarget.getType() == HitResult.Type.ENTITY)
+		if(MC.hitResult != null
+			&& MC.hitResult.getType() == HitResult.Type.ENTITY)
 		{
-			candidate = ((EntityHitResult)MC.crosshairTarget).getEntity();
+			candidate = ((EntityHitResult)MC.hitResult).getEntity();
 		}
 		
 		if(!isTargetCandidate(candidate) || !isFallReachable(candidate))
@@ -273,8 +272,8 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	
 	private void updateFallTracking()
 	{
-		boolean onGround = MC.player.isOnGround();
-		Vec3d velocity = MC.player.getVelocity();
+		boolean onGround = MC.player.onGround();
+		Vec3 velocity = MC.player.getDeltaMovement();
 		boolean falling = velocity.y < -0.1;
 		double currentY = MC.player.getY();
 		
@@ -331,14 +330,14 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		if(!EntityUtils.IS_ATTACKABLE.test(entity))
 			return false;
 		
-		if(!(entity instanceof LivingEntity living) || living.isDead()
+		if(!(entity instanceof LivingEntity living) || living.isDeadOrDying()
 			|| !living.isAlive())
 			return false;
 		
-		if(MC.player.isTeammate(entity))
+		if(MC.player.isAlliedTo(entity))
 			return false;
 		
-		if(entity instanceof PlayerEntity)
+		if(entity instanceof Player)
 		{
 			if(!targetPlayers.isChecked())
 				return false;
@@ -347,10 +346,10 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			if(!targetMobs.isChecked())
 				return false;
 			
-			if(ignorePassiveMobs.isChecked() && entity instanceof PassiveEntity)
+			if(ignorePassiveMobs.isChecked() && entity instanceof AgeableMob)
 				return false;
 			
-			if(entity instanceof TameableEntity tame && tame.isTamed())
+			if(entity instanceof TamableAnimal tame && tame.isTame())
 				return false;
 		}
 		
@@ -376,10 +375,10 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		}
 		
 		if(respectCooldown.isChecked()
-			&& MC.player.getAttackCooldownProgress(0) < 0.75F)
+			&& MC.player.getAttackStrengthScale(0) < 0.75F)
 		{
-			logSkip("cooldown=" + String.format("%.2f",
-				MC.player.getAttackCooldownProgress(0)));
+			logSkip("cooldown="
+				+ String.format("%.2f", MC.player.getAttackStrengthScale(0)));
 			return false;
 		}
 		
@@ -413,7 +412,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		if(!cheatMode)
 		{
 			float minCritFall =
-				(float)MathHelper.clamp(minFallDistance.getValue() * 0.8F, 1.2F,
+				(float)Mth.clamp(minFallDistance.getValue() * 0.8F, 1.2F,
 					Math.max(2.0F, minFallDistance.getValue() + 0.4F));
 			if(MC.player.fallDistance < minCritFall)
 			{
@@ -432,13 +431,13 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	
 	private void attackTarget(Entity target)
 	{
-		if(target == null || MC.interactionManager == null)
+		if(target == null || MC.gameMode == null)
 			return;
 		
 		currentTarget = target;
-		MC.interactionManager.attackEntity(MC.player, target);
-		MC.player.swingHand(Hand.MAIN_HAND);
-		MC.player.resetLastAttackedTicks();
+		MC.gameMode.attack(MC.player, target);
+		MC.player.swing(InteractionHand.MAIN_HAND);
+		MC.player.resetAttackStrengthTicker();
 		attackedThisFall = true;
 		double vertical = MC.player.getY() - target.getBoundingBox().maxY;
 		logDebug("Attacked target " + target.getName().getString()
@@ -550,8 +549,8 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	
 	private boolean isMaceEquipped()
 	{
-		ItemStack mainHand = MC.player.getMainHandStack();
-		return mainHand.isOf(Items.MACE);
+		ItemStack mainHand = MC.player.getMainHandItem();
+		return mainHand.is(Items.MACE);
 	}
 	
 	private void storePreviousSlot()
@@ -573,8 +572,8 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	{
 		for(int i = 0; i < 9; i++)
 		{
-			ItemStack stack = MC.player.getInventory().getStack(i);
-			if(stack.isOf(Items.MACE))
+			ItemStack stack = MC.player.getInventory().getItem(i);
+			if(stack.is(Items.MACE))
 			{
 				setSelectedHotbarSlot(i);
 				hasSwitchedToMace = true;
@@ -604,9 +603,9 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			return;
 		
 		MC.player.getInventory().setSelectedSlot(slot);
-		if(MC.player.networkHandler != null)
-			MC.player.networkHandler
-				.sendPacket(new UpdateSelectedSlotC2SPacket(slot));
+		if(MC.player.connection != null)
+			MC.player.connection
+				.send(new ServerboundSetCarriedItemPacket(slot));
 	}
 	
 	private void alignToTargetTop(Entity target)
@@ -614,7 +613,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		if(!useAimAssist.isChecked() || target == null)
 			return;
 		
-		Vec3d topCenter = getTopAimPoint(target);
+		Vec3 topCenter = getTopAimPoint(target);
 		
 		WURST.getRotationFaker().faceVectorClient(topCenter);
 		WURST.getRotationFaker().faceVectorPacket(topCenter);
@@ -625,8 +624,8 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		if(entity == null)
 			return false;
 		
-		Box playerBox = MC.player.getBoundingBox();
-		Box targetBox = entity.getBoundingBox();
+		AABB playerBox = MC.player.getBoundingBox();
+		AABB targetBox = entity.getBoundingBox();
 		
 		double playerFeet = playerBox.minY;
 		double playerTop = playerBox.maxY;
@@ -646,7 +645,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		double horizontal = Math.hypot(playerCenterX - targetCenterX,
 			playerCenterZ - targetCenterZ);
 		
-		double maxHorizontal = Math.max(1.4, 0.9 + entity.getWidth() * 0.6);
+		double maxHorizontal = Math.max(1.4, 0.9 + entity.getBbWidth() * 0.6);
 		if(horizontal > maxHorizontal)
 		{
 			logSkip(String.format("horizontal %.2f > %.2f", horizontal,
@@ -654,7 +653,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			return false;
 		}
 		
-		double downwardSpeed = MC.player.getVelocity().y;
+		double downwardSpeed = MC.player.getDeltaMovement().y;
 		if(downwardSpeed > -0.35)
 		{
 			logSkip(String.format("velocity %.3f too slow", downwardSpeed));
@@ -676,9 +675,9 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		if(entity == null)
 			return false;
 		
-		Vec3d playerPos =
-			new Vec3d(MC.player.getX(), MC.player.getY(), MC.player.getZ());
-		Vec3d top = getTopAimPoint(entity);
+		Vec3 playerPos =
+			new Vec3(MC.player.getX(), MC.player.getY(), MC.player.getZ());
+		Vec3 top = getTopAimPoint(entity);
 		
 		if(top.y >= playerPos.y)
 			return false;
@@ -696,23 +695,23 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 	
 	private Entity findBestFallTarget()
 	{
-		Vec3d playerPos =
-			new Vec3d(MC.player.getX(), MC.player.getY(), MC.player.getZ());
+		Vec3 playerPos =
+			new Vec3(MC.player.getX(), MC.player.getY(), MC.player.getZ());
 		double maxDistanceSq = 36.0; // 6 blocks
 		double maxHorizontal = 5.5;
 		
 		return EntityUtils.getAttackableEntities()
 			.filter(this::isTargetCandidate)
-			.filter(e -> MC.player.squaredDistanceTo(e) <= maxDistanceSq)
+			.filter(e -> MC.player.distanceToSqr(e) <= maxDistanceSq)
 			.filter(e -> getTopAimPoint(e).y < playerPos.y)
 			.filter(this::isFallReachable).filter(e -> {
-				Vec3d top = getTopAimPoint(e);
+				Vec3 top = getTopAimPoint(e);
 				double dx = top.x - playerPos.x;
 				double dz = top.z - playerPos.z;
 				double horizontal = Math.hypot(dx, dz);
 				return horizontal <= maxHorizontal;
 			}).min(Comparator.comparingDouble(e -> {
-				Vec3d top = getTopAimPoint(e);
+				Vec3 top = getTopAimPoint(e);
 				double verticalDiff = Math.max(0, playerPos.y - top.y - 0.05);
 				double dx = top.x - playerPos.x;
 				double dz = top.z - playerPos.z;
@@ -721,13 +720,13 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 			})).orElse(null);
 	}
 	
-	private static Vec3d getTopAimPoint(Entity entity)
+	private static Vec3 getTopAimPoint(Entity entity)
 	{
-		Box box = entity.getBoundingBox();
+		AABB box = entity.getBoundingBox();
 		double x = (box.minX + box.maxX) * 0.5;
 		double y = box.maxY + 0.05;
 		double z = (box.minZ + box.maxZ) * 0.5;
-		return new Vec3d(x, y, z);
+		return new Vec3(x, y, z);
 	}
 	
 	private long nextDelay(double min, double max)
@@ -809,7 +808,7 @@ public final class AutoMaceHack extends Hack implements UpdateListener
 		CombinedFormatter formatter = new CombinedFormatter();
 		formatter.add(message);
 		formatter.add("fallDist=%.2f", MC.player.fallDistance);
-		formatter.add("velY=%.3f", MC.player.getVelocity().y);
+		formatter.add("velY=%.3f", MC.player.getDeltaMovement().y);
 		formatter.add("hasMace=%s", isMaceEquipped());
 		formatter.add("target=%s", currentTarget == null ? "none"
 			: currentTarget.getName().getString());
diff --git a/src/main/java/net/wurstclient/hacks/AutoMineHack.java b/src/main/java/net/wurstclient/hacks/AutoMineHack.java
index 59439caa9..851f1ceb2 100644
--- a/src/main/java/net/wurstclient/hacks/AutoMineHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoMineHack.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleBlockBreakingListener;
@@ -59,38 +59,38 @@ public final class AutoMineHack extends Hack
 	{
 		EVENTS.remove(UpdateListener.class, this);
 		EVENTS.remove(HandleBlockBreakingListener.class, this);
-		IKeyBinding.get(MC.options.attackKey).resetPressedState();
-		MC.interactionManager.cancelBlockBreaking();
+		IKeyBinding.get(MC.options.keyAttack).resetPressedState();
+		MC.gameMode.stopDestroyBlock();
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerInteractionManager im = MC.interactionManager;
+		MultiPlayerGameMode im = MC.gameMode;
 		
 		// Ignore the attack cooldown because opening any screen
 		// will set it to 10k ticks.
 		
-		if(MC.player.isRiding())
+		if(MC.player.isHandsBusy())
 		{
-			im.cancelBlockBreaking();
+			im.stopDestroyBlock();
 			return;
 		}
 		
-		HitResult hitResult = MC.crosshairTarget;
+		HitResult hitResult = MC.hitResult;
 		if(hitResult == null || hitResult.getType() != HitResult.Type.BLOCK
 			|| !(hitResult instanceof BlockHitResult bHitResult))
 		{
-			im.cancelBlockBreaking();
+			im.stopDestroyBlock();
 			return;
 		}
 		
 		BlockPos pos = bHitResult.getBlockPos();
-		BlockState state = MC.world.getBlockState(pos);
-		Direction side = bHitResult.getSide();
+		BlockState state = MC.level.getBlockState(pos);
+		Direction side = bHitResult.getDirection();
 		if(state.isAir())
 		{
-			im.cancelBlockBreaking();
+			im.stopDestroyBlock();
 			return;
 		}
 		
@@ -100,14 +100,14 @@ public final class AutoMineHack extends Hack
 			// This case doesn't cancel block breaking in vanilla Minecraft.
 			return;
 		
-		if(!im.isBreakingBlock())
-			im.attackBlock(pos, side);
+		if(!im.isDestroying())
+			im.startDestroyBlock(pos, side);
 		
-		if(im.updateBlockBreakingProgress(pos, side))
+		if(im.continueDestroyBlock(pos, side))
 		{
-			MC.world.spawnBlockBreakingParticle(pos, side);
-			MC.player.swingHand(Hand.MAIN_HAND);
-			MC.options.attackKey.setPressed(true);
+			MC.level.addBreakingBlockEffect(pos, side);
+			MC.player.swing(InteractionHand.MAIN_HAND);
+			MC.options.keyAttack.setDown(true);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/AutoPotionHack.java b/src/main/java/net/wurstclient/hacks/AutoPotionHack.java
index b86de9749..3c828404c 100644
--- a/src/main/java/net/wurstclient/hacks/AutoPotionHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoPotionHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -75,12 +75,12 @@ public final class AutoPotionHack extends Hack implements UpdateListener
 			
 			// throw potion in hotbar
 			MC.player.getInventory().setSelectedSlot(potionInHotbar);
-			new Rotation(MC.player.getYaw(), 90).sendPlayerLookPacket();
+			new Rotation(MC.player.getYRot(), 90).sendPlayerLookPacket();
 			IMC.getInteractionManager().rightClickItem();
 			
 			// reset slot and rotation
 			MC.player.getInventory().setSelectedSlot(oldSlot);
-			new Rotation(MC.player.getYaw(), MC.player.getPitch())
+			new Rotation(MC.player.getYRot(), MC.player.getXRot())
 				.sendPlayerLookPacket();
 			
 			// reset timer
@@ -102,14 +102,14 @@ public final class AutoPotionHack extends Hack implements UpdateListener
 	{
 		for(int i = startSlot; i < endSlot; i++)
 		{
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			
 			// filter out non-splash potion items
 			if(stack.getItem() != Items.SPLASH_POTION)
 				continue;
 			
 			// search for instant health effects
-			if(ItemUtils.hasEffect(stack, StatusEffects.INSTANT_HEALTH))
+			if(ItemUtils.hasEffect(stack, MobEffects.INSTANT_HEALTH))
 				return i;
 		}
 		
diff --git a/src/main/java/net/wurstclient/hacks/AutoRespawnHack.java b/src/main/java/net/wurstclient/hacks/AutoRespawnHack.java
index 5add707cb..0b3bb4a22 100644
--- a/src/main/java/net/wurstclient/hacks/AutoRespawnHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoRespawnHack.java
@@ -43,7 +43,7 @@ public final class AutoRespawnHack extends Hack implements DeathListener
 	@Override
 	public void onDeath()
 	{
-		MC.player.requestRespawn();
+		MC.player.respawn();
 		MC.setScreen(null);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/AutoSoupHack.java b/src/main/java/net/wurstclient/hacks/AutoSoupHack.java
index 61a89b969..47b2c036d 100644
--- a/src/main/java/net/wurstclient/hacks/AutoSoupHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoSoupHack.java
@@ -8,20 +8,19 @@
 package net.wurstclient.hacks;
 
 import java.util.List;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockWithEntity;
-import net.minecraft.block.CraftingTableBlock;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.passive.TameableEntity;
-import net.minecraft.entity.passive.VillagerEntity;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.BaseEntityBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.CraftingTableBlock;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -67,12 +66,12 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 		for(int i = 0; i < 36; i++)
 		{
 			// filter out non-bowl items and empty bowl slot
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			if(stack == null || stack.getItem() != Items.BOWL || i == 9)
 				continue;
 			
 			// check if empty bowl slot contains a non-bowl item
-			ItemStack emptyBowlStack = MC.player.getInventory().getStack(9);
+			ItemStack emptyBowlStack = MC.player.getInventory().getItem(9);
 			boolean swap = !emptyBowlStack.isEmpty()
 				&& emptyBowlStack.getItem() != Items.BOWL;
 			
@@ -107,7 +106,7 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 			MC.player.getInventory().setSelectedSlot(soupInHotbar);
 			
 			// eat soup
-			MC.options.useKey.setPressed(true);
+			MC.options.keyUse.setDown(true);
 			IMC.getInteractionManager().rightClickItem();
 			
 			return;
@@ -130,7 +129,7 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 		
 		for(int i = startSlot; i < endSlot; i++)
 		{
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			
 			if(stack != null && stews.contains(stack.getItem()))
 				return i;
@@ -146,7 +145,7 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 			return false;
 		
 		// check for clickable objects
-		if(isClickable(MC.crosshairTarget))
+		if(isClickable(MC.hitResult))
 			return false;
 		
 		return true;
@@ -159,19 +158,19 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 		
 		if(hitResult instanceof EntityHitResult)
 		{
-			Entity entity = ((EntityHitResult)MC.crosshairTarget).getEntity();
-			return entity instanceof VillagerEntity
-				|| entity instanceof TameableEntity;
+			Entity entity = ((EntityHitResult)MC.hitResult).getEntity();
+			return entity instanceof Villager
+				|| entity instanceof TamableAnimal;
 		}
 		
 		if(hitResult instanceof BlockHitResult)
 		{
-			BlockPos pos = ((BlockHitResult)MC.crosshairTarget).getBlockPos();
+			BlockPos pos = ((BlockHitResult)MC.hitResult).getBlockPos();
 			if(pos == null)
 				return false;
 			
-			Block block = MC.world.getBlockState(pos).getBlock();
-			return block instanceof BlockWithEntity
+			Block block = MC.level.getBlockState(pos).getBlock();
+			return block instanceof BaseEntityBlock
 				|| block instanceof CraftingTableBlock;
 		}
 		
@@ -185,7 +184,7 @@ public final class AutoSoupHack extends Hack implements UpdateListener
 			return;
 		
 		// stop eating
-		MC.options.useKey.setPressed(false);
+		MC.options.keyUse.setDown(false);
 		
 		// reset slot
 		MC.player.getInventory().setSelectedSlot(oldSlot);
diff --git a/src/main/java/net/wurstclient/hacks/AutoSprintHack.java b/src/main/java/net/wurstclient/hacks/AutoSprintHack.java
index 04cd4de83..aa1485f0a 100644
--- a/src/main/java/net/wurstclient/hacks/AutoSprintHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoSprintHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
+import net.minecraft.client.player.LocalPlayer;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -47,17 +47,17 @@ public final class AutoSprintHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		if(player.horizontalCollision || player.isSneaking())
+		LocalPlayer player = MC.player;
+		if(player.horizontalCollision || player.isShiftKeyDown())
 			return;
 		
-		if(player.isTouchingWater() || player.isSubmergedInWater())
+		if(player.isInWater() || player.isUnderWater())
 			return;
 		
-		if(!allDirections.isChecked() && player.forwardSpeed <= 0)
+		if(!allDirections.isChecked() && player.zza <= 0)
 			return;
 		
-		if(player.input.getMovementInput().length() <= 1e-5F)
+		if(player.input.getMoveVector().length() <= 1e-5F)
 			return;
 		
 		player.setSprinting(true);
diff --git a/src/main/java/net/wurstclient/hacks/AutoStealHack.java b/src/main/java/net/wurstclient/hacks/AutoStealHack.java
index c4b6786a3..88682f958 100644
--- a/src/main/java/net/wurstclient/hacks/AutoStealHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoStealHack.java
@@ -9,11 +9,10 @@ package net.wurstclient.hacks;
 
 import java.util.List;
 import java.util.stream.IntStream;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.item.Item;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.Item;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -52,18 +51,18 @@ public final class AutoStealHack extends Hack
 		addSetting(stealStoreSame);
 	}
 	
-	public void steal(HandledScreen<?> screen, int rows)
+	public void steal(AbstractContainerScreen<?> screen, int rows)
 	{
 		startClickingSlots(screen, 0, rows * 9, true);
 	}
 	
-	public void store(HandledScreen<?> screen, int rows)
+	public void store(AbstractContainerScreen<?> screen, int rows)
 	{
 		startClickingSlots(screen, rows * 9, rows * 9 + 36, false);
 	}
 	
-	private void startClickingSlots(HandledScreen<?> screen, int from, int to,
-		boolean steal)
+	private void startClickingSlots(AbstractContainerScreen<?> screen, int from,
+		int to, boolean steal)
 	{
 		if(thread != null && thread.isAlive())
 			thread.interrupt();
@@ -73,11 +72,11 @@ public final class AutoStealHack extends Hack
 			.start(() -> shiftClickSlots(screen, from, to, steal));
 	}
 	
-	private void shiftClickSlots(HandledScreen<?> screen, int from, int to,
-		boolean steal)
+	private void shiftClickSlots(AbstractContainerScreen<?> screen, int from,
+		int to, boolean steal)
 	{
 		List<Slot> slots = IntStream.range(from, to)
-			.mapToObj(i -> screen.getScreenHandler().slots.get(i)).toList();
+			.mapToObj(i -> screen.getMenu().slots.get(i)).toList();
 		
 		if(reverseSteal.isChecked() && steal)
 			slots = slots.reversed();
@@ -94,14 +93,14 @@ public final class AutoStealHack extends Hack
 				// hotbar).
 				int rows = to / 9; // when stealing `to` equals rows*9
 				int invStart = rows * 9;
-				int invEnd = Math.min(invStart + 36,
-					screen.getScreenHandler().slots.size());
+				int invEnd =
+					Math.min(invStart + 36, screen.getMenu().slots.size());
 				java.util.Set<Item> typesFromUI = new java.util.HashSet<>();
 				for(int i = invStart; i < invEnd; i++)
 				{
-					Slot s = screen.getScreenHandler().slots.get(i);
-					if(!s.getStack().isEmpty())
-						typesFromUI.add(s.getStack().getItem());
+					Slot s = screen.getMenu().slots.get(i);
+					if(!s.getItem().isEmpty())
+						typesFromUI.add(s.getItem().getItem());
 				}
 				if(!typesFromUI.isEmpty())
 					inventoryTypes = typesFromUI;
@@ -119,9 +118,9 @@ public final class AutoStealHack extends Hack
 				chestTypes = new java.util.HashSet<>();
 				for(int i = 0; i < from; i++)
 				{
-					Slot s = screen.getScreenHandler().slots.get(i);
-					if(!s.getStack().isEmpty())
-						chestTypes.add(s.getStack().getItem());
+					Slot s = screen.getMenu().slots.get(i);
+					if(!s.getItem().isEmpty())
+						chestTypes.add(s.getItem().getItem());
 				}
 			}
 		}
@@ -129,13 +128,14 @@ public final class AutoStealHack extends Hack
 		for(Slot slot : slots)
 			try
 			{
-				if(slot.getStack().isEmpty())
+				if(slot.getItem().isEmpty())
 					continue;
 				
 				// Exact-type filtering (Steal/Store same)
 				if(stealStoreSame.isChecked())
 				{
-					net.minecraft.item.Item item = slot.getStack().getItem();
+					net.minecraft.world.item.Item item =
+						slot.getItem().getItem();
 					if(steal)
 					{
 						if(inventoryTypes != null
@@ -150,11 +150,10 @@ public final class AutoStealHack extends Hack
 				
 				Thread.sleep(delay.getValueI());
 				
-				if(MC.currentScreen == null)
+				if(MC.screen == null)
 					break;
 				
-				screen.onMouseClick(slot, slot.id, 0,
-					SlotActionType.QUICK_MOVE);
+				screen.slotClicked(slot, slot.index, 0, ClickType.QUICK_MOVE);
 				
 			}catch(InterruptedException e)
 			{
@@ -177,10 +176,10 @@ public final class AutoStealHack extends Hack
 			{
 				for(Object o : (java.util.List<?>)main)
 				{
-					if(o instanceof net.minecraft.item.ItemStack)
+					if(o instanceof net.minecraft.world.item.ItemStack)
 					{
-						net.minecraft.item.ItemStack stack =
-							(net.minecraft.item.ItemStack)o;
+						net.minecraft.world.item.ItemStack stack =
+							(net.minecraft.world.item.ItemStack)o;
 						if(stack != null && !stack.isEmpty())
 							types.add(stack.getItem());
 					}
@@ -201,10 +200,10 @@ public final class AutoStealHack extends Hack
 						{
 							for(Object obj : (java.util.List<?>)listObj)
 							{
-								if(obj instanceof net.minecraft.item.ItemStack)
+								if(obj instanceof net.minecraft.world.item.ItemStack)
 								{
-									net.minecraft.item.ItemStack st =
-										(net.minecraft.item.ItemStack)obj;
+									net.minecraft.world.item.ItemStack st =
+										(net.minecraft.world.item.ItemStack)obj;
 									if(st != null && !st.isEmpty())
 										types.add(st.getItem());
 								}
@@ -220,14 +219,15 @@ public final class AutoStealHack extends Hack
 		return types.isEmpty() ? null : types;
 	}
 	
-	private java.util.Set<Item> getInventoryItemTypesUI(HandledScreen<?> screen)
+	private java.util.Set<Item> getInventoryItemTypesUI(
+		AbstractContainerScreen<?> screen)
 	{
 		java.util.Set<Item> types = new java.util.HashSet<>();
 		try
 		{
 			// Access the chest inventory directly from the screen handler
-			Object chestInventory = screen.getScreenHandler().getClass()
-				.getMethod("getInventory").invoke(screen.getScreenHandler());
+			Object chestInventory = screen.getMenu().getClass()
+				.getMethod("getInventory").invoke(screen.getMenu());
 			
 			// Try to read the 'stacks' field directly, which should contain
 			// the items visible in the player's chest GUI
@@ -237,10 +237,10 @@ public final class AutoStealHack extends Hack
 			{
 				for(Object o : (java.util.List<?>)stacksObj)
 				{
-					if(o instanceof net.minecraft.item.ItemStack)
+					if(o instanceof net.minecraft.world.item.ItemStack)
 					{
-						net.minecraft.item.ItemStack stack =
-							(net.minecraft.item.ItemStack)o;
+						net.minecraft.world.item.ItemStack stack =
+							(net.minecraft.world.item.ItemStack)o;
 						if(stack != null && !stack.isEmpty())
 							types.add(stack.getItem());
 					}
@@ -252,9 +252,9 @@ public final class AutoStealHack extends Hack
 			{
 				for(int i = 27; i < 63; i++)
 				{
-					Slot s = screen.getScreenHandler().slots.get(i);
-					if(!s.getStack().isEmpty())
-						types.add(s.getStack().getItem());
+					Slot s = screen.getMenu().slots.get(i);
+					if(!s.getItem().isEmpty())
+						types.add(s.getItem().getItem());
 				}
 			}
 		}catch(Exception ignored)
diff --git a/src/main/java/net/wurstclient/hacks/AutoSwimHack.java b/src/main/java/net/wurstclient/hacks/AutoSwimHack.java
index 94f8dabfd..3b9db6b2e 100644
--- a/src/main/java/net/wurstclient/hacks/AutoSwimHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoSwimHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
+import net.minecraft.client.player.LocalPlayer;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -37,15 +37,15 @@ public final class AutoSwimHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		if(player.horizontalCollision || player.isSneaking())
+		if(player.horizontalCollision || player.isShiftKeyDown())
 			return;
 		
-		if(!player.isTouchingWater())
+		if(!player.isInWater())
 			return;
 		
-		if(player.forwardSpeed > 0)
+		if(player.zza > 0)
 			player.setSprinting(true);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/AutoSwitchHack.java b/src/main/java/net/wurstclient/hacks/AutoSwitchHack.java
index 67e231f15..9776e7354 100644
--- a/src/main/java/net/wurstclient/hacks/AutoSwitchHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoSwitchHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.player.PlayerInventory;
+import net.minecraft.world.entity.player.Inventory;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -37,7 +37,7 @@ public final class AutoSwitchHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		int prevSlot = inventory.getSelectedSlot();
 		
 		if(prevSlot == 8)
diff --git a/src/main/java/net/wurstclient/hacks/AutoSwordHack.java b/src/main/java/net/wurstclient/hacks/AutoSwordHack.java
index c0ec93492..e65333dbb 100644
--- a/src/main/java/net/wurstclient/hacks/AutoSwordHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoSwordHack.java
@@ -7,15 +7,15 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.attribute.EntityAttributes;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.MaceItem;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.MaceItem;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -75,10 +75,10 @@ public final class AutoSwordHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.crosshairTarget != null
-			&& MC.crosshairTarget.getType() == HitResult.Type.ENTITY)
+		if(MC.hitResult != null
+			&& MC.hitResult.getType() == HitResult.Type.ENTITY)
 		{
-			Entity entity = ((EntityHitResult)MC.crosshairTarget).getEntity();
+			Entity entity = ((EntityHitResult)MC.hitResult).getEntity();
 			
 			if(entity instanceof LivingEntity
 				&& EntityUtils.IS_ATTACKABLE.test(entity))
@@ -111,11 +111,11 @@ public final class AutoSwordHack extends Hack implements UpdateListener
 		for(int i = 0; i < 9; i++)
 		{
 			// skip empty slots
-			if(MC.player.getInventory().getStack(i).isEmpty())
+			if(MC.player.getInventory().getItem(i).isEmpty())
 				continue;
 			
 			// get weapon value
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			float value = getValue(stack, entity);
 			
 			// compare with previous best weapon
@@ -144,29 +144,28 @@ public final class AutoSwordHack extends Hack implements UpdateListener
 	private float getValue(ItemStack stack, Entity entity)
 	{
 		Item item = stack.getItem();
-		if(stack.get(DataComponentTypes.TOOL) == null
-			&& stack.get(DataComponentTypes.WEAPON) == null)
+		if(stack.get(DataComponents.TOOL) == null
+			&& stack.get(DataComponents.WEAPON) == null)
 			return Integer.MIN_VALUE;
 		
 		switch(priority.getSelected())
 		{
 			case SPEED:
-			return (float)ItemUtils
-				.getAttribute(item, EntityAttributes.ATTACK_SPEED)
+			return (float)ItemUtils.getAttribute(item, Attributes.ATTACK_SPEED)
 				.orElse(Integer.MIN_VALUE);
 			
 			// Client-side item-specific attack damage calculation no
 			// longer exists as of 24w18a (1.21). Related bug: MC-196250
 			case DAMAGE:
 			// EntityType<?> group = entity.getType();
-			float dmg = (float)ItemUtils
-				.getAttribute(item, EntityAttributes.ATTACK_DAMAGE)
-				.orElse(Integer.MIN_VALUE);
+			float dmg =
+				(float)ItemUtils.getAttribute(item, Attributes.ATTACK_DAMAGE)
+					.orElse(Integer.MIN_VALUE);
 			
 			// Check for mace, get bonus damage from fall
 			if(item instanceof MaceItem mace)
-				dmg = mace.getBonusAttackDamage(MC.player, dmg,
-					entity.getDamageSources().playerAttack(MC.player));
+				dmg = mace.getAttackDamageBonus(MC.player, dmg,
+					entity.damageSources().playerAttack(MC.player));
 			// dmg += EnchantmentHelper.getAttackDamage(stack, group);
 			return dmg;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/AutoToolHack.java b/src/main/java/net/wurstclient/hacks/AutoToolHack.java
index 6a51efdb5..08cce3e39 100644
--- a/src/main/java/net/wurstclient/hacks/AutoToolHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoToolHack.java
@@ -10,21 +10,20 @@ package net.wurstclient.hacks;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.stream.IntStream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.enchantment.Enchantments;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.entry.RegistryEntry.Reference;
-import net.minecraft.registry.tag.ItemTags;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder.Reference;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -106,10 +105,10 @@ public final class AutoToolHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		if(prevSelectedSlot == -1 || MC.interactionManager.isBreakingBlock())
+		if(prevSelectedSlot == -1 || MC.gameMode.isDestroying())
 			return;
 		
-		HitResult hitResult = MC.crosshairTarget;
+		HitResult hitResult = MC.hitResult;
 		if(hitResult != null && hitResult.getType() == HitResult.Type.BLOCK)
 			return;
 		
@@ -131,11 +130,11 @@ public final class AutoToolHack extends Hack
 	public void equipBestTool(BlockPos pos, boolean useSwords, boolean useHands,
 		int repairMode)
 	{
-		ClientPlayerEntity player = MC.player;
-		if(player.getAbilities().creativeMode)
+		LocalPlayer player = MC.player;
+		if(player.getAbilities().instabuild)
 			return;
 		
-		ItemStack heldItem = player.getMainHandStack();
+		ItemStack heldItem = player.getMainHandItem();
 		boolean heldItemDamageable = isDamageable(heldItem);
 		if(heldItemDamageable && isTooDamaged(heldItem, repairMode))
 			putAwayDamagedTool(repairMode);
@@ -155,9 +154,9 @@ public final class AutoToolHack extends Hack
 	
 	private int getBestSlot(BlockState state, boolean useSwords, int repairMode)
 	{
-		ClientPlayerEntity player = MC.player;
-		PlayerInventory inventory = player.getInventory();
-		ItemStack heldItem = MC.player.getMainHandStack();
+		LocalPlayer player = MC.player;
+		Inventory inventory = player.getInventory();
+		ItemStack heldItem = MC.player.getMainHandItem();
 		
 		float bestSpeed = getMiningSpeed(heldItem, state);
 		if(isTooDamaged(heldItem, repairMode))
@@ -169,13 +168,13 @@ public final class AutoToolHack extends Hack
 			if(slot == inventory.getSelectedSlot())
 				continue;
 			
-			ItemStack stack = inventory.getStack(slot);
+			ItemStack stack = inventory.getItem(slot);
 			
 			float speed = getMiningSpeed(stack, state);
 			if(speed <= bestSpeed)
 				continue;
 			
-			if(!useSwords && stack.isIn(ItemTags.SWORDS))
+			if(!useSwords && stack.is(ItemTags.SWORDS))
 				continue;
 			
 			if(isTooDamaged(stack, repairMode))
@@ -190,20 +189,18 @@ public final class AutoToolHack extends Hack
 	
 	private float getMiningSpeed(ItemStack stack, BlockState state)
 	{
-		float speed = stack.getMiningSpeedMultiplier(state);
+		float speed = stack.getDestroySpeed(state);
 		
 		if(speed > 1)
 		{
-			DynamicRegistryManager drm =
-				WurstClient.MC.world.getRegistryManager();
+			RegistryAccess drm = WurstClient.MC.level.registryAccess();
 			Registry<Enchantment> registry =
-				drm.getOrThrow(RegistryKeys.ENCHANTMENT);
+				drm.lookupOrThrow(Registries.ENCHANTMENT);
 			
 			Optional<Reference<Enchantment>> efficiency =
-				registry.getOptional(Enchantments.EFFICIENCY);
-			int effLvl = efficiency
-				.map(entry -> EnchantmentHelper.getLevel(entry, stack))
-				.orElse(0);
+				registry.get(Enchantments.EFFICIENCY);
+			int effLvl = efficiency.map(entry -> EnchantmentHelper
+				.getItemEnchantmentLevel(entry, stack)).orElse(0);
 			
 			if(effLvl > 0 && !stack.isEmpty())
 				speed += effLvl * effLvl + 1;
@@ -214,24 +211,24 @@ public final class AutoToolHack extends Hack
 	
 	private boolean isDamageable(ItemStack stack)
 	{
-		return !stack.isEmpty() && stack.isDamageable();
+		return !stack.isEmpty() && stack.isDamageableItem();
 	}
 	
 	private boolean isTooDamaged(ItemStack stack, int repairMode)
 	{
-		return stack.getMaxDamage() - stack.getDamage() <= repairMode;
+		return stack.getMaxDamage() - stack.getDamageValue() <= repairMode;
 	}
 	
 	private void putAwayDamagedTool(int repairMode)
 	{
-		PlayerInventory inv = MC.player.getInventory();
+		Inventory inv = MC.player.getInventory();
 		int selectedSlot = inv.getSelectedSlot();
 		IClientPlayerInteractionManager im = IMC.getInteractionManager();
 		
 		// If there's an empty slot in the main inventory,
 		// shift-click the damaged item out of the hotbar
 		OptionalInt emptySlot = IntStream.range(9, 36)
-			.filter(i -> !inv.getStack(i).isEmpty()).findFirst();
+			.filter(i -> !inv.getItem(i).isEmpty()).findFirst();
 		if(emptySlot.isPresent())
 		{
 			im.windowClick_QUICK_MOVE(
@@ -241,7 +238,7 @@ public final class AutoToolHack extends Hack
 		
 		// Failing that, swap with a non-damageable item
 		OptionalInt nonDamageableSlot = IntStream.range(9, 36)
-			.filter(i -> !isDamageable(inv.getStack(i))).findFirst();
+			.filter(i -> !isDamageable(inv.getItem(i))).findFirst();
 		if(nonDamageableSlot.isPresent())
 		{
 			im.windowClick_SWAP(nonDamageableSlot.getAsInt(), selectedSlot);
@@ -250,8 +247,7 @@ public final class AutoToolHack extends Hack
 		
 		// Failing that, swap with a less damaged item
 		OptionalInt notTooDamagedSlot = IntStream.range(9, 36)
-			.filter(i -> !isTooDamaged(inv.getStack(i), repairMode))
-			.findFirst();
+			.filter(i -> !isTooDamaged(inv.getItem(i), repairMode)).findFirst();
 		if(notTooDamagedSlot.isPresent())
 		{
 			im.windowClick_SWAP(notTooDamagedSlot.getAsInt(), selectedSlot);
@@ -271,7 +267,7 @@ public final class AutoToolHack extends Hack
 	private void selectFallbackSlot()
 	{
 		int fallbackSlot = getFallbackSlot();
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		
 		if(fallbackSlot == -1)
 		{
@@ -289,14 +285,14 @@ public final class AutoToolHack extends Hack
 	
 	private int getFallbackSlot()
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		
 		for(int slot = 0; slot < 9; slot++)
 		{
 			if(slot == inventory.getSelectedSlot())
 				continue;
 			
-			ItemStack stack = inventory.getStack(slot);
+			ItemStack stack = inventory.getItem(slot);
 			
 			if(!isDamageable(stack))
 				return slot;
diff --git a/src/main/java/net/wurstclient/hacks/AutoTotemHack.java b/src/main/java/net/wurstclient/hacks/AutoTotemHack.java
index a441ffb97..dd3de4c86 100644
--- a/src/main/java/net/wurstclient/hacks/AutoTotemHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoTotemHack.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.CreativeModeInventoryScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -87,7 +87,7 @@ public final class AutoTotemHack extends Hack implements UpdateListener
 		
 		int nextTotemSlot = searchForTotems();
 		
-		if(isTotem(MC.player.getOffHandStack()))
+		if(isTotem(MC.player.getOffhandItem()))
 		{
 			wasTotemInOffhand = true;
 			return;
@@ -107,9 +107,9 @@ public final class AutoTotemHack extends Hack implements UpdateListener
 			return;
 		
 		// don't move items while a container is open
-		if(MC.currentScreen instanceof HandledScreen
-			&& !(MC.currentScreen instanceof InventoryScreen
-				|| MC.currentScreen instanceof CreativeInventoryScreen))
+		if(MC.screen instanceof AbstractContainerScreen
+			&& !(MC.screen instanceof InventoryScreen
+				|| MC.screen instanceof CreativeModeInventoryScreen))
 			return;
 		
 		if(timer > 0)
@@ -123,7 +123,7 @@ public final class AutoTotemHack extends Hack implements UpdateListener
 	
 	private void moveToOffhand(int itemSlot)
 	{
-		boolean offhandEmpty = MC.player.getOffHandStack().isEmpty();
+		boolean offhandEmpty = MC.player.getOffhandItem().isEmpty();
 		
 		IClientPlayerInteractionManager im = IMC.getInteractionManager();
 		im.windowClick_PICKUP(itemSlot);
@@ -155,6 +155,6 @@ public final class AutoTotemHack extends Hack implements UpdateListener
 	
 	private boolean isTotem(ItemStack stack)
 	{
-		return stack.isOf(Items.TOTEM_OF_UNDYING);
+		return stack.is(Items.TOTEM_OF_UNDYING);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/AutoTraderHack.java b/src/main/java/net/wurstclient/hacks/AutoTraderHack.java
index 96dcd166b..a3ade012d 100644
--- a/src/main/java/net/wurstclient/hacks/AutoTraderHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoTraderHack.java
@@ -8,15 +8,14 @@
 package net.wurstclient.hacks;
 
 import java.util.List;
-
-import net.minecraft.client.gui.screen.ingame.MerchantScreen;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.SelectMerchantTradeC2SPacket;
-import net.minecraft.screen.slot.SlotActionType;
-import net.minecraft.village.TradeOffer;
-import net.minecraft.village.TradeOfferList;
+import net.minecraft.client.gui.screens.inventory.MerchantScreen;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ServerboundSelectTradePacket;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.trading.MerchantOffer;
+import net.minecraft.world.item.trading.MerchantOffers;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -66,13 +65,13 @@ public final class AutoTraderHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.player == null || MC.currentScreen == null)
+		if(MC.player == null || MC.screen == null)
 			return;
 		
-		if(!(MC.currentScreen instanceof MerchantScreen tradeScreen))
+		if(!(MC.screen instanceof MerchantScreen tradeScreen))
 			return;
 		
-		TradeOfferList recipes = tradeScreen.getScreenHandler().getRecipes();
+		MerchantOffers recipes = tradeScreen.getMenu().getOffers();
 		if(recipes == null || recipes.isEmpty())
 			return;
 		
@@ -80,30 +79,30 @@ public final class AutoTraderHack extends Hack implements UpdateListener
 		if(wanted.isEmpty())
 			return;
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		// do one purchase per update tick to avoid spamming
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
 		for(int i = 0; i < recipes.size(); i++)
 		{
-			TradeOffer offer = recipes.get(i);
+			MerchantOffer offer = recipes.get(i);
 			if(offer == null)
 				continue;
 			
-			ItemStack sell = offer.getSellItem();
+			ItemStack sell = offer.getResult();
 			// we want trades where the villager gives emeralds (we sell items)
 			if(sell == null || sell.isEmpty()
 				|| sell.getItem() != Items.EMERALD)
 				continue;
 			
-			ItemStack firstBuy = offer.getDisplayedFirstBuyItem();
+			ItemStack firstBuy = offer.getCostA();
 			if(firstBuy == null || firstBuy.isEmpty())
 				continue;
 			
-			String req = net.minecraft.registry.Registries.ITEM
-				.getId(firstBuy.getItem()).toString();
+			String req = net.minecraft.core.registries.BuiltInRegistries.ITEM
+				.getKey(firstBuy.getItem()).toString();
 			boolean matches =
 				wanted.stream().anyMatch(s -> s.equalsIgnoreCase(req));
 			if(!matches)
@@ -114,31 +113,30 @@ public final class AutoTraderHack extends Hack implements UpdateListener
 				continue;
 			
 			// select trade
-			tradeScreen.getScreenHandler().setRecipeIndex(i);
-			tradeScreen.getScreenHandler().switchTo(i);
-			MC.getNetworkHandler()
-				.sendPacket(new SelectMerchantTradeC2SPacket(i));
+			tradeScreen.getMenu().setSelectionHint(i);
+			tradeScreen.getMenu().tryMoveItems(i);
+			MC.getConnection().send(new ServerboundSelectTradePacket(i));
 			
 			// click the result slot to perform the trade. Use HandledScreen
 			// mouse clicks so the client's cursor stack is updated and we can
 			// move the result into the inventory if it ends up on the cursor.
-			var handler = tradeScreen.getScreenHandler();
+			var handler = tradeScreen.getMenu();
 			if(handler.slots.size() > 2)
 			{
 				var outputSlot = handler.slots.get(2);
 				// pickup result
-				tradeScreen.onMouseClick(outputSlot, outputSlot.id, 0,
-					SlotActionType.PICKUP);
+				tradeScreen.slotClicked(outputSlot, outputSlot.index, 0,
+					ClickType.PICKUP);
 				
 				// if result ended up on the cursor, quick-move it into the
 				// inventory to avoid stalling.
-				if(!handler.getCursorStack().isEmpty())
-					tradeScreen.onMouseClick(outputSlot, outputSlot.id, 0,
-						SlotActionType.QUICK_MOVE);
+				if(!handler.getCarried().isEmpty())
+					tradeScreen.slotClicked(outputSlot, outputSlot.index, 0,
+						ClickType.QUICK_MOVE);
 			}
 			
 			// set a small cooldown
-			MC.itemUseCooldown = 4;
+			MC.rightClickDelay = 4;
 			return;
 		}
 	}
diff --git a/src/main/java/net/wurstclient/hacks/AutoWalkHack.java b/src/main/java/net/wurstclient/hacks/AutoWalkHack.java
index f300e6f89..7130f41d1 100644
--- a/src/main/java/net/wurstclient/hacks/AutoWalkHack.java
+++ b/src/main/java/net/wurstclient/hacks/AutoWalkHack.java
@@ -32,12 +32,12 @@ public final class AutoWalkHack extends Hack implements UpdateListener
 	protected void onDisable()
 	{
 		EVENTS.remove(UpdateListener.class, this);
-		IKeyBinding.get(MC.options.forwardKey).resetPressedState();
+		IKeyBinding.get(MC.options.keyUp).resetPressedState();
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		MC.options.forwardKey.setPressed(true);
+		MC.options.keyUp.setDown(true);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/BaseFinderHack.java b/src/main/java/net/wurstclient/hacks/BaseFinderHack.java
index 81046cc86..b33c22d43 100644
--- a/src/main/java/net/wurstclient/hacks/BaseFinderHack.java
+++ b/src/main/java/net/wurstclient/hacks/BaseFinderHack.java
@@ -7,15 +7,13 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.HashSet;
-
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstRenderLayers;
@@ -249,7 +247,7 @@ public final class BaseFinderHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		RegionPos region = RenderUtils.getCameraRegion();
 		if(!region.equals(lastRegion))
@@ -258,19 +256,19 @@ public final class BaseFinderHack extends Hack
 		if(vertexBuffer == null)
 			return;
 		
-		matrixStack.push();
+		matrixStack.pushPose();
 		RenderUtils.applyRegionalRenderOffset(matrixStack, region);
 		
 		vertexBuffer.draw(matrixStack, WurstRenderLayers.ESP_QUADS,
 			color.getColorF(), 0.25F);
 		
-		matrixStack.pop();
+		matrixStack.popPose();
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		int modulo = MC.player.age % 64;
+		int modulo = MC.player.tickCount % 64;
 		RegionPos region = RenderUtils.getCameraRegion();
 		
 		if(modulo == 0 || !region.equals(lastRegion))
@@ -278,11 +276,11 @@ public final class BaseFinderHack extends Hack
 			if(vertexBuffer != null)
 				vertexBuffer.close();
 			
-			vertexBuffer = EasyVertexBuffer.createAndUpload(DrawMode.QUADS,
-				VertexFormats.POSITION_COLOR, buffer -> {
+			vertexBuffer = EasyVertexBuffer.createAndUpload(Mode.QUADS,
+				DefaultVertexFormat.POSITION_COLOR, buffer -> {
 					for(int[] vertex : vertices)
-						buffer.vertex(vertex[0] - region.x(), vertex[1],
-							vertex[2] - region.z()).color(0xFFFFFFFF);
+						buffer.addVertex(vertex[0] - region.x(), vertex[1],
+							vertex[2] - region.z()).setColor(0xFFFFFFFF);
 				});
 			
 			lastRegion = region;
@@ -292,12 +290,12 @@ public final class BaseFinderHack extends Hack
 		if(modulo == 0)
 			matchingBlocks.clear();
 		
-		int stepSize = MC.world.getHeight() / 64;
-		int startY = MC.world.getTopYInclusive() - 1 - modulo * stepSize;
+		int stepSize = MC.level.getHeight() / 64;
+		int startY = MC.level.getMaxY() - 1 - modulo * stepSize;
 		int endY = startY - stepSize;
 		
 		BlockPos playerPos =
-			BlockPos.ofFloored(MC.player.getX(), 0, MC.player.getZ());
+			BlockPos.containing(MC.player.getX(), 0, MC.player.getZ());
 		
 		// search matching blocks
 		loop: for(int y = startY; y > endY; y--)
@@ -320,8 +318,9 @@ public final class BaseFinderHack extends Hack
 							? idFull.substring(idFull.indexOf(":") + 1)
 							: idFull;
 						String localSpaced = localId.replace('_', ' ');
-						net.minecraft.block.Block b = BlockUtils.getBlock(pos);
-						String transKey = b.getTranslationKey();
+						net.minecraft.world.level.block.Block b =
+							BlockUtils.getBlock(pos);
+						String transKey = b.getDescriptionId();
 						String display = b.getName().getString();
 						for(String term : naturalKeywords)
 							if(containsNormalized(idFull, term)
@@ -374,8 +373,8 @@ public final class BaseFinderHack extends Hack
 		java.util.ArrayList<String> kw = new java.util.ArrayList<>();
 		for(String s : blockNames)
 		{
-			net.minecraft.util.Identifier id =
-				net.minecraft.util.Identifier.tryParse(s);
+			net.minecraft.resources.ResourceLocation id =
+				net.minecraft.resources.ResourceLocation.tryParse(s);
 			if(id != null)
 				exact.add(id.toString());
 			else if(s != null && !s.isBlank())
diff --git a/src/main/java/net/wurstclient/hacks/BeaconExploitHack.java b/src/main/java/net/wurstclient/hacks/BeaconExploitHack.java
index 6a4f8ccd1..634c11bb5 100644
--- a/src/main/java/net/wurstclient/hacks/BeaconExploitHack.java
+++ b/src/main/java/net/wurstclient/hacks/BeaconExploitHack.java
@@ -8,11 +8,10 @@
 package net.wurstclient.hacks;
 
 import java.util.Optional;
-
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.network.packet.c2s.play.UpdateBeaconC2SPacket;
-import net.minecraft.registry.entry.RegistryEntry;
+import net.minecraft.core.Holder;
+import net.minecraft.network.protocol.game.ServerboundSetBeaconPacket;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -61,32 +60,30 @@ public final class BeaconExploitHack extends Hack
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(!(event.getPacket() instanceof UpdateBeaconC2SPacket packet))
+		if(!(event.getPacket() instanceof ServerboundSetBeaconPacket packet))
 			return;
 		
-		RegistryEntry<StatusEffect> primarySpoof =
+		Holder<MobEffect> primarySpoof =
 			primaryEffectSetting.getSelected().getStatusEffectEntry();
-		RegistryEntry<StatusEffect> secondarySpoof =
+		Holder<MobEffect> secondarySpoof =
 			secondaryEffectSetting.getSelected().getStatusEffectEntry();
 		
-		RegistryEntry<StatusEffect> primaryPacket =
-			packet.primary().orElse(null);
-		RegistryEntry<StatusEffect> secondaryPacket =
-			packet.secondary().orElse(null);
+		Holder<MobEffect> primaryPacket = packet.primary().orElse(null);
+		Holder<MobEffect> secondaryPacket = packet.secondary().orElse(null);
 		
 		if(primaryPacket == primarySpoof && secondaryPacket == secondarySpoof)
 			return;
 		
 		event.cancel();
 		
-		Optional<RegistryEntry<StatusEffect>> primaryOpt =
+		Optional<Holder<MobEffect>> primaryOpt =
 			Optional.ofNullable(primarySpoof);
-		Optional<RegistryEntry<StatusEffect>> secondaryOpt =
+		Optional<Holder<MobEffect>> secondaryOpt =
 			Optional.ofNullable(secondarySpoof);
 		
-		UpdateBeaconC2SPacket spoofedPacket =
-			new UpdateBeaconC2SPacket(primaryOpt, secondaryOpt);
-		MC.player.networkHandler.sendPacket(spoofedPacket);
+		ServerboundSetBeaconPacket spoofedPacket =
+			new ServerboundSetBeaconPacket(primaryOpt, secondaryOpt);
+		MC.player.connection.send(spoofedPacket);
 		
 		ChatUtils.message("Beacon effects spoofed:\n\tPrimary: [ "
 			+ primaryEffectSetting.getSelected().getName() + " ], Secondary: [ "
@@ -96,17 +93,17 @@ public final class BeaconExploitHack extends Hack
 	public enum BeaconEffect
 	{
 		NONE("None", null),
-		SPEED("Speed", StatusEffects.SPEED),
-		HASTE("Haste", StatusEffects.HASTE),
-		RESISTANCE("Resistance", StatusEffects.RESISTANCE),
-		JUMP_BOOST("Jump Boost", StatusEffects.JUMP_BOOST),
-		STRENGTH("Strength", StatusEffects.STRENGTH),
-		REGENERATION("Regeneration", StatusEffects.REGENERATION);
+		SPEED("Speed", MobEffects.SPEED),
+		HASTE("Haste", MobEffects.HASTE),
+		RESISTANCE("Resistance", MobEffects.RESISTANCE),
+		JUMP_BOOST("Jump Boost", MobEffects.JUMP_BOOST),
+		STRENGTH("Strength", MobEffects.STRENGTH),
+		REGENERATION("Regeneration", MobEffects.REGENERATION);
 		
 		private final String name;
-		private final RegistryEntry<StatusEffect> statusEffectEntry;
+		private final Holder<MobEffect> statusEffectEntry;
 		
-		BeaconEffect(String name, RegistryEntry<StatusEffect> statusEffectEntry)
+		BeaconEffect(String name, Holder<MobEffect> statusEffectEntry)
 		{
 			this.name = name;
 			this.statusEffectEntry = statusEffectEntry;
@@ -117,7 +114,7 @@ public final class BeaconExploitHack extends Hack
 			return name;
 		}
 		
-		public RegistryEntry<StatusEffect> getStatusEffectEntry()
+		public Holder<MobEffect> getStatusEffectEntry()
 		{
 			return statusEffectEntry;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/BedEspHack.java b/src/main/java/net/wurstclient/hacks/BedEspHack.java
index 8d2dcd249..a19d5d777 100644
--- a/src/main/java/net/wurstclient/hacks/BedEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/BedEspHack.java
@@ -7,33 +7,32 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.Arrays;
 import java.util.List;
 import java.util.function.BiPredicate;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.BedBlock;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.DoorBlock;
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.TrialSpawnerBlockEntity;
-import net.minecraft.block.enums.BedPart;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.passive.IronGolemEntity;
-import net.minecraft.entity.passive.VillagerEntity;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.tag.TagKey;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.IronGolem;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.DoorBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BedPart;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -103,10 +102,11 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	private int foundCount;
 	private int lastMatchesVersion;
 	private List<BlockPos> cachedTrialSpawners = List.of();
-	private List<Vec3d> cachedVillagerPositions = List.of();
-	private List<Vec3d> cachedGolemPositions = List.of();
-	private static final TagKey<Block> WAXED_COPPER_BLOCKS_TAG = TagKey.of(
-		RegistryKeys.BLOCK, Identifier.of("minecraft", "waxed_copper_blocks"));
+	private List<Vec3> cachedVillagerPositions = List.of();
+	private List<Vec3> cachedGolemPositions = List.of();
+	private static final TagKey<Block> WAXED_COPPER_BLOCKS_TAG =
+		TagKey.create(Registries.BLOCK, ResourceLocation
+			.fromNamespaceAndPath("minecraft", "waxed_copper_blocks"));
 	private boolean lastTrialFilterState;
 	private boolean lastVillageFilterState;
 	
@@ -137,7 +137,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 		EVENTS.add(PacketInputListener.class, coordinator);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
 		EVENTS.add(RenderListener.class, this);
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMatchesVersion = coordinator.getMatchesVersion();
 		lastTrialFilterState = filterTrialChambers.isChecked();
 		lastVillageFilterState = filterVillageBeds.isChecked();
@@ -174,7 +174,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -198,7 +198,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(style.hasBoxes())
 			renderBoxes(matrixStack);
@@ -207,14 +207,14 @@ public final class BedEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(BedEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
 			
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			
@@ -224,15 +224,15 @@ public final class BedEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(BedEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
 			
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
@@ -265,7 +265,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	{
 		BlockState state = result.state();
 		if(!(state.getBlock() instanceof BedBlock)
-			|| state.get(BedBlock.PART) == BedPart.FOOT)
+			|| state.getValue(BedBlock.PART) == BedPart.FOOT)
 			return;
 		
 		BlockPos headPos = result.pos();
@@ -294,10 +294,8 @@ public final class BedEspHack extends Hack implements UpdateListener,
 		
 		if(filterVillageBeds.isChecked())
 		{
-			cachedVillagerPositions =
-				collectEntityPositions(VillagerEntity.class);
-			cachedGolemPositions =
-				collectEntityPositions(IronGolemEntity.class);
+			cachedVillagerPositions = collectEntityPositions(Villager.class);
+			cachedGolemPositions = collectEntityPositions(IronGolem.class);
 		}else
 		{
 			cachedVillagerPositions = List.of();
@@ -321,23 +319,24 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	
 	private List<BlockPos> collectTrialSpawnerPositions()
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return List.of();
 		
 		return ChunkUtils.getLoadedBlockEntities()
 			.filter(be -> be instanceof TrialSpawnerBlockEntity)
-			.map(BlockEntity::getPos).map(BlockPos::toImmutable)
+			.map(BlockEntity::getBlockPos).map(BlockPos::immutable)
 			.collect(Collectors.toList());
 	}
 	
-	private <T extends Entity> List<Vec3d> collectEntityPositions(Class<T> type)
+	private <T extends Entity> List<Vec3> collectEntityPositions(Class<T> type)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return List.of();
 		
-		return StreamSupport.stream(MC.world.getEntities().spliterator(), false)
+		return StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), false)
 			.filter(e -> !e.isRemoved()).filter(type::isInstance)
-			.map(entity -> Vec3d.ofCenter(entity.getBlockPos()))
+			.map(entity -> Vec3.atCenterOf(entity.blockPosition()))
 			.collect(Collectors.toList());
 	}
 	
@@ -355,7 +354,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	
 	private boolean isNearWaxedCopper(BlockPos center, int range)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return false;
 		
 		return BlockUtils.getAllInBoxStream(center, range)
@@ -364,10 +363,11 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	
 	private boolean isWaxedCopper(BlockState state)
 	{
-		if(state.isIn(WAXED_COPPER_BLOCKS_TAG))
+		if(state.is(WAXED_COPPER_BLOCKS_TAG))
 			return true;
 		
-		String idPath = Registries.BLOCK.getId(state.getBlock()).getPath();
+		String idPath =
+			BuiltInRegistries.BLOCK.getKey(state.getBlock()).getPath();
 		return idPath.contains("waxed") && idPath.contains("copper");
 	}
 	
@@ -377,9 +377,9 @@ public final class BedEspHack extends Hack implements UpdateListener,
 			return false;
 		
 		double rangeSq = range * range;
-		Vec3d centerVec = Vec3d.ofCenter(center);
+		Vec3 centerVec = Vec3.atCenterOf(center);
 		return cachedTrialSpawners.stream().anyMatch(
-			pos -> Vec3d.ofCenter(pos).squaredDistanceTo(centerVec) <= rangeSq);
+			pos -> Vec3.atCenterOf(pos).distanceToSqr(centerVec) <= rangeSq);
 	}
 	
 	private boolean isLikelyVillageBed(BlockPos headPos)
@@ -398,21 +398,21 @@ public final class BedEspHack extends Hack implements UpdateListener,
 		return hasGlassPaneCluster(headPos, 4, 1);
 	}
 	
-	private boolean isEntityWithinRange(List<Vec3d> positions, BlockPos center,
+	private boolean isEntityWithinRange(List<Vec3> positions, BlockPos center,
 		double range)
 	{
 		if(positions.isEmpty())
 			return false;
 		
 		double rangeSq = range * range;
-		Vec3d centerVec = Vec3d.ofCenter(center);
+		Vec3 centerVec = Vec3.atCenterOf(center);
 		return positions.stream()
-			.anyMatch(pos -> pos.squaredDistanceTo(centerVec) <= rangeSq);
+			.anyMatch(pos -> pos.distanceToSqr(centerVec) <= rangeSq);
 	}
 	
 	private boolean hasHayBaleCluster(BlockPos center, int range)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return false;
 		
 		long count = BlockUtils.getAllInBoxStream(center, range)
@@ -423,7 +423,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	
 	private boolean hasDoorNearby(BlockPos center, int range)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return false;
 		
 		return BlockUtils.getAllInBoxStream(center, range)
@@ -433,7 +433,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	private boolean hasGlassPaneCluster(BlockPos center, int range,
 		int requiredCount)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return false;
 		
 		long glassCount = BlockUtils.getAllInBoxStream(center, range)
@@ -444,7 +444,7 @@ public final class BedEspHack extends Hack implements UpdateListener,
 	
 	private boolean isGlassPane(Block block)
 	{
-		String path = Registries.BLOCK.getId(block).getPath();
+		String path = BuiltInRegistries.BLOCK.getKey(block).getPath();
 		return path.contains("glass_pane");
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/BlinkHack.java b/src/main/java/net/wurstclient/hacks/BlinkHack.java
index 8faf80e10..e877e01e5 100644
--- a/src/main/java/net/wurstclient/hacks/BlinkHack.java
+++ b/src/main/java/net/wurstclient/hacks/BlinkHack.java
@@ -8,8 +8,7 @@
 package net.wurstclient.hacks;
 
 import java.util.ArrayDeque;
-
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -30,7 +29,8 @@ public final class BlinkHack extends Hack
 			+ "0 = no limit",
 		0, 0, 500, 1, ValueDisplay.INTEGER.withLabel(0, "disabled"));
 	
-	private final ArrayDeque<PlayerMoveC2SPacket> packets = new ArrayDeque<>();
+	private final ArrayDeque<ServerboundMovePlayerPacket> packets =
+		new ArrayDeque<>();
 	private FakePlayerEntity fakePlayer;
 	
 	public BlinkHack()
@@ -65,7 +65,7 @@ public final class BlinkHack extends Hack
 		EVENTS.remove(PacketOutputListener.class, this);
 		
 		fakePlayer.despawn();
-		packets.forEach(p -> MC.player.networkHandler.sendPacket(p));
+		packets.forEach(p -> MC.player.connection.send(p));
 		packets.clear();
 	}
 	
@@ -85,17 +85,18 @@ public final class BlinkHack extends Hack
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(!(event.getPacket() instanceof PlayerMoveC2SPacket))
+		if(!(event.getPacket() instanceof ServerboundMovePlayerPacket))
 			return;
 		
 		event.cancel();
 		
-		PlayerMoveC2SPacket packet = (PlayerMoveC2SPacket)event.getPacket();
-		PlayerMoveC2SPacket prevPacket = packets.peekLast();
+		ServerboundMovePlayerPacket packet =
+			(ServerboundMovePlayerPacket)event.getPacket();
+		ServerboundMovePlayerPacket prevPacket = packets.peekLast();
 		
 		if(prevPacket != null && packet.isOnGround() == prevPacket.isOnGround()
-			&& packet.getYaw(-1) == prevPacket.getYaw(-1)
-			&& packet.getPitch(-1) == prevPacket.getPitch(-1)
+			&& packet.getYRot(-1) == prevPacket.getYRot(-1)
+			&& packet.getXRot(-1) == prevPacket.getXRot(-1)
 			&& packet.getX(-1) == prevPacket.getX(-1)
 			&& packet.getY(-1) == prevPacket.getY(-1)
 			&& packet.getZ(-1) == prevPacket.getZ(-1))
diff --git a/src/main/java/net/wurstclient/hacks/BoatFlyHack.java b/src/main/java/net/wurstclient/hacks/BoatFlyHack.java
index c98bfdd00..27581c784 100644
--- a/src/main/java/net/wurstclient/hacks/BoatFlyHack.java
+++ b/src/main/java/net/wurstclient/hacks/BoatFlyHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -57,11 +57,11 @@ public final class BoatFlyHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// check if riding
-		if(!MC.player.hasVehicle())
+		if(!MC.player.isPassenger())
 			return;
 		
 		Entity vehicle = MC.player.getVehicle();
-		Vec3d velocity = vehicle.getVelocity();
+		Vec3 velocity = vehicle.getDeltaMovement();
 		
 		// default motion
 		double motionX = velocity.x;
@@ -69,22 +69,22 @@ public final class BoatFlyHack extends Hack implements UpdateListener
 		double motionZ = velocity.z;
 		
 		// up/down
-		if(MC.options.jumpKey.isPressed())
+		if(MC.options.keyJump.isDown())
 			motionY = upwardSpeed.getValue();
-		else if(MC.options.sprintKey.isPressed())
+		else if(MC.options.keySprint.isDown())
 			motionY = velocity.y;
 		
 		// forward
-		if(MC.options.forwardKey.isPressed() && changeForwardSpeed.isChecked())
+		if(MC.options.keyUp.isDown() && changeForwardSpeed.isChecked())
 		{
 			double speed = forwardSpeed.getValue();
-			float yawRad = vehicle.getYaw() * MathHelper.RADIANS_PER_DEGREE;
+			float yawRad = vehicle.getYRot() * Mth.DEG_TO_RAD;
 			
-			motionX = MathHelper.sin(-yawRad) * speed;
-			motionZ = MathHelper.cos(yawRad) * speed;
+			motionX = Mth.sin(-yawRad) * speed;
+			motionZ = Mth.cos(yawRad) * speed;
 		}
 		
 		// apply motion
-		vehicle.setVelocity(motionX, motionY, motionZ);
+		vehicle.setDeltaMovement(motionX, motionY, motionZ);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/BonemealAuraHack.java b/src/main/java/net/wurstclient/hacks/BonemealAuraHack.java
index 050349e44..bdda433a7 100644
--- a/src/main/java/net/wurstclient/hacks/BonemealAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/BonemealAuraHack.java
@@ -11,12 +11,19 @@ import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Collectors;
 
-import net.minecraft.block.*;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.item.Items;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.CocoaBlock;
+import net.minecraft.world.level.block.CropBlock;
+import net.minecraft.world.level.block.GrassBlock;
+import net.minecraft.world.level.block.SaplingBlock;
+import net.minecraft.world.level.block.StemBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleInputListener;
@@ -96,10 +103,10 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 	public void onHandleInput()
 	{
 		// wait for right click timer
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
-		if(MC.interactionManager.isBreakingBlock() || MC.player.isRiding())
+		if(MC.gameMode.isDestroying() || MC.player.isHandsBusy())
 			return;
 		
 		// get valid blocks
@@ -142,14 +149,14 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 				
 			// swing arm
 			if(shouldSwing)
-				MC.player.swingHand(Hand.MAIN_HAND);
+				MC.player.swing(InteractionHand.MAIN_HAND);
 		}
 	}
 	
 	private ArrayList<BlockPos> getValidBlocks()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
@@ -157,11 +164,11 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 		// sight to other plants behind them. That's why we need to bone-meal
 		// the farthest plants first.
 		Comparator<BlockPos> farthestFirst = Comparator
-			.comparingDouble((BlockPos pos) -> pos.getSquaredDistance(eyesVec))
+			.comparingDouble((BlockPos pos) -> pos.distToCenterSqr(eyesVec))
 			.reversed();
 		
 		return BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-			.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
+			.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
 			.filter(this::isCorrectBlock).sorted(farthestFirst)
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
@@ -170,29 +177,29 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 	{
 		Block block = BlockUtils.getBlock(pos);
 		BlockState state = BlockUtils.getState(pos);
-		ClientWorld world = MC.world;
+		ClientLevel world = MC.level;
 		
-		if(!(block instanceof Fertilizable fBlock)
-			|| !fBlock.canGrow(world, world.random, pos, state))
+		if(!(block instanceof BonemealableBlock fBlock)
+			|| !fBlock.isBonemealSuccess(world, world.random, pos, state))
 			return false;
 		
 		if(block instanceof GrassBlock)
 			return false;
 		
 		if(block instanceof SaplingBlock sapling
-			&& sapling.isFertilizable(world, pos, state))
+			&& sapling.isValidBonemealTarget(world, pos, state))
 			return saplings.isChecked();
 		
 		if(block instanceof CropBlock crop
-			&& crop.isFertilizable(world, pos, state))
+			&& crop.isValidBonemealTarget(world, pos, state))
 			return crops.isChecked();
 		
 		if(block instanceof StemBlock stem
-			&& stem.isFertilizable(world, pos, state))
+			&& stem.isValidBonemealTarget(world, pos, state))
 			return stems.isChecked();
 		
 		if(block instanceof CocoaBlock cocoaBlock
-			&& cocoaBlock.isFertilizable(world, pos, state))
+			&& cocoaBlock.isValidBonemealTarget(world, pos, state))
 			return cocoa.isChecked();
 		
 		return other.isChecked();
@@ -201,7 +208,7 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 	private boolean rightClickBlockLegit(BlockPos pos)
 	{
 		// if breaking or riding, stop and don't try other blocks
-		if(MC.interactionManager.isBreakingBlock() || MC.player.isRiding())
+		if(MC.gameMode.isDestroying() || MC.player.isHandsBusy())
 			return true;
 		
 		// if this block is unreachable, try the next one
@@ -211,7 +218,7 @@ public final class BonemealAuraHack extends Hack implements HandleInputListener
 			return false;
 		
 		// face and right click the block
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 		WURST.getRotationFaker().faceVectorPacket(params.hitVec());
 		InteractionSimulator.rightClickBlock(params.toHitResult());
 		return true;
diff --git a/src/main/java/net/wurstclient/hacks/BowAimbotHack.java b/src/main/java/net/wurstclient/hacks/BowAimbotHack.java
index 4b0a1089f..780f4d1ec 100644
--- a/src/main/java/net/wurstclient/hacks/BowAimbotHack.java
+++ b/src/main/java/net/wurstclient/hacks/BowAimbotHack.java
@@ -7,23 +7,22 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.Comparator;
 import java.util.function.ToDoubleFunction;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.item.BowItem;
-import net.minecraft.item.CrossbowItem;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.BowItem;
+import net.minecraft.world.item.CrossbowItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.GUIRenderListener;
@@ -102,10 +101,10 @@ public final class BowAimbotHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		// check if item is ranged weapon
-		ItemStack stack = MC.player.getInventory().getSelectedStack();
+		ItemStack stack = MC.player.getInventory().getSelectedItem();
 		Item item = stack.getItem();
 		if(!(item instanceof BowItem || item instanceof CrossbowItem))
 		{
@@ -114,7 +113,7 @@ public final class BowAimbotHack extends Hack
 		}
 		
 		// check if using bow
-		if(item instanceof BowItem && !MC.options.useKey.isPressed()
+		if(item instanceof BowItem && !MC.options.keyUse.isDown()
 			&& !player.isUsingItem())
 		{
 			target = null;
@@ -131,13 +130,13 @@ public final class BowAimbotHack extends Hack
 		// set target
 		if(filterEntities(Stream.of(target)) == null)
 			target = filterEntities(StreamSupport
-				.stream(MC.world.getEntities().spliterator(), true));
+				.stream(MC.level.entitiesForRendering().spliterator(), true));
 		
 		if(target == null)
 			return;
 		
 		// set velocity
-		velocity = (72000 - player.getItemUseTimeLeft()) / 20F;
+		velocity = (72000 - player.getUseItemRemainingTicks()) / 20F;
 		velocity = (velocity * velocity + velocity * 2) / 3;
 		if(velocity > 1)
 			velocity = 1;
@@ -145,18 +144,18 @@ public final class BowAimbotHack extends Hack
 		// set position to aim at
 		double d = RotationUtils.getEyesPos().distanceTo(
 			target.getBoundingBox().getCenter()) * predictMovement.getValue();
-		double posX = target.getX() + (target.getX() - target.lastRenderX) * d
-			- player.getX();
-		double posY = target.getY() + (target.getY() - target.lastRenderY) * d
-			+ target.getHeight() * 0.5 - player.getY()
+		double posX =
+			target.getX() + (target.getX() - target.xOld) * d - player.getX();
+		double posY = target.getY() + (target.getY() - target.yOld) * d
+			+ target.getBbHeight() * 0.5 - player.getY()
 			- player.getEyeHeight(player.getPose());
-		double posZ = target.getZ() + (target.getZ() - target.lastRenderZ) * d
-			- player.getZ();
+		double posZ =
+			target.getZ() + (target.getZ() - target.zOld) * d - player.getZ();
 		
 		// set yaw
 		float neededYaw = (float)Math.toDegrees(Math.atan2(posZ, posX)) - 90;
-		MC.player.setYaw(
-			RotationUtils.limitAngleChange(MC.player.getYaw(), neededYaw));
+		MC.player.setYRot(
+			RotationUtils.limitAngleChange(MC.player.getYRot(), neededYaw));
 		
 		// calculate needed pitch
 		double hDistance = Math.sqrt(posX * posX + posZ * posZ);
@@ -173,7 +172,7 @@ public final class BowAimbotHack extends Hack
 			WURST.getRotationFaker()
 				.faceVectorClient(target.getBoundingBox().getCenter());
 		else
-			MC.player.setPitch(neededPitch);
+			MC.player.setXRot(neededPitch);
 	}
 	
 	private Entity filterEntities(Stream<Entity> s)
@@ -185,13 +184,13 @@ public final class BowAimbotHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(target == null)
 			return;
 		
-		Box box = EntityUtils.getLerpedBox(target, partialTicks)
-			.offset(0, 0.05, 0).expand(0.05);
+		AABB box = EntityUtils.getLerpedBox(target, partialTicks)
+			.move(0, 0.05, 0).inflate(0.05);
 		
 		int quadColor = color.getColorI(0.5F * velocity);
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
@@ -201,7 +200,7 @@ public final class BowAimbotHack extends Hack
 	}
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
 		if(target == null)
 			return;
@@ -212,24 +211,25 @@ public final class BowAimbotHack extends Hack
 		else
 			message = "Target Locked";
 		
-		TextRenderer tr = MC.textRenderer;
-		int msgWidth = tr.getWidth(message);
+		Font tr = MC.font;
+		int msgWidth = tr.width(message);
 		
-		int msgX1 = context.getScaledWindowWidth() / 2 - msgWidth / 2;
+		int msgX1 = context.guiWidth() / 2 - msgWidth / 2;
 		int msgX2 = msgX1 + msgWidth + 3;
-		int msgY1 = context.getScaledWindowHeight() / 2 + 1;
+		int msgY1 = context.guiHeight() / 2 + 1;
 		int msgY2 = msgY1 + 10;
 		
 		// background
 		context.fill(msgX1, msgY1, msgX2, msgY2, 0x80000000);
 		
 		// text
-		context.drawText(tr, message, msgX1 + 2, msgY1 + 1, 0xFFFFFFFF, false);
+		context.drawString(tr, message, msgX1 + 2, msgY1 + 1, 0xFFFFFFFF,
+			false);
 	}
 	
 	private enum Priority
 	{
-		DISTANCE("Distance", e -> MC.player.squaredDistanceTo(e)),
+		DISTANCE("Distance", e -> MC.player.distanceToSqr(e)),
 		
 		ANGLE("Angle",
 			e -> RotationUtils
@@ -239,7 +239,7 @@ public final class BowAimbotHack extends Hack
 			e -> Math
 				.pow(RotationUtils
 					.getAngleToLookVec(e.getBoundingBox().getCenter()), 2)
-				+ MC.player.squaredDistanceTo(e)),
+				+ MC.player.distanceToSqr(e)),
 		
 		HEALTH("Health", e -> e instanceof LivingEntity
 			? ((LivingEntity)e).getHealth() : Integer.MAX_VALUE);
diff --git a/src/main/java/net/wurstclient/hacks/BreadcrumbsHack.java b/src/main/java/net/wurstclient/hacks/BreadcrumbsHack.java
index 87e814f1a..4d4f00cfc 100644
--- a/src/main/java/net/wurstclient/hacks/BreadcrumbsHack.java
+++ b/src/main/java/net/wurstclient/hacks/BreadcrumbsHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -15,10 +16,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.world.dimension.DimensionType;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.level.dimension.DimensionType;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -46,7 +45,7 @@ public final class BreadcrumbsHack extends Hack
 		BOTH
 	}
 	
-	private boolean movedEnough(Vec3d a, Vec3d b, double minDist)
+	private boolean movedEnough(Vec3 a, Vec3 b, double minDist)
 	{
 		double dx = a.x - b.x;
 		double dy = a.y - b.y;
@@ -138,10 +137,10 @@ public final class BreadcrumbsHack extends Hack
 	// per-player colors are managed via PlayerColorRegistry
 	private static final class Point
 	{
-		final Vec3d pos;
+		final Vec3 pos;
 		final DimensionType dim;
 		
-		Point(Vec3d pos, DimensionType dim)
+		Point(Vec3 pos, DimensionType dim)
 		{
 			this.pos = pos;
 			this.dim = dim;
@@ -215,15 +214,15 @@ public final class BreadcrumbsHack extends Hack
 		// Do not add new points while paused
 		if(paused.isChecked())
 			return;
-		Vec3d herePos =
-			new Vec3d(MC.player.getX(), MC.player.getY(), MC.player.getZ());
-		DimensionType hereDim = MC.world.getDimension();
+		Vec3 herePos =
+			new Vec3(MC.player.getX(), MC.player.getY(), MC.player.getZ());
+		DimensionType hereDim = MC.level.dimensionType();
 		if(points.isEmpty())
 		{
 			points.add(new Point(herePos, hereDim));
 			return;
 		}
-		Vec3d last = points.peekLast().pos;
+		Vec3 last = points.peekLast().pos;
 		if(movedEnough(last, herePos, sectionLen.getValue()))
 		{
 			points.add(new Point(herePos, hereDim));
@@ -236,11 +235,11 @@ public final class BreadcrumbsHack extends Hack
 		// Track other players if enabled
 		if(sel == Target.OTHERS || sel == Target.BOTH)
 		{
-			for(var p : MC.world.getPlayers())
+			for(var p : MC.level.players())
 			{
 				if(p == MC.player)
 					continue;
-				UUID id = p.getUuid();
+				UUID id = p.getUUID();
 				// assign a color if needed via central registry
 				if(randomBrightColors.isChecked())
 				{
@@ -256,14 +255,14 @@ public final class BreadcrumbsHack extends Hack
 				}
 				Deque<Point> dq =
 					otherPoints.computeIfAbsent(id, k -> new ArrayDeque<>());
-				Vec3d pos = new Vec3d(p.getX(), p.getY(), p.getZ());
-				DimensionType pdim = MC.world.getDimension();
+				Vec3 pos = new Vec3(p.getX(), p.getY(), p.getZ());
+				DimensionType pdim = MC.level.dimensionType();
 				if(dq.isEmpty())
 				{
 					dq.add(new Point(pos, pdim));
 					continue;
 				}
-				Vec3d lastp = dq.peekLast().pos;
+				Vec3 lastp = dq.peekLast().pos;
 				if(movedEnough(lastp, pos, sectionLen.getValue()))
 				{
 					dq.add(new Point(pos, pdim));
@@ -277,10 +276,10 @@ public final class BreadcrumbsHack extends Hack
 			if(!keepOthersOnLeave.isChecked())
 			{
 				otherPoints.keySet()
-					.removeIf(uuid -> MC.world.getPlayerByUuid(uuid) == null);
+					.removeIf(uuid -> MC.level.getPlayerByUUID(uuid) == null);
 				// If not keeping trails we also remove registry entries
 				otherPoints.keySet().forEach(uuid -> {
-					if(MC.world.getPlayerByUuid(uuid) == null)
+					if(MC.level.getPlayerByUUID(uuid) == null)
 						net.wurstclient.util.PlayerColorRegistry.remove(uuid);
 				});
 			}
@@ -313,15 +312,15 @@ public final class BreadcrumbsHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		double thickness = lineThickness.getValue();
 		Target sel = target.getSelected();
 		// render your trail only when YOU or BOTH selected
 		if((sel == Target.YOU || sel == Target.BOTH))
 		{
-			DimensionType curDim = MC.world.getDimension();
-			List<Vec3d> list = new ArrayList<>();
+			DimensionType curDim = MC.level.dimensionType();
+			List<Vec3> list = new ArrayList<>();
 			for(Point p : points)
 			{
 				if(p.dim == curDim)
@@ -343,13 +342,13 @@ public final class BreadcrumbsHack extends Hack
 		// render other players' trails
 		if(sel == Target.OTHERS || sel == Target.BOTH)
 		{
-			DimensionType curDim = MC.world.getDimension();
+			DimensionType curDim = MC.level.dimensionType();
 			for(var entry : otherPoints.entrySet())
 			{
 				Deque<Point> dq = entry.getValue();
 				UUID id = entry.getKey();
 				
-				List<Vec3d> l = new ArrayList<>();
+				List<Vec3> l = new ArrayList<>();
 				for(Point p : dq)
 					if(p.dim == curDim)
 						l.add(p.pos);
diff --git a/src/main/java/net/wurstclient/hacks/BuildRandomHack.java b/src/main/java/net/wurstclient/hacks/BuildRandomHack.java
index 4da8b6c3f..42cd8fbb9 100644
--- a/src/main/java/net/wurstclient/hacks/BuildRandomHack.java
+++ b/src/main/java/net/wurstclient/hacks/BuildRandomHack.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Random;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.item.BlockItem;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -127,18 +126,17 @@ public final class BuildRandomHack extends Hack
 		if(WURST.getHax().freecamHack.isEnabled())
 			return;
 		
-		if(!fastPlace.isChecked() && MC.itemUseCooldown > 0)
+		if(!fastPlace.isChecked() && MC.rightClickDelay > 0)
 			return;
 		
 		if(checkItem.isChecked() && !MC.player.isHolding(
 			stack -> !stack.isEmpty() && stack.getItem() instanceof BlockItem))
 			return;
 		
-		if(!placeWhileBreaking.isChecked()
-			&& MC.interactionManager.isBreakingBlock())
+		if(!placeWhileBreaking.isChecked() && MC.gameMode.isDestroying())
 			return;
 		
-		if(!placeWhileRiding.isChecked() && MC.player.isRiding())
+		if(!placeWhileRiding.isChecked() && MC.player.isHandsBusy())
 			return;
 		
 		int maxAttempts = this.maxAttempts.getValueI();
@@ -150,7 +148,7 @@ public final class BuildRandomHack extends Hack
 		do
 		{
 			// generate random position
-			pos = BlockPos.ofFloored(RotationUtils.getEyesPos()).add(
+			pos = BlockPos.containing(RotationUtils.getEyesPos()).offset(
 				random.nextInt(bound) - blockRange,
 				random.nextInt(bound) - blockRange,
 				random.nextInt(bound) - blockRange);
@@ -161,7 +159,7 @@ public final class BuildRandomHack extends Hack
 	
 	private boolean tryToPlaceBlock(BlockPos pos)
 	{
-		if(!BlockUtils.getState(pos).isReplaceable())
+		if(!BlockUtils.getState(pos).canBeReplaced())
 			return false;
 		
 		BlockPlacingParams params = BlockPlacer.getBlockPlacingParams(pos);
@@ -170,7 +168,7 @@ public final class BuildRandomHack extends Hack
 		if(checkLOS.isChecked() && !params.lineOfSight())
 			return false;
 		
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 		faceTarget.face(params.hitVec());
 		lastPos = pos;
 		
@@ -180,7 +178,7 @@ public final class BuildRandomHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(lastPos == null || !indicator.isChecked())
 			return;
@@ -193,7 +191,7 @@ public final class BuildRandomHack extends Hack
 		int lineColor = RenderUtils.toIntColor(rgb, 0.5F);
 		
 		// Draw box
-		Box box = new Box(lastPos);
+		AABB box = new AABB(lastPos);
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, box, lineColor, false);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/BunnyHopHack.java b/src/main/java/net/wurstclient/hacks/BunnyHopHack.java
index 3473a7e75..137a15da6 100644
--- a/src/main/java/net/wurstclient/hacks/BunnyHopHack.java
+++ b/src/main/java/net/wurstclient/hacks/BunnyHopHack.java
@@ -8,8 +8,7 @@
 package net.wurstclient.hacks;
 
 import java.util.function.Predicate;
-
-import net.minecraft.client.network.ClientPlayerEntity;
+import net.minecraft.client.player.LocalPlayer;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -50,28 +49,27 @@ public final class BunnyHopHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		if(!player.isOnGround() || player.isSneaking())
+		LocalPlayer player = MC.player;
+		if(!player.onGround() || player.isShiftKeyDown())
 			return;
 		
 		if(jumpIf.getSelected().condition.test(player))
-			player.jump();
+			player.jumpFromGround();
 	}
 	
 	private enum JumpIf
 	{
 		SPRINTING("Sprinting",
-			p -> p.isSprinting()
-				&& (p.forwardSpeed != 0 || p.sidewaysSpeed != 0)),
+			p -> p.isSprinting() && (p.zza != 0 || p.xxa != 0)),
 		
-		WALKING("Walking", p -> p.forwardSpeed != 0 || p.sidewaysSpeed != 0),
+		WALKING("Walking", p -> p.zza != 0 || p.xxa != 0),
 		
 		ALWAYS("Always", p -> true);
 		
 		private final String name;
-		private final Predicate<ClientPlayerEntity> condition;
+		private final Predicate<LocalPlayer> condition;
 		
-		private JumpIf(String name, Predicate<ClientPlayerEntity> condition)
+		private JumpIf(String name, Predicate<LocalPlayer> condition)
 		{
 			this.name = name;
 			this.condition = condition;
diff --git a/src/main/java/net/wurstclient/hacks/CaveFinderHack.java b/src/main/java/net/wurstclient/hacks/CaveFinderHack.java
index a6cde760e..2fbf08a13 100644
--- a/src/main/java/net/wurstclient/hacks/CaveFinderHack.java
+++ b/src/main/java/net/wurstclient/hacks/CaveFinderHack.java
@@ -7,6 +7,9 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.Comparator;
@@ -14,14 +17,9 @@ import java.util.HashSet;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.ForkJoinTask;
 import java.util.stream.Collectors;
-
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.block.Blocks;
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstRenderLayers;
@@ -157,23 +155,23 @@ public final class CaveFinderHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(vertexBuffer == null || bufferRegion == null)
 			return;
 		
 		float x = System.currentTimeMillis() % 2000 / 1000F;
-		float alpha = 0.25F + 0.25F * MathHelper.sin(x * MathHelper.PI);
+		float alpha = 0.25F + 0.25F * Mth.sin(x * Mth.PI);
 		if(opacity.getValue() > 0)
 			alpha = opacity.getValueF();
 		
-		matrixStack.push();
+		matrixStack.pushPose();
 		RenderUtils.applyRegionalRenderOffset(matrixStack, bufferRegion);
 		
 		vertexBuffer.draw(matrixStack, WurstRenderLayers.ESP_QUADS,
 			color.getColorF(), alpha);
 		
-		matrixStack.pop();
+		matrixStack.popPose();
 	}
 	
 	private void stopBuildingBuffer()
@@ -195,9 +193,9 @@ public final class CaveFinderHack extends Hack
 	
 	private void startGetMatchingBlocksTask()
 	{
-		BlockPos eyesPos = BlockPos.ofFloored(RotationUtils.getEyesPos());
+		BlockPos eyesPos = BlockPos.containing(RotationUtils.getEyesPos());
 		Comparator<BlockPos> comparator =
-			Comparator.comparingInt(pos -> eyesPos.getManhattanDistance(pos));
+			Comparator.comparingInt(pos -> eyesPos.distManhattan(pos));
 		
 		getMatchingBlocksTask = forkJoinPool.submit(() -> coordinator
 			.getMatches().parallel().map(ChunkSearcher.Result::pos)
@@ -231,11 +229,11 @@ public final class CaveFinderHack extends Hack
 		if(vertexBuffer != null)
 			vertexBuffer.close();
 		
-		vertexBuffer = EasyVertexBuffer.createAndUpload(DrawMode.QUADS,
-			VertexFormats.POSITION_COLOR, buffer -> {
+		vertexBuffer = EasyVertexBuffer.createAndUpload(Mode.QUADS,
+			DefaultVertexFormat.POSITION_COLOR, buffer -> {
 				for(int[] vertex : vertices)
-					buffer.vertex(vertex[0] - region.x(), vertex[1],
-						vertex[2] - region.z()).color(0xFFFFFFFF);
+					buffer.addVertex(vertex[0] - region.x(), vertex[1],
+						vertex[2] - region.z()).setColor(0xFFFFFFFF);
 			});
 		
 		bufferUpToDate = true;
diff --git a/src/main/java/net/wurstclient/hacks/ChatTranslatorHack.java b/src/main/java/net/wurstclient/hacks/ChatTranslatorHack.java
index 0b23284f8..6e272088b 100644
--- a/src/main/java/net/wurstclient/hacks/ChatTranslatorHack.java
+++ b/src/main/java/net/wurstclient/hacks/ChatTranslatorHack.java
@@ -110,7 +110,7 @@ public final class ChatTranslatorHack extends Hack
 			fromLang.getValue(), toLang.getValue());
 		
 		if(translated != null)
-			MC.inGameHud.getChatHud().addMessage(toLang.prefixText(translated));
+			MC.gui.getChat().addMessage(toLang.prefixText(translated));
 	}
 	
 	@Override
@@ -143,6 +143,6 @@ public final class ChatTranslatorHack extends Hack
 		if(translated == null)
 			translated = message;
 		
-		MC.getNetworkHandler().sendChatMessage(translated);
+		MC.getConnection().sendChat(translated);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/CheatDetectorHack.java b/src/main/java/net/wurstclient/hacks/CheatDetectorHack.java
index 0c37cf9c6..a1f4b70dc 100644
--- a/src/main/java/net/wurstclient/hacks/CheatDetectorHack.java
+++ b/src/main/java/net/wurstclient/hacks/CheatDetectorHack.java
@@ -14,22 +14,21 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.entity.vehicle.BoatEntity;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.registry.tag.FluidTags;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.core.BlockPos;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.util.Mth;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.vehicle.Boat;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -160,7 +159,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 	
 	private final Map<UUID, PlayerStats> playerStats = new HashMap<>();
 	private long tickCounter;
-	private ClientWorld lastWorld;
+	private ClientLevel lastWorld;
 	
 	public CheatDetectorHack()
 	{
@@ -216,7 +215,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 	protected void onEnable()
 	{
 		tickCounter = 0L;
-		lastWorld = MC.world;
+		lastWorld = MC.level;
 		playerStats.clear();
 		EVENTS.add(UpdateListener.class, this);
 	}
@@ -232,28 +231,28 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.world == null || MC.player == null)
+		if(MC.level == null || MC.player == null)
 		{
 			playerStats.clear();
 			lastWorld = null;
 			return;
 		}
 		
-		if(MC.world != lastWorld)
+		if(MC.level != lastWorld)
 		{
 			playerStats.clear();
-			lastWorld = MC.world;
+			lastWorld = MC.level;
 		}
 		
 		tickCounter++;
 		Set<UUID> seen = new HashSet<>();
 		
-		for(PlayerEntity other : MC.world.getPlayers())
+		for(Player other : MC.level.players())
 		{
 			if(other == MC.player || other.isRemoved())
 				continue;
 			
-			UUID id = other.getUuid();
+			UUID id = other.getUUID();
 			seen.add(id);
 			
 			PlayerStats stats =
@@ -264,7 +263,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		playerStats.keySet().removeIf(id -> !seen.contains(id));
 	}
 	
-	private void processPlayer(PlayerEntity player, PlayerStats stats)
+	private void processPlayer(Player player, PlayerStats stats)
 	{
 		if(player.isSpectator() || player.isCreative())
 		{
@@ -308,14 +307,14 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		stats.lastZ = z;
 	}
 	
-	private void checkSpeed(PlayerEntity player, PlayerStats stats,
+	private void checkSpeed(Player player, PlayerStats stats,
 		double horizontalPerSecond)
 	{
 		if(!detectSpeed.isChecked())
 			return;
 		
 		// ignore if elytra or in vehicle or swimming - handle separately
-		if(player.isTouchingWater() || player.isSwimming())
+		if(player.isInWater() || player.isSwimming())
 			return;
 		
 		// compute base allowed speed with buffer
@@ -335,10 +334,10 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 			// vehicle
 			try
 			{
-				int bx = MathHelper.floor(vehicle.getX());
-				int bz = MathHelper.floor(vehicle.getZ());
-				int by = MathHelper.floor(vehicle.getY()) - 1;
-				BlockState under = ((ClientWorld)vehicle.getEntityWorld())
+				int bx = Mth.floor(vehicle.getX());
+				int bz = Mth.floor(vehicle.getZ());
+				int by = Mth.floor(vehicle.getY()) - 1;
+				BlockState under = ((ClientLevel)vehicle.level())
 					.getBlockState(new BlockPos(bx, by, bz));
 				String id =
 					under.getBlock().toString().toLowerCase(Locale.ROOT);
@@ -349,7 +348,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		}
 		
 		// status effect speed gives small allowance
-		if(player.hasStatusEffect(StatusEffects.SPEED))
+		if(player.hasEffect(MobEffects.SPEED))
 			allowed *= 1.2;
 		
 		// latency compensation
@@ -385,13 +384,13 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		stats.speedViolationCount = 0;
 	}
 	
-	private void updateFlightPattern(PlayerEntity player, PlayerStats stats,
+	private void updateFlightPattern(Player player, PlayerStats stats,
 		double dy)
 	{
 		double clearance = getClearanceAboveGround(player, 16);
 		
-		if(!player.isOnGround() && !player.isTouchingWater()
-			&& player.getVehicle() == null && !player.isClimbing())
+		if(!player.onGround() && !player.isInWater()
+			&& player.getVehicle() == null && !player.onClimbable())
 		{
 			if(clearance >= flightClearanceThreshold.getValue())
 			{
@@ -415,7 +414,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		stats.lastClearance = clearance;
 	}
 	
-	private void checkFlight(PlayerEntity player, PlayerStats stats, double dy,
+	private void checkFlight(Player player, PlayerStats stats, double dy,
 		double horizontalPerSecond)
 	{
 		if(!detectFlight.isChecked())
@@ -430,10 +429,10 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 			return;
 		}
 		
-		boolean airborne = !player.isOnGround() && !player.isTouchingWater()
-			&& player.getVehicle() == null && !player.isClimbing()
-			&& !player.hasStatusEffect(StatusEffects.SLOW_FALLING)
-			&& !player.hasStatusEffect(StatusEffects.LEVITATION);
+		boolean airborne = !player.onGround() && !player.isInWater()
+			&& player.getVehicle() == null && !player.onClimbable()
+			&& !player.hasEffect(MobEffects.SLOW_FALLING)
+			&& !player.hasEffect(MobEffects.LEVITATION);
 		
 		if(airborne)
 		{
@@ -479,7 +478,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		sendAlert(player, "suspected of flying");
 	}
 	
-	private void checkBoatFly(PlayerEntity player, PlayerStats stats)
+	private void checkBoatFly(Player player, PlayerStats stats)
 	{
 		if(!detectBoatFly.isChecked())
 		{
@@ -488,7 +487,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		}
 		
 		Entity vehicle = player.getVehicle();
-		if(!(vehicle instanceof BoatEntity boat))
+		if(!(vehicle instanceof Boat boat))
 		{
 			stats.boatAirTicks = 0;
 			return;
@@ -514,7 +513,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		if(stats.boatAirTicks < boatAirTicks.getValue())
 			return;
 		
-		Vec3d vel = boat.getVelocity();
+		Vec3 vel = boat.getDeltaMovement();
 		double horizontalSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
 		boolean meetsHorizontal =
 			horizontalSpeed >= boatHorizontalSpeed.getValue();
@@ -533,18 +532,18 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		sendAlert(player, "suspected of boat-flying");
 	}
 	
-	private void checkAura(PlayerEntity player, PlayerStats stats)
+	private void checkAura(Player player, PlayerStats stats)
 	{
 		if(!detectAura.isChecked())
 		{
 			stats.swingTicks.clear();
 			stats.swingIntervals.clear();
 			stats.lastSwingTick = 0L;
-			stats.lastSwingProgress = player.getHandSwingProgress(1.0F);
+			stats.lastSwingProgress = player.getAttackAnim(1.0F);
 			return;
 		}
 		
-		float swingProgress = player.getHandSwingProgress(1.0F);
+		float swingProgress = player.getAttackAnim(1.0F);
 		
 		if(stats.lastSwingProgress > 0.6F && swingProgress < 0.2F)
 		{
@@ -609,7 +608,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 			"suspected of killaura (%.1f swings/s)", swingsPerSecond));
 	}
 	
-	private void sendAlert(PlayerEntity player, String reason)
+	private void sendAlert(Player player, String reason)
 	{
 		String name = player.getName().getString();
 		ChatUtils.message("CheatDetector: " + name + " " + reason);
@@ -624,14 +623,14 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 	 * Try to obtain the player's ping/latency in milliseconds. Returns -1 if
 	 * unavailable.
 	 */
-	private int getPlayerPing(PlayerEntity player)
+	private int getPlayerPing(Player player)
 	{
 		try
 		{
-			var handler = MC.getNetworkHandler();
+			var handler = MC.getConnection();
 			if(handler == null)
 				return -1;
-			var entry = handler.getPlayerListEntry(player.getUuid());
+			var entry = handler.getPlayerInfo(player.getUUID());
 			if(entry == null)
 				return -1;
 				
@@ -723,18 +722,18 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 	
 	private double getClearanceAboveGround(Entity entity, int maxDepth)
 	{
-		ClientWorld world = (ClientWorld)entity.getEntityWorld();
-		Box box = entity.getBoundingBox();
+		ClientLevel world = (ClientLevel)entity.level();
+		AABB box = entity.getBoundingBox();
 		double entityBottom = box.minY;
 		
-		int minX = MathHelper.floor(box.minX);
-		int maxX = MathHelper.ceil(box.maxX);
-		int minZ = MathHelper.floor(box.minZ);
-		int maxZ = MathHelper.ceil(box.maxZ);
+		int minX = Mth.floor(box.minX);
+		int maxX = Mth.ceil(box.maxX);
+		int minZ = Mth.floor(box.minZ);
+		int maxZ = Mth.ceil(box.maxZ);
 		
-		int maxY = MathHelper.floor(entityBottom);
-		int minY = Math.max(world.getBottomY(),
-			MathHelper.floor(entityBottom - maxDepth));
+		int maxY = Mth.floor(entityBottom);
+		int minY =
+			Math.max(world.getMinY(), Mth.floor(entityBottom - maxDepth));
 		
 		for(int y = maxY; y >= minY; y--)
 		{
@@ -750,8 +749,8 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 					else
 					{
 						FluidState fluid = world.getFluidState(pos);
-						if(!fluid.isEmpty() && (fluid.isIn(FluidTags.WATER)
-							|| fluid.isIn(FluidTags.LAVA)))
+						if(!fluid.isEmpty() && (fluid.is(FluidTags.WATER)
+							|| fluid.is(FluidTags.LAVA)))
 							foundSupport = true;
 					}
 				}
@@ -766,19 +765,19 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		return maxDepth;
 	}
 	
-	private boolean isBoatSupported(BoatEntity boat)
+	private boolean isBoatSupported(Boat boat)
 	{
-		ClientWorld world = (ClientWorld)boat.getEntityWorld();
-		Box box = boat.getBoundingBox();
+		ClientLevel world = (ClientLevel)boat.level();
+		AABB box = boat.getBoundingBox();
 		double sampleMinY = box.minY - 0.2;
 		double sampleMaxY = box.minY - 0.05;
 		
-		int minX = MathHelper.floor(box.minX);
-		int maxX = MathHelper.floor(box.maxX);
-		int minY = MathHelper.floor(sampleMinY);
-		int maxY = MathHelper.floor(sampleMaxY);
-		int minZ = MathHelper.floor(box.minZ);
-		int maxZ = MathHelper.floor(box.maxZ);
+		int minX = Mth.floor(box.minX);
+		int maxX = Mth.floor(box.maxX);
+		int minY = Mth.floor(sampleMinY);
+		int maxY = Mth.floor(sampleMaxY);
+		int minZ = Mth.floor(box.minZ);
+		int maxZ = Mth.floor(box.maxZ);
 		
 		for(int x = minX; x <= maxX; x++)
 			for(int y = minY; y <= maxY; y++)
@@ -790,7 +789,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 						return true;
 					
 					FluidState fluid = world.getFluidState(pos);
-					if(!fluid.isEmpty() && fluid.isIn(FluidTags.WATER))
+					if(!fluid.isEmpty() && fluid.is(FluidTags.WATER))
 						return true;
 				}
 			
@@ -822,7 +821,7 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 		// consecutive speed violations
 		private int speedViolationCount;
 		
-		private void resetPosition(PlayerEntity player)
+		private void resetPosition(Player player)
 		{
 			lastX = player.getX();
 			lastY = player.getY();
@@ -839,20 +838,20 @@ public final class CheatDetectorHack extends Hack implements UpdateListener
 			swingTicks.clear();
 			swingIntervals.clear();
 			lastSwingTick = 0L;
-			lastSwingProgress = player.getHandSwingProgress(1.0F);
+			lastSwingProgress = player.getAttackAnim(1.0F);
 			speedViolationCount = 0;
 		}
 	}
 	
-	private boolean isUsingElytra(PlayerEntity player)
+	private boolean isUsingElytra(Player player)
 	{
-		if(player.isGliding())
+		if(player.isFallFlying())
 			return true;
 		
-		if(player.isOnGround())
+		if(player.onGround())
 			return false;
 		
-		ItemStack chest = player.getEquippedStack(EquipmentSlot.CHEST);
-		return !chest.isEmpty() && chest.isOf(Items.ELYTRA);
+		ItemStack chest = player.getItemBySlot(EquipmentSlot.CHEST);
+		return !chest.isEmpty() && chest.is(Items.ELYTRA);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/ChestEspHack.java b/src/main/java/net/wurstclient/hacks/ChestEspHack.java
index 123b69d83..1f1a8c986 100644
--- a/src/main/java/net/wurstclient/hacks/ChestEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/ChestEspHack.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.List;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
 import net.wurstclient.events.RenderListener;
@@ -92,15 +91,15 @@ public class ChestEspHack extends Hack implements UpdateListener,
 		boolean enforceAboveGround = onlyAboveGround.isChecked();
 		
 		ChunkUtils.getLoadedBlockEntities().forEach(be -> {
-			if(enforceAboveGround && be.getPos().getY() < yLimit)
+			if(enforceAboveGround && be.getBlockPos().getY() < yLimit)
 				return;
 			
 			groups.blockGroups.forEach(group -> group.addIfMatches(be));
 		});
 		
-		if(MC.world != null)
+		if(MC.level != null)
 		{
-			for(Entity entity : MC.world.getEntities())
+			for(Entity entity : MC.level.entitiesForRendering())
 			{
 				if(enforceAboveGround && entity.getY() < yLimit)
 					continue;
@@ -124,7 +123,7 @@ public class ChestEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		groups.entityGroups.stream().filter(ChestEspGroup::isEnabled)
 			.forEach(g -> g.updateBoxes(partialTicks));
@@ -136,14 +135,14 @@ public class ChestEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(ChestEspGroup group : groups.allGroups)
 		{
 			if(!group.isEnabled())
 				continue;
 			
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			
@@ -153,15 +152,15 @@ public class ChestEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(ChestEspGroup group : groups.allGroups)
 		{
 			if(!group.isEnabled())
 				continue;
 			
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
diff --git a/src/main/java/net/wurstclient/hacks/ChestSearchHack.java b/src/main/java/net/wurstclient/hacks/ChestSearchHack.java
index 32d0b2a72..48b8fc386 100644
--- a/src/main/java/net/wurstclient/hacks/ChestSearchHack.java
+++ b/src/main/java/net/wurstclient/hacks/ChestSearchHack.java
@@ -137,7 +137,7 @@ public final class ChestSearchHack extends Hack
 		try
 		{
 			MC.setScreen(new net.wurstclient.clickgui.screens.ChestSearchScreen(
-				MC.currentScreen, Boolean.TRUE));
+				MC.screen, Boolean.TRUE));
 		}catch(Throwable ignored)
 		{}
 		setEnabled(false);
diff --git a/src/main/java/net/wurstclient/hacks/ClickAuraHack.java b/src/main/java/net/wurstclient/hacks/ClickAuraHack.java
index e55122edd..763b310af 100644
--- a/src/main/java/net/wurstclient/hacks/ClickAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/ClickAuraHack.java
@@ -10,11 +10,10 @@ package net.wurstclient.hacks;
 import java.util.Comparator;
 import java.util.function.ToDoubleFunction;
 import java.util.stream.Stream;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.Hand;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.LeftClickListener;
@@ -93,7 +92,7 @@ public final class ClickAuraHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		if(!MC.options.attackKey.isPressed())
+		if(!MC.options.keyAttack.isDown())
 			return;
 		
 		speed.updateTimer();
@@ -112,11 +111,11 @@ public final class ClickAuraHack extends Hack
 	private void attack()
 	{
 		// set entity
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		
 		double rangeSq = Math.pow(range.getValue(), 2);
-		stream = stream.filter(e -> player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> player.distanceToSqr(e) <= rangeSq);
 		
 		if(fov.getValue() < 360.0)
 			stream = stream.filter(e -> RotationUtils.getAngleToLookVec(
@@ -136,14 +135,14 @@ public final class ClickAuraHack extends Hack
 			.sendPlayerLookPacket();
 		
 		// attack entity
-		MC.interactionManager.attackEntity(player, target);
-		player.swingHand(Hand.MAIN_HAND);
+		MC.gameMode.attack(player, target);
+		player.swing(InteractionHand.MAIN_HAND);
 		speed.resetTimer();
 	}
 	
 	private enum Priority
 	{
-		DISTANCE("Distance", e -> MC.player.squaredDistanceTo(e)),
+		DISTANCE("Distance", e -> MC.player.distanceToSqr(e)),
 		
 		ANGLE("Angle",
 			e -> RotationUtils
diff --git a/src/main/java/net/wurstclient/hacks/CrashChestHack.java b/src/main/java/net/wurstclient/hacks/CrashChestHack.java
index a2378c3a8..285fe3a3f 100644
--- a/src/main/java/net/wurstclient/hacks/CrashChestHack.java
+++ b/src/main/java/net/wurstclient/hacks/CrashChestHack.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.block.Blocks;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.NbtComponent;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NbtCompound;
-import net.minecraft.nbt.NbtList;
-import net.minecraft.text.Text;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -33,14 +33,14 @@ public final class CrashChestHack extends Hack
 	@Override
 	protected void onEnable()
 	{
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 		{
 			ChatUtils.error("Creative mode only.");
 			setEnabled(false);
 			return;
 		}
 		
-		if(!MC.player.getEquippedStack(EquipmentSlot.FEET).isEmpty())
+		if(!MC.player.getItemBySlot(EquipmentSlot.FEET).isEmpty())
 		{
 			ChatUtils.error("Please clear your shoes slot.");
 			setEnabled(false);
@@ -49,16 +49,16 @@ public final class CrashChestHack extends Hack
 		
 		// generate item
 		ItemStack stack = new ItemStack(Blocks.CHEST);
-		NbtCompound nbtCompound = new NbtCompound();
-		NbtList nbtList = new NbtList();
+		CompoundTag nbtCompound = new CompoundTag();
+		ListTag nbtList = new ListTag();
 		for(int i = 0; i < 40000; i++)
-			nbtList.add(new NbtList());
+			nbtList.add(new ListTag());
 		nbtCompound.put("www.wurstclient.net", nbtList);
-		stack.set(DataComponentTypes.CUSTOM_DATA, NbtComponent.of(nbtCompound));
-		stack.set(DataComponentTypes.CUSTOM_NAME, Text.literal("Copy Me"));
+		stack.set(DataComponents.CUSTOM_DATA, CustomData.of(nbtCompound));
+		stack.set(DataComponents.CUSTOM_NAME, Component.literal("Copy Me"));
 		
 		// give item
-		MC.player.equipment.put(EquipmentSlot.FEET, stack);
+		MC.player.equipment.set(EquipmentSlot.FEET, stack);
 		ChatUtils.message("Item has been placed in your shoes slot.");
 		setEnabled(false);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/CreativeFlightHack.java b/src/main/java/net/wurstclient/hacks/CreativeFlightHack.java
index 4606f526b..1913f2ff6 100644
--- a/src/main/java/net/wurstclient/hacks/CreativeFlightHack.java
+++ b/src/main/java/net/wurstclient/hacks/CreativeFlightHack.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.entity.player.PlayerAbilities;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.entity.player.Abilities;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -67,12 +67,12 @@ public final class CreativeFlightHack extends Hack implements UpdateListener
 	{
 		EVENTS.remove(UpdateListener.class, this);
 		
-		ClientPlayerEntity player = MC.player;
-		PlayerAbilities abilities = player.getAbilities();
+		LocalPlayer player = MC.player;
+		Abilities abilities = player.getAbilities();
 		
-		boolean creative = player.getAbilities().creativeMode;
-		abilities.flying = creative && !player.isOnGround();
-		abilities.allowFlying = creative;
+		boolean creative = player.getAbilities().instabuild;
+		abilities.flying = creative && !player.onGround();
+		abilities.mayfly = creative;
 		
 		restoreKeyPresses();
 	}
@@ -80,8 +80,8 @@ public final class CreativeFlightHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		PlayerAbilities abilities = MC.player.getAbilities();
-		abilities.allowFlying = true;
+		Abilities abilities = MC.player.getAbilities();
+		abilities.mayfly = true;
 		
 		if(antiKick.isChecked() && abilities.flying)
 			doAntiKick();
@@ -96,8 +96,7 @@ public final class CreativeFlightHack extends Hack implements UpdateListener
 		{
 			case 0 ->
 			{
-				if(MC.options.sneakKey.isPressed()
-					&& !MC.options.jumpKey.isPressed())
+				if(MC.options.keyShift.isDown() && !MC.options.keyJump.isDown())
 					tickCounter = 3;
 				else
 					setMotionY(-antiKickDistance.getValue());
@@ -115,18 +114,18 @@ public final class CreativeFlightHack extends Hack implements UpdateListener
 	
 	private void setMotionY(double motionY)
 	{
-		MC.options.sneakKey.setPressed(false);
-		MC.options.jumpKey.setPressed(false);
+		MC.options.keyShift.setDown(false);
+		MC.options.keyJump.setDown(false);
 		
-		Vec3d velocity = MC.player.getVelocity();
-		MC.player.setVelocity(velocity.x, motionY, velocity.z);
+		Vec3 velocity = MC.player.getDeltaMovement();
+		MC.player.setDeltaMovement(velocity.x, motionY, velocity.z);
 	}
 	
 	private void restoreKeyPresses()
 	{
-		KeyBinding[] keys = {MC.options.jumpKey, MC.options.sneakKey};
+		KeyMapping[] keys = {MC.options.keyJump, MC.options.keyShift};
 		
-		for(KeyBinding key : keys)
+		for(KeyMapping key : keys)
 			IKeyBinding.get(key).resetPressedState();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/CriticalsHack.java b/src/main/java/net/wurstclient/hacks/CriticalsHack.java
index e716c32a4..a6509ac65 100644
--- a/src/main/java/net/wurstclient/hacks/CriticalsHack.java
+++ b/src/main/java/net/wurstclient/hacks/CriticalsHack.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionAndOnGround;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Pos;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PlayerAttacksEntityListener;
@@ -59,13 +59,13 @@ public final class CriticalsHack extends Hack
 			return;
 		
 		if(WURST.getHax().maceDmgHack.isEnabled()
-			&& MC.player.getMainHandStack().isOf(Items.MACE))
+			&& MC.player.getMainHandItem().is(Items.MACE))
 			return;
 		
-		if(!MC.player.isOnGround())
+		if(!MC.player.onGround())
 			return;
 		
-		if(MC.player.isTouchingWater() || MC.player.isInLava())
+		if(MC.player.isInWater() || MC.player.isInLava())
 			return;
 		
 		switch(mode.getSelected())
@@ -94,21 +94,21 @@ public final class CriticalsHack extends Hack
 	
 	private void sendFakeY(double offset, boolean onGround)
 	{
-		MC.player.networkHandler.sendPacket(
-			new PositionAndOnGround(MC.player.getX(), MC.player.getY() + offset,
+		MC.player.connection
+			.send(new Pos(MC.player.getX(), MC.player.getY() + offset,
 				MC.player.getZ(), onGround, MC.player.horizontalCollision));
 	}
 	
 	private void doMiniJump()
 	{
-		MC.player.addVelocity(0, 0.1, 0);
+		MC.player.push(0, 0.1, 0);
 		MC.player.fallDistance = 0.1F;
 		MC.player.setOnGround(false);
 	}
 	
 	private void doFullJump()
 	{
-		MC.player.jump();
+		MC.player.jumpFromGround();
 	}
 	
 	private enum Mode
diff --git a/src/main/java/net/wurstclient/hacks/CrystalAuraHack.java b/src/main/java/net/wurstclient/hacks/CrystalAuraHack.java
index 79db89e0b..e33b6f118 100644
--- a/src/main/java/net/wurstclient/hacks/CrystalAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/CrystalAuraHack.java
@@ -12,19 +12,18 @@ import java.util.Comparator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.decoration.EndCrystalEntity;
-import net.minecraft.item.Items;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.boss.enderdragon.EndCrystal;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -157,7 +156,7 @@ public final class CrystalAuraHack extends Hack implements UpdateListener
 		}
 		
 		if(shouldSwing)
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 		
 		return newCrystals;
 	}
@@ -167,37 +166,37 @@ public final class CrystalAuraHack extends Hack implements UpdateListener
 		for(Entity e : crystals)
 		{
 			faceTarget.face(e.getBoundingBox().getCenter());
-			MC.interactionManager.attackEntity(MC.player, e);
+			MC.gameMode.attack(MC.player, e);
 		}
 		
 		if(!crystals.isEmpty())
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 	}
 	
 	private boolean placeCrystal(BlockPos pos)
 	{
-		Vec3d eyesPos = RotationUtils.getEyesPos();
+		Vec3 eyesPos = RotationUtils.getEyesPos();
 		double rangeSq = Math.pow(range.getValue(), 2);
-		Vec3d posVec = Vec3d.ofCenter(pos);
-		double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+		Vec3 posVec = Vec3.atCenterOf(pos);
+		double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 		
 		for(Direction side : Direction.values())
 		{
-			BlockPos neighbor = pos.offset(side);
+			BlockPos neighbor = pos.relative(side);
 			
 			// check if neighbor can be right clicked
 			if(!isClickableNeighbor(neighbor))
 				continue;
 			
-			Vec3d dirVec = Vec3d.of(side.getVector());
-			Vec3d hitVec = posVec.add(dirVec.multiply(0.5));
+			Vec3 dirVec = Vec3.atLowerCornerOf(side.getUnitVec3i());
+			Vec3 hitVec = posVec.add(dirVec.scale(0.5));
 			
 			// check if hitVec is within range
-			if(eyesPos.squaredDistanceTo(hitVec) > rangeSq)
+			if(eyesPos.distanceToSqr(hitVec) > rangeSq)
 				continue;
 			
 			// check if side is visible (facing away from player)
-			if(distanceSqPosVec > eyesPos.squaredDistanceTo(posVec.add(dirVec)))
+			if(distanceSqPosVec > eyesPos.distanceToSqr(posVec.add(dirVec)))
 				continue;
 			
 			if(checkLOS.isChecked()
@@ -223,17 +222,17 @@ public final class CrystalAuraHack extends Hack implements UpdateListener
 	
 	private ArrayList<Entity> getNearbyCrystals()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		double rangeSq = Math.pow(range.getValue(), 2);
 		
-		Comparator<Entity> furthestFromPlayer = Comparator
-			.<Entity> comparingDouble(e -> MC.player.squaredDistanceTo(e))
-			.reversed();
+		Comparator<Entity> furthestFromPlayer =
+			Comparator.<Entity> comparingDouble(e -> MC.player.distanceToSqr(e))
+				.reversed();
 		
-		return StreamSupport.stream(MC.world.getEntities().spliterator(), true)
-			.filter(EndCrystalEntity.class::isInstance)
-			.filter(e -> !e.isRemoved())
-			.filter(e -> player.squaredDistanceTo(e) <= rangeSq)
+		return StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
+			.filter(EndCrystal.class::isInstance).filter(e -> !e.isRemoved())
+			.filter(e -> player.distanceToSqr(e) <= rangeSq)
 			.sorted(furthestFromPlayer)
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
@@ -242,20 +241,19 @@ public final class CrystalAuraHack extends Hack implements UpdateListener
 	{
 		double rangeSq = Math.pow(range.getValue(), 2);
 		
-		Comparator<Entity> furthestFromPlayer = Comparator
-			.<Entity> comparingDouble(e -> MC.player.squaredDistanceTo(e))
-			.reversed();
+		Comparator<Entity> furthestFromPlayer =
+			Comparator.<Entity> comparingDouble(e -> MC.player.distanceToSqr(e))
+				.reversed();
 		
-		Stream<Entity> stream =
-			StreamSupport.stream(MC.world.getEntities().spliterator(), false)
-				.filter(e -> !e.isRemoved())
-				.filter(e -> e instanceof LivingEntity
-					&& ((LivingEntity)e).getHealth() > 0)
-				.filter(e -> e != MC.player)
-				.filter(e -> !(e instanceof FakePlayerEntity))
-				.filter(
-					e -> !WURST.getFriends().contains(e.getName().getString()))
-				.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		Stream<Entity> stream = StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), false)
+			.filter(e -> !e.isRemoved())
+			.filter(e -> e instanceof LivingEntity
+				&& ((LivingEntity)e).getHealth() > 0)
+			.filter(e -> e != MC.player)
+			.filter(e -> !(e instanceof FakePlayerEntity))
+			.filter(e -> !WURST.getFriends().contains(e.getName().getString()))
+			.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		stream = entityFilters.applyTo(stream);
 		
@@ -265,46 +263,46 @@ public final class CrystalAuraHack extends Hack implements UpdateListener
 	
 	private ArrayList<BlockPos> getFreeBlocksNear(Entity target)
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
+		Vec3 eyesVec = RotationUtils.getEyesPos().subtract(0.5, 0.5, 0.5);
 		double rangeD = range.getValue();
 		double rangeSq = Math.pow(rangeD + 0.5, 2);
 		int rangeI = 2;
 		
-		BlockPos center = target.getBlockPos();
-		BlockPos min = center.add(-rangeI, -rangeI, -rangeI);
-		BlockPos max = center.add(rangeI, rangeI, rangeI);
-		Box targetBB = target.getBoundingBox();
+		BlockPos center = target.blockPosition();
+		BlockPos min = center.offset(-rangeI, -rangeI, -rangeI);
+		BlockPos max = center.offset(rangeI, rangeI, rangeI);
+		AABB targetBB = target.getBoundingBox();
 		
-		Vec3d targetEyesVec = target.getEntityPos().add(0,
-			target.getEyeHeight(target.getPose()), 0);
+		Vec3 targetEyesVec =
+			target.position().add(0, target.getEyeHeight(target.getPose()), 0);
 		
 		Comparator<BlockPos> closestToTarget =
 			Comparator.<BlockPos> comparingDouble(
-				pos -> targetEyesVec.squaredDistanceTo(Vec3d.ofCenter(pos)));
+				pos -> targetEyesVec.distanceToSqr(Vec3.atCenterOf(pos)));
 		
-		return BlockUtils.getAllInBoxStream(min, max)
-			.filter(pos -> eyesVec.squaredDistanceTo(Vec3d.of(pos)) <= rangeSq)
+		return BlockUtils.getAllInBoxStream(min, max).filter(
+			pos -> eyesVec.distanceToSqr(Vec3.atLowerCornerOf(pos)) <= rangeSq)
 			.filter(this::isReplaceable).filter(this::hasCrystalBase)
-			.filter(pos -> !targetBB.intersects(new Box(pos)))
+			.filter(pos -> !targetBB.intersects(new AABB(pos)))
 			.sorted(closestToTarget)
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
 	
 	private boolean isReplaceable(BlockPos pos)
 	{
-		return BlockUtils.getState(pos).isReplaceable();
+		return BlockUtils.getState(pos).canBeReplaced();
 	}
 	
 	private boolean hasCrystalBase(BlockPos pos)
 	{
-		Block block = BlockUtils.getBlock(pos.down());
+		Block block = BlockUtils.getBlock(pos.below());
 		return block == Blocks.BEDROCK || block == Blocks.OBSIDIAN;
 	}
 	
 	private boolean isClickableNeighbor(BlockPos pos)
 	{
 		return BlockUtils.canBeClicked(pos)
-			&& !BlockUtils.getState(pos).isReplaceable();
+			&& !BlockUtils.getState(pos).canBeReplaced();
 	}
 	
 	private enum TakeItemsFrom
diff --git a/src/main/java/net/wurstclient/hacks/DerpHack.java b/src/main/java/net/wurstclient/hacks/DerpHack.java
index ebca3f279..ab091e58d 100644
--- a/src/main/java/net/wurstclient/hacks/DerpHack.java
+++ b/src/main/java/net/wurstclient/hacks/DerpHack.java
@@ -45,7 +45,7 @@ public final class DerpHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		float yaw = MC.player.getYaw() + random.nextFloat() * 360F - 180F;
+		float yaw = MC.player.getYRot() + random.nextFloat() * 360F - 180F;
 		float pitch = random.nextFloat() * 180F - 90F;
 		
 		new Rotation(yaw, pitch).sendPlayerLookPacket();
diff --git a/src/main/java/net/wurstclient/hacks/DolphinHack.java b/src/main/java/net/wurstclient/hacks/DolphinHack.java
index 0ba534163..1f3172e5b 100644
--- a/src/main/java/net/wurstclient/hacks/DolphinHack.java
+++ b/src/main/java/net/wurstclient/hacks/DolphinHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -39,11 +39,11 @@ public final class DolphinHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		if(!player.isTouchingWater() || player.isSneaking())
+		LocalPlayer player = MC.player;
+		if(!player.isInWater() || player.isShiftKeyDown())
 			return;
 		
-		Vec3d velocity = player.getVelocity();
-		player.setVelocity(velocity.x, velocity.y + 0.04, velocity.z);
+		Vec3 velocity = player.getDeltaMovement();
+		player.setDeltaMovement(velocity.x, velocity.y + 0.04, velocity.z);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/EnchantmentHandlerHack.java b/src/main/java/net/wurstclient/hacks/EnchantmentHandlerHack.java
index d0ce67b56..fdf21a253 100644
--- a/src/main/java/net/wurstclient/hacks/EnchantmentHandlerHack.java
+++ b/src/main/java/net/wurstclient/hacks/EnchantmentHandlerHack.java
@@ -16,33 +16,32 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.stream.Collectors;
-
+import com.mojang.blaze3d.platform.Window;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.util.Window;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.component.type.ContainerComponent;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.potion.Potion;
-import net.minecraft.component.type.WeaponComponent;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.screen.GenericContainerScreenHandler;
-import net.minecraft.screen.ScreenHandler;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
-import net.minecraft.text.Text;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.Mth;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.ChestMenu;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.alchemy.Potion;
+import net.minecraft.world.item.alchemy.PotionContents;
+import net.minecraft.world.item.component.ItemContainerContents;
+import net.minecraft.world.item.component.Weapon;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -185,12 +184,12 @@ public final class EnchantmentHandlerHack extends Hack
 		hoverStartMs = 0L;
 	}
 	
-	public void renderOnHandledScreen(HandledScreen<?> screen,
-		DrawContext context, float partialTicks)
+	public void renderOnHandledScreen(AbstractContainerScreen<?> screen,
+		GuiGraphics context, float partialTicks)
 	{
 		lastRenderActive = false;
 		
-		if(MC.player == null || MC.interactionManager == null)
+		if(MC.player == null || MC.gameMode == null)
 			return;
 		
 		if(needsRescan)
@@ -207,10 +206,10 @@ public final class EnchantmentHandlerHack extends Hack
 		}
 		
 		HandledScreenAccessor accessor = (HandledScreenAccessor)screen;
-		int windowWidth = context.getScaledWindowWidth();
-		int windowHeight = context.getScaledWindowHeight();
+		int windowWidth = context.guiWidth();
+		int windowHeight = context.guiHeight();
 		
-		panelWidth = MathHelper.clamp(boxWidth.getValueI(), MIN_BOX_WIDTH,
+		panelWidth = Mth.clamp(boxWidth.getValueI(), MIN_BOX_WIDTH,
 			Math.min(MAX_BOX_WIDTH, windowWidth - 10));
 		
 		int configuredHeight = boxHeight.getValueI();
@@ -218,23 +217,23 @@ public final class EnchantmentHandlerHack extends Hack
 			panelHeight =
 				Math.min(accessor.getBackgroundHeight(), windowHeight - 10);
 		else
-			panelHeight = MathHelper.clamp(configuredHeight, 60,
+			panelHeight = Mth.clamp(configuredHeight, 60,
 				Math.max(60, windowHeight - 10));
 		
 		panelY = accessor.getY() + offsetY.getValueI();
 		panelX =
 			accessor.getX() - panelWidth - PANEL_PADDING + offsetX.getValueI();
 		
-		panelX = MathHelper.clamp(panelX, 2 - panelWidth,
-			windowWidth - panelWidth - 2);
-		panelY = MathHelper.clamp(panelY, 2, windowHeight - panelHeight - 2);
+		panelX =
+			Mth.clamp(panelX, 2 - panelWidth, windowWidth - panelWidth - 2);
+		panelY = Mth.clamp(panelY, 2, windowHeight - panelHeight - 2);
 		
 		renderOverlay(context);
 		lastRenderActive = true;
 	}
 	
-	public boolean handleMouseClick(HandledScreen<?> screen, double mouseX,
-		double mouseY, int button)
+	public boolean handleMouseClick(AbstractContainerScreen<?> screen,
+		double mouseX, double mouseY, int button)
 	{
 		if(!lastRenderActive)
 			return false;
@@ -242,7 +241,8 @@ public final class EnchantmentHandlerHack extends Hack
 		if(button != 0 && button != 1)
 			return isInsidePanel(mouseX, mouseY);
 		
-		ScreenHandler handler = ((HandledScreen<?>)screen).getScreenHandler();
+		AbstractContainerMenu handler =
+			((AbstractContainerScreen<?>)screen).getMenu();
 		
 		for(Hitbox hitbox : hitboxes)
 		{
@@ -301,8 +301,8 @@ public final class EnchantmentHandlerHack extends Hack
 		return isInsidePanel(mouseX, mouseY);
 	}
 	
-	public boolean handleMouseScroll(HandledScreen<?> screen, double mouseX,
-		double mouseY, double amount)
+	public boolean handleMouseScroll(AbstractContainerScreen<?> screen,
+		double mouseX, double mouseY, double amount)
 	{
 		if(!lastRenderActive)
 			return false;
@@ -313,10 +313,9 @@ public final class EnchantmentHandlerHack extends Hack
 		if(contentHeight <= panelInnerHeight())
 			return true;
 		
-		float scale = MathHelper.clamp(textScale.getValueF(), 0.5F, 1.25F);
-		int step = Math.max(8, Math.round(MC.textRenderer.fontHeight * scale));
-		scrollOffset =
-			MathHelper.clamp(scrollOffset - amount * step, 0, maxScroll);
+		float scale = Mth.clamp(textScale.getValueF(), 0.5F, 1.25F);
+		int step = Math.max(8, Math.round(MC.font.lineHeight * scale));
+		scrollOffset = Mth.clamp(scrollOffset - amount * step, 0, maxScroll);
 		return true;
 	}
 	
@@ -326,13 +325,13 @@ public final class EnchantmentHandlerHack extends Hack
 			&& mouseY >= panelY && mouseY <= panelY + panelHeight;
 	}
 	
-	private void renderOverlay(DrawContext context)
+	private void renderOverlay(GuiGraphics context)
 	{
 		hitboxes.clear();
 		
-		TextRenderer tr = MC.textRenderer;
-		float scale = MathHelper.clamp(textScale.getValueF(), 0.5F, 1.25F);
-		int lineHeight = Math.max(1, Math.round(tr.fontHeight * scale));
+		Font tr = MC.font;
+		float scale = Mth.clamp(textScale.getValueF(), 0.5F, 1.25F);
+		int lineHeight = Math.max(1, Math.round(tr.lineHeight * scale));
 		int headerMargin = Math.max(1, Math.round(HEADER_MARGIN * scale));
 		int entryMargin = Math.max(1, Math.round(ENTRY_MARGIN * scale));
 		
@@ -406,16 +405,15 @@ public final class EnchantmentHandlerHack extends Hack
 		
 		contentHeight = (int)Math.max(0, Math.round(cursorY - contentTop));
 		maxScroll = Math.max(0, contentHeight - innerHeight);
-		scrollOffset = MathHelper.clamp(scrollOffset, 0, maxScroll);
+		scrollOffset = Mth.clamp(scrollOffset, 0, maxScroll);
 		
 		context.disableScissor();
 	}
 	
-	private double renderGearSection(DrawContext context, TextRenderer tr,
-		float scale, int titleX, double cursorY, double offset,
-		double textAreaWidth, double hoverSpeed, double scaledMouseX,
-		double scaledMouseY, int lineHeight, int entryMargin, int headerMargin,
-		boolean[] hoverFlag)
+	private double renderGearSection(GuiGraphics context, Font tr, float scale,
+		int titleX, double cursorY, double offset, double textAreaWidth,
+		double hoverSpeed, double scaledMouseX, double scaledMouseY,
+		int lineHeight, int entryMargin, int headerMargin, boolean[] hoverFlag)
 	{
 		boolean hasEntries = GearCategory.ORDERED.stream().anyMatch(
 			cat -> !gearGroupedEntries.getOrDefault(cat, List.of()).isEmpty());
@@ -426,7 +424,7 @@ public final class EnchantmentHandlerHack extends Hack
 		drawSectionHeader(context, tr, titleX, sectionTitleY, "Enchanted Gear",
 			scale);
 		int underlineY = sectionTitleY
-			+ Math.max(1, Math.round(MC.textRenderer.fontHeight * scale)) + 2;
+			+ Math.max(1, Math.round(MC.font.lineHeight * scale)) + 2;
 		context.fill(panelX + 2, underlineY, panelX + panelWidth - 2,
 			underlineY + 1, 0xFFD0D0D0);
 		cursorY += lineHeight + headerMargin + 4;
@@ -448,7 +446,7 @@ public final class EnchantmentHandlerHack extends Hack
 		return cursorY;
 	}
 	
-	private double renderSourceSection(DrawContext context, TextRenderer tr,
+	private double renderSourceSection(GuiGraphics context, Font tr,
 		float scale, int titleX, double cursorY, double offset,
 		double textAreaWidth, double hoverSpeed, double scaledMouseX,
 		double scaledMouseY, int lineHeight, int entryMargin, int headerMargin,
@@ -470,7 +468,7 @@ public final class EnchantmentHandlerHack extends Hack
 		drawSectionHeader(context, tr, titleX, sectionTitleY, sourceTitle,
 			scale);
 		int underlineY = sectionTitleY
-			+ Math.max(1, Math.round(MC.textRenderer.fontHeight * scale)) + 2;
+			+ Math.max(1, Math.round(MC.font.lineHeight * scale)) + 2;
 		context.fill(panelX + 2, underlineY, panelX + panelWidth - 2,
 			underlineY + 1, 0xFFD0D0D0);
 		cursorY += lineHeight + headerMargin + 4;
@@ -521,11 +519,10 @@ public final class EnchantmentHandlerHack extends Hack
 		return cursorY;
 	}
 	
-	private double renderBookSection(DrawContext context, TextRenderer tr,
-		float scale, int titleX, double cursorY, double offset,
-		double textAreaWidth, double hoverSpeed, double scaledMouseX,
-		double scaledMouseY, int lineHeight, int entryMargin, int headerMargin,
-		boolean[] hoverFlag)
+	private double renderBookSection(GuiGraphics context, Font tr, float scale,
+		int titleX, double cursorY, double offset, double textAreaWidth,
+		double hoverSpeed, double scaledMouseX, double scaledMouseY,
+		int lineHeight, int entryMargin, int headerMargin, boolean[] hoverFlag)
 	{
 		boolean hasEntries = BookCategory.ORDERED.stream().anyMatch(
 			cat -> !bookGroupedEntries.getOrDefault(cat, List.of()).isEmpty());
@@ -536,7 +533,7 @@ public final class EnchantmentHandlerHack extends Hack
 		drawSectionHeader(context, tr, titleX, sectionTitleY, "Enchanted Books",
 			scale);
 		int underlineY = sectionTitleY
-			+ Math.max(1, Math.round(MC.textRenderer.fontHeight * scale)) + 2;
+			+ Math.max(1, Math.round(MC.font.lineHeight * scale)) + 2;
 		context.fill(panelX + 2, underlineY, panelX + panelWidth - 2,
 			underlineY + 1, 0xFFD0D0D0);
 		cursorY += lineHeight + headerMargin + 4;
@@ -558,7 +555,7 @@ public final class EnchantmentHandlerHack extends Hack
 		return cursorY;
 	}
 	
-	private double renderPotionSection(DrawContext context, TextRenderer tr,
+	private double renderPotionSection(GuiGraphics context, Font tr,
 		float scale, int titleX, double cursorY, double offset,
 		double textAreaWidth, double hoverSpeed, double scaledMouseX,
 		double scaledMouseY, int lineHeight, int entryMargin, int headerMargin,
@@ -573,7 +570,7 @@ public final class EnchantmentHandlerHack extends Hack
 		int sectionTitleY = (int)Math.round(cursorY - offset);
 		drawSectionHeader(context, tr, titleX, sectionTitleY, "Potions", scale);
 		int underlineY = sectionTitleY
-			+ Math.max(1, Math.round(MC.textRenderer.fontHeight * scale)) + 2;
+			+ Math.max(1, Math.round(MC.font.lineHeight * scale)) + 2;
 		context.fill(panelX + 2, underlineY, panelX + panelWidth - 2,
 			underlineY + 1, 0xFFD0D0D0);
 		cursorY += lineHeight + headerMargin + 4;
@@ -595,7 +592,7 @@ public final class EnchantmentHandlerHack extends Hack
 		return cursorY;
 	}
 	
-	private double renderCategoryEntries(DrawContext context, TextRenderer tr,
+	private double renderCategoryEntries(GuiGraphics context, Font tr,
 		float scale, int titleX, double cursorY, double offset,
 		double textAreaWidth, double hoverSpeed, double scaledMouseX,
 		double scaledMouseY, int lineHeight, int entryMargin, int headerMargin,
@@ -610,7 +607,7 @@ public final class EnchantmentHandlerHack extends Hack
 		
 		String takeAllText = "Take All";
 		int takeAllWidth =
-			Math.max(1, Math.round(tr.getWidth(takeAllText) * scale));
+			Math.max(1, Math.round(tr.width(takeAllText) * scale));
 		int takeAllX = panelX + panelWidth - PANEL_PADDING - takeAllWidth;
 		int takeAllY = headerY;
 		boolean actionHovered = scaledMouseX >= takeAllX - 2
@@ -641,7 +638,7 @@ public final class EnchantmentHandlerHack extends Hack
 				context.fill(panelX + 2, entryY - 2, panelX + panelWidth - 2,
 					entryY + lineHeight + 2, 0x802A2A2A);
 			
-			double textWidth = Math.max(1.0, tr.getWidth(entry.line) * scale);
+			double textWidth = Math.max(1.0, tr.width(entry.line) * scale);
 			double travel = textWidth - textAreaWidth;
 			double scrollX = 0.0;
 			
@@ -675,7 +672,7 @@ public final class EnchantmentHandlerHack extends Hack
 						}
 					}
 				}
-				scrollX = MathHelper.clamp(scrollX, 0.0, Math.max(0.0, travel));
+				scrollX = Mth.clamp(scrollX, 0.0, Math.max(0.0, travel));
 			}else if(hoveredSlotId == entry.slotId)
 			{
 				hoveredSlotId = -1;
@@ -696,18 +693,18 @@ public final class EnchantmentHandlerHack extends Hack
 		return cursorY;
 	}
 	
-	private void rescan(HandledScreen<?> screen)
+	private void rescan(AbstractContainerScreen<?> screen)
 	{
-		refreshEntries(screen.getScreenHandler());
+		refreshEntries(screen.getMenu());
 		needsRescan = false;
 	}
 	
-	private void refreshIfDirty(HandledScreen<?> screen)
+	private void refreshIfDirty(AbstractContainerScreen<?> screen)
 	{
-		refreshEntries(screen.getScreenHandler());
+		refreshEntries(screen.getMenu());
 	}
 	
-	private void refreshEntries(ScreenHandler handler)
+	private void refreshEntries(AbstractContainerMenu handler)
 	{
 		allEntries.clear();
 		gearGroupedEntries.values().forEach(List::clear);
@@ -724,9 +721,10 @@ public final class EnchantmentHandlerHack extends Hack
 		List<Slot> slots = handler.slots;
 		int totalSlots = slots.size();
 		int containerSlots;
-		if(handler instanceof GenericContainerScreenHandler genericHandler)
+		if(handler instanceof ChestMenu genericHandler)
 		{
-			containerSlots = Math.min(genericHandler.getRows() * 9, totalSlots);
+			containerSlots =
+				Math.min(genericHandler.getRowCount() * 9, totalSlots);
 		}else
 		{
 			// For other handlers (shulker, player inventory, etc.) assume the
@@ -734,7 +732,7 @@ public final class EnchantmentHandlerHack extends Hack
 			// slots as total - 36. If this yields 0, fall back to using all
 			// slots so we still show items.
 			int playerInvSlots = 36;
-			if(MC.player != null && handler == MC.player.playerScreenHandler)
+			if(MC.player != null && handler == MC.player.inventoryMenu)
 				containerSlots = totalSlots; // player's own inventory: show all
 			else
 			{
@@ -747,10 +745,10 @@ public final class EnchantmentHandlerHack extends Hack
 		for(int i = 0; i < containerSlots; i++)
 		{
 			Slot slot = slots.get(i);
-			if(slot == null || !slot.hasStack())
+			if(slot == null || !slot.hasItem())
 				continue;
 			
-			ItemStack stack = slot.getStack();
+			ItemStack stack = slot.getItem();
 			if(stack.isEmpty())
 				continue;
 				
@@ -758,19 +756,19 @@ public final class EnchantmentHandlerHack extends Hack
 			// items
 			if(includeShulkerContents.isChecked())
 			{
-				ContainerComponent container =
-					stack.get(DataComponentTypes.CONTAINER);
+				ItemContainerContents container =
+					stack.get(DataComponents.CONTAINER);
 				if(container != null)
 				{
-					int parentSlotNumber = slot.getIndex() + 1;
-					for(ItemStack inner : container.iterateNonEmpty())
+					int parentSlotNumber = slot.getContainerSlot() + 1;
+					for(ItemStack inner : container.nonEmptyItems())
 					{
 						if(inner == null || inner.isEmpty())
 							continue;
-						if(inner.isOf(Items.ENCHANTED_BOOK))
+						if(inner.is(Items.ENCHANTED_BOOK))
 						{
-							var ench = EnchantmentHelper.getEnchantments(inner)
-								.getEnchantmentEntries();
+							var ench = EnchantmentHelper
+								.getEnchantmentsForCrafting(inner).entrySet();
 							BookEntry entry = buildBookEntryFromStack(
 								parentSlotNumber, inner, ench);
 							if(entry != null)
@@ -799,8 +797,8 @@ public final class EnchantmentHandlerHack extends Hack
 							}
 							continue;
 						}
-						var enchInner = EnchantmentHelper.getEnchantments(inner)
-							.getEnchantmentEntries();
+						var enchInner = EnchantmentHelper
+							.getEnchantmentsForCrafting(inner).entrySet();
 						if(!enchInner.isEmpty())
 						{
 							GearCategory gCatInner =
@@ -824,11 +822,11 @@ public final class EnchantmentHandlerHack extends Hack
 				}
 			}
 			
-			if(stack.isOf(Items.ENCHANTED_BOOK))
+			if(stack.is(Items.ENCHANTED_BOOK))
 			{
-				Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments =
-					EnchantmentHelper.getEnchantments(stack)
-						.getEnchantmentEntries();
+				Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments =
+					EnchantmentHelper.getEnchantmentsForCrafting(stack)
+						.entrySet();
 				if(enchantments.isEmpty())
 					continue;
 				
@@ -857,9 +855,8 @@ public final class EnchantmentHandlerHack extends Hack
 				continue;
 			}
 			
-			Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments =
-				EnchantmentHelper.getEnchantments(stack)
-					.getEnchantmentEntries();
+			Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments =
+				EnchantmentHelper.getEnchantmentsForCrafting(stack).entrySet();
 			if(enchantments.isEmpty())
 				continue;
 			
@@ -885,19 +882,19 @@ public final class EnchantmentHandlerHack extends Hack
 		for(int i = containerSlots; i < scanSlots; i++)
 		{
 			Slot slot = slots.get(i);
-			if(slot == null || !slot.hasStack())
+			if(slot == null || !slot.hasItem())
 				continue;
-			ItemStack stack = slot.getStack();
+			ItemStack stack = slot.getItem();
 			if(stack.isEmpty())
 				continue;
 				
 			// First, handle top-level enchanted books, potions and gear in
 			// the player inventory the same way we handle container slots.
-			if(stack.isOf(Items.ENCHANTED_BOOK))
+			if(stack.is(Items.ENCHANTED_BOOK))
 			{
-				Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments =
-					EnchantmentHelper.getEnchantments(stack)
-						.getEnchantmentEntries();
+				Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments =
+					EnchantmentHelper.getEnchantmentsForCrafting(stack)
+						.entrySet();
 				if(!enchantments.isEmpty())
 				{
 					BookEntry entry = buildBookEntry(slot, enchantments);
@@ -925,9 +922,8 @@ public final class EnchantmentHandlerHack extends Hack
 				continue;
 			}
 			
-			Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments =
-				EnchantmentHelper.getEnchantments(stack)
-					.getEnchantmentEntries();
+			Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments =
+				EnchantmentHelper.getEnchantmentsForCrafting(stack).entrySet();
 			if(!enchantments.isEmpty())
 			{
 				GearCategory category = GearCategory.fromStack(stack);
@@ -950,20 +946,20 @@ public final class EnchantmentHandlerHack extends Hack
 			// items
 			if(includeShulkerContents.isChecked())
 			{
-				ContainerComponent container =
-					stack.get(DataComponentTypes.CONTAINER);
+				ItemContainerContents container =
+					stack.get(DataComponents.CONTAINER);
 				if(container != null)
 				{
-					int parentSlotNumber = slot.getIndex() + 1;
-					for(ItemStack inner : container.iterateNonEmpty())
+					int parentSlotNumber = slot.getContainerSlot() + 1;
+					for(ItemStack inner : container.nonEmptyItems())
 					{
 						if(inner == null || inner.isEmpty())
 							continue;
 						// Enchanted book inside shulker
-						if(inner.isOf(Items.ENCHANTED_BOOK))
+						if(inner.is(Items.ENCHANTED_BOOK))
 						{
-							var ench = EnchantmentHelper.getEnchantments(inner)
-								.getEnchantmentEntries();
+							var ench = EnchantmentHelper
+								.getEnchantmentsForCrafting(inner).entrySet();
 							BookEntry entry = buildBookEntryFromStack(
 								parentSlotNumber, inner, ench);
 							if(entry != null)
@@ -993,8 +989,8 @@ public final class EnchantmentHandlerHack extends Hack
 							}
 							continue;
 						}
-						var enchInner = EnchantmentHelper.getEnchantments(inner)
-							.getEnchantmentEntries();
+						var enchInner = EnchantmentHelper
+							.getEnchantmentsForCrafting(inner).entrySet();
 						if(!enchInner.isEmpty())
 						{
 							GearCategory gCatInner =
@@ -1079,24 +1075,24 @@ public final class EnchantmentHandlerHack extends Hack
 	
 	private GearEntry buildGearEntry(Slot slot, ItemStack stack,
 		GearCategory category,
-		Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments)
+		Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments)
 	{
 		List<String> parts = new ArrayList<>();
 		
-		for(Object2IntMap.Entry<RegistryEntry<Enchantment>> entry : enchantments)
+		for(Object2IntMap.Entry<Holder<Enchantment>> entry : enchantments)
 		{
-			RegistryEntry<Enchantment> enchantmentEntry = entry.getKey();
+			Holder<Enchantment> enchantmentEntry = entry.getKey();
 			if(enchantmentEntry == null)
 				continue;
 			
 			int level = entry.getIntValue();
-			Identifier id = enchantmentEntry.getKey()
-				.map(registryKey -> registryKey.getValue()).orElse(null);
+			ResourceLocation id = enchantmentEntry.unwrapKey()
+				.map(registryKey -> registryKey.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(enchantmentEntry.getIdAsString());
+				: sanitizePath(enchantmentEntry.getRegisteredName());
 			String name = buildEnchantmentName(id, path);
-			String levelText =
-				Text.translatable("enchantment.level." + level).getString();
+			String levelText = Component
+				.translatable("enchantment.level." + level).getString();
 			parts.add(name + " " + levelText);
 		}
 		
@@ -1105,67 +1101,67 @@ public final class EnchantmentHandlerHack extends Hack
 		
 		String enchantSummary = limitLength(String.join(", ", parts), 90);
 		
-		int slotNumber = slot.getIndex() + 1;
-		String itemName = limitLength(stack.getName().getString(), 40);
+		int slotNumber = slot.getContainerSlot() + 1;
+		String itemName = limitLength(stack.getHoverName().getString(), 40);
 		
 		String line = slotNumber + " - " + itemName + " | " + enchantSummary;
 		
-		return new GearEntry(slot.id, slotNumber, category, line);
+		return new GearEntry(slot.index, slotNumber, category, line);
 	}
 	
 	// Build a GearEntry for an item inside a shulker box (no real slot id)
 	private GearEntry buildGearEntryFromStack(int parentSlotNumber,
 		ItemStack stack, GearCategory category,
-		Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments)
+		Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments)
 	{
 		List<String> parts = new ArrayList<>();
-		for(Object2IntMap.Entry<RegistryEntry<Enchantment>> entry : enchantments)
+		for(Object2IntMap.Entry<Holder<Enchantment>> entry : enchantments)
 		{
-			RegistryEntry<Enchantment> enchantmentEntry = entry.getKey();
+			Holder<Enchantment> enchantmentEntry = entry.getKey();
 			if(enchantmentEntry == null)
 				continue;
 			int level = entry.getIntValue();
-			Identifier id = enchantmentEntry.getKey()
-				.map(registryKey -> registryKey.getValue()).orElse(null);
+			ResourceLocation id = enchantmentEntry.unwrapKey()
+				.map(registryKey -> registryKey.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(enchantmentEntry.getIdAsString());
+				: sanitizePath(enchantmentEntry.getRegisteredName());
 			String name = buildEnchantmentName(id, path);
-			String levelText =
-				Text.translatable("enchantment.level." + level).getString();
+			String levelText = Component
+				.translatable("enchantment.level." + level).getString();
 			parts.add(name + " " + levelText);
 		}
 		if(parts.isEmpty())
 			return null;
 		String enchantSummary = limitLength(String.join(", ", parts), 90);
-		String itemName = limitLength(stack.getName().getString(), 40);
+		String itemName = limitLength(stack.getHoverName().getString(), 40);
 		String line = parentSlotNumber + " - " + itemName + " | "
 			+ enchantSummary + " (in shulker)";
 		return new GearEntry(-1, parentSlotNumber, category, line);
 	}
 	
 	private BookEntry buildBookEntry(Slot slot,
-		Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments)
+		Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments)
 	{
 		List<String> parts = new ArrayList<>();
 		EnumSet<BookCategory> categories = EnumSet.noneOf(BookCategory.class);
 		
-		for(Object2IntMap.Entry<RegistryEntry<Enchantment>> entry : enchantments)
+		for(Object2IntMap.Entry<Holder<Enchantment>> entry : enchantments)
 		{
-			RegistryEntry<Enchantment> enchantmentEntry = entry.getKey();
+			Holder<Enchantment> enchantmentEntry = entry.getKey();
 			if(enchantmentEntry == null)
 				continue;
 			
 			int level = entry.getIntValue();
-			Identifier id = enchantmentEntry.getKey()
-				.map(registryKey -> registryKey.getValue()).orElse(null);
+			ResourceLocation id = enchantmentEntry.unwrapKey()
+				.map(registryKey -> registryKey.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(enchantmentEntry.getIdAsString());
+				: sanitizePath(enchantmentEntry.getRegisteredName());
 			BookCategory category = BookCategory.fromPath(path);
 			categories.add(category);
 			
 			String name = buildEnchantmentName(id, path);
-			String levelText =
-				Text.translatable("enchantment.level." + level).getString();
+			String levelText = Component
+				.translatable("enchantment.level." + level).getString();
 			parts.add(name + " " + levelText);
 		}
 		
@@ -1178,34 +1174,34 @@ public final class EnchantmentHandlerHack extends Hack
 					.orElse(BookCategory.MISC));
 		
 		String enchantSummary = limitLength(String.join(", ", parts), 90);
-		int slotNumber = slot.getIndex() + 1;
+		int slotNumber = slot.getContainerSlot() + 1;
 		String line = slotNumber + " - " + enchantSummary;
 		
-		return new BookEntry(slot.id, slotNumber, primary, line);
+		return new BookEntry(slot.index, slotNumber, primary, line);
 	}
 	
 	// Build a BookEntry for an item inside a shulker box (no real slot id)
 	private BookEntry buildBookEntryFromStack(int parentSlotNumber,
 		ItemStack stack,
-		Set<Object2IntMap.Entry<RegistryEntry<Enchantment>>> enchantments)
+		Set<Object2IntMap.Entry<Holder<Enchantment>>> enchantments)
 	{
 		List<String> parts = new ArrayList<>();
 		EnumSet<BookCategory> categories = EnumSet.noneOf(BookCategory.class);
-		for(Object2IntMap.Entry<RegistryEntry<Enchantment>> entry : enchantments)
+		for(Object2IntMap.Entry<Holder<Enchantment>> entry : enchantments)
 		{
-			RegistryEntry<Enchantment> enchantmentEntry = entry.getKey();
+			Holder<Enchantment> enchantmentEntry = entry.getKey();
 			if(enchantmentEntry == null)
 				continue;
 			int level = entry.getIntValue();
-			Identifier id = enchantmentEntry.getKey()
-				.map(registryKey -> registryKey.getValue()).orElse(null);
+			ResourceLocation id = enchantmentEntry.unwrapKey()
+				.map(registryKey -> registryKey.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(enchantmentEntry.getIdAsString());
+				: sanitizePath(enchantmentEntry.getRegisteredName());
 			BookCategory category = BookCategory.fromPath(path);
 			categories.add(category);
 			String name = buildEnchantmentName(id, path);
-			String levelText =
-				Text.translatable("enchantment.level." + level).getString();
+			String levelText = Component
+				.translatable("enchantment.level." + level).getString();
 			parts.add(name + " " + levelText);
 		}
 		if(parts.isEmpty())
@@ -1224,19 +1220,17 @@ public final class EnchantmentHandlerHack extends Hack
 		PotionCategory category)
 	{
 		List<String> parts = new ArrayList<>();
-		PotionContentsComponent potionContents = stack.getComponents()
-			.getOrDefault(DataComponentTypes.POTION_CONTENTS,
-				PotionContentsComponent.DEFAULT);
+		PotionContents potionContents = stack.getComponents()
+			.getOrDefault(DataComponents.POTION_CONTENTS, PotionContents.EMPTY);
 		
 		// First list all actual effects
-		for(StatusEffectInstance effectInstance : potionContents.getEffects())
+		for(MobEffectInstance effectInstance : potionContents.getAllEffects())
 		{
-			RegistryEntry<StatusEffect> effEntry =
-				effectInstance.getEffectType();
-			Identifier id =
-				effEntry.getKey().map(k -> k.getValue()).orElse(null);
+			Holder<MobEffect> effEntry = effectInstance.getEffect();
+			ResourceLocation id =
+				effEntry.unwrapKey().map(k -> k.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(effEntry.getIdAsString());
+				: sanitizePath(effEntry.getRegisteredName());
 			String name = buildEffectName(id, path);
 			String ampText = effectInstance.getAmplifier() > 0
 				? " " + (effectInstance.getAmplifier() + 1) : "";
@@ -1253,10 +1247,11 @@ public final class EnchantmentHandlerHack extends Hack
 			var basePotion = potionContents.potion();
 			if(basePotion.isPresent())
 			{
-				RegistryEntry<Potion> p = basePotion.get();
-				Identifier id = p.getKey().map(k -> k.getValue()).orElse(null);
-				String path =
-					id != null ? id.getPath() : sanitizePath(p.getIdAsString());
+				Holder<Potion> p = basePotion.get();
+				ResourceLocation id =
+					p.unwrapKey().map(k -> k.location()).orElse(null);
+				String path = id != null ? id.getPath()
+					: sanitizePath(p.getRegisteredName());
 				String name = buildPotionName(id, path);
 				parts.add(name);
 			}
@@ -1266,15 +1261,15 @@ public final class EnchantmentHandlerHack extends Hack
 		int primaryLevel = 0;
 		int primaryDuration = 0;
 		
-		Iterable<StatusEffectInstance> effects = potionContents.getEffects();
-		java.util.Iterator<StatusEffectInstance> it = effects.iterator();
+		Iterable<MobEffectInstance> effects = potionContents.getAllEffects();
+		java.util.Iterator<MobEffectInstance> it = effects.iterator();
 		if(it.hasNext())
 		{
-			StatusEffectInstance first = it.next();
-			Identifier id = first.getEffectType().getKey()
-				.map(k -> k.getValue()).orElse(null);
+			MobEffectInstance first = it.next();
+			ResourceLocation id = first.getEffect().unwrapKey()
+				.map(k -> k.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(first.getEffectType().getIdAsString());
+				: sanitizePath(first.getEffect().getRegisteredName());
 			primaryName = buildEffectName(id, path);
 			primaryLevel = first.getAmplifier() + 1;
 			primaryDuration = Math.max(0, first.getDuration());
@@ -1283,10 +1278,10 @@ public final class EnchantmentHandlerHack extends Hack
 			var basePotion = potionContents.potion();
 			if(basePotion.isPresent())
 			{
-				Identifier id = basePotion.get().getKey().map(k -> k.getValue())
-					.orElse(null);
+				ResourceLocation id = basePotion.get().unwrapKey()
+					.map(k -> k.location()).orElse(null);
 				String path = id != null ? id.getPath()
-					: sanitizePath(basePotion.get().getIdAsString());
+					: sanitizePath(basePotion.get().getRegisteredName());
 				primaryName = buildPotionName(id, path);
 			}else
 			{
@@ -1298,29 +1293,27 @@ public final class EnchantmentHandlerHack extends Hack
 			return null;
 		
 		String summary = limitLength(String.join(", ", parts), 90);
-		int slotNumber = slot.getIndex() + 1;
-		String itemName = limitLength(stack.getName().getString(), 40);
+		int slotNumber = slot.getContainerSlot() + 1;
+		String itemName = limitLength(stack.getHoverName().getString(), 40);
 		String line = slotNumber + " - " + itemName + " | " + summary;
 		
-		return new PotionEntry(slot.id, slotNumber, category, line, primaryName,
-			primaryLevel, primaryDuration);
+		return new PotionEntry(slot.index, slotNumber, category, line,
+			primaryName, primaryLevel, primaryDuration);
 	}
 	
 	private PotionEntry buildPotionEntryFromStack(int parentSlotNumber,
 		ItemStack stack, PotionCategory category)
 	{
 		List<String> parts = new ArrayList<>();
-		PotionContentsComponent potionContents = stack.getComponents()
-			.getOrDefault(DataComponentTypes.POTION_CONTENTS,
-				PotionContentsComponent.DEFAULT);
-		for(StatusEffectInstance effectInstance : potionContents.getEffects())
+		PotionContents potionContents = stack.getComponents()
+			.getOrDefault(DataComponents.POTION_CONTENTS, PotionContents.EMPTY);
+		for(MobEffectInstance effectInstance : potionContents.getAllEffects())
 		{
-			RegistryEntry<StatusEffect> effEntry =
-				effectInstance.getEffectType();
-			Identifier id =
-				effEntry.getKey().map(k -> k.getValue()).orElse(null);
+			Holder<MobEffect> effEntry = effectInstance.getEffect();
+			ResourceLocation id =
+				effEntry.unwrapKey().map(k -> k.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(effEntry.getIdAsString());
+				: sanitizePath(effEntry.getRegisteredName());
 			String name = buildEffectName(id, path);
 			String ampText = effectInstance.getAmplifier() > 0
 				? " " + (effectInstance.getAmplifier() + 1) : "";
@@ -1334,10 +1327,11 @@ public final class EnchantmentHandlerHack extends Hack
 			var basePotion = potionContents.potion();
 			if(basePotion.isPresent())
 			{
-				RegistryEntry<Potion> p = basePotion.get();
-				Identifier id = p.getKey().map(k -> k.getValue()).orElse(null);
-				String path =
-					id != null ? id.getPath() : sanitizePath(p.getIdAsString());
+				Holder<Potion> p = basePotion.get();
+				ResourceLocation id =
+					p.unwrapKey().map(k -> k.location()).orElse(null);
+				String path = id != null ? id.getPath()
+					: sanitizePath(p.getRegisteredName());
 				String name = buildPotionName(id, path);
 				parts.add(name);
 			}
@@ -1345,21 +1339,21 @@ public final class EnchantmentHandlerHack extends Hack
 		if(parts.isEmpty())
 			return null;
 		String summary = limitLength(String.join(", ", parts), 90);
-		String itemName = limitLength(stack.getName().getString(), 40);
+		String itemName = limitLength(stack.getHoverName().getString(), 40);
 		String line = parentSlotNumber + " - " + itemName + " | " + summary
 			+ " (in shulker)";
 		String primaryName = null;
 		int primaryLevel = 0;
 		int primaryDuration = 0;
-		Iterable<StatusEffectInstance> effects = potionContents.getEffects();
-		java.util.Iterator<StatusEffectInstance> it = effects.iterator();
+		Iterable<MobEffectInstance> effects = potionContents.getAllEffects();
+		java.util.Iterator<MobEffectInstance> it = effects.iterator();
 		if(it.hasNext())
 		{
-			StatusEffectInstance first = it.next();
-			Identifier id = first.getEffectType().getKey()
-				.map(k -> k.getValue()).orElse(null);
+			MobEffectInstance first = it.next();
+			ResourceLocation id = first.getEffect().unwrapKey()
+				.map(k -> k.location()).orElse(null);
 			String path = id != null ? id.getPath()
-				: sanitizePath(first.getEffectType().getIdAsString());
+				: sanitizePath(first.getEffect().getRegisteredName());
 			primaryName = buildEffectName(id, path);
 			primaryLevel = first.getAmplifier() + 1;
 			primaryDuration = Math.max(0, first.getDuration());
@@ -1368,10 +1362,10 @@ public final class EnchantmentHandlerHack extends Hack
 			var basePotion = potionContents.potion();
 			if(basePotion.isPresent())
 			{
-				Identifier id = basePotion.get().getKey().map(k -> k.getValue())
-					.orElse(null);
+				ResourceLocation id = basePotion.get().unwrapKey()
+					.map(k -> k.location()).orElse(null);
 				String path = id != null ? id.getPath()
-					: sanitizePath(basePotion.get().getIdAsString());
+					: sanitizePath(basePotion.get().getRegisteredName());
 				primaryName = buildPotionName(id, path);
 			}else
 			{
@@ -1382,9 +1376,9 @@ public final class EnchantmentHandlerHack extends Hack
 			primaryName, primaryLevel, primaryDuration);
 	}
 	
-	private void takeEntry(GearEntry entry, ScreenHandler handler)
+	private void takeEntry(GearEntry entry, AbstractContainerMenu handler)
 	{
-		if(MC.player == null || MC.interactionManager == null || entry == null)
+		if(MC.player == null || MC.gameMode == null || entry == null)
 			return;
 		
 		// slotId < 0 indicates a display-only entry (e.g. shulker-inner)
@@ -1392,52 +1386,52 @@ public final class EnchantmentHandlerHack extends Hack
 			return;
 		
 		Slot slot = getSlotSafe(handler, entry.slotId);
-		if(slot == null || !slot.hasStack())
+		if(slot == null || !slot.hasItem())
 			return;
 		
-		MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-			SlotActionType.QUICK_MOVE, MC.player);
+		MC.gameMode.handleInventoryMouseClick(handler.containerId, entry.slotId,
+			0, ClickType.QUICK_MOVE, MC.player);
 		needsRescan = true;
 	}
 	
-	private void takeEntry(BookEntry entry, ScreenHandler handler)
+	private void takeEntry(BookEntry entry, AbstractContainerMenu handler)
 	{
-		if(MC.player == null || MC.interactionManager == null || entry == null)
+		if(MC.player == null || MC.gameMode == null || entry == null)
 			return;
 		
 		if(entry.slotId < 0)
 			return;
 		
 		Slot slot = getSlotSafe(handler, entry.slotId);
-		if(slot == null || !slot.hasStack())
+		if(slot == null || !slot.hasItem())
 			return;
 		
-		MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-			SlotActionType.QUICK_MOVE, MC.player);
+		MC.gameMode.handleInventoryMouseClick(handler.containerId, entry.slotId,
+			0, ClickType.QUICK_MOVE, MC.player);
 		needsRescan = true;
 	}
 	
-	private void takeEntry(PotionEntry entry, ScreenHandler handler)
+	private void takeEntry(PotionEntry entry, AbstractContainerMenu handler)
 	{
-		if(MC.player == null || MC.interactionManager == null || entry == null)
+		if(MC.player == null || MC.gameMode == null || entry == null)
 			return;
 		
 		if(entry.slotId < 0)
 			return;
 		
 		Slot slot = getSlotSafe(handler, entry.slotId);
-		if(slot == null || !slot.hasStack())
+		if(slot == null || !slot.hasItem())
 			return;
 		
-		MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-			SlotActionType.QUICK_MOVE, MC.player);
+		MC.gameMode.handleInventoryMouseClick(handler.containerId, entry.slotId,
+			0, ClickType.QUICK_MOVE, MC.player);
 		needsRescan = true;
 	}
 	
-	private void takeGearCategory(GearCategory category, ScreenHandler handler,
-		String source)
+	private void takeGearCategory(GearCategory category,
+		AbstractContainerMenu handler, String source)
 	{
-		if(MC.player == null || MC.interactionManager == null)
+		if(MC.player == null || MC.gameMode == null)
 			return;
 		
 		List<GearEntry> list;
@@ -1461,20 +1455,20 @@ public final class EnchantmentHandlerHack extends Hack
 			if(entry.slotId < 0)
 				continue; // display-only (in shulker)
 			Slot slot = getSlotSafe(handler, entry.slotId);
-			if(slot == null || !slot.hasStack())
+			if(slot == null || !slot.hasItem())
 				continue;
 			
-			MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-				SlotActionType.QUICK_MOVE, MC.player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId,
+				entry.slotId, 0, ClickType.QUICK_MOVE, MC.player);
 		}
 		
 		needsRescan = true;
 	}
 	
-	private void takeBookCategory(BookCategory category, ScreenHandler handler,
-		String source)
+	private void takeBookCategory(BookCategory category,
+		AbstractContainerMenu handler, String source)
 	{
-		if(MC.player == null || MC.interactionManager == null)
+		if(MC.player == null || MC.gameMode == null)
 			return;
 		
 		List<BookEntry> list;
@@ -1498,19 +1492,19 @@ public final class EnchantmentHandlerHack extends Hack
 			if(entry.slotId < 0)
 				continue;
 			Slot slot = getSlotSafe(handler, entry.slotId);
-			if(slot == null || !slot.hasStack())
+			if(slot == null || !slot.hasItem())
 				continue;
-			MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-				SlotActionType.QUICK_MOVE, MC.player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId,
+				entry.slotId, 0, ClickType.QUICK_MOVE, MC.player);
 		}
 		
 		needsRescan = true;
 	}
 	
 	private void takePotionCategory(PotionCategory category,
-		ScreenHandler handler, String source)
+		AbstractContainerMenu handler, String source)
 	{
-		if(MC.player == null || MC.interactionManager == null)
+		if(MC.player == null || MC.gameMode == null)
 			return;
 		
 		List<PotionEntry> list;
@@ -1534,16 +1528,16 @@ public final class EnchantmentHandlerHack extends Hack
 			if(entry.slotId < 0)
 				continue;
 			Slot slot = getSlotSafe(handler, entry.slotId);
-			if(slot == null || !slot.hasStack())
+			if(slot == null || !slot.hasItem())
 				continue;
-			MC.interactionManager.clickSlot(handler.syncId, entry.slotId, 0,
-				SlotActionType.QUICK_MOVE, MC.player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId,
+				entry.slotId, 0, ClickType.QUICK_MOVE, MC.player);
 		}
 		
 		needsRescan = true;
 	}
 	
-	private Slot getSlotSafe(ScreenHandler handler, int slotId)
+	private Slot getSlotSafe(AbstractContainerMenu handler, int slotId)
 	{
 		if(handler == null || slotId < 0)
 			return null;
@@ -1557,9 +1551,9 @@ public final class EnchantmentHandlerHack extends Hack
 	
 	private int panelInnerHeight()
 	{
-		float scale = MathHelper.clamp(textScale.getValueF(), 0.5F, 1.25F);
-		TextRenderer tr = MC.textRenderer;
-		int titleHeight = Math.max(1, Math.round(tr.fontHeight * scale));
+		float scale = Mth.clamp(textScale.getValueF(), 0.5F, 1.25F);
+		Font tr = MC.font;
+		int titleHeight = Math.max(1, Math.round(tr.lineHeight * scale));
 		int headerMargin = Math.max(1, Math.round(HEADER_MARGIN * scale));
 		int contentTop =
 			panelY + PANEL_PADDING + titleHeight + headerMargin + 1;
@@ -1567,32 +1561,32 @@ public final class EnchantmentHandlerHack extends Hack
 		return Math.max(0, contentBottom - contentTop);
 	}
 	
-	private static double getScaledMouseX(DrawContext context)
+	private static double getScaledMouseX(GuiGraphics context)
 	{
 		Window window = MC.getWindow();
-		return MC.mouse.getX() * context.getScaledWindowWidth()
-			/ window.getWidth();
+		return MC.mouseHandler.xpos() * context.guiWidth()
+			/ window.getScreenWidth();
 	}
 	
-	private static double getScaledMouseY(DrawContext context)
+	private static double getScaledMouseY(GuiGraphics context)
 	{
 		Window window = MC.getWindow();
-		return MC.mouse.getY() * context.getScaledWindowHeight()
-			/ window.getHeight();
+		return MC.mouseHandler.ypos() * context.guiHeight()
+			/ window.getScreenHeight();
 	}
 	
-	private static void drawScaledText(DrawContext context, TextRenderer tr,
+	private static void drawScaledText(GuiGraphics context, Font tr,
 		String text, float x, float y, int color, float scale)
 	{
 		RenderUtils.drawScaledText(context, tr, text, Math.round(x),
 			Math.round(y), color, false, scale);
 	}
 	
-	private void drawSectionHeader(DrawContext context, TextRenderer tr, int x,
-		int y, String text, float scale)
+	private void drawSectionHeader(GuiGraphics context, Font tr, int x, int y,
+		String text, float scale)
 	{
-		int textWidth = Math.max(1, Math.round(tr.getWidth(text) * scale));
-		int textHeight = Math.max(1, Math.round(tr.fontHeight * scale));
+		int textWidth = Math.max(1, Math.round(tr.width(text) * scale));
+		int textHeight = Math.max(1, Math.round(tr.lineHeight * scale));
 		int left = Math.round(x - 4);
 		int right = Math.round(x + textWidth + 4);
 		int top = Math.round(y - 4);
@@ -1608,40 +1602,40 @@ public final class EnchantmentHandlerHack extends Hack
 		return text.substring(0, Math.max(0, max - 3)) + "...";
 	}
 	
-	private static String buildEnchantmentName(Identifier id, String path)
+	private static String buildEnchantmentName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Enchant";
 		
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "enchantment." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
 	}
 	
-	private static String buildEffectName(Identifier id, String path)
+	private static String buildEffectName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Effect";
 		
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "effect." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
 	}
 	
-	private static String buildPotionName(Identifier id, String path)
+	private static String buildPotionName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Potion";
 		
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "potion." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
@@ -1816,22 +1810,21 @@ public final class EnchantmentHandlerHack extends Hack
 					case FEET -> BOOTS;
 					case OFFHAND ->
 					{
-						if(stack.isOf(Items.SHIELD))
+						if(stack.is(Items.SHIELD))
 							yield SHIELD;
 						yield null;
 					}
 					default -> null;
 				};
 			
-			if(stack.isOf(Items.SHIELD))
+			if(stack.is(Items.SHIELD))
 				return SHIELD;
 			
-			if(stack.isOf(Items.TRIDENT) || stack.isOf(Items.BOW)
-				|| stack.isOf(Items.CROSSBOW))
+			if(stack.is(Items.TRIDENT) || stack.is(Items.BOW)
+				|| stack.is(Items.CROSSBOW))
 				return WEAPON;
 			
-			WeaponComponent weapon =
-				stack.getComponents().get(DataComponentTypes.WEAPON);
+			Weapon weapon = stack.getComponents().get(DataComponents.WEAPON);
 			if(weapon != null)
 				return WEAPON;
 			
diff --git a/src/main/java/net/wurstclient/hacks/ExcavatorHack.java b/src/main/java/net/wurstclient/hacks/ExcavatorHack.java
index c2731bbc4..5e2cc4fbc 100644
--- a/src/main/java/net/wurstclient/hacks/ExcavatorHack.java
+++ b/src/main/java/net/wurstclient/hacks/ExcavatorHack.java
@@ -7,6 +7,8 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.platform.InputConstants;
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.HashSet;
@@ -15,17 +17,14 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Colors;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.CommonColors;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.ai.PathFinder;
 import net.wurstclient.ai.PathProcessor;
@@ -118,7 +117,7 @@ public final class ExcavatorHack extends Hack
 		posLookingAt = null;
 		area = null;
 		
-		MC.interactionManager.cancelBlockBreaking();
+		MC.gameMode.stopDestroyBlock();
 		overlay.resetProgress();
 		currentBlock = null;
 		
@@ -139,7 +138,7 @@ public final class ExcavatorHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(pathFinder != null)
 		{
@@ -159,28 +158,27 @@ public final class ExcavatorHack extends Hack
 			// recently scanned blocks
 			if(step == Step.SCAN_AREA && area.progress < 1)
 			{
-				ArrayList<Box> boxes = new ArrayList<>();
+				ArrayList<AABB> boxes = new ArrayList<>();
 				for(int i = Math.max(0, area.blocksList.size()
 					- area.scanSpeed); i < area.blocksList.size(); i++)
-					boxes.add(new Box(area.blocksList.get(i)).expand(0.005));
+					boxes.add(new AABB(area.blocksList.get(i)).inflate(0.005));
 				
 				RenderUtils.drawOutlinedBoxes(matrixStack, boxes, black, true);
 				RenderUtils.drawSolidBoxes(matrixStack, boxes, green1, true);
 			}
 			
 			// area box
-			Box areaBox =
-				new Box(area.minX, area.minY, area.minZ, area.minX + area.sizeX,
-					area.minY + area.sizeY, area.minZ + area.sizeZ)
-						.contract(1 / 16.0);
+			AABB areaBox = new AABB(area.minX, area.minY, area.minZ,
+				area.minX + area.sizeX, area.minY + area.sizeY,
+				area.minZ + area.sizeZ).deflate(1 / 16.0);
 			RenderUtils.drawOutlinedBox(matrixStack, areaBox, black, true);
 			
 			// area scanner
 			if(area.progress < 1)
 			{
 				double scannerX =
-					MathHelper.lerp(area.progress, areaBox.minX, areaBox.maxX);
-				Box scanner = areaBox.withMinX(scannerX).withMaxX(scannerX);
+					Mth.lerp(area.progress, areaBox.minX, areaBox.maxX);
+				AABB scanner = areaBox.setMinX(scannerX).setMaxX(scannerX);
 				
 				RenderUtils.drawOutlinedBox(matrixStack, scanner, black, true);
 				RenderUtils.drawSolidBox(matrixStack, scanner, green2, true);
@@ -190,23 +188,24 @@ public final class ExcavatorHack extends Hack
 		// area preview
 		if(area == null && step == Step.END_POS && step.pos != null)
 		{
-			Box preview = Box.enclosing(Step.START_POS.pos, Step.END_POS.pos)
-				.contract(1 / 16.0);
+			AABB preview = AABB
+				.encapsulatingFullBlocks(Step.START_POS.pos, Step.END_POS.pos)
+				.deflate(1 / 16.0);
 			RenderUtils.drawOutlinedBox(matrixStack, preview, black, true);
 		}
 		
 		// selected positions
-		ArrayList<Box> selectedBoxes = new ArrayList<>();
+		ArrayList<AABB> selectedBoxes = new ArrayList<>();
 		for(Step step : Step.SELECT_POSITION_STEPS)
 			if(step.pos != null)
-				selectedBoxes.add(new Box(step.pos).contract(1 / 16.0));
+				selectedBoxes.add(new AABB(step.pos).deflate(1 / 16.0));
 		RenderUtils.drawOutlinedBoxes(matrixStack, selectedBoxes, black, false);
 		RenderUtils.drawSolidBoxes(matrixStack, selectedBoxes, green1, false);
 		
 		// posLookingAt
 		if(posLookingAt != null)
 		{
-			Box box = new Box(posLookingAt).contract(1 / 16.0);
+			AABB box = new AABB(posLookingAt).deflate(1 / 16.0);
 			RenderUtils.drawOutlinedBox(matrixStack, box, black, false);
 			RenderUtils.drawSolidBox(matrixStack, box, gray, false);
 		}
@@ -215,7 +214,7 @@ public final class ExcavatorHack extends Hack
 	}
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
 		String message;
 		if(step.selectPos && step.pos != null)
@@ -223,20 +222,20 @@ public final class ExcavatorHack extends Hack
 		else
 			message = step.message;
 		
-		TextRenderer tr = MC.textRenderer;
-		int msgWidth = tr.getWidth(message);
+		Font tr = MC.font;
+		int msgWidth = tr.width(message);
 		
-		int msgX1 = context.getScaledWindowWidth() / 2 - msgWidth / 2;
+		int msgX1 = context.guiWidth() / 2 - msgWidth / 2;
 		int msgX2 = msgX1 + msgWidth + 2;
-		int msgY1 = context.getScaledWindowHeight() / 2 + 1;
+		int msgY1 = context.guiHeight() / 2 + 1;
 		int msgY2 = msgY1 + 10;
 		
 		// background
 		context.fill(msgX1, msgY1, msgX2, msgY2, 0x80000000);
 		
 		// text
-		context.drawText(tr, message, msgX1 + 2, msgY1 + 1, Colors.WHITE,
-			false);
+		context.drawString(tr, message, msgX1 + 2, msgY1 + 1,
+			CommonColors.WHITE, false);
 	}
 	
 	public void enableWithArea(BlockPos pos1, BlockPos pos2)
@@ -251,7 +250,7 @@ public final class ExcavatorHack extends Hack
 	{
 		// continue with next step
 		if(step.pos != null
-			&& InputUtil.isKeyPressed(MC.getWindow(), GLFW.GLFW_KEY_ENTER))
+			&& InputConstants.isKeyDown(MC.getWindow(), GLFW.GLFW_KEY_ENTER))
 		{
 			step = Step.values()[step.ordinal() + 1];
 			
@@ -262,21 +261,21 @@ public final class ExcavatorHack extends Hack
 			return;
 		}
 		
-		if(MC.crosshairTarget instanceof BlockHitResult)
+		if(MC.hitResult instanceof BlockHitResult)
 		{
 			// set posLookingAt
-			posLookingAt = ((BlockHitResult)MC.crosshairTarget).getBlockPos();
+			posLookingAt = ((BlockHitResult)MC.hitResult).getBlockPos();
 			
 			// offset if sneaking
-			if(MC.options.sneakKey.isPressed())
+			if(MC.options.keyShift.isDown())
 				posLookingAt = posLookingAt
-					.offset(((BlockHitResult)MC.crosshairTarget).getSide());
+					.relative(((BlockHitResult)MC.hitResult).getDirection());
 			
 		}else
 			posLookingAt = null;
 		
 		// set selected position
-		if(posLookingAt != null && MC.options.useKey.isPressed())
+		if(posLookingAt != null && MC.options.keyUse.isDown())
 			step.pos = posLookingAt;
 	}
 	
@@ -321,10 +320,10 @@ public final class ExcavatorHack extends Hack
 			return;
 		
 		// prioritize the closest block from the top layer
-		Vec3d eyesVec = RotationUtils.getEyesPos();
+		Vec3 eyesVec = RotationUtils.getEyesPos();
 		Comparator<BlockPos> cNextTargetBlock =
-			Comparator.comparingInt(BlockPos::getY).reversed()
-				.thenComparingDouble(pos -> pos.getSquaredDistance(eyesVec));
+			Comparator.<BlockPos> comparingInt(pos -> pos.getY()).reversed()
+				.thenComparingDouble(pos -> pos.distToCenterSqr(eyesVec));
 		
 		// get valid blocks
 		ArrayList<BlockPos> validBlocks = getValidBlocks();
@@ -333,9 +332,9 @@ public final class ExcavatorHack extends Hack
 		
 		// nuke all
 		boolean legit = mode.getSelected() == Mode.LEGIT;
-		if(MC.player.getAbilities().creativeMode && !legit)
+		if(MC.player.getAbilities().instabuild && !legit)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			
 			// set closest block as current
@@ -364,7 +363,7 @@ public final class ExcavatorHack extends Hack
 			// reset if no block was found
 			if(currentBlock == null)
 			{
-				MC.interactionManager.cancelBlockBreaking();
+				MC.gameMode.stopDestroyBlock();
 				overlay.resetProgress();
 			}
 		}
@@ -372,7 +371,7 @@ public final class ExcavatorHack extends Hack
 		overlay.updateProgress();
 		
 		// get remaining blocks
-		Predicate<BlockPos> pBreakable = MC.player.getAbilities().creativeMode
+		Predicate<BlockPos> pBreakable = MC.player.getAbilities().instabuild
 			? BlockUtils::canBeClicked : pos -> BlockUtils.canBeClicked(pos)
 				&& !BlockUtils.isUnbreakable(pos);
 		area.remainingBlocks =
@@ -429,17 +428,17 @@ public final class ExcavatorHack extends Hack
 	
 	private ArrayList<BlockPos> getValidBlocks()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = Math.pow(range.getValue() + 0.5, 2);
 		int blockRange = range.getValueCeil();
 		
 		return BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-			.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
+			.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
 			.filter(area.blocksSet::contains).filter(BlockUtils::canBeClicked)
 			.filter(pos -> !BlockUtils.isUnbreakable(pos))
-			.sorted(Comparator
-				.comparingDouble(pos -> pos.getSquaredDistance(eyesVec)))
+			.sorted(
+				Comparator.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
 	
@@ -521,7 +520,7 @@ public final class ExcavatorHack extends Hack
 			sizeZ = Math.abs(startZ - endZ);
 			
 			totalBlocks = (sizeX + 1) * (sizeY + 1) * (sizeZ + 1);
-			scanSpeed = MathHelper.clamp(totalBlocks / 30, 1, 16384);
+			scanSpeed = Mth.clamp(totalBlocks / 30, 1, 16384);
 			iterator = BlockUtils.getAllInBox(start, end).iterator();
 		}
 	}
@@ -544,14 +543,14 @@ public final class ExcavatorHack extends Hack
 		{
 			BlockPos goal = getGoal();
 			
-			return done = goal.down(2).equals(current)
-				|| goal.up().equals(current) || goal.north().equals(current)
+			return done = goal.below(2).equals(current)
+				|| goal.above().equals(current) || goal.north().equals(current)
 				|| goal.south().equals(current) || goal.west().equals(current)
 				|| goal.east().equals(current)
-				|| goal.down().north().equals(current)
-				|| goal.down().south().equals(current)
-				|| goal.down().west().equals(current)
-				|| goal.down().east().equals(current);
+				|| goal.below().north().equals(current)
+				|| goal.below().south().equals(current)
+				|| goal.below().west().equals(current)
+				|| goal.below().east().equals(current);
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/ExtraElytraHack.java b/src/main/java/net/wurstclient/hacks/ExtraElytraHack.java
index 5d5b3d1de..c7422b523 100644
--- a/src/main/java/net/wurstclient/hacks/ExtraElytraHack.java
+++ b/src/main/java/net/wurstclient/hacks/ExtraElytraHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.network.protocol.game.ServerboundPlayerCommandPacket;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -70,9 +70,9 @@ public final class ExtraElytraHack extends Hack implements UpdateListener
 		if(!MC.player.canGlide())
 			return;
 		
-		if(MC.player.isGliding())
+		if(MC.player.isFallFlying())
 		{
-			if(stopInWater.isChecked() && MC.player.isTouchingWater())
+			if(stopInWater.isChecked() && MC.player.isInWater())
 			{
 				sendStartStopPacket();
 				return;
@@ -83,15 +83,16 @@ public final class ExtraElytraHack extends Hack implements UpdateListener
 			return;
 		}
 		
-		if(MC.options.jumpKey.isPressed())
+		if(MC.options.keyJump.isDown())
 			doInstantFly();
 	}
 	
 	private void sendStartStopPacket()
 	{
-		ClientCommandC2SPacket packet = new ClientCommandC2SPacket(MC.player,
-			ClientCommandC2SPacket.Mode.START_FALL_FLYING);
-		MC.player.networkHandler.sendPacket(packet);
+		ServerboundPlayerCommandPacket packet =
+			new ServerboundPlayerCommandPacket(MC.player,
+				ServerboundPlayerCommandPacket.Action.START_FALL_FLYING);
+		MC.player.connection.send(packet);
 	}
 	
 	private void controlHeight()
@@ -99,12 +100,12 @@ public final class ExtraElytraHack extends Hack implements UpdateListener
 		if(!heightCtrl.isChecked())
 			return;
 		
-		Vec3d v = MC.player.getVelocity();
+		Vec3 v = MC.player.getDeltaMovement();
 		
-		if(MC.options.jumpKey.isPressed())
-			MC.player.setVelocity(v.x, v.y + 0.08, v.z);
-		else if(MC.options.sneakKey.isPressed())
-			MC.player.setVelocity(v.x, v.y - 0.04, v.z);
+		if(MC.options.keyJump.isDown())
+			MC.player.setDeltaMovement(v.x, v.y + 0.08, v.z);
+		else if(MC.options.keyShift.isDown())
+			MC.player.setDeltaMovement(v.x, v.y - 0.04, v.z);
 	}
 	
 	private void controlSpeed()
@@ -112,16 +113,15 @@ public final class ExtraElytraHack extends Hack implements UpdateListener
 		if(!speedCtrl.isChecked())
 			return;
 		
-		float yaw = (float)Math.toRadians(MC.player.getYaw());
-		Vec3d forward = new Vec3d(-MathHelper.sin(yaw) * 0.05, 0,
-			MathHelper.cos(yaw) * 0.05);
+		float yaw = (float)Math.toRadians(MC.player.getYRot());
+		Vec3 forward = new Vec3(-Mth.sin(yaw) * 0.05, 0, Mth.cos(yaw) * 0.05);
 		
-		Vec3d v = MC.player.getVelocity();
+		Vec3 v = MC.player.getDeltaMovement();
 		
-		if(MC.options.forwardKey.isPressed())
-			MC.player.setVelocity(v.add(forward));
-		else if(MC.options.backKey.isPressed())
-			MC.player.setVelocity(v.subtract(forward));
+		if(MC.options.keyUp.isDown())
+			MC.player.setDeltaMovement(v.add(forward));
+		else if(MC.options.keyDown.isDown())
+			MC.player.setDeltaMovement(v.subtract(forward));
 	}
 	
 	private void doInstantFly()
@@ -134,7 +134,7 @@ public final class ExtraElytraHack extends Hack implements UpdateListener
 			jumpTimer = 20;
 			MC.player.setJumping(false);
 			MC.player.setSprinting(true);
-			MC.player.jump();
+			MC.player.jumpFromGround();
 		}
 		
 		sendStartStopPacket();
diff --git a/src/main/java/net/wurstclient/hacks/FastBreakHack.java b/src/main/java/net/wurstclient/hacks/FastBreakHack.java
index 3c9831d9d..7a7a30380 100644
--- a/src/main/java/net/wurstclient/hacks/FastBreakHack.java
+++ b/src/main/java/net/wurstclient/hacks/FastBreakHack.java
@@ -8,11 +8,10 @@
 package net.wurstclient.hacks;
 
 import java.util.Random;
-
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket.Action;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket.Action;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.BlockBreakingProgressListener;
@@ -82,7 +81,7 @@ public final class FastBreakHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		MC.interactionManager.blockBreakingCooldown = 0;
+		MC.gameMode.destroyDelay = 0;
 	}
 	
 	@Override
@@ -91,7 +90,7 @@ public final class FastBreakHack extends Hack
 		if(legitMode.isChecked())
 			return;
 		
-		if(MC.interactionManager.currentBreakingProgress >= 1)
+		if(MC.gameMode.destroyProgress >= 1)
 			return;
 		
 		BlockPos blockPos = event.getBlockPos();
@@ -108,7 +107,7 @@ public final class FastBreakHack extends Hack
 		if(!fastBreakBlock)
 			return;
 		
-		Action action = PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK;
+		Action action = ServerboundPlayerActionPacket.Action.STOP_DESTROY_BLOCK;
 		Direction direction = event.getDirection();
 		IMC.getInteractionManager().sendPlayerActionC2SPacket(action, blockPos,
 			direction);
diff --git a/src/main/java/net/wurstclient/hacks/FastLadderHack.java b/src/main/java/net/wurstclient/hacks/FastLadderHack.java
index 81385b17f..8036e3c98 100644
--- a/src/main/java/net/wurstclient/hacks/FastLadderHack.java
+++ b/src/main/java/net/wurstclient/hacks/FastLadderHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -38,15 +38,15 @@ public final class FastLadderHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		if(!player.isClimbing() || !player.horizontalCollision)
+		if(!player.onClimbable() || !player.horizontalCollision)
 			return;
 		
-		if(player.input.getMovementInput().length() <= 1e-5F)
+		if(player.input.getMoveVector().length() <= 1e-5F)
 			return;
 		
-		Vec3d velocity = player.getVelocity();
-		player.setVelocity(velocity.x, 0.2872, velocity.z);
+		Vec3 velocity = player.getDeltaMovement();
+		player.setDeltaMovement(velocity.x, 0.2872, velocity.z);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/FastPlaceHack.java b/src/main/java/net/wurstclient/hacks/FastPlaceHack.java
index 1fbb7cf7e..e3fda7738 100644
--- a/src/main/java/net/wurstclient/hacks/FastPlaceHack.java
+++ b/src/main/java/net/wurstclient/hacks/FastPlaceHack.java
@@ -36,6 +36,6 @@ public final class FastPlaceHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		MC.itemUseCooldown = 0;
+		MC.rightClickDelay = 0;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/FeedAuraHack.java b/src/main/java/net/wurstclient/hacks/FeedAuraHack.java
index 1e4be748c..6dd1fb6b2 100644
--- a/src/main/java/net/wurstclient/hacks/FeedAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/FeedAuraHack.java
@@ -7,23 +7,22 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Random;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.passive.AbstractHorseEntity;
-import net.minecraft.entity.passive.AnimalEntity;
-import net.minecraft.entity.passive.TameableEntity;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.animal.horse.AbstractHorse;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleInputListener;
@@ -64,8 +63,8 @@ public final class FeedAuraHack extends Hack
 		false);
 	
 	private final Random random = new Random();
-	private AnimalEntity target;
-	private AnimalEntity renderTarget;
+	private Animal target;
+	private Animal renderTarget;
 	
 	public FeedAuraHack()
 	{
@@ -108,14 +107,13 @@ public final class FeedAuraHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		ItemStack heldStack = player.getInventory().getSelectedStack();
+		LocalPlayer player = MC.player;
+		ItemStack heldStack = player.getInventory().getSelectedItem();
 		
 		double rangeSq = range.getValueSq();
-		Stream<AnimalEntity> stream = EntityUtils.getValidAnimals()
-			.filter(e -> player.squaredDistanceTo(e) <= rangeSq)
-			.filter(e -> e.isBreedingItem(heldStack))
-			.filter(AnimalEntity::canEat);
+		Stream<Animal> stream = EntityUtils.getValidAnimals()
+			.filter(e -> player.distanceToSqr(e) <= rangeSq)
+			.filter(e -> e.isFood(heldStack)).filter(Animal::canFallInLove);
 		
 		if(filterBabies.isChecked())
 			stream = stream.filter(filterBabies);
@@ -124,10 +122,10 @@ public final class FeedAuraHack extends Hack
 			stream = stream.filter(e -> !isUntamed(e));
 		
 		if(filterHorses.isChecked())
-			stream = stream.filter(e -> !(e instanceof AbstractHorseEntity));
+			stream = stream.filter(e -> !(e instanceof AbstractHorse));
 		
 		// convert targets to list
-		ArrayList<AnimalEntity> targets =
+		ArrayList<Animal> targets =
 			stream.collect(Collectors.toCollection(ArrayList::new));
 		
 		// pick a target at random
@@ -148,35 +146,35 @@ public final class FeedAuraHack extends Hack
 		if(target == null)
 			return;
 		
-		ClientPlayerInteractionManager im = MC.interactionManager;
-		ClientPlayerEntity player = MC.player;
-		Hand hand = Hand.MAIN_HAND;
+		MultiPlayerGameMode im = MC.gameMode;
+		LocalPlayer player = MC.player;
+		InteractionHand hand = InteractionHand.MAIN_HAND;
 		
-		if(im.isBreakingBlock() || player.isRiding())
+		if(im.isDestroying() || player.isHandsBusy())
 			return;
 		
 		// create realistic hit result
-		Box box = target.getBoundingBox();
-		Vec3d start = RotationUtils.getEyesPos();
-		Vec3d end = box.getCenter();
-		Vec3d hitVec = box.raycast(start, end).orElse(start);
+		AABB box = target.getBoundingBox();
+		Vec3 start = RotationUtils.getEyesPos();
+		Vec3 end = box.getCenter();
+		Vec3 hitVec = box.clip(start, end).orElse(start);
 		EntityHitResult hitResult = new EntityHitResult(target, hitVec);
 		
-		ActionResult actionResult =
-			im.interactEntityAtLocation(player, target, hitResult, hand);
+		InteractionResult actionResult =
+			im.interactAt(player, target, hitResult, hand);
 		
-		if(!actionResult.isAccepted())
-			actionResult = im.interactEntity(player, target, hand);
+		if(!actionResult.consumesAction())
+			actionResult = im.interact(player, target, hand);
 		
-		if(actionResult instanceof ActionResult.Success success
-			&& success.swingSource() == ActionResult.SwingSource.CLIENT)
-			player.swingHand(hand);
+		if(actionResult instanceof InteractionResult.Success success
+			&& success.swingSource() == InteractionResult.SwingSource.CLIENT)
+			player.swing(hand);
 		
 		target = null;
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(renderTarget == null)
 			return;
@@ -190,22 +188,21 @@ public final class FeedAuraHack extends Hack
 		int quadColor = RenderUtils.toIntColor(rgb, 0.25F);
 		int lineColor = RenderUtils.toIntColor(rgb, 0.5F);
 		
-		Box box = EntityUtils.getLerpedBox(renderTarget, partialTicks);
+		AABB box = EntityUtils.getLerpedBox(renderTarget, partialTicks);
 		if(p < 1)
-			box = box.contract((1 - p) * 0.5 * box.getLengthX(),
-				(1 - p) * 0.5 * box.getLengthY(),
-				(1 - p) * 0.5 * box.getLengthZ());
+			box = box.deflate((1 - p) * 0.5 * box.getXsize(),
+				(1 - p) * 0.5 * box.getYsize(), (1 - p) * 0.5 * box.getZsize());
 		
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, box, lineColor, false);
 	}
 	
-	private boolean isUntamed(AnimalEntity e)
+	private boolean isUntamed(Animal e)
 	{
-		if(e instanceof AbstractHorseEntity horse && !horse.isTame())
+		if(e instanceof AbstractHorse horse && !horse.isTamed())
 			return true;
 		
-		if(e instanceof TameableEntity tame && !tame.isTamed())
+		if(e instanceof TamableAnimal tame && !tame.isTame())
 			return true;
 		
 		return false;
diff --git a/src/main/java/net/wurstclient/hacks/FightBotHack.java b/src/main/java/net/wurstclient/hacks/FightBotHack.java
index 07084ae85..b00b576ed 100644
--- a/src/main/java/net/wurstclient/hacks/FightBotHack.java
+++ b/src/main/java/net/wurstclient/hacks/FightBotHack.java
@@ -7,15 +7,14 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.ai.PathFinder;
@@ -131,8 +130,7 @@ public final class FightBotHack extends Hack
 		stream = entityFilters.applyTo(stream);
 		
 		Entity entity = stream
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		if(entity == null)
 			return;
@@ -171,34 +169,34 @@ public final class FightBotHack extends Hack
 		}else
 		{
 			// jump if necessary
-			if(MC.player.horizontalCollision && MC.player.isOnGround())
-				MC.player.jump();
+			if(MC.player.horizontalCollision && MC.player.onGround())
+				MC.player.jumpFromGround();
 			
 			// swim up if necessary
-			if(MC.player.isTouchingWater() && MC.player.getY() < entity.getY())
-				MC.player.addVelocity(0, 0.04, 0);
+			if(MC.player.isInWater() && MC.player.getY() < entity.getY())
+				MC.player.push(0, 0.04, 0);
 			
 			// control height if flying
-			if(!MC.player.isOnGround()
+			if(!MC.player.onGround()
 				&& (MC.player.getAbilities().flying
 					|| WURST.getHax().flightHack.isEnabled())
-				&& MC.player.squaredDistanceTo(entity.getX(), MC.player.getY(),
-					entity.getZ()) <= MC.player.squaredDistanceTo(
-						MC.player.getX(), entity.getY(), MC.player.getZ()))
+				&& MC.player.distanceToSqr(entity.getX(), MC.player.getY(),
+					entity.getZ()) <= MC.player.distanceToSqr(MC.player.getX(),
+						entity.getY(), MC.player.getZ()))
 			{
 				if(MC.player.getY() > entity.getY() + 1D)
-					MC.options.sneakKey.setPressed(true);
+					MC.options.keyShift.setDown(true);
 				else if(MC.player.getY() < entity.getY() - 1D)
-					MC.options.jumpKey.setPressed(true);
+					MC.options.keyJump.setDown(true);
 			}else
 			{
-				MC.options.sneakKey.setPressed(false);
-				MC.options.jumpKey.setPressed(false);
+				MC.options.keyShift.setDown(false);
+				MC.options.keyJump.setDown(false);
 			}
 			
 			// follow entity
-			MC.options.forwardKey.setPressed(
-				MC.player.distanceTo(entity) > distance.getValueF());
+			MC.options.keyUp
+				.setDown(MC.player.distanceTo(entity) > distance.getValueF());
 			WURST.getRotationFaker()
 				.faceVectorClient(entity.getBoundingBox().getCenter());
 		}
@@ -208,17 +206,17 @@ public final class FightBotHack extends Hack
 			return;
 		
 		// check range
-		if(MC.player.squaredDistanceTo(entity) > Math.pow(range.getValue(), 2))
+		if(MC.player.distanceToSqr(entity) > Math.pow(range.getValue(), 2))
 			return;
 		
 		// attack entity
-		MC.interactionManager.attackEntity(MC.player, entity);
-		swingHand.swing(Hand.MAIN_HAND);
+		MC.gameMode.attack(MC.player, entity);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		speed.resetTimer();
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		PathCmd pathCmd = WURST.getCmds().pathCmd;
 		pathFinder.renderPath(matrixStack, pathCmd.isDebugMode(),
@@ -231,7 +229,7 @@ public final class FightBotHack extends Hack
 		
 		public EntityPathFinder(Entity entity)
 		{
-			super(BlockPos.ofFloored(entity.getEntityPos()));
+			super(BlockPos.containing(entity.position()));
 			this.entity = entity;
 			setThinkTime(1);
 		}
@@ -239,9 +237,8 @@ public final class FightBotHack extends Hack
 		@Override
 		protected boolean checkDone()
 		{
-			return done =
-				entity.squaredDistanceTo(Vec3d.ofCenter(current)) <= Math
-					.pow(distance.getValue(), 2);
+			return done = entity.distanceToSqr(Vec3.atCenterOf(current)) <= Math
+				.pow(distance.getValue(), 2);
 		}
 		
 		@Override
diff --git a/src/main/java/net/wurstclient/hacks/FishHack.java b/src/main/java/net/wurstclient/hacks/FishHack.java
index e6bbf2c07..f2d29ddaa 100644
--- a/src/main/java/net/wurstclient/hacks/FishHack.java
+++ b/src/main/java/net/wurstclient/hacks/FishHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -39,11 +39,11 @@ public final class FishHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		if(!player.isTouchingWater() || player.isSneaking())
+		LocalPlayer player = MC.player;
+		if(!player.isInWater() || player.isShiftKeyDown())
 			return;
 		
-		Vec3d velocity = player.getVelocity();
-		player.setVelocity(velocity.x, velocity.y + 0.005, velocity.z);
+		Vec3 velocity = player.getDeltaMovement();
+		player.setDeltaMovement(velocity.x, velocity.y + 0.005, velocity.z);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/FlightHack.java b/src/main/java/net/wurstclient/hacks/FlightHack.java
index ee521bb98..7da9a2c1d 100644
--- a/src/main/java/net/wurstclient/hacks/FlightHack.java
+++ b/src/main/java/net/wurstclient/hacks/FlightHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.AirStrafingSpeedListener;
@@ -91,19 +91,19 @@ public final class FlightHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		player.getAbilities().flying = false;
 		
-		player.setVelocity(0, 0, 0);
-		Vec3d velocity = player.getVelocity();
+		player.setDeltaMovement(0, 0, 0);
+		Vec3 velocity = player.getDeltaMovement();
 		
-		if(MC.options.jumpKey.isPressed())
-			player.setVelocity(velocity.x, verticalSpeed.getValue(),
+		if(MC.options.keyJump.isDown())
+			player.setDeltaMovement(velocity.x, verticalSpeed.getValue(),
 				velocity.z);
 		
-		if(MC.options.sneakKey.isPressed())
-			player.setVelocity(velocity.x, -verticalSpeed.getValue(),
+		if(MC.options.keyShift.isDown())
+			player.setDeltaMovement(velocity.x, -verticalSpeed.getValue(),
 				velocity.z);
 		
 		if(antiKick.isChecked())
@@ -115,13 +115,13 @@ public final class FlightHack extends Hack
 	{
 		float speed = horizontalSpeed.getValueF();
 		
-		if(MC.options.sneakKey.isPressed() && slowSneaking.isChecked())
+		if(MC.options.keyShift.isDown() && slowSneaking.isChecked())
 			speed = Math.min(speed, 0.85F);
 		
 		event.setSpeed(speed);
 	}
 	
-	private void doAntiKick(Vec3d velocity)
+	private void doAntiKick(Vec3 velocity)
 	{
 		if(tickCounter > antiKickInterval.getValueI() + 1)
 			tickCounter = 0;
@@ -130,14 +130,14 @@ public final class FlightHack extends Hack
 		{
 			case 0 ->
 			{
-				if(MC.options.sneakKey.isPressed())
+				if(MC.options.keyShift.isDown())
 					tickCounter = 2;
 				else
-					MC.player.setVelocity(velocity.x,
+					MC.player.setDeltaMovement(velocity.x,
 						-antiKickDistance.getValue(), velocity.z);
 			}
 			
-			case 1 -> MC.player.setVelocity(velocity.x,
+			case 1 -> MC.player.setDeltaMovement(velocity.x,
 				antiKickDistance.getValue(), velocity.z);
 		}
 		
diff --git a/src/main/java/net/wurstclient/hacks/FollowHack.java b/src/main/java/net/wurstclient/hacks/FollowHack.java
index 80e71577a..183df8d7a 100644
--- a/src/main/java/net/wurstclient/hacks/FollowHack.java
+++ b/src/main/java/net/wurstclient/hacks/FollowHack.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.vehicle.AbstractMinecartEntity;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.vehicle.AbstractMinecart;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.ai.PathFinder;
 import net.wurstclient.ai.PathPos;
@@ -81,20 +80,20 @@ public final class FollowHack extends Hack
 		
 		if(entity == null)
 		{
-			Stream<Entity> stream =
-				StreamSupport.stream(MC.world.getEntities().spliterator(), true)
-					.filter(e -> !e.isRemoved())
-					.filter(e -> e instanceof LivingEntity
-						&& ((LivingEntity)e).getHealth() > 0
-						|| e instanceof AbstractMinecartEntity)
-					.filter(e -> e != MC.player)
-					.filter(e -> !(e instanceof FakePlayerEntity));
+			Stream<Entity> stream = StreamSupport
+				.stream(MC.level.entitiesForRendering().spliterator(), true)
+				.filter(e -> !e.isRemoved())
+				.filter(e -> e instanceof LivingEntity
+					&& ((LivingEntity)e).getHealth() > 0
+					|| e instanceof AbstractMinecart)
+				.filter(e -> e != MC.player)
+				.filter(e -> !(e instanceof FakePlayerEntity));
 			
 			stream = entityFilters.applyTo(stream);
 			
 			entity = stream
-				.min(Comparator
-					.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+				.min(
+					Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 				.orElse(null);
 			
 			if(entity == null)
@@ -146,7 +145,7 @@ public final class FollowHack extends Hack
 			&& ((LivingEntity)entity).getHealth() <= 0)
 		{
 			entity = StreamSupport
-				.stream(MC.world.getEntities().spliterator(), true)
+				.stream(MC.level.entitiesForRendering().spliterator(), true)
 				.filter(LivingEntity.class::isInstance)
 				.filter(
 					e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
@@ -154,8 +153,8 @@ public final class FollowHack extends Hack
 				.filter(e -> !(e instanceof FakePlayerEntity))
 				.filter(e -> entity.getName().getString()
 					.equalsIgnoreCase(e.getName().getString()))
-				.min(Comparator
-					.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+				.min(
+					Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 				.orElse(null);
 			
 			if(entity == null)
@@ -202,43 +201,43 @@ public final class FollowHack extends Hack
 		}else
 		{
 			// jump if necessary
-			if(MC.player.horizontalCollision && MC.player.isOnGround())
-				MC.player.jump();
+			if(MC.player.horizontalCollision && MC.player.onGround())
+				MC.player.jumpFromGround();
 			
 			// swim up if necessary
-			if(MC.player.isTouchingWater() && MC.player.getY() < entity.getY())
-				MC.player.setVelocity(MC.player.getVelocity().add(0, 0.04, 0));
+			if(MC.player.isInWater() && MC.player.getY() < entity.getY())
+				MC.player.setDeltaMovement(
+					MC.player.getDeltaMovement().add(0, 0.04, 0));
 			
 			// control height if flying
-			if(!MC.player.isOnGround()
+			if(!MC.player.onGround()
 				&& (MC.player.getAbilities().flying
 					|| WURST.getHax().flightHack.isEnabled())
-				&& MC.player.squaredDistanceTo(entity.getX(), MC.player.getY(),
-					entity.getZ()) <= MC.player.squaredDistanceTo(
-						MC.player.getX(), entity.getY(), MC.player.getZ()))
+				&& MC.player.distanceToSqr(entity.getX(), MC.player.getY(),
+					entity.getZ()) <= MC.player.distanceToSqr(MC.player.getX(),
+						entity.getY(), MC.player.getZ()))
 			{
 				if(MC.player.getY() > entity.getY() + 1D)
-					MC.options.sneakKey.setPressed(true);
+					MC.options.keyShift.setDown(true);
 				else if(MC.player.getY() < entity.getY() - 1D)
-					MC.options.jumpKey.setPressed(true);
+					MC.options.keyJump.setDown(true);
 			}else
 			{
-				MC.options.sneakKey.setPressed(false);
-				MC.options.jumpKey.setPressed(false);
+				MC.options.keyShift.setDown(false);
+				MC.options.keyJump.setDown(false);
 			}
 			
 			// follow entity
 			WURST.getRotationFaker()
 				.faceVectorClient(entity.getBoundingBox().getCenter());
 			double distanceSq = Math.pow(distance.getValue(), 2);
-			MC.options.forwardKey
-				.setPressed(MC.player.squaredDistanceTo(entity.getX(),
-					MC.player.getY(), entity.getZ()) > distanceSq);
+			MC.options.keyUp.setDown(MC.player.distanceToSqr(entity.getX(),
+				MC.player.getY(), entity.getZ()) > distanceSq);
 		}
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		PathCmd pathCmd = WURST.getCmds().pathCmd;
 		pathFinder.renderPath(matrixStack, pathCmd.isDebugMode(),
@@ -254,16 +253,16 @@ public final class FollowHack extends Hack
 	{
 		public EntityPathFinder()
 		{
-			super(BlockPos.ofFloored(entity.getEntityPos()));
+			super(BlockPos.containing(entity.position()));
 			setThinkTime(1);
 		}
 		
 		@Override
 		protected boolean checkDone()
 		{
-			Vec3d center = Vec3d.ofCenter(current);
+			Vec3 center = Vec3.atCenterOf(current);
 			double distanceSq = Math.pow(distance.getValue(), 2);
-			return done = entity.squaredDistanceTo(center) <= distanceSq;
+			return done = entity.distanceToSqr(center) <= distanceSq;
 		}
 		
 		@Override
diff --git a/src/main/java/net/wurstclient/hacks/ForceOpHack.java b/src/main/java/net/wurstclient/hacks/ForceOpHack.java
index 33bd98560..767a7d37a 100644
--- a/src/main/java/net/wurstclient/hacks/ForceOpHack.java
+++ b/src/main/java/net/wurstclient/hacks/ForceOpHack.java
@@ -61,7 +61,7 @@ public final class ForceOpHack extends Hack implements ChatInputListener
 		try
 		{
 			process = MultiProcessingUtils.startProcessWithIO(
-				ForceOpDialog.class, MC.getSession().getUsername());
+				ForceOpDialog.class, MC.getUser().getName());
 			
 			new Thread(this::handleDialogOutput, "ForceOP dialog output")
 				.start();
@@ -172,8 +172,7 @@ public final class ForceOpHack extends Hack implements ChatInputListener
 			return;
 		}
 		
-		MC.getNetworkHandler()
-			.sendChatCommand("login " + MC.getSession().getUsername());
+		MC.getConnection().sendCommand("login " + MC.getUser().getName());
 		lastPW = 0;
 		sendIndexToDialog();
 		
@@ -203,8 +202,7 @@ public final class ForceOpHack extends Hack implements ChatInputListener
 			while(!sent)
 				try
 				{
-					MC.getNetworkHandler()
-						.sendChatCommand("login " + passwords[i]);
+					MC.getConnection().sendCommand("login " + passwords[i]);
 					sent = true;
 					
 				}catch(Exception e)
@@ -267,7 +265,7 @@ public final class ForceOpHack extends Hack implements ChatInputListener
 			
 			String password;
 			if(lastPW == 0)
-				password = MC.getSession().getUsername();
+				password = MC.getUser().getName();
 			else
 				password = passwords[lastPW - 1];
 			
diff --git a/src/main/java/net/wurstclient/hacks/FreecamHack.java b/src/main/java/net/wurstclient/hacks/FreecamHack.java
index 2c340c9f8..a479bc1d2 100644
--- a/src/main/java/net/wurstclient/hacks/FreecamHack.java
+++ b/src/main/java/net/wurstclient/hacks/FreecamHack.java
@@ -7,15 +7,14 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.option.GameOptions;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.Options;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.*;
@@ -71,11 +70,11 @@ public final class FreecamHack extends Hack implements UpdateListener,
 		
 		fakePlayer = new FakePlayerEntity();
 		
-		GameOptions opt = MC.options;
-		KeyBinding[] bindings = {opt.forwardKey, opt.backKey, opt.leftKey,
-			opt.rightKey, opt.jumpKey, opt.sneakKey};
+		Options opt = MC.options;
+		KeyMapping[] bindings = {opt.keyUp, opt.keyDown, opt.keyLeft,
+			opt.keyRight, opt.keyJump, opt.keyShift};
 		
-		for(KeyBinding binding : bindings)
+		for(KeyMapping binding : bindings)
 			IKeyBinding.get(binding).resetPressedState();
 	}
 	
@@ -95,27 +94,27 @@ public final class FreecamHack extends Hack implements UpdateListener,
 		fakePlayer.resetPlayerPosition();
 		fakePlayer.despawn();
 		
-		ClientPlayerEntity player = MC.player;
-		player.setVelocity(Vec3d.ZERO);
+		LocalPlayer player = MC.player;
+		player.setDeltaMovement(Vec3.ZERO);
 		
-		MC.worldRenderer.reload();
+		MC.levelRenderer.allChanged();
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		player.setVelocity(Vec3d.ZERO);
+		LocalPlayer player = MC.player;
+		player.setDeltaMovement(Vec3.ZERO);
 		player.getAbilities().flying = false;
 		
 		player.setOnGround(false);
-		Vec3d velocity = player.getVelocity();
+		Vec3 velocity = player.getDeltaMovement();
 		
-		if(MC.options.jumpKey.isPressed())
-			player.setVelocity(velocity.add(0, speed.getValue(), 0));
+		if(MC.options.keyJump.isDown())
+			player.setDeltaMovement(velocity.add(0, speed.getValue(), 0));
 		
-		if(MC.options.sneakKey.isPressed())
-			player.setVelocity(velocity.subtract(0, speed.getValue(), 0));
+		if(MC.options.keyShift.isDown())
+			player.setDeltaMovement(velocity.subtract(0, speed.getValue(), 0));
 	}
 	
 	@Override
@@ -127,7 +126,7 @@ public final class FreecamHack extends Hack implements UpdateListener,
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(event.getPacket() instanceof PlayerMoveC2SPacket)
+		if(event.getPacket() instanceof ServerboundMovePlayerPacket)
 			event.cancel();
 	}
 	
@@ -164,7 +163,7 @@ public final class FreecamHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(fakePlayer == null || !tracer.isChecked())
 			return;
@@ -173,8 +172,8 @@ public final class FreecamHack extends Hack implements UpdateListener,
 		
 		// box
 		double extraSize = 0.05;
-		Box box = fakePlayer.getBoundingBox().offset(0, extraSize, 0)
-			.expand(extraSize);
+		AABB box = fakePlayer.getBoundingBox().move(0, extraSize, 0)
+			.inflate(extraSize);
 		RenderUtils.drawOutlinedBox(matrixStack, box, colorI, false);
 		
 		// line
diff --git a/src/main/java/net/wurstclient/hacks/FullbrightHack.java b/src/main/java/net/wurstclient/hacks/FullbrightHack.java
index 4f7529d5c..f829012b6 100644
--- a/src/main/java/net/wurstclient/hacks/FullbrightHack.java
+++ b/src/main/java/net/wurstclient/hacks/FullbrightHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.option.SimpleOption;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.OptionInstance;
+import net.minecraft.util.Mth;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -59,7 +59,7 @@ public final class FullbrightHack extends Hack implements UpdateListener
 			@Override
 			public void onUpdate()
 			{
-				double gamma = MC.options.getGamma().getValue();
+				double gamma = MC.options.gamma().get();
 				System.out.println("Brightness started at " + gamma);
 				
 				if(gamma > 1)
@@ -95,9 +95,9 @@ public final class FullbrightHack extends Hack implements UpdateListener
 	{
 		wasGammaChanged = true;
 		
-		SimpleOption<Double> gammaOption = MC.options.getGamma();
+		OptionInstance<Double> gammaOption = MC.options.gamma();
 		ISimpleOption<Double> gammaOption2 = ISimpleOption.get(gammaOption);
-		double oldGammaValue = gammaOption.getValue();
+		double oldGammaValue = gammaOption.get();
 		
 		if(!fade.isChecked() || Math.abs(oldGammaValue - target) <= 0.5)
 		{
@@ -113,9 +113,9 @@ public final class FullbrightHack extends Hack implements UpdateListener
 	
 	private void resetGamma(double target)
 	{
-		SimpleOption<Double> gammaOption = MC.options.getGamma();
+		OptionInstance<Double> gammaOption = MC.options.gamma();
 		ISimpleOption<Double> gammaOption2 = ISimpleOption.get(gammaOption);
-		double oldGammaValue = gammaOption.getValue();
+		double oldGammaValue = gammaOption.get();
 		
 		if(!fade.isChecked() || Math.abs(oldGammaValue - target) <= 0.5)
 		{
@@ -142,7 +142,7 @@ public final class FullbrightHack extends Hack implements UpdateListener
 			else
 				nightVisionStrength -= 0.03125;
 			
-			nightVisionStrength = MathHelper.clamp(nightVisionStrength, 0, 1);
+			nightVisionStrength = Mth.clamp(nightVisionStrength, 0, 1);
 			
 		}else if(shouldGiveNightVision)
 			nightVisionStrength = 1;
diff --git a/src/main/java/net/wurstclient/hacks/GlideHack.java b/src/main/java/net/wurstclient/hacks/GlideHack.java
index ed8469f7a..e418ef178 100644
--- a/src/main/java/net/wurstclient/hacks/GlideHack.java
+++ b/src/main/java/net/wurstclient/hacks/GlideHack.java
@@ -9,12 +9,11 @@ package net.wurstclient.hacks;
 
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.block.FluidBlock;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.LiquidBlock;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.AirStrafingSpeedListener;
 import net.wurstclient.events.UpdateListener;
@@ -54,11 +53,11 @@ public final class GlideHack extends Hack
 	@Override
 	public String getRenderName()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(player == null)
 			return getName();
 		
-		if(pauseOnSneak.isChecked() && player.isSneaking())
+		if(pauseOnSneak.isChecked() && player.isShiftKeyDown())
 			return getName() + " (paused)";
 		
 		return getName();
@@ -81,36 +80,36 @@ public final class GlideHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		if(pauseOnSneak.isChecked() && player.isSneaking())
+		if(pauseOnSneak.isChecked() && player.isShiftKeyDown())
 			return;
 		
-		Vec3d v = player.getVelocity();
+		Vec3 v = player.getDeltaMovement();
 		
-		if(player.isOnGround() || player.isTouchingWater() || player.isInLava()
-			|| player.isClimbing() || v.y >= 0)
+		if(player.onGround() || player.isInWater() || player.isInLava()
+			|| player.onClimbable() || v.y >= 0)
 			return;
 		
 		if(minHeight.getValue() > 0)
 		{
-			Box box = player.getBoundingBox();
-			box = box.union(box.offset(0, -minHeight.getValue(), 0));
-			if(!MC.world.isSpaceEmpty(box))
+			AABB box = player.getBoundingBox();
+			box = box.minmax(box.move(0, -minHeight.getValue(), 0));
+			if(!MC.level.noCollision(box))
 				return;
 			
-			BlockPos min = BlockPos.ofFloored(box.minX, box.minY, box.minZ);
-			BlockPos max = BlockPos.ofFloored(box.maxX, box.maxY, box.maxZ);
+			BlockPos min = BlockPos.containing(box.minX, box.minY, box.minZ);
+			BlockPos max = BlockPos.containing(box.maxX, box.maxY, box.maxZ);
 			Stream<BlockPos> stream = StreamSupport
 				.stream(BlockUtils.getAllInBox(min, max).spliterator(), true);
 			
 			// manual collision check, since liquids don't have bounding boxes
 			if(stream.map(BlockUtils::getBlock)
-				.anyMatch(FluidBlock.class::isInstance))
+				.anyMatch(LiquidBlock.class::isInstance))
 				return;
 		}
 		
-		player.setVelocity(v.x, Math.max(v.y, -fallSpeed.getValue()), v.z);
+		player.setDeltaMovement(v.x, Math.max(v.y, -fallSpeed.getValue()), v.z);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/HandNoClipHack.java b/src/main/java/net/wurstclient/hacks/HandNoClipHack.java
index 78dafe20b..af8c1b675 100644
--- a/src/main/java/net/wurstclient/hacks/HandNoClipHack.java
+++ b/src/main/java/net/wurstclient/hacks/HandNoClipHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
diff --git a/src/main/java/net/wurstclient/hacks/HeadRollHack.java b/src/main/java/net/wurstclient/hacks/HeadRollHack.java
index 7c456b02a..9813c2bf9 100644
--- a/src/main/java/net/wurstclient/hacks/HeadRollHack.java
+++ b/src/main/java/net/wurstclient/hacks/HeadRollHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -42,9 +42,9 @@ public final class HeadRollHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		float timer = MC.player.age % 20 / 10F;
-		float pitch = MathHelper.sin(timer * (float)Math.PI) * 90F;
+		float timer = MC.player.tickCount % 20 / 10F;
+		float pitch = Mth.sin(timer * (float)Math.PI) * 90F;
 		
-		new Rotation(MC.player.getYaw(), pitch).sendPlayerLookPacket();
+		new Rotation(MC.player.getYRot(), pitch).sendPlayerLookPacket();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/HealthTagsHack.java b/src/main/java/net/wurstclient/hacks/HealthTagsHack.java
index e8a934897..aa24b4b6e 100644
--- a/src/main/java/net/wurstclient/hacks/HealthTagsHack.java
+++ b/src/main/java/net/wurstclient/hacks/HealthTagsHack.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.Text;
-import net.minecraft.util.Formatting;
+import net.minecraft.ChatFormatting;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -24,30 +24,30 @@ public final class HealthTagsHack extends Hack
 		setCategory(Category.RENDER);
 	}
 	
-	public Text addHealth(LivingEntity entity, MutableText nametag)
+	public Component addHealth(LivingEntity entity, MutableComponent nametag)
 	{
 		if(!isEnabled())
 			return nametag;
 		
 		int health = (int)entity.getHealth();
 		
-		MutableText formattedHealth = Text.literal(" ")
-			.append(Integer.toString(health)).formatted(getColor(health));
+		MutableComponent formattedHealth = Component.literal(" ")
+			.append(Integer.toString(health)).withStyle(getColor(health));
 		return nametag.append(formattedHealth);
 	}
 	
-	private Formatting getColor(int health)
+	private ChatFormatting getColor(int health)
 	{
 		if(health <= 5)
-			return Formatting.DARK_RED;
+			return ChatFormatting.DARK_RED;
 		
 		if(health <= 10)
-			return Formatting.GOLD;
+			return ChatFormatting.GOLD;
 		
 		if(health <= 15)
-			return Formatting.YELLOW;
+			return ChatFormatting.YELLOW;
 		
-		return Formatting.GREEN;
+		return ChatFormatting.GREEN;
 	}
 	
 	// See EntityRendererMixin
diff --git a/src/main/java/net/wurstclient/hacks/InstaBuildHack.java b/src/main/java/net/wurstclient/hacks/InstaBuildHack.java
index 906e3296a..cd71c047c 100644
--- a/src/main/java/net/wurstclient/hacks/InstaBuildHack.java
+++ b/src/main/java/net/wurstclient/hacks/InstaBuildHack.java
@@ -11,15 +11,14 @@ import java.io.IOException;
 import java.nio.file.Path;
 import java.util.LinkedHashMap;
 import java.util.Map;
-
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.events.RightClickListener;
 import net.wurstclient.events.UpdateListener;
@@ -125,7 +124,7 @@ public final class InstaBuildHack extends Hack
 		if(status != Status.IDLE)
 			return;
 		
-		HitResult hitResult = MC.crosshairTarget;
+		HitResult hitResult = MC.hitResult;
 		if(hitResult == null || hitResult.getType() != HitResult.Type.BLOCK
 			|| !(hitResult instanceof BlockHitResult blockHitResult))
 			return;
@@ -134,8 +133,9 @@ public final class InstaBuildHack extends Hack
 		if(!BlockUtils.canBeClicked(hitResultPos))
 			return;
 		
-		BlockPos startPos = hitResultPos.offset(blockHitResult.getSide());
-		Direction direction = MC.player.getHorizontalFacing();
+		BlockPos startPos =
+			hitResultPos.relative(blockHitResult.getDirection());
+		Direction direction = MC.player.getDirection();
 		remainingBlocks = template.getBlocksToPlace(startPos, direction);
 		
 		buildInstantly();
@@ -163,7 +163,7 @@ public final class InstaBuildHack extends Hack
 	
 	private void buildInstantly()
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		int oldSlot = inventory.getSelectedSlot();
 		
 		for(Map.Entry<BlockPos, Item> entry : remainingBlocks.entrySet())
@@ -171,7 +171,7 @@ public final class InstaBuildHack extends Hack
 			BlockPos pos = entry.getKey();
 			Item item = entry.getValue();
 			
-			if(!BlockUtils.getState(pos).isReplaceable())
+			if(!BlockUtils.getState(pos).canBeReplaced())
 				continue;
 			
 			BlockPlacingParams params = BlockPlacer.getBlockPlacingParams(pos);
@@ -179,7 +179,7 @@ public final class InstaBuildHack extends Hack
 				continue;
 			
 			if(useSavedBlocks.isChecked() && item != Items.AIR
-				&& !MC.player.getMainHandStack().isOf(item))
+				&& !MC.player.getMainHandItem().is(item))
 				giveOrSelectItem(item);
 			
 			InteractionSimulator.rightClickBlock(params.toHitResult(),
@@ -195,12 +195,12 @@ public final class InstaBuildHack extends Hack
 		if(InventoryUtils.selectItem(item, 9))
 			return;
 		
-		if(!MC.player.isInCreativeMode())
+		if(!MC.player.hasInfiniteMaterials())
 			return;
 		
-		PlayerInventory inventory = MC.player.getInventory();
-		int slot = inventory.getEmptySlot();
-		if(!PlayerInventory.isValidHotbarIndex(slot))
+		Inventory inventory = MC.player.getInventory();
+		int slot = inventory.getFreeSlot();
+		if(!Inventory.isHotbarSlot(slot))
 			slot = inventory.getSelectedSlot();
 		
 		ItemStack stack = new ItemStack(item);
diff --git a/src/main/java/net/wurstclient/hacks/InstantBunkerHack.java b/src/main/java/net/wurstclient/hacks/InstantBunkerHack.java
index caa8fe263..c0425f88e 100644
--- a/src/main/java/net/wurstclient/hacks/InstantBunkerHack.java
+++ b/src/main/java/net/wurstclient/hacks/InstantBunkerHack.java
@@ -8,16 +8,15 @@
 package net.wurstclient.hacks;
 
 import java.util.ArrayList;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.item.BlockItem;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.shape.VoxelShape;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -55,14 +54,14 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 	{
 		WURST.getHax().tunnellerHack.setEnabled(false);
 		
-		if(!MC.player.isOnGround())
+		if(!MC.player.onGround())
 		{
 			ChatUtils.error("Can't build this in mid-air.");
 			setEnabled(false);
 			return;
 		}
 		
-		ItemStack stack = MC.player.getInventory().getSelectedStack();
+		ItemStack stack = MC.player.getInventory().getSelectedItem();
 		
 		if(!(stack.getItem() instanceof BlockItem))
 		{
@@ -71,22 +70,22 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 			return;
 		}
 		
-		if(stack.getCount() < 57 && !MC.player.getAbilities().creativeMode)
+		if(stack.getCount() < 57 && !MC.player.getAbilities().instabuild)
 			ChatUtils.warning("Not enough blocks. Bunker may be incomplete.");
 		
 		// get start pos and facings
-		BlockPos startPos = BlockPos.ofFloored(MC.player.getEntityPos());
-		Direction facing = MC.player.getHorizontalFacing();
-		Direction facing2 = facing.rotateYCounterclockwise();
+		BlockPos startPos = BlockPos.containing(MC.player.position());
+		Direction facing = MC.player.getDirection();
+		Direction facing2 = facing.getCounterClockWise();
 		
 		// set positions
 		positions.clear();
 		for(int[] pos : template)
-			positions.add(startPos.up(pos[1]).offset(facing, pos[2])
-				.offset(facing2, pos[0]));
+			positions.add(startPos.above(pos[1]).relative(facing, pos[2])
+				.relative(facing2, pos[0]));
 		
 		startTimer = 2;
-		MC.player.jump();
+		MC.player.jumpFromGround();
 		
 		EVENTS.add(UpdateListener.class, this);
 	}
@@ -110,12 +109,12 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 		if(startTimer <= 0)
 		{
 			for(BlockPos pos : positions)
-				if(BlockUtils.getState(pos).isReplaceable()
-					&& !MC.player.getBoundingBox().intersects(new Box(pos)))
+				if(BlockUtils.getState(pos).canBeReplaced()
+					&& !MC.player.getBoundingBox().intersects(new AABB(pos)))
 					placeBlockSimple(pos);
-			MC.player.swingHand(Hand.MAIN_HAND);
+			MC.player.swing(InteractionHand.MAIN_HAND);
 			
-			if(MC.player.isOnGround())
+			if(MC.player.onGround())
 				setEnabled(false);
 		}
 	}
@@ -125,28 +124,28 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 		Direction side = null;
 		Direction[] sides = Direction.values();
 		
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		Vec3d posVec = Vec3d.ofCenter(pos);
-		double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		Vec3 posVec = Vec3.atCenterOf(pos);
+		double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 		
-		Vec3d[] hitVecs = new Vec3d[sides.length];
+		Vec3[] hitVecs = new Vec3[sides.length];
 		for(int i = 0; i < sides.length; i++)
-			hitVecs[i] =
-				posVec.add(Vec3d.of(sides[i].getVector()).multiply(0.5));
+			hitVecs[i] = posVec
+				.add(Vec3.atLowerCornerOf(sides[i].getUnitVec3i()).scale(0.5));
 		
 		for(int i = 0; i < sides.length; i++)
 		{
 			// check if neighbor can be right clicked
-			BlockPos neighbor = pos.offset(sides[i]);
+			BlockPos neighbor = pos.relative(sides[i]);
 			if(!BlockUtils.canBeClicked(neighbor))
 				continue;
 			
 			// check line of sight
 			BlockState neighborState = BlockUtils.getState(neighbor);
 			VoxelShape neighborShape =
-				neighborState.getOutlineShape(MC.world, neighbor);
-			if(MC.world.raycastBlock(eyesPos, hitVecs[i], neighbor,
-				neighborShape, neighborState) != null)
+				neighborState.getShape(MC.level, neighbor);
+			if(MC.level.clipWithInteractionOverride(eyesPos, hitVecs[i],
+				neighbor, neighborShape, neighborState) != null)
 				continue;
 			
 			side = sides[i];
@@ -157,11 +156,11 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 			for(int i = 0; i < sides.length; i++)
 			{
 				// check if neighbor can be right clicked
-				if(!BlockUtils.canBeClicked(pos.offset(sides[i])))
+				if(!BlockUtils.canBeClicked(pos.relative(sides[i])))
 					continue;
 				
 				// check if side is facing away from player
-				if(distanceSqPosVec > eyesPos.squaredDistanceTo(hitVecs[i]))
+				if(distanceSqPosVec > eyesPos.distanceToSqr(hitVecs[i]))
 					continue;
 				
 				side = sides[i];
@@ -171,7 +170,7 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 		if(side == null)
 			return;
 		
-		Vec3d hitVec = hitVecs[side.ordinal()];
+		Vec3 hitVec = hitVecs[side.ordinal()];
 		
 		// face block
 		// WURST.getRotationFaker().faceVectorPacket(hitVec);
@@ -183,13 +182,13 @@ public final class InstantBunkerHack extends Hack implements UpdateListener
 		// return;
 		
 		// place block
-		IMC.getInteractionManager().rightClickBlock(pos.offset(side),
+		IMC.getInteractionManager().rightClickBlock(pos.relative(side),
 			side.getOpposite(), hitVec);
 		
 		// swing arm
-		SwingHand.SERVER.swing(Hand.MAIN_HAND);
+		SwingHand.SERVER.swing(InteractionHand.MAIN_HAND);
 		
 		// reset timer
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/InvWalkHack.java b/src/main/java/net/wurstclient/hacks/InvWalkHack.java
index 469c5c1d5..3adf226b4 100644
--- a/src/main/java/net/wurstclient/hacks/InvWalkHack.java
+++ b/src/main/java/net/wurstclient/hacks/InvWalkHack.java
@@ -9,14 +9,13 @@ package net.wurstclient.hacks;
 
 import java.util.ArrayList;
 import java.util.Arrays;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.item.ItemGroups;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.CreativeModeInventoryScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.world.item.CreativeModeTabs;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.clickgui.screens.ClickGuiScreen;
@@ -72,41 +71,41 @@ public final class InvWalkHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		Screen screen = MC.currentScreen;
+		Screen screen = MC.screen;
 		if(screen == null)
 			return;
 		
 		if(!isAllowedScreen(screen))
 			return;
 		
-		ArrayList<KeyBinding> keys =
-			new ArrayList<>(Arrays.asList(MC.options.forwardKey,
-				MC.options.backKey, MC.options.leftKey, MC.options.rightKey));
+		ArrayList<KeyMapping> keys =
+			new ArrayList<>(Arrays.asList(MC.options.keyUp, MC.options.keyDown,
+				MC.options.keyLeft, MC.options.keyRight));
 		
 		if(allowSneak.isChecked())
-			keys.add(MC.options.sneakKey);
+			keys.add(MC.options.keyShift);
 		
 		if(allowSprint.isChecked())
-			keys.add(MC.options.sprintKey);
+			keys.add(MC.options.keySprint);
 		
 		if(allowJump.isChecked())
-			keys.add(MC.options.jumpKey);
+			keys.add(MC.options.keyJump);
 		
-		for(KeyBinding key : keys)
+		for(KeyMapping key : keys)
 			IKeyBinding.get(key).resetPressedState();
 	}
 	
 	private boolean isAllowedScreen(Screen screen)
 	{
 		if((screen instanceof InventoryScreen
-			|| screen instanceof CreativeInventoryScreen)
+			|| screen instanceof CreativeModeInventoryScreen)
 			&& !isCreativeSearchBarOpen(screen))
 			return true;
 		
 		if(allowClickGUI.isChecked() && screen instanceof ClickGuiScreen)
 			return true;
 		
-		if(allowOther.isChecked() && screen instanceof HandledScreen
+		if(allowOther.isChecked() && screen instanceof AbstractContainerScreen
 			&& !hasTextBox(screen))
 			return true;
 		
@@ -115,16 +114,15 @@ public final class InvWalkHack extends Hack implements UpdateListener
 	
 	private boolean isCreativeSearchBarOpen(Screen screen)
 	{
-		if(!(screen instanceof CreativeInventoryScreen))
+		if(!(screen instanceof CreativeModeInventoryScreen))
 			return false;
 		
-		return CreativeInventoryScreen.selectedTab == ItemGroups
-			.getSearchGroup();
+		return CreativeModeInventoryScreen.selectedTab == CreativeModeTabs
+			.searchTab();
 	}
 	
 	private boolean hasTextBox(Screen screen)
 	{
-		return screen.children().stream()
-			.anyMatch(TextFieldWidget.class::isInstance);
+		return screen.children().stream().anyMatch(EditBox.class::isInstance);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/ItemEspHack.java b/src/main/java/net/wurstclient/hacks/ItemEspHack.java
index 3c44eb8c4..a101e9615 100644
--- a/src/main/java/net/wurstclient/hacks/ItemEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/ItemEspHack.java
@@ -7,28 +7,27 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Locale;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.ItemEntity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.decoration.ArmorStandEntity;
-import net.minecraft.entity.decoration.ItemFrameEntity;
-import net.minecraft.entity.passive.VillagerEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Arm;
-import net.minecraft.util.Hand;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.HumanoidArm;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.decoration.ArmorStand;
+import net.minecraft.world.entity.decoration.ItemFrame;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -203,7 +202,7 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 	public void onUpdate()
 	{
 		items.clear();
-		for(Entity entity : MC.world.getEntities())
+		for(Entity entity : MC.level.entitiesForRendering())
 			if(entity instanceof ItemEntity)
 				items.add((ItemEntity)entity);
 		// update count for HUD (clamped to 999)
@@ -219,7 +218,7 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		int baseLines = color.getColorI(0x80);
 		int baseQuads = color.getColorI(0x40);
@@ -242,8 +241,8 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 					String raw = s.trim();
 					if(raw.isEmpty())
 						continue;
-					Identifier id = Identifier.tryParse(raw);
-					if(id != null && Registries.ITEM.containsId(id))
+					ResourceLocation id = ResourceLocation.tryParse(raw);
+					if(id != null && BuiltInRegistries.ITEM.containsKey(id))
 						exact.add(id.toString());
 					else
 						kw.add(raw.toLowerCase(Locale.ROOT));
@@ -268,8 +267,8 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 					String raw = s.trim();
 					if(raw.isEmpty())
 						continue;
-					Identifier id = Identifier.tryParse(raw);
-					if(id != null && Registries.ITEM.containsId(id))
+					ResourceLocation id = ResourceLocation.tryParse(raw);
+					if(id != null && BuiltInRegistries.ITEM.containsKey(id))
 						exact.add(id.toString());
 				}
 				ignoredExactIds = exact;
@@ -281,10 +280,10 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 		}
 		
 		// Partition items into normal vs special
-		ArrayList<Box> normalBoxes = new ArrayList<>();
-		ArrayList<Box> specialBoxes = new ArrayList<>();
-		ArrayList<Vec3d> normalEnds = new ArrayList<>();
-		ArrayList<Vec3d> specialEnds = new ArrayList<>();
+		ArrayList<AABB> normalBoxes = new ArrayList<>();
+		ArrayList<AABB> specialBoxes = new ArrayList<>();
+		ArrayList<Vec3> normalEnds = new ArrayList<>();
+		ArrayList<Vec3> specialEnds = new ArrayList<>();
 		
 		double extraSize = boxSize.getExtraSize() / 2;
 		int visibleDrops = 0;
@@ -293,13 +292,13 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 			if(onlyAboveGround.isChecked()
 				&& e.getY() < aboveGroundY.getValue())
 				continue;
-			ItemStack stack = e.getStack();
+			ItemStack stack = e.getItem();
 			if(stack == null || stack.isEmpty())
 				continue;
 			if(isIgnored(stack))
 				continue;
-			Box box = EntityUtils.getLerpedBox(e, partialTicks)
-				.offset(0, extraSize, 0).expand(extraSize);
+			AABB box = EntityUtils.getLerpedBox(e, partialTicks)
+				.move(0, extraSize, 0).inflate(extraSize);
 			boolean isSpecial = isSpecial(stack);
 			visibleDrops++;
 			if(isSpecial)
@@ -307,8 +306,7 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 			else
 				normalBoxes.add(box);
 			
-			Vec3d center =
-				EntityUtils.getLerpedBox(e, partialTicks).getCenter();
+			Vec3 center = EntityUtils.getLerpedBox(e, partialTicks).getCenter();
 			if(isSpecial)
 				specialEnds.add(center);
 			else
@@ -319,11 +317,11 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 		// Item frames holding special items
 		if(includeItemFrames.isChecked())
 		{
-			for(Entity ent : MC.world.getEntities())
+			for(Entity ent : MC.level.entitiesForRendering())
 			{
-				if(!(ent instanceof ItemFrameEntity frame))
+				if(!(ent instanceof ItemFrame frame))
 					continue;
-				ItemStack fs = frame.getHeldItemStack();
+				ItemStack fs = frame.getItem();
 				if(fs == null || fs.isEmpty())
 					continue;
 				if(isIgnored(fs))
@@ -333,8 +331,8 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 				if(onlyAboveGround.isChecked()
 					&& frame.getY() < aboveGroundY.getValue())
 					continue;
-				Box fbox = EntityUtils.getLerpedBox(frame, partialTicks)
-					.offset(0, extraSize, 0).expand(extraSize);
+				AABB fbox = EntityUtils.getLerpedBox(frame, partialTicks)
+					.move(0, extraSize, 0).inflate(extraSize);
 				specialBoxes.add(fbox);
 				specialEnds.add(fbox.getCenter());
 			}
@@ -343,15 +341,14 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 		// Equipped specials (held or head) on entities
 		if(includeEquippedSpecial.isChecked())
 		{
-			for(Entity ent : MC.world.getEntities())
+			for(Entity ent : MC.level.entitiesForRendering())
 			{
 				if(!(ent instanceof LivingEntity le))
 					continue;
-				if(ignoreArmorStands.isChecked()
-					&& le instanceof ArmorStandEntity)
+				if(ignoreArmorStands.isChecked() && le instanceof ArmorStand)
 					continue;
-				boolean isPlayer = le instanceof PlayerEntity;
-				if(ignoreVillagers.isChecked() && le instanceof VillagerEntity)
+				boolean isPlayer = le instanceof Player;
+				if(ignoreVillagers.isChecked() && le instanceof Villager)
 					continue;
 				if(ignoreOtherPlayers.isChecked() && isPlayer
 					&& le != MC.player)
@@ -359,31 +356,32 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 				if(le == MC.player)
 					continue;
 				// hands
-				ItemStack main = le.getMainHandStack();
+				ItemStack main = le.getMainHandItem();
 				if(main != null && !main.isEmpty() && !isIgnored(main)
 					&& isSpecial(main))
 				{
-					Vec3d pos =
-						getHeldItemPos(le, Hand.MAIN_HAND, partialTicks);
+					Vec3 pos = getHeldItemPos(le, InteractionHand.MAIN_HAND,
+						partialTicks);
 					if(onlyAboveGround.isChecked() && pos != null
 						&& pos.y < aboveGroundY.getValue())
 						continue;
-					Box b = smallBoxAt(pos);
+					AABB b = smallBoxAt(pos);
 					if(b != null)
 					{
 						specialBoxes.add(b);
 						specialEnds.add(b.getCenter());
 					}
 				}
-				ItemStack off = le.getOffHandStack();
+				ItemStack off = le.getOffhandItem();
 				if(off != null && !off.isEmpty() && !isIgnored(off)
 					&& isSpecial(off))
 				{
-					Vec3d pos = getHeldItemPos(le, Hand.OFF_HAND, partialTicks);
+					Vec3 pos = getHeldItemPos(le, InteractionHand.OFF_HAND,
+						partialTicks);
 					if(onlyAboveGround.isChecked() && pos != null
 						&& pos.y < aboveGroundY.getValue())
 						continue;
-					Box b = smallBoxAt(pos);
+					AABB b = smallBoxAt(pos);
 					if(b != null)
 					{
 						specialBoxes.add(b);
@@ -391,17 +389,17 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 					}
 				}
 				// head worn
-				ItemStack head = le.getEquippedStack(EquipmentSlot.HEAD);
+				ItemStack head = le.getItemBySlot(EquipmentSlot.HEAD);
 				if(head != null && !head.isEmpty() && !isIgnored(head)
 					&& isSpecial(head))
 				{
-					Vec3d hp = getHeadPos(le, partialTicks);
+					Vec3 hp = getHeadPos(le, partialTicks);
 					if(hp != null)
 					{
 						if(onlyAboveGround.isChecked()
 							&& hp.y < aboveGroundY.getValue())
 							continue;
-						Box b = smallBoxAt(hp);
+						AABB b = smallBoxAt(hp);
 						specialBoxes.add(b);
 						specialEnds.add(hp);
 					}
@@ -466,7 +464,7 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 			return false;
 		if(ignoredExactIds == null || ignoredExactIds.isEmpty())
 			return false;
-		Identifier id = Registries.ITEM.getId(stack.getItem());
+		ResourceLocation id = BuiltInRegistries.ITEM.getKey(stack.getItem());
 		if(id == null)
 			return false;
 		return ignoredExactIds.contains(id.toString());
@@ -479,15 +477,15 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 		{
 			case LIST:
 			{
-				String id = Registries.ITEM.getId(item).toString();
+				String id = BuiltInRegistries.ITEM.getKey(item).toString();
 				if(specialExactIds != null && specialExactIds.contains(id))
 					return true;
 				String localId =
 					id.contains(":") ? id.substring(id.indexOf(":") + 1) : id;
 				String localSpaced = localId.replace('_', ' ');
-				String transKey = item.getTranslationKey();
+				String transKey = item.getDescriptionId();
 				String display = item.getName().getString();
-				String stackDisplay = stack.getName().getString();
+				String stackDisplay = stack.getHoverName().getString();
 				if(specialKeywords != null)
 					for(String term : specialKeywords)
 						if(containsNormalized(id, term)
@@ -515,8 +513,8 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 			return false;
 		try
 		{
-			Identifier id = Identifier.of(idStr.trim());
-			Item target = Registries.ITEM.get(id);
+			ResourceLocation id = ResourceLocation.parse(idStr.trim());
+			Item target = BuiltInRegistries.ITEM.getValue(id);
 			return target != null && target == item;
 		}catch(IllegalArgumentException e)
 		{
@@ -536,13 +534,14 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 	{
 		if(normalizedQuery.isEmpty())
 			return false;
-		String fullId = Registries.ITEM.getId(item).toString();
+		String fullId = BuiltInRegistries.ITEM.getKey(item).toString();
 		String localId = fullId.contains(":")
 			? fullId.substring(fullId.indexOf(":") + 1) : fullId;
 		String localSpaced = localId.replace('_', ' ');
-		String transKey = item.getTranslationKey();
+		String transKey = item.getDescriptionId();
 		String display = item.getName().getString();
-		String stackDisplay = stack != null ? stack.getName().getString() : "";
+		String stackDisplay =
+			stack != null ? stack.getHoverName().getString() : "";
 		String[] terms = Arrays.stream(normalizedQuery.split(","))
 			.map(String::trim).filter(s -> !s.isEmpty()).toArray(String[]::new);
 		if(terms.length == 0)
@@ -565,17 +564,20 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 	}
 	
 	// Helpers to approximate held/head positions and box creation
-	private Vec3d getHeldItemPos(LivingEntity e, Hand hand, float partialTicks)
+	private Vec3 getHeldItemPos(LivingEntity e, InteractionHand hand,
+		float partialTicks)
 	{
 		if(hand == null)
 			return null;
-		Vec3d base = EntityUtils.getLerpedPos(e, partialTicks);
-		double yawRad = Math.toRadians(e.getYaw());
-		Arm mainArm = Arm.RIGHT;
-		if(e instanceof PlayerEntity pe)
+		Vec3 base = EntityUtils.getLerpedPos(e, partialTicks);
+		double yawRad = Math.toRadians(e.getYRot());
+		HumanoidArm mainArm = HumanoidArm.RIGHT;
+		if(e instanceof Player pe)
 			mainArm = pe.getMainArm();
-		boolean rightSide = (mainArm == Arm.RIGHT && hand == Hand.MAIN_HAND)
-			|| (mainArm == Arm.LEFT && hand == Hand.OFF_HAND);
+		boolean rightSide =
+			(mainArm == HumanoidArm.RIGHT && hand == InteractionHand.MAIN_HAND)
+				|| (mainArm == HumanoidArm.LEFT
+					&& hand == InteractionHand.OFF_HAND);
 		double side = rightSide ? -1 : 1;
 		double eyeH = e.getEyeHeight(e.getPose());
 		double offX = Math.cos(yawRad) * 0.16 * side;
@@ -584,19 +586,19 @@ public final class ItemEspHack extends Hack implements UpdateListener,
 		return base.add(offX, offY, offZ);
 	}
 	
-	private Vec3d getHeadPos(LivingEntity e, float partialTicks)
+	private Vec3 getHeadPos(LivingEntity e, float partialTicks)
 	{
-		Vec3d base = EntityUtils.getLerpedPos(e, partialTicks);
+		Vec3 base = EntityUtils.getLerpedPos(e, partialTicks);
 		double eyeH = e.getEyeHeight(e.getPose());
 		return base.add(0, eyeH + 0.05, 0);
 	}
 	
-	private Box smallBoxAt(Vec3d c)
+	private AABB smallBoxAt(Vec3 c)
 	{
 		if(c == null)
 			return null;
 		double r = 0.18;
-		return new Box(c.x - r, c.y - r, c.z - r, c.x + r, c.y + r, c.z + r);
+		return new AABB(c.x - r, c.y - r, c.z - r, c.x + r, c.y + r, c.z + r);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/ItemGeneratorHack.java b/src/main/java/net/wurstclient/hacks/ItemGeneratorHack.java
index a1b3a7069..5d9e62bfd 100644
--- a/src/main/java/net/wurstclient/hacks/ItemGeneratorHack.java
+++ b/src/main/java/net/wurstclient/hacks/ItemGeneratorHack.java
@@ -8,12 +8,11 @@
 package net.wurstclient.hacks;
 
 import java.util.Optional;
-
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.util.math.random.Random;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -35,7 +34,8 @@ public final class ItemGeneratorHack extends Hack implements UpdateListener
 			+ "Doesn't seem to affect performance.",
 		1, 1, 64, 1, ValueDisplay.INTEGER);
 	
-	private final Random random = Random.createLocal();
+	private final RandomSource random =
+		RandomSource.createNewThreadLocalInstance();
 	
 	public ItemGeneratorHack()
 	{
@@ -61,7 +61,7 @@ public final class ItemGeneratorHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(!MC.player.isInCreativeMode())
+		if(!MC.player.hasInfiniteMaterials())
 		{
 			ChatUtils.error("Creative mode only.");
 			setEnabled(false);
@@ -72,9 +72,9 @@ public final class ItemGeneratorHack extends Hack implements UpdateListener
 		{
 			// Not sure if it's possible to get an empty optional here,
 			// but if so it will just retry.
-			Optional<RegistryEntry.Reference<Item>> optional = Optional.empty();
+			Optional<Holder.Reference<Item>> optional = Optional.empty();
 			while(optional.isEmpty())
-				optional = Registries.ITEM.getRandom(random);
+				optional = BuiltInRegistries.ITEM.getRandom(random);
 			
 			Item item = optional.get().value();
 			ItemStack stack = new ItemStack(item, stackSize.getValueI());
diff --git a/src/main/java/net/wurstclient/hacks/JesusHack.java b/src/main/java/net/wurstclient/hacks/JesusHack.java
index d7b873b05..20de8d555 100644
--- a/src/main/java/net/wurstclient/hacks/JesusHack.java
+++ b/src/main/java/net/wurstclient/hacks/JesusHack.java
@@ -9,16 +9,15 @@ package net.wurstclient.hacks;
 
 import java.util.ArrayList;
 import java.util.stream.Collectors;
-
-import net.minecraft.block.AirBlock;
-import net.minecraft.block.Block;
-import net.minecraft.block.FluidBlock;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.network.packet.Packet;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.level.block.AirBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.LiquidBlock;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -63,26 +62,26 @@ public final class JesusHack extends Hack
 	public void onUpdate()
 	{
 		// check if sneaking
-		if(MC.options.sneakKey.isPressed())
+		if(MC.options.keyShift.isDown())
 			return;
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		// move up in liquid
-		if(player.isTouchingWater() || player.isInLava())
+		if(player.isInWater() || player.isInLava())
 		{
-			Vec3d velocity = player.getVelocity();
-			player.setVelocity(velocity.x, 0.11, velocity.z);
+			Vec3 velocity = player.getDeltaMovement();
+			player.setDeltaMovement(velocity.x, 0.11, velocity.z);
 			tickTimer = 0;
 			return;
 		}
 		
 		// simulate jumping out of water
-		Vec3d velocity = player.getVelocity();
+		Vec3 velocity = player.getDeltaMovement();
 		if(tickTimer == 0)
-			player.setVelocity(velocity.x, 0.30, velocity.z);
+			player.setDeltaMovement(velocity.x, 0.30, velocity.z);
 		else if(tickTimer == 1)
-			player.setVelocity(velocity.x, 0, velocity.z);
+			player.setDeltaMovement(velocity.x, 0, velocity.z);
 		
 		// update timer
 		tickTimer++;
@@ -92,18 +91,19 @@ public final class JesusHack extends Hack
 	public void onSentPacket(PacketOutputEvent event)
 	{
 		// check packet type
-		if(!(event.getPacket() instanceof PlayerMoveC2SPacket))
+		if(!(event.getPacket() instanceof ServerboundMovePlayerPacket))
 			return;
 		
-		PlayerMoveC2SPacket packet = (PlayerMoveC2SPacket)event.getPacket();
+		ServerboundMovePlayerPacket packet =
+			(ServerboundMovePlayerPacket)event.getPacket();
 		
 		// check if packet contains a position
-		if(!(packet instanceof PlayerMoveC2SPacket.PositionAndOnGround
-			|| packet instanceof PlayerMoveC2SPacket.Full))
+		if(!(packet instanceof ServerboundMovePlayerPacket.Pos
+			|| packet instanceof ServerboundMovePlayerPacket.PosRot))
 			return;
 		
 		// check inWater
-		if(MC.player.isTouchingWater())
+		if(MC.player.isInWater())
 			return;
 		
 		// check fall distance
@@ -134,37 +134,38 @@ public final class JesusHack extends Hack
 		double z = packet.getZ(0);
 		
 		// offset y
-		if(bypass.isChecked() && MC.player.age % 2 == 0)
+		if(bypass.isChecked() && MC.player.tickCount % 2 == 0)
 			y -= 0.05;
 		else
 			y += 0.05;
 		
 		// create new packet
 		Packet<?> newPacket;
-		if(packet instanceof PlayerMoveC2SPacket.PositionAndOnGround)
-			newPacket = new PlayerMoveC2SPacket.PositionAndOnGround(x, y, z,
-				true, MC.player.horizontalCollision);
+		if(packet instanceof ServerboundMovePlayerPacket.Pos)
+			newPacket = new ServerboundMovePlayerPacket.Pos(x, y, z, true,
+				MC.player.horizontalCollision);
 		else
-			newPacket = new PlayerMoveC2SPacket.Full(x, y, z, packet.getYaw(0),
-				packet.getPitch(0), true, MC.player.horizontalCollision);
+			newPacket = new ServerboundMovePlayerPacket.PosRot(x, y, z,
+				packet.getYRot(0), packet.getXRot(0), true,
+				MC.player.horizontalCollision);
 		
 		// send new packet
-		MC.player.networkHandler.getConnection().send(newPacket);
+		MC.player.connection.getConnection().send(newPacket);
 	}
 	
 	public boolean isOverLiquid()
 	{
 		boolean foundLiquid = false;
 		boolean foundSolid = false;
-		Box box = MC.player.getBoundingBox().offset(0, -0.5, 0);
+		AABB box = MC.player.getBoundingBox().move(0, -0.5, 0);
 		
 		// check collision boxes below player
 		ArrayList<Block> blockCollisions = BlockUtils.getBlockCollisions(box)
-			.map(bb -> BlockUtils.getBlock(BlockPos.ofFloored(bb.getCenter())))
+			.map(bb -> BlockUtils.getBlock(BlockPos.containing(bb.getCenter())))
 			.collect(Collectors.toCollection(ArrayList::new));
 		
 		for(Block block : blockCollisions)
-			if(block instanceof FluidBlock)
+			if(block instanceof LiquidBlock)
 				foundLiquid = true;
 			else if(!(block instanceof AirBlock))
 				foundSolid = true;
@@ -175,7 +176,7 @@ public final class JesusHack extends Hack
 	public boolean shouldBeSolid()
 	{
 		return isEnabled() && MC.player != null && MC.player.fallDistance <= 3
-			&& !MC.options.sneakKey.isPressed() && !MC.player.isTouchingWater()
+			&& !MC.options.keyShift.isDown() && !MC.player.isInWater()
 			&& !MC.player.isInLava();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/JetpackHack.java b/src/main/java/net/wurstclient/hacks/JetpackHack.java
index 23a0e0728..b7470676a 100644
--- a/src/main/java/net/wurstclient/hacks/JetpackHack.java
+++ b/src/main/java/net/wurstclient/hacks/JetpackHack.java
@@ -40,7 +40,7 @@ public final class JetpackHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.options.jumpKey.isPressed())
-			MC.player.jump();
+		if(MC.options.keyJump.isDown())
+			MC.player.jumpFromGround();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/KaboomHack.java b/src/main/java/net/wurstclient/hacks/KaboomHack.java
index f4156f761..ff2f23375 100644
--- a/src/main/java/net/wurstclient/hacks/KaboomHack.java
+++ b/src/main/java/net/wurstclient/hacks/KaboomHack.java
@@ -10,13 +10,12 @@ package net.wurstclient.hacks;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Collectors;
-
-import net.minecraft.particle.ParticleTypes;
-import net.minecraft.sound.SoundCategory;
-import net.minecraft.sound.SoundEvents;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.random.Random;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -39,7 +38,7 @@ public final class KaboomHack extends Hack implements UpdateListener
 	private final CheckboxSetting particles = new CheckboxSetting("Particles",
 		"description.wurst.setting.kaboom.particles", true);
 	
-	private final Random random = Random.create();
+	private final RandomSource random = RandomSource.create();
 	
 	public KaboomHack()
 	{
@@ -66,7 +65,7 @@ public final class KaboomHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// Abort if flying to prevent getting kicked
-		if(!MC.player.getAbilities().creativeMode && !MC.player.isOnGround())
+		if(!MC.player.getAbilities().instabuild && !MC.player.onGround())
 			return;
 		
 		double x = MC.player.getX();
@@ -78,13 +77,13 @@ public final class KaboomHack extends Hack implements UpdateListener
 		{
 			float soundPitch =
 				(1F + (random.nextFloat() - random.nextFloat()) * 0.2F) * 0.7F;
-			MC.world.playSoundClient(x, y, z,
-				SoundEvents.ENTITY_GENERIC_EXPLODE.value(),
-				SoundCategory.BLOCKS, 4, soundPitch, false);
+			MC.level.playLocalSound(x, y, z,
+				SoundEvents.GENERIC_EXPLODE.value(), SoundSource.BLOCKS, 4,
+				soundPitch, false);
 		}
 		if(particles.isChecked())
-			MC.world.addParticleClient(ParticleTypes.EXPLOSION_EMITTER, x, y, z,
-				1, 0, 0);
+			MC.level.addParticle(ParticleTypes.EXPLOSION_EMITTER, x, y, z, 1, 0,
+				0);
 		
 		// Break all blocks
 		ArrayList<BlockPos> blocks = getBlocksByDistanceReversed();
@@ -96,16 +95,16 @@ public final class KaboomHack extends Hack implements UpdateListener
 	
 	private ArrayList<BlockPos> getBlocksByDistanceReversed()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = 36;
 		int blockRange = 6;
 		
 		// farthest blocks first
 		return BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-			.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
+			.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
 			.sorted(Comparator
-				.comparingDouble(pos -> -pos.getSquaredDistance(eyesVec)))
+				.comparingDouble(pos -> -pos.distToCenterSqr(eyesVec)))
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/KillPotionHack.java b/src/main/java/net/wurstclient/hacks/KillPotionHack.java
index 8c06aca8a..1d1cda004 100644
--- a/src/main/java/net/wurstclient/hacks/KillPotionHack.java
+++ b/src/main/java/net/wurstclient/hacks/KillPotionHack.java
@@ -9,16 +9,15 @@ package net.wurstclient.hacks;
 
 import java.util.List;
 import java.util.Optional;
-
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.text.Text;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.alchemy.PotionContents;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -46,7 +45,7 @@ public final class KillPotionHack extends Hack
 	protected void onEnable()
 	{
 		// check gamemode
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 		{
 			ChatUtils.error("Creative mode only.");
 			setEnabled(false);
@@ -57,8 +56,8 @@ public final class KillPotionHack extends Hack
 		ItemStack stack = potionType.getSelected().createPotionStack();
 		
 		// give potion
-		PlayerInventory inventory = MC.player.getInventory();
-		int slot = inventory.getEmptySlot();
+		Inventory inventory = MC.player.getInventory();
+		int slot = inventory.getFreeSlot();
 		if(slot < 0)
 			ChatUtils.error("Cannot give potion. Your inventory is full.");
 		else
@@ -102,18 +101,17 @@ public final class KillPotionHack extends Hack
 		{
 			ItemStack stack = new ItemStack(item);
 			
-			StatusEffectInstance effect = new StatusEffectInstance(
-				StatusEffects.INSTANT_HEALTH, 2000, 125);
+			MobEffectInstance effect =
+				new MobEffectInstance(MobEffects.INSTANT_HEALTH, 2000, 125);
 			
-			PotionContentsComponent potionContents =
-				new PotionContentsComponent(Optional.empty(), Optional.empty(),
-					List.of(effect), Optional.empty());
+			PotionContents potionContents = new PotionContents(Optional.empty(),
+				Optional.empty(), List.of(effect), Optional.empty());
 			
-			stack.set(DataComponentTypes.POTION_CONTENTS, potionContents);
+			stack.set(DataComponents.POTION_CONTENTS, potionContents);
 			
 			String name =
 				"\u00a7f" + itemName + " of \u00a74\u00a7lINSTANT DEATH";
-			stack.set(DataComponentTypes.CUSTOM_NAME, Text.literal(name));
+			stack.set(DataComponents.CUSTOM_NAME, Component.literal(name));
 			
 			return stack;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/KillauraHack.java b/src/main/java/net/wurstclient/hacks/KillauraHack.java
index 3c0e61fec..5c54ee7fa 100644
--- a/src/main/java/net/wurstclient/hacks/KillauraHack.java
+++ b/src/main/java/net/wurstclient/hacks/KillauraHack.java
@@ -7,16 +7,15 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Comparator;
 import java.util.function.ToDoubleFunction;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleInputListener;
@@ -153,7 +152,7 @@ public final class KillauraHack extends Hack
 		
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		double rangeSq = range.getValueSq();
-		stream = stream.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		if(fov.getValue() < 360.0)
 			stream = stream.filter(e -> RotationUtils.getAngleToLookVec(
@@ -168,7 +167,7 @@ public final class KillauraHack extends Hack
 		
 		WURST.getHax().autoSwordHack.setSlot(target);
 		
-		Vec3d hitVec = target.getBoundingBox().getCenter();
+		Vec3 hitVec = target.getBoundingBox().getCenter();
 		if(checkLOS.isChecked() && !BlockUtils.hasLineOfSight(hitVec))
 		{
 			target = null;
@@ -184,15 +183,15 @@ public final class KillauraHack extends Hack
 		if(target == null)
 			return;
 		
-		MC.interactionManager.attackEntity(MC.player, target);
-		swingHand.swing(Hand.MAIN_HAND);
+		MC.gameMode.attack(MC.player, target);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		
 		target = null;
 		speed.resetTimer(speedRandMS.getValue());
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(renderTarget == null || !damageIndicator.isChecked())
 			return;
@@ -206,11 +205,10 @@ public final class KillauraHack extends Hack
 		int quadColor = RenderUtils.toIntColor(rgb, 0.25F);
 		int lineColor = RenderUtils.toIntColor(rgb, 0.5F);
 		
-		Box box = EntityUtils.getLerpedBox(renderTarget, partialTicks);
+		AABB box = EntityUtils.getLerpedBox(renderTarget, partialTicks);
 		if(p < 1)
-			box = box.contract((1 - p) * 0.5 * box.getLengthX(),
-				(1 - p) * 0.5 * box.getLengthY(),
-				(1 - p) * 0.5 * box.getLengthZ());
+			box = box.deflate((1 - p) * 0.5 * box.getXsize(),
+				(1 - p) * 0.5 * box.getYsize(), (1 - p) * 0.5 * box.getZsize());
 		
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, box, lineColor, false);
@@ -218,7 +216,7 @@ public final class KillauraHack extends Hack
 	
 	private enum Priority
 	{
-		DISTANCE("Distance", e -> MC.player.squaredDistanceTo(e)),
+		DISTANCE("Distance", e -> MC.player.distanceToSqr(e)),
 		
 		ANGLE("Angle",
 			e -> RotationUtils
diff --git a/src/main/java/net/wurstclient/hacks/KillauraLegitHack.java b/src/main/java/net/wurstclient/hacks/KillauraLegitHack.java
index 0507e76d8..1bb2cb015 100644
--- a/src/main/java/net/wurstclient/hacks/KillauraLegitHack.java
+++ b/src/main/java/net/wurstclient/hacks/KillauraLegitHack.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Comparator;
 import java.util.function.ToDoubleFunction;
 import java.util.stream.Stream;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.util.Mth;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.events.HandleInputListener;
 import net.wurstclient.events.MouseUpdateListener;
@@ -171,12 +170,12 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 		target = null;
 		
 		// don't attack when a container/inventory screen is open
-		if(MC.currentScreen instanceof HandledScreen)
+		if(MC.screen instanceof AbstractContainerScreen)
 			return;
 		
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		double rangeSq = range.getValueSq();
-		stream = stream.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		if(fov.getValue() < 360.0)
 			stream = stream.filter(e -> RotationUtils.getAngleToLookVec(
@@ -215,15 +214,15 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 			return;
 		
 		// attack entity
-		MC.interactionManager.attackEntity(MC.player, target);
-		swingHand.swing(Hand.MAIN_HAND);
+		MC.gameMode.attack(MC.player, target);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		speed.resetTimer(speedRandMS.getValue());
 	}
 	
 	private boolean faceEntityClient(Entity entity)
 	{
 		// get needed rotation
-		Box box = entity.getBoundingBox();
+		AABB box = entity.getBoundingBox();
 		Rotation needed = RotationUtils.getNeededRotations(box.getCenter());
 		
 		// turn towards center of boundingBox
@@ -246,9 +245,9 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 		if(target == null || MC.player == null)
 			return;
 		
-		int diffYaw = (int)(nextYaw - MC.player.getYaw());
-		int diffPitch = (int)(nextPitch - MC.player.getPitch());
-		if(MathHelper.abs(diffYaw) < 1 && MathHelper.abs(diffPitch) < 1)
+		int diffYaw = (int)(nextYaw - MC.player.getYRot());
+		int diffPitch = (int)(nextPitch - MC.player.getXRot());
+		if(Mth.abs(diffYaw) < 1 && Mth.abs(diffPitch) < 1)
 			return;
 		
 		event.setDeltaX(event.getDefaultDeltaX() + diffYaw);
@@ -256,7 +255,7 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(target == null || !damageIndicator.isChecked())
 			return;
@@ -270,11 +269,10 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 		int quadColor = RenderUtils.toIntColor(rgb, 0.25F);
 		int lineColor = RenderUtils.toIntColor(rgb, 0.5F);
 		
-		Box box = EntityUtils.getLerpedBox(target, partialTicks);
+		AABB box = EntityUtils.getLerpedBox(target, partialTicks);
 		if(p < 1)
-			box = box.contract((1 - p) * 0.5 * box.getLengthX(),
-				(1 - p) * 0.5 * box.getLengthY(),
-				(1 - p) * 0.5 * box.getLengthZ());
+			box = box.deflate((1 - p) * 0.5 * box.getXsize(),
+				(1 - p) * 0.5 * box.getYsize(), (1 - p) * 0.5 * box.getZsize());
 		
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, box, lineColor, false);
@@ -282,7 +280,7 @@ public final class KillauraLegitHack extends Hack implements UpdateListener,
 	
 	private enum Priority
 	{
-		DISTANCE("Distance", e -> MC.player.squaredDistanceTo(e)),
+		DISTANCE("Distance", e -> MC.player.distanceToSqr(e)),
 		
 		ANGLE("Angle",
 			e -> RotationUtils
diff --git a/src/main/java/net/wurstclient/hacks/LavaWaterEspHack.java b/src/main/java/net/wurstclient/hacks/LavaWaterEspHack.java
index af1083c5c..b0813d18e 100644
--- a/src/main/java/net/wurstclient/hacks/LavaWaterEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/LavaWaterEspHack.java
@@ -7,21 +7,20 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
 import java.util.function.BiPredicate;
 import java.util.stream.Collectors;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -121,7 +120,7 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 	{
 		groupsUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMatchesVersion = coordinator.getMatchesVersion();
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
@@ -154,7 +153,7 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -183,7 +182,7 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(style.getSelected().hasBoxes())
 			renderBoxes(matrixStack);
@@ -191,13 +190,13 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(LiquidEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int alpha = group == lavaGroup ? lavaAlpha.getValueI()
 				: waterAlpha.getValueI();
 			int quadsColor = group.getColorI(alpha);
@@ -208,14 +207,14 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(LiquidEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int alpha = group == lavaGroup ? lavaAlpha.getValueI()
 				: waterAlpha.getValueI();
 			int color = group.getColorI(alpha);
@@ -230,7 +229,7 @@ public final class LavaWaterEspHack extends Hack implements UpdateListener,
 		int limit = renderAmount.getValueI();
 		java.util.List<Result> matches = coordinator.getMatches()
 			.sorted(Comparator.comparingDouble(
-				r -> r.pos().getSquaredDistance(RotationUtils.getEyesPos())))
+				r -> r.pos().distToCenterSqr(RotationUtils.getEyesPos())))
 			.limit(limit).collect(Collectors.toList());
 		matches.forEach(this::addToGroupBoxes);
 		groupsUpToDate = true;
diff --git a/src/main/java/net/wurstclient/hacks/LogoutSpotsHack.java b/src/main/java/net/wurstclient/hacks/LogoutSpotsHack.java
index ec5cda47a..57ab754ef 100644
--- a/src/main/java/net/wurstclient/hacks/LogoutSpotsHack.java
+++ b/src/main/java/net/wurstclient/hacks/LogoutSpotsHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -14,14 +15,12 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
-
-import net.minecraft.client.network.PlayerListEntry;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -40,11 +39,11 @@ public final class LogoutSpotsHack extends Hack
 	private static final class Entry
 	{
 		final String name;
-		final Box box;
+		final AABB box;
 		final String dimKey;
 		final long createdAtMs;
 		
-		Entry(String n, Box b, String dim, long createdAtMs)
+		Entry(String n, AABB b, String dim, long createdAtMs)
 		{
 			name = n;
 			box = b;
@@ -72,8 +71,8 @@ public final class LogoutSpotsHack extends Hack
 			.withLabel(INFINITE_LIFETIME_MARKER, "Infinite"));
 	
 	private final Map<UUID, Entry> spots = new HashMap<>();
-	private List<PlayerListEntry> lastList = List.of();
-	private Map<UUID, PlayerEntity> lastPlayers = Map.of();
+	private List<PlayerInfo> lastList = List.of();
+	private Map<UUID, Player> lastPlayers = Map.of();
 	private final Map<UUID, java.util.UUID> spotToWaypoint = new HashMap<>();
 	private String lastServerKey = "unknown";
 	
@@ -119,25 +118,25 @@ public final class LogoutSpotsHack extends Hack
 			lastServerKey = serverKeyNow;
 		}
 		
-		if(MC.getNetworkHandler() == null || MC.world == null)
+		if(MC.getConnection() == null || MC.level == null)
 			return;
-		var nowList = MC.getNetworkHandler().getPlayerList();
+		var nowList = MC.getConnection().getOnlinePlayers();
 		if(nowList.size() != lastList.size())
 		{
 			// find missing
-			var lastMap = new HashMap<UUID, PlayerListEntry>();
+			var lastMap = new HashMap<UUID, PlayerInfo>();
 			for(var e : lastList)
 				lastMap.put(e.getProfile().id(), e);
-			var nowMap = new HashMap<UUID, PlayerListEntry>();
+			var nowMap = new HashMap<UUID, PlayerInfo>();
 			for(var e : nowList)
 				nowMap.put(e.getProfile().id(), e);
 			for(var id : lastMap.keySet())
 				if(!nowMap.containsKey(id))
 				{
-					PlayerEntity p = lastPlayers.get(id);
+					Player p = lastPlayers.get(id);
 					if(p != null)
 					{
-						Box b = p.getBoundingBox();
+						AABB b = p.getBoundingBox();
 						long now = System.currentTimeMillis();
 						spots.put(id, new Entry(p.getName().getString(), b,
 							currentDimKey(), now));
@@ -152,7 +151,7 @@ public final class LogoutSpotsHack extends Hack
 							w.setName("Logout: " + p.getName().getString());
 							w.setIcon("skull");
 							w.setColor(0xFF88CCFF);
-							w.setPos(new net.minecraft.util.math.BlockPos(
+							w.setPos(new net.minecraft.core.BlockPos(
 								(int)p.getX(), (int)p.getY(), (int)p.getZ()));
 							// set waypoint dimension based on current world
 							w.setDimension(
@@ -170,12 +169,12 @@ public final class LogoutSpotsHack extends Hack
 			snapshot();
 		}
 		// cull rejoined players
-		if(MC.world != null)
+		if(MC.level != null)
 		{
-			for(PlayerEntity p : MC.world.getPlayers())
+			for(Player p : MC.level.players())
 			{
-				spots.remove(p.getUuid());
-				removeTemporaryWaypoint(p.getUuid());
+				spots.remove(p.getUUID());
+				removeTemporaryWaypoint(p.getUUID());
 			}
 		}
 		
@@ -199,38 +198,38 @@ public final class LogoutSpotsHack extends Hack
 	
 	private String currentDimKey()
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return "overworld";
-		return MC.world.getRegistryKey().getValue().getPath();
+		return MC.level.dimension().location().getPath();
 	}
 	
 	private void snapshot()
 	{
-		if(MC.getNetworkHandler() != null)
+		if(MC.getConnection() != null)
 			lastList = new java.util.ArrayList<>(
-				MC.getNetworkHandler().getPlayerList());
-		var map = new HashMap<UUID, PlayerEntity>();
-		if(MC.world != null)
+				MC.getConnection().getOnlinePlayers());
+		var map = new HashMap<UUID, Player>();
+		if(MC.level != null)
 		{
-			for(PlayerEntity p : MC.world.getPlayers())
-				map.put(p.getUuid(), p);
+			for(Player p : MC.level.players())
+				map.put(p.getUUID(), p);
 		}
 		lastPlayers = map;
 	}
 	
 	private String resolveServerKey()
 	{
-		ServerInfo info = MC.getCurrentServerEntry();
+		ServerData info = MC.getCurrentServer();
 		if(info != null)
 		{
-			if(info.address != null && !info.address.isEmpty())
-				return info.address.replace(':', '_');
+			if(info.ip != null && !info.ip.isEmpty())
+				return info.ip.replace(':', '_');
 			if(info.isRealm())
 				return "realms_" + (info.name == null ? "" : info.name);
 			if(info.name != null && !info.name.isEmpty())
 				return "server_" + info.name;
 		}
-		if(MC.isIntegratedServerRunning())
+		if(MC.hasSingleplayerServer())
 			return "singleplayer";
 		return "unknown";
 	}
@@ -254,14 +253,14 @@ public final class LogoutSpotsHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrices, float partialTicks)
+	public void onRender(PoseStack matrices, float partialTicks)
 	{
 		if(spots.isEmpty())
 			return;
 		String curDim = currentDimKey();
 		int sides = sideColor.getColorI(0x40);
 		int lines = lineColor.getColorI(0xFF);
-		var boxes = new java.util.ArrayList<Box>();
+		var boxes = new java.util.ArrayList<AABB>();
 		for(var e : spots.values())
 			if(e.dimKey.equals(curDim))
 				boxes.add(e.box);
@@ -272,7 +271,7 @@ public final class LogoutSpotsHack extends Hack
 		// (Optional) draw tracers to centers
 		if(showTracers.isChecked())
 		{
-			var ends = boxes.stream().map(Box::getCenter).toList();
+			var ends = boxes.stream().map(AABB::getCenter).toList();
 			RenderUtils.drawTracers(matrices, partialTicks, ends, lines, false);
 		}
 		for(var e : spots.values())
@@ -285,36 +284,35 @@ public final class LogoutSpotsHack extends Hack
 		}
 	}
 	
-	private void drawWorldLabel(MatrixStack matrices, String text, double x,
+	private void drawWorldLabel(PoseStack matrices, String text, double x,
 		double y, double z, int argb, float scale)
 	{
-		matrices.push();
-		net.minecraft.util.math.Vec3d cam =
+		matrices.pushPose();
+		net.minecraft.world.phys.Vec3 cam =
 			net.wurstclient.util.RenderUtils.getCameraPos();
 		matrices.translate(x - cam.x, y - cam.y, z - cam.z);
 		// Face the camera (billboard)
 		var camEntity = MC.getCameraEntity();
 		if(camEntity != null)
 		{
-			matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_Y
-				.rotationDegrees(-camEntity.getYaw()));
-			matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_X
-				.rotationDegrees(camEntity.getPitch()));
+			matrices.mulPose(
+				com.mojang.math.Axis.YP.rotationDegrees(-camEntity.getYRot()));
+			matrices.mulPose(
+				com.mojang.math.Axis.XP.rotationDegrees(camEntity.getXRot()));
 		}
-		matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_Y
-			.rotationDegrees(180.0F));
+		matrices.mulPose(com.mojang.math.Axis.YP.rotationDegrees(180.0F));
 		float s = 0.025F * scale;
 		matrices.scale(s, -s, s);
-		TextRenderer tr = MC.textRenderer;
-		VertexConsumerProvider.Immediate vcp =
+		Font tr = MC.font;
+		MultiBufferSource.BufferSource vcp =
 			net.wurstclient.util.RenderUtils.getVCP();
-		float w = tr.getWidth(text) / 2F;
-		int bg = (int)(MC.options.getTextBackgroundOpacity(0.25F) * 255) << 24;
-		var matrix = matrices.peek().getPositionMatrix();
-		tr.draw(text, -w, 0, argb, false, matrix, vcp,
-			TextRenderer.TextLayerType.SEE_THROUGH, bg, 0xF000F0);
-		vcp.draw();
-		matrices.pop();
+		float w = tr.width(text) / 2F;
+		int bg = (int)(MC.options.getBackgroundOpacity(0.25F) * 255) << 24;
+		var matrix = matrices.last().pose();
+		tr.drawInBatch(text, -w, 0, argb, false, matrix, vcp,
+			Font.DisplayMode.SEE_THROUGH, bg, 0xF000F0);
+		vcp.endBatch();
+		matrices.popPose();
 	}
 	
 	private WaypointDimension mapDimKeyToWaypointDim(String dimKey)
diff --git a/src/main/java/net/wurstclient/hacks/LsdHack.java b/src/main/java/net/wurstclient/hacks/LsdHack.java
index f22d3da13..89e94bcf2 100644
--- a/src/main/java/net/wurstclient/hacks/LsdHack.java
+++ b/src/main/java/net/wurstclient/hacks/LsdHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.Identifier;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.player.Player;
 import net.wurstclient.Category;
 import net.wurstclient.hack.DontSaveState;
 import net.wurstclient.hack.Hack;
@@ -25,22 +25,23 @@ public final class LsdHack extends Hack
 	@Override
 	protected void onEnable()
 	{
-		if(!(MC.getCameraEntity() instanceof PlayerEntity))
+		if(!(MC.getCameraEntity() instanceof Player))
 		{
 			setEnabled(false);
 			return;
 		}
 		
-		if(MC.gameRenderer.getPostProcessorId() != null)
-			MC.gameRenderer.clearPostProcessor();
+		if(MC.gameRenderer.currentPostEffect() != null)
+			MC.gameRenderer.clearPostEffect();
 		
-		MC.gameRenderer.setPostProcessor(Identifier.of("wurst", "lsd"));
+		MC.gameRenderer.setPostEffect(
+			ResourceLocation.fromNamespaceAndPath("wurst", "lsd"));
 	}
 	
 	@Override
 	protected void onDisable()
 	{
-		if(MC.gameRenderer.getPostProcessorId() != null)
-			MC.gameRenderer.clearPostProcessor();
+		if(MC.gameRenderer.currentPostEffect() != null)
+			MC.gameRenderer.clearPostEffect();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/MaceDmgHack.java b/src/main/java/net/wurstclient/hacks/MaceDmgHack.java
index a78eac5fd..840aa7825 100644
--- a/src/main/java/net/wurstclient/hacks/MaceDmgHack.java
+++ b/src/main/java/net/wurstclient/hacks/MaceDmgHack.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionAndOnGround;
-import net.minecraft.util.hit.HitResult;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Pos;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PlayerAttacksEntityListener;
@@ -41,11 +41,11 @@ public final class MaceDmgHack extends Hack
 	@Override
 	public void onPlayerAttacksEntity(Entity target)
 	{
-		if(MC.crosshairTarget == null
-			|| MC.crosshairTarget.getType() != HitResult.Type.ENTITY)
+		if(MC.hitResult == null
+			|| MC.hitResult.getType() != HitResult.Type.ENTITY)
 			return;
 		
-		if(!MC.player.getMainHandStack().isOf(Items.MACE))
+		if(!MC.player.getMainHandItem().is(Items.MACE))
 			return;
 			
 		// See ServerPlayNetworkHandler.onPlayerMove()
@@ -59,8 +59,8 @@ public final class MaceDmgHack extends Hack
 	
 	private void sendFakeY(double offset)
 	{
-		MC.player.networkHandler.sendPacket(
-			new PositionAndOnGround(MC.player.getX(), MC.player.getY() + offset,
+		MC.player.connection
+			.send(new Pos(MC.player.getX(), MC.player.getY() + offset,
 				MC.player.getZ(), false, MC.player.horizontalCollision));
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/MassTpaHack.java b/src/main/java/net/wurstclient/hacks/MassTpaHack.java
index 8989f1ba3..c9309c83c 100644
--- a/src/main/java/net/wurstclient/hacks/MassTpaHack.java
+++ b/src/main/java/net/wurstclient/hacks/MassTpaHack.java
@@ -11,9 +11,8 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Random;
 import java.util.regex.Pattern;
-
-import net.minecraft.client.network.PlayerListEntry;
-import net.minecraft.util.StringHelper;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.util.StringUtil;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.ChatInputListener;
@@ -86,11 +85,11 @@ public final class MassTpaHack extends Hack
 		command = commandSetting.getValue().substring(1);
 		
 		// collect player names
-		String playerName = MC.getSession().getUsername();
-		for(PlayerListEntry info : MC.player.networkHandler.getPlayerList())
+		String playerName = MC.getUser().getName();
+		for(PlayerInfo info : MC.player.connection.getOnlinePlayers())
 		{
 			String name = info.getProfile().name();
-			name = StringHelper.stripTextFormat(name);
+			name = StringUtil.stripColor(name);
 			
 			if(name.equalsIgnoreCase(playerName))
 				continue;
@@ -132,8 +131,7 @@ public final class MassTpaHack extends Hack
 			return;
 		}
 		
-		MC.getNetworkHandler()
-			.sendChatCommand(command + " " + players.get(index));
+		MC.getConnection().sendCommand(command + " " + players.get(index));
 		
 		index++;
 		timer = delay.getValueI() - 1;
diff --git a/src/main/java/net/wurstclient/hacks/MileyCyrusHack.java b/src/main/java/net/wurstclient/hacks/MileyCyrusHack.java
index e3ef1a0d9..0d24e1783 100644
--- a/src/main/java/net/wurstclient/hacks/MileyCyrusHack.java
+++ b/src/main/java/net/wurstclient/hacks/MileyCyrusHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.option.KeyBinding;
+import net.minecraft.client.KeyMapping;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -43,7 +43,7 @@ public final class MileyCyrusHack extends Hack implements UpdateListener
 	protected void onDisable()
 	{
 		EVENTS.remove(UpdateListener.class, this);
-		IKeyBinding.get(MC.options.sneakKey).resetPressedState();
+		IKeyBinding.get(MC.options.keyShift).resetPressedState();
 	}
 	
 	@Override
@@ -53,8 +53,8 @@ public final class MileyCyrusHack extends Hack implements UpdateListener
 		if(timer < 10 - twerkSpeed.getValueI())
 			return;
 		
-		KeyBinding sneakKey = MC.options.sneakKey;
-		sneakKey.setPressed(!sneakKey.isPressed());
+		KeyMapping sneakKey = MC.options.keyShift;
+		sneakKey.setDown(!sneakKey.isDown());
 		timer = -1;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/MobEspHack.java b/src/main/java/net/wurstclient/hacks/MobEspHack.java
index a435664bb..17b031dc2 100644
--- a/src/main/java/net/wurstclient/hacks/MobEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/MobEspHack.java
@@ -7,16 +7,15 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.Box;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -135,9 +134,9 @@ public final class MobEspHack extends Hack implements UpdateListener,
 		mobs.clear();
 		
 		Stream<LivingEntity> stream = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), false)
+			.stream(MC.level.entitiesForRendering().spliterator(), false)
 			.filter(LivingEntity.class::isInstance).map(e -> (LivingEntity)e)
-			.filter(e -> !(e instanceof PlayerEntity))
+			.filter(e -> !(e instanceof Player))
 			.filter(e -> !e.isRemoved() && e.getHealth() > 0);
 		// optionally filter out mobs below the configured Y level
 		if(onlyAboveGround.isChecked())
@@ -168,7 +167,7 @@ public final class MobEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		MobEspStyleSetting.Shape shape = style.getShape();
 		boolean glowMode = shape == MobEspStyleSetting.Shape.GLOW;
@@ -189,14 +188,14 @@ public final class MobEspHack extends Hack implements UpdateListener,
 			
 			for(LivingEntity e : mobs)
 			{
-				Box lerpedBox = EntityUtils.getLerpedBox(e, partialTicks);
+				AABB lerpedBox = EntityUtils.getLerpedBox(e, partialTicks);
 				float[] rgb = getColorRgb();
 				int outlineColor = RenderUtils.toIntColor(rgb, 0.5F);
 				
 				if(drawShape)
 				{
-					Box box =
-						lerpedBox.offset(0, extraSize, 0).expand(extraSize);
+					AABB box =
+						lerpedBox.move(0, extraSize, 0).inflate(extraSize);
 					outlineShapes.add(new ColoredBox(box, outlineColor));
 					
 					if(filledShapes != null)
diff --git a/src/main/java/net/wurstclient/hacks/MobSearchHack.java b/src/main/java/net/wurstclient/hacks/MobSearchHack.java
index 124593b4b..cd4492696 100644
--- a/src/main/java/net/wurstclient/hacks/MobSearchHack.java
+++ b/src/main/java/net/wurstclient/hacks/MobSearchHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.Locale;
@@ -14,13 +15,11 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -178,8 +177,8 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 				String raw = s.trim();
 				if(raw.isEmpty())
 					continue;
-				Identifier id = Identifier.tryParse(raw);
-				if(id != null && Registries.ENTITY_TYPE.containsId(id))
+				ResourceLocation id = ResourceLocation.tryParse(raw);
+				if(id != null && BuiltInRegistries.ENTITY_TYPE.containsKey(id))
 					exact.add(id.toString());
 				else
 					kw.add(raw.toLowerCase(Locale.ROOT));
@@ -192,15 +191,16 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 		{
 			case LIST:
 			predicate = e -> {
-				Identifier id = Registries.ENTITY_TYPE.getId(e.getType());
+				ResourceLocation id =
+					BuiltInRegistries.ENTITY_TYPE.getKey(e.getType());
 				String idFull = id == null ? "" : id.toString();
 				if(listExactIds != null && listExactIds.contains(idFull))
 					return true;
 				String local = idFull.contains(":")
 					? idFull.substring(idFull.indexOf(":") + 1) : idFull;
 				String localSpaced = local.replace('_', ' ');
-				String transKey = e.getType().getTranslationKey();
-				String display = e.getType().getName().getString();
+				String transKey = e.getType().getDescriptionId();
+				String display = e.getType().getDescription().getString();
 				if(listKeywords != null)
 					for(String term : listKeywords)
 						if(containsNormalized(idFull, term)
@@ -221,9 +221,9 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 		}
 		
 		Stream<LivingEntity> stream = StreamSupport
-			.stream(MC.world.getEntities().spliterator(), false)
+			.stream(MC.level.entitiesForRendering().spliterator(), false)
 			.filter(LivingEntity.class::isInstance).map(e -> (LivingEntity)e)
-			.filter(e -> !(e instanceof PlayerEntity))
+			.filter(e -> !(e instanceof Player))
 			.filter(e -> !e.isRemoved() && e.getHealth() > 0).filter(predicate);
 		
 		// apply above-ground filter if enabled
@@ -251,7 +251,7 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(matches.isEmpty())
 			return;
@@ -276,12 +276,12 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 			
 			for(LivingEntity e : matches)
 			{
-				Box lerpedBox = EntityUtils.getLerpedBox(e, partialTicks);
+				AABB lerpedBox = EntityUtils.getLerpedBox(e, partialTicks);
 				int outlineColor = getColorI(0.5F);
 				
 				if(drawShape)
 				{
-					Box box = lerpedBox.offset(0, extra, 0).expand(extra);
+					AABB box = lerpedBox.move(0, extra, 0).inflate(extra);
 					outlineShapes.add(new ColoredBox(box, outlineColor));
 					
 					if(filledShapes != null)
@@ -345,7 +345,8 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 	private Predicate<LivingEntity> byExactType(String normalizedType)
 	{
 		return e -> {
-			Identifier id = Registries.ENTITY_TYPE.getId(e.getType());
+			ResourceLocation id =
+				BuiltInRegistries.ENTITY_TYPE.getKey(e.getType());
 			String s = id == null ? "" : id.toString().toLowerCase(Locale.ROOT);
 			String local =
 				s.contains(":") ? s.substring(s.indexOf(":") + 1) : s;
@@ -359,13 +360,14 @@ public final class MobSearchHack extends Hack implements UpdateListener,
 		String[] terms = Stream.of(q.split(",")).map(String::trim)
 			.filter(s -> !s.isEmpty()).toArray(String[]::new);
 		return e -> {
-			Identifier id = Registries.ENTITY_TYPE.getId(e.getType());
+			ResourceLocation id =
+				BuiltInRegistries.ENTITY_TYPE.getKey(e.getType());
 			String s = id == null ? "" : id.toString();
 			String local =
 				s.contains(":") ? s.substring(s.indexOf(":") + 1) : s;
 			String localSpaced = local.replace('_', ' ');
-			String transKey = e.getType().getTranslationKey();
-			String display = e.getType().getName().getString();
+			String transKey = e.getType().getDescriptionId();
+			String display = e.getType().getDescription().getString();
 			for(String term : terms)
 				if(containsNormalized(s, term)
 					|| containsNormalized(local, term)
diff --git a/src/main/java/net/wurstclient/hacks/MobSpawnEspHack.java b/src/main/java/net/wurstclient/hacks/MobSpawnEspHack.java
index 88f874a41..d125bce6d 100644
--- a/src/main/java/net/wurstclient/hacks/MobSpawnEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/MobSpawnEspHack.java
@@ -7,21 +7,19 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexConsumer;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
 import java.awt.Color;
 import java.util.Map.Entry;
-
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.EntityType;
-import net.minecraft.entity.SpawnRestriction;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.world.LightType;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.SpawnPlacements;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstRenderLayers;
@@ -66,8 +64,8 @@ public final class MobSpawnEspHack extends Hack
 	private final HitboxCheckSetting hitboxCheck = new HitboxCheckSetting();
 	
 	private final ChunkVertexBufferCoordinator coordinator =
-		new ChunkVertexBufferCoordinator(this::isSpawnable, DrawMode.LINES,
-			VertexFormats.POSITION_COLOR_NORMAL, this::buildBuffer,
+		new ChunkVertexBufferCoordinator(this::isSpawnable, Mode.LINES,
+			DefaultVertexFormat.POSITION_COLOR_NORMAL, this::buildBuffer,
 			drawDistance);
 	
 	private int cachedDayColor;
@@ -121,22 +119,22 @@ public final class MobSpawnEspHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		RenderLayer.MultiPhase layer =
+		RenderType.CompositeRenderType layer =
 			WurstRenderLayers.getLines(depthTest.isChecked());
 		
 		for(Entry<ChunkPos, EasyVertexBuffer> entry : coordinator.getBuffers())
 		{
 			RegionPos region = RegionPos.of(entry.getKey());
 			
-			matrixStack.push();
+			matrixStack.pushPose();
 			RenderUtils.applyRegionalRenderOffset(matrixStack, region);
 			
 			entry.getValue().draw(matrixStack, layer, 1, 1, 1,
 				opacity.getValueF());
 			
-			matrixStack.pop();
+			matrixStack.popPose();
 		}
 	}
 	
@@ -144,7 +142,7 @@ public final class MobSpawnEspHack extends Hack
 	{
 		// Check for solid blocks, fluids, redstone, prevent_spawning tags, etc.
 		// See SpawnLocationTypes.ON_GROUND
-		if(!SpawnRestriction.isSpawnPosAllowed(EntityType.CREEPER, MC.world,
+		if(!SpawnPlacements.isSpawnPositionOk(EntityType.CREEPER, MC.level,
 			pos))
 			return false;
 		
@@ -153,7 +151,7 @@ public final class MobSpawnEspHack extends Hack
 			return false;
 		
 		// Check block light level
-		return MC.world.getLightLevel(LightType.BLOCK, pos) < 1;
+		return MC.level.getBrightness(LightLayer.BLOCK, pos) < 1;
 	}
 	
 	private void buildBuffer(VertexConsumer buffer, ChunkSearcher searcher,
@@ -179,12 +177,12 @@ public final class MobSpawnEspHack extends Hack
 		float z1 = pos.getZ() - region.z();
 		float z2 = z1 + 1;
 		
-		int color = MC.world.getLightLevel(LightType.SKY, pos) < 8
+		int color = MC.level.getBrightness(LightLayer.SKY, pos) < 8
 			? cachedDayColor : cachedNightColor;
 		
-		buffer.vertex(x1, y, z1).color(color).normal(1, 0, 1);
-		buffer.vertex(x2, y, z2).color(color).normal(1, 0, 1);
-		buffer.vertex(x2, y, z1).color(color).normal(-1, 0, 1);
-		buffer.vertex(x1, y, z2).color(color).normal(-1, 0, 1);
+		buffer.addVertex(x1, y, z1).setColor(color).setNormal(1, 0, 1);
+		buffer.addVertex(x2, y, z2).setColor(color).setNormal(1, 0, 1);
+		buffer.addVertex(x2, y, z1).setColor(color).setNormal(-1, 0, 1);
+		buffer.addVertex(x1, y, z2).setColor(color).setNormal(-1, 0, 1);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/MultiAuraHack.java b/src/main/java/net/wurstclient/hacks/MultiAuraHack.java
index 8e49a3127..ace112650 100644
--- a/src/main/java/net/wurstclient/hacks/MultiAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/MultiAuraHack.java
@@ -10,9 +10,8 @@ package net.wurstclient.hacks;
 import java.util.ArrayList;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.util.Hand;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -99,7 +98,7 @@ public final class MultiAuraHack extends Hack implements UpdateListener
 		// get entities
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		double rangeSq = Math.pow(range.getValue(), 2);
-		stream = stream.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		if(fov.getValue() < 360.0)
 			stream = stream.filter(e -> RotationUtils.getAngleToLookVec(
@@ -121,10 +120,10 @@ public final class MultiAuraHack extends Hack implements UpdateListener
 				.getNeededRotations(entity.getBoundingBox().getCenter())
 				.sendPlayerLookPacket();
 			
-			MC.interactionManager.attackEntity(MC.player, entity);
+			MC.gameMode.attack(MC.player, entity);
 		}
 		
-		swingHand.swing(Hand.MAIN_HAND);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		speed.resetTimer();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/NameProtectHack.java b/src/main/java/net/wurstclient/hacks/NameProtectHack.java
index 7db29fb8d..0fac3dd44 100644
--- a/src/main/java/net/wurstclient/hacks/NameProtectHack.java
+++ b/src/main/java/net/wurstclient/hacks/NameProtectHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.AbstractClientPlayerEntity;
-import net.minecraft.client.network.PlayerListEntry;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.client.player.AbstractClientPlayer;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -27,12 +27,12 @@ public final class NameProtectHack extends Hack
 		if(!isEnabled() || MC.player == null)
 			return string;
 		
-		String me = MC.getSession().getUsername();
+		String me = MC.getUser().getName();
 		if(string.contains(me))
 			return string.replace(me, "\u00a7oMe\u00a7r");
 		
 		int i = 0;
-		for(PlayerListEntry info : MC.player.networkHandler.getPlayerList())
+		for(PlayerInfo info : MC.player.connection.getOnlinePlayers())
 		{
 			i++;
 			String name =
@@ -42,7 +42,7 @@ public final class NameProtectHack extends Hack
 				return string.replace(name, "\u00a7oPlayer" + i + "\u00a7r");
 		}
 		
-		for(AbstractClientPlayerEntity player : MC.world.getPlayers())
+		for(AbstractClientPlayer player : MC.level.players())
 		{
 			i++;
 			String name = player.getName().getString();
diff --git a/src/main/java/net/wurstclient/hacks/NavigatorHack.java b/src/main/java/net/wurstclient/hacks/NavigatorHack.java
index caa2fee48..53b438759 100644
--- a/src/main/java/net/wurstclient/hacks/NavigatorHack.java
+++ b/src/main/java/net/wurstclient/hacks/NavigatorHack.java
@@ -27,7 +27,7 @@ public final class NavigatorHack extends Hack
 	@Override
 	protected void onEnable()
 	{
-		if(!(MC.currentScreen instanceof NavigatorMainScreen))
+		if(!(MC.screen instanceof NavigatorMainScreen))
 			MC.setScreen(new NavigatorMainScreen());
 		
 		setEnabled(false);
diff --git a/src/main/java/net/wurstclient/hacks/NewChunksHack.java b/src/main/java/net/wurstclient/hacks/NewChunksHack.java
index 6e1ea08d6..58fb7287b 100644
--- a/src/main/java/net/wurstclient/hacks/NewChunksHack.java
+++ b/src/main/java/net/wurstclient/hacks/NewChunksHack.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.world.chunk.WorldChunk;
-import net.minecraft.world.dimension.DimensionType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.dimension.DimensionType;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.Category;
 import net.wurstclient.events.RenderListener;
 import net.wurstclient.events.UpdateListener;
@@ -118,7 +117,7 @@ public final class NewChunksHack extends Hack
 		oldChunkReasons.clear();
 		newChunkReasons.clear();
 		lastRegion = null;
-		lastDimension = MC.world.getDimension();
+		lastDimension = MC.level.dimensionType();
 	}
 	
 	@Override
@@ -177,24 +176,24 @@ public final class NewChunksHack extends Hack
 		if(!isEnabled())
 			return;
 		
-		WorldChunk chunk = MC.world.getChunk(x, z);
+		LevelChunk chunk = MC.level.getChunk(x, z);
 		new Thread(() -> checkLoadedChunk(chunk), "NewChunks " + chunk.getPos())
 			.start();
 	}
 	
-	private void checkLoadedChunk(WorldChunk chunk)
+	private void checkLoadedChunk(LevelChunk chunk)
 	{
 		ChunkPos chunkPos = chunk.getPos();
 		if(newChunks.contains(chunkPos) || oldChunks.contains(chunkPos)
 			|| dontCheckAgain.contains(chunkPos))
 			return;
 		
-		int minX = chunkPos.getStartX();
-		int minY = chunk.getBottomY();
-		int minZ = chunkPos.getStartZ();
-		int maxX = chunkPos.getEndX();
+		int minX = chunkPos.getMinBlockX();
+		int minY = chunk.getMinY();
+		int minZ = chunkPos.getMinBlockZ();
+		int maxX = chunkPos.getMaxBlockX();
 		int maxY = ChunkUtils.getHighestNonEmptySectionYOffset(chunk) + 16;
-		int maxZ = chunkPos.getEndZ();
+		int maxZ = chunkPos.getMaxBlockZ();
 		
 		for(int x = minX; x <= maxX; x++)
 			for(int y = minY; y <= maxY; y++)
@@ -203,7 +202,7 @@ public final class NewChunksHack extends Hack
 					BlockPos pos = new BlockPos(x, y, z);
 					FluidState fluidState = chunk.getFluidState(pos);
 					
-					if(fluidState.isEmpty() || fluidState.isStill())
+					if(fluidState.isEmpty() || fluidState.isSource())
 						continue;
 						
 					// Liquid always generates still, the flowing happens later
@@ -229,7 +228,7 @@ public final class NewChunksHack extends Hack
 		
 		// Liquid starts flowing -> probably a new chunk
 		FluidState fluidState = BlockUtils.getState(pos).getFluidState();
-		if(fluidState.isEmpty() || fluidState.isStill())
+		if(fluidState.isEmpty() || fluidState.isSource())
 			return;
 		
 		ChunkPos chunkPos = new ChunkPos(pos);
@@ -243,9 +242,9 @@ public final class NewChunksHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		if(MC.world.getDimension() != lastDimension)
+		if(MC.level.dimensionType() != lastDimension)
 			reset();
 		
 		RegionPos region = RenderUtils.getCameraRegion();
diff --git a/src/main/java/net/wurstclient/hacks/NoBackgroundHack.java b/src/main/java/net/wurstclient/hacks/NoBackgroundHack.java
index 94abc4e28..7a8dc9496 100644
--- a/src/main/java/net/wurstclient/hacks/NoBackgroundHack.java
+++ b/src/main/java/net/wurstclient/hacks/NoBackgroundHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -33,10 +33,10 @@ public final class NoBackgroundHack extends Hack
 		if(!isEnabled())
 			return false;
 		
-		if(MC.world == null)
+		if(MC.level == null)
 			return false;
 		
-		if(!allGuis.isChecked() && !(screen instanceof HandledScreen))
+		if(!allGuis.isChecked() && !(screen instanceof AbstractContainerScreen))
 			return false;
 		
 		return true;
diff --git a/src/main/java/net/wurstclient/hacks/NoClipHack.java b/src/main/java/net/wurstclient/hacks/NoClipHack.java
index db5116574..0ecb36e16 100644
--- a/src/main/java/net/wurstclient/hacks/NoClipHack.java
+++ b/src/main/java/net/wurstclient/hacks/NoClipHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
+import net.minecraft.client.player.LocalPlayer;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.AirStrafingSpeedListener;
@@ -47,26 +47,26 @@ public final class NoClipHack extends Hack
 		EVENTS.remove(SetOpaqueCubeListener.class, this);
 		EVENTS.remove(AirStrafingSpeedListener.class, this);
 		
-		MC.player.noClip = false;
+		MC.player.noPhysics = false;
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		player.noClip = true;
+		player.noPhysics = true;
 		player.fallDistance = 0;
 		player.setOnGround(false);
 		
 		player.getAbilities().flying = false;
-		player.setVelocity(0, 0, 0);
+		player.setDeltaMovement(0, 0, 0);
 		
 		float speed = 0.2F;
-		if(MC.options.jumpKey.isPressed())
-			player.addVelocity(0, speed, 0);
-		if(MC.options.sneakKey.isPressed())
-			player.addVelocity(0, -speed, 0);
+		if(MC.options.keyJump.isDown())
+			player.push(0, speed, 0);
+		if(MC.options.keyShift.isDown())
+			player.push(0, -speed, 0);
 	}
 	
 	@Override
@@ -78,7 +78,7 @@ public final class NoClipHack extends Hack
 	@Override
 	public void onPlayerMove()
 	{
-		MC.player.noClip = true;
+		MC.player.noPhysics = true;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/NoFallHack.java b/src/main/java/net/wurstclient/hacks/NoFallHack.java
index 8478a544b..836dae306 100644
--- a/src/main/java/net/wurstclient/hacks/NoFallHack.java
+++ b/src/main/java/net/wurstclient/hacks/NoFallHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.OnGroundOnly;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.StatusOnly;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -37,14 +37,14 @@ public final class NoFallHack extends Hack implements UpdateListener
 	@Override
 	public String getRenderName()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(player == null)
 			return getName();
 		
-		if(player.isGliding() && !allowElytra.isChecked())
+		if(player.isFallFlying() && !allowElytra.isChecked())
 			return getName() + " (paused)";
 		
-		if(player.getAbilities().creativeMode)
+		if(player.getAbilities().instabuild)
 			return getName() + " (paused)";
 		
 		if(pauseForMace.isChecked() && isHoldingMace(player))
@@ -70,12 +70,12 @@ public final class NoFallHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// do nothing in creative mode, since there is no fall damage anyway
-		ClientPlayerEntity player = MC.player;
-		if(player.getAbilities().creativeMode)
+		LocalPlayer player = MC.player;
+		if(player.getAbilities().instabuild)
 			return;
 		
 		// pause when flying with elytra, unless allowed
-		boolean fallFlying = player.isGliding();
+		boolean fallFlying = player.isFallFlying();
 		if(fallFlying && !allowElytra.isChecked())
 			return;
 		
@@ -84,22 +84,22 @@ public final class NoFallHack extends Hack implements UpdateListener
 			return;
 		
 		// attempt to fix elytra weirdness, if allowed
-		if(fallFlying && player.isSneaking()
+		if(fallFlying && player.isShiftKeyDown()
 			&& !isFallingFastEnoughToCauseDamage(player))
 			return;
 		
 		// send packet to stop fall damage
-		player.networkHandler
-			.sendPacket(new OnGroundOnly(true, MC.player.horizontalCollision));
+		player.connection
+			.send(new StatusOnly(true, MC.player.horizontalCollision));
 	}
 	
-	private boolean isHoldingMace(ClientPlayerEntity player)
+	private boolean isHoldingMace(LocalPlayer player)
 	{
-		return player.getMainHandStack().isOf(Items.MACE);
+		return player.getMainHandItem().is(Items.MACE);
 	}
 	
-	private boolean isFallingFastEnoughToCauseDamage(ClientPlayerEntity player)
+	private boolean isFallingFastEnoughToCauseDamage(LocalPlayer player)
 	{
-		return player.getVelocity().y < -0.5;
+		return player.getDeltaMovement().y < -0.5;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/NoShieldOverlayHack.java b/src/main/java/net/wurstclient/hacks/NoShieldOverlayHack.java
index 1c4faa49e..686b9d6c2 100644
--- a/src/main/java/net/wurstclient/hacks/NoShieldOverlayHack.java
+++ b/src/main/java/net/wurstclient/hacks/NoShieldOverlayHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.util.math.MatrixStack;
+import com.mojang.blaze3d.vertex.PoseStack;
 import net.wurstclient.Category;
 import net.wurstclient.hack.Hack;
 import net.wurstclient.settings.SliderSetting;
@@ -33,7 +33,7 @@ public final class NoShieldOverlayHack extends Hack
 		addSetting(nonBlockingOffset);
 	}
 	
-	public void adjustShieldPosition(MatrixStack matrixStack, boolean blocking)
+	public void adjustShieldPosition(PoseStack matrixStack, boolean blocking)
 	{
 		if(!isEnabled())
 			return;
diff --git a/src/main/java/net/wurstclient/hacks/NoWebHack.java b/src/main/java/net/wurstclient/hacks/NoWebHack.java
index 6ed42adb8..61dc7a83d 100644
--- a/src/main/java/net/wurstclient/hacks/NoWebHack.java
+++ b/src/main/java/net/wurstclient/hacks/NoWebHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -35,6 +35,6 @@ public final class NoWebHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		MC.player.movementMultiplier = Vec3d.ZERO;
+		MC.player.stuckSpeedMultiplier = Vec3.ZERO;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/NukerHack.java b/src/main/java/net/wurstclient/hacks/NukerHack.java
index f70a14ed0..2275a1e19 100644
--- a/src/main/java/net/wurstclient/hacks/NukerHack.java
+++ b/src/main/java/net/wurstclient/hacks/NukerHack.java
@@ -7,14 +7,13 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.LeftClickListener;
 import net.wurstclient.events.RenderListener;
@@ -105,8 +104,8 @@ public final class NukerHack extends Hack
 		
 		if(currentBlock != null)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			currentBlock = null;
 		}
 		
@@ -126,11 +125,11 @@ public final class NukerHack extends Hack
 	{
 		currentBlock = null;
 		
-		if(MC.options.attackKey.isPressed() || commonSettings.isIdModeWithAir())
+		if(MC.options.keyAttack.isDown() || commonSettings.isIdModeWithAir())
 			return;
 		
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
@@ -145,9 +144,9 @@ public final class NukerHack extends Hack
 		stream = stream.sorted(BlockBreaker.comparingParams());
 		
 		// Break all blocks in creative mode
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			
 			ArrayList<BlockPos> blocks = cache
@@ -157,7 +156,7 @@ public final class NukerHack extends Hack
 			
 			currentBlock = blocks.get(0);
 			BlockBreaker.breakBlocksWithPacketSpam(blocks);
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 			return;
 		}
 		
@@ -167,7 +166,7 @@ public final class NukerHack extends Hack
 		
 		if(currentBlock == null)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			return;
 		}
@@ -193,16 +192,15 @@ public final class NukerHack extends Hack
 				0);
 		}
 		
-		if(!MC.interactionManager.updateBlockBreakingProgress(params.pos(),
-			params.side()))
+		if(!MC.gameMode.continueDestroyBlock(params.pos(), params.side()))
 			return false;
 		
-		swingHand.swing(Hand.MAIN_HAND);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		return true;
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		overlay.render(matrixStack, partialTicks, currentBlock);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/NukerLegitHack.java b/src/main/java/net/wurstclient/hacks/NukerLegitHack.java
index 83bc6cdd2..91025b760 100644
--- a/src/main/java/net/wurstclient/hacks/NukerLegitHack.java
+++ b/src/main/java/net/wurstclient/hacks/NukerLegitHack.java
@@ -7,19 +7,18 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Comparator;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleBlockBreakingListener;
@@ -114,8 +113,8 @@ public final class NukerLegitHack extends Hack
 		EVENTS.remove(RenderListener.class, this);
 		
 		// resets
-		IKeyBinding.get(MC.options.attackKey).resetPressedState();
-		MC.interactionManager.cancelBlockBreaking();
+		IKeyBinding.get(MC.options.keyAttack).resetPressedState();
+		MC.gameMode.stopDestroyBlock();
 		overlay.resetProgress();
 		currentBlock = null;
 		commonSettings.reset();
@@ -141,16 +140,16 @@ public final class NukerLegitHack extends Hack
 		// Ignore the attack cooldown because opening any screen
 		// will set it to 10k ticks.
 		
-		if(MC.player.isRiding())
+		if(MC.player.isHandsBusy())
 		{
 			overlay.resetProgress();
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			return;
 		}
 		
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
-		double maxRange = MC.player.getBlockInteractionRange() + 1;
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
+		double maxRange = MC.player.blockInteractionRange() + 1;
 		double rangeSq = commonSettings.isSphereShape() ? range.getValueSq()
 			: maxRange * maxRange;
 		int blockRange = range.getValueCeil();
@@ -170,7 +169,7 @@ public final class NukerLegitHack extends Hack
 		// reset if no block was found
 		if(currentBlock == null)
 		{
-			IKeyBinding.get(MC.options.attackKey).resetPressedState();
+			IKeyBinding.get(MC.options.keyAttack).resetPressedState();
 			overlay.resetProgress();
 		}
 		
@@ -179,24 +178,24 @@ public final class NukerLegitHack extends Hack
 	
 	private boolean breakBlock(BlockBreakingParams params)
 	{
-		ClientPlayerInteractionManager im = MC.interactionManager;
+		MultiPlayerGameMode im = MC.gameMode;
 		
 		WURST.getRotationFaker().faceVectorClient(params.hitVec());
-		HitResult hitResult = MC.crosshairTarget;
+		HitResult hitResult = MC.hitResult;
 		if(hitResult == null || hitResult.getType() != HitResult.Type.BLOCK
 			|| !(hitResult instanceof BlockHitResult bHitResult))
 		{
-			im.cancelBlockBreaking();
+			im.stopDestroyBlock();
 			return true;
 		}
 		
 		BlockPos pos = bHitResult.getBlockPos();
-		BlockState state = MC.world.getBlockState(pos);
-		Direction side = bHitResult.getSide();
+		BlockState state = MC.level.getBlockState(pos);
+		Direction side = bHitResult.getDirection();
 		if(state.isAir() || !params.pos().equals(pos)
 			|| !params.side().equals(side))
 		{
-			im.cancelBlockBreaking();
+			im.stopDestroyBlock();
 			return true;
 		}
 		
@@ -215,14 +214,14 @@ public final class NukerLegitHack extends Hack
 			// This case doesn't cancel block breaking in vanilla Minecraft.
 			return true;
 		
-		if(!im.isBreakingBlock())
-			im.attackBlock(pos, side);
+		if(!im.isDestroying())
+			im.startDestroyBlock(pos, side);
 		
-		if(im.updateBlockBreakingProgress(pos, side))
+		if(im.continueDestroyBlock(pos, side))
 		{
-			MC.world.spawnBlockBreakingParticle(pos, side);
-			swingHand.swing(Hand.MAIN_HAND);
-			MC.options.attackKey.setPressed(true);
+			MC.level.addBreakingBlockEffect(pos, side);
+			swingHand.swing(InteractionHand.MAIN_HAND);
+			MC.options.keyAttack.setDown(true);
 		}
 		
 		return true;
@@ -237,7 +236,7 @@ public final class NukerLegitHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		overlay.render(matrixStack, partialTicks, currentBlock);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/OpenWaterEspHack.java b/src/main/java/net/wurstclient/hacks/OpenWaterEspHack.java
index 8aa9e5f71..7da7cb4cf 100644
--- a/src/main/java/net/wurstclient/hacks/OpenWaterEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/OpenWaterEspHack.java
@@ -7,11 +7,10 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Optional;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.projectile.FishingBobberEntity;
-import net.minecraft.util.math.Box;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -30,8 +29,8 @@ public final class OpenWaterEspHack extends Hack implements RenderListener
 	@Override
 	public String getRenderName()
 	{
-		FishingBobberEntity bobber = Optional.ofNullable(MC.player)
-			.map(player -> player.fishHook).orElse(null);
+		FishingHook bobber = Optional.ofNullable(MC.player)
+			.map(player -> player.fishing).orElse(null);
 		if(bobber == null)
 			return getName();
 		
@@ -51,13 +50,13 @@ public final class OpenWaterEspHack extends Hack implements RenderListener
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		FishingBobberEntity bobber = MC.player.fishHook;
+		FishingHook bobber = MC.player.fishing;
 		if(bobber == null)
 			return;
 		
-		Box box = new Box(-2, -1, -2, 3, 2, 3).offset(bobber.getBlockPos());
+		AABB box = new AABB(-2, -1, -2, 3, 2, 3).move(bobber.blockPosition());
 		boolean inOpenWater = isInOpenWater(bobber);
 		int color = inOpenWater ? 0x8000FF00 : 0x80FF0000;
 		
@@ -67,8 +66,8 @@ public final class OpenWaterEspHack extends Hack implements RenderListener
 		RenderUtils.drawOutlinedBox(matrixStack, box, color, false);
 	}
 	
-	private boolean isInOpenWater(FishingBobberEntity bobber)
+	private boolean isInOpenWater(FishingHook bobber)
 	{
-		return bobber.isOpenOrWaterAround(bobber.getBlockPos());
+		return bobber.calculateOpenWater(bobber.blockPosition());
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/OverlayHack.java b/src/main/java/net/wurstclient/hacks/OverlayHack.java
index da541de98..447c840eb 100644
--- a/src/main/java/net/wurstclient/hacks/OverlayHack.java
+++ b/src/main/java/net/wurstclient/hacks/OverlayHack.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.events.RenderListener;
 import net.wurstclient.events.UpdateListener;
@@ -45,19 +45,19 @@ public final class OverlayHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		if(MC.interactionManager.isBreakingBlock())
+		if(MC.gameMode.isDestroying())
 			renderer.updateProgress();
 		else
 			renderer.resetProgress();
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		if(!MC.interactionManager.isBreakingBlock())
+		if(!MC.gameMode.isDestroying())
 			return;
 		
-		if(!(MC.crosshairTarget instanceof BlockHitResult blockHitResult)
+		if(!(MC.hitResult instanceof BlockHitResult blockHitResult)
 			|| blockHitResult.getType() != HitResult.Type.BLOCK)
 			return;
 		
diff --git a/src/main/java/net/wurstclient/hacks/ParkourHack.java b/src/main/java/net/wurstclient/hacks/ParkourHack.java
index 8ff85456f..7e685dcee 100644
--- a/src/main/java/net/wurstclient/hacks/ParkourHack.java
+++ b/src/main/java/net/wurstclient/hacks/ParkourHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.Box;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -60,20 +60,20 @@ public final class ParkourHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(!MC.player.isOnGround() || MC.options.jumpKey.isPressed())
+		if(!MC.player.onGround() || MC.options.keyJump.isDown())
 			return;
 		
 		if(!sneak.isChecked()
-			&& (MC.player.isSneaking() || MC.options.sneakKey.isPressed()))
+			&& (MC.player.isShiftKeyDown() || MC.options.keyShift.isDown()))
 			return;
 		
-		Box box = MC.player.getBoundingBox();
-		Box adjustedBox = box.stretch(0, -minDepth.getValue(), 0)
-			.expand(-edgeDistance.getValue(), 0, -edgeDistance.getValue());
+		AABB box = MC.player.getBoundingBox();
+		AABB adjustedBox = box.expandTowards(0, -minDepth.getValue(), 0)
+			.inflate(-edgeDistance.getValue(), 0, -edgeDistance.getValue());
 		
-		if(!MC.world.isSpaceEmpty(MC.player, adjustedBox))
+		if(!MC.level.noCollision(MC.player, adjustedBox))
 			return;
 		
-		MC.player.jump();
+		MC.player.jumpFromGround();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/PlayerEspHack.java b/src/main/java/net/wurstclient/hacks/PlayerEspHack.java
index 658c091ec..34c27fc0d 100644
--- a/src/main/java/net/wurstclient/hacks/PlayerEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/PlayerEspHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -15,21 +16,19 @@ import java.util.Optional;
 import java.util.UUID;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.client.network.AbstractClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.Util;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.text.Text;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.TextColor;
-import net.minecraft.util.Formatting;
-import net.minecraft.world.RaycastContext;
+import net.minecraft.ChatFormatting;
+import net.minecraft.Util;
+import net.minecraft.client.player.AbstractClientPlayer;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -67,7 +66,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		new FilterSleepingSetting("Won't show sleeping players.", false),
 		new FilterInvisibleSetting("Won't show invisible players.", false));
 	
-	private final ArrayList<PlayerEntity> players = new ArrayList<>();
+	private final ArrayList<Player> players = new ArrayList<>();
 	// Alert settings & tracking for enter/exit notifications
 	private final CheckboxSetting enterAlert = new CheckboxSetting(
 		"Enter alert",
@@ -84,7 +83,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		new PlayerRangeAlertManager.Listener()
 		{
 			@Override
-			public void onPlayerEnter(PlayerEntity player,
+			public void onPlayerEnter(Player player,
 				PlayerRangeAlertManager.PlayerInfo info)
 			{
 				if(!isEnabled() || !enterAlert.isChecked())
@@ -205,7 +204,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 	{
 		players.clear();
 		
-		Stream<AbstractClientPlayerEntity> stream = MC.world.getPlayers()
+		Stream<AbstractClientPlayer> stream = MC.level.players()
 			.parallelStream().filter(e -> !e.isRemoved() && e.getHealth() > 0)
 			.filter(e -> e != MC.player)
 			.filter(e -> !(e instanceof FakePlayerEntity))
@@ -216,10 +215,9 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		if(ignoreNpcs.isChecked())
 		{
 			stream = stream.filter(e -> {
-				if(MC.getNetworkHandler() == null)
+				if(MC.getConnection() == null)
 					return true;
-				return MC.getNetworkHandler()
-					.getPlayerListEntry(e.getUuid()) != null;
+				return MC.getConnection().getPlayerInfo(e.getUUID()) != null;
 			});
 		}
 		
@@ -228,22 +226,22 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		players.addAll(stream.collect(Collectors.toList()));
 		
 		if(losThreatDetection.isChecked())
-			updateLosStates(Util.getMeasuringTimeMs());
+			updateLosStates(Util.getMillis());
 		else
 			losStates.clear();
 	}
 	
-	private void sendEnterMessage(PlayerEntity p)
+	private void sendEnterMessage(Player p)
 	{
 		if(MC.player == null)
 			return;
-		UUID id = p.getUuid();
+		UUID id = p.getUUID();
 		double dist = Math.round(MC.player.distanceTo(p) * 10.0) / 10.0;
 		int x = (int)Math.round(p.getX());
 		int y = (int)Math.round(p.getY());
 		int z = (int)Math.round(p.getZ());
-		MutableText nameText =
-			MutableText.of(Text.literal(p.getName().getString()).getContent());
+		MutableComponent nameText = MutableComponent
+			.create(Component.literal(p.getName().getString()).getContents());
 		if(randomBrightColors.isChecked())
 		{
 			int idx = Math.abs(id.hashCode());
@@ -252,11 +250,11 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 			nameText.setStyle(nameText.getStyle().withColor(TextColor.fromRgb(
 				(gen.getRed() << 16) | (gen.getGreen() << 8) | gen.getBlue())));
 		}
-		Text msg = nameText.append(Text
+		Component msg = nameText.append(Component
 			.literal(" entered range (" + dist + " blocks) at " + x + ", " + y
 				+ ", " + z + ".")
-			.styled(
-				s -> s.withColor(TextColor.fromFormatting(Formatting.WHITE))));
+			.withStyle(s -> s
+				.withColor(TextColor.fromLegacyFormat(ChatFormatting.WHITE))));
 		ChatUtils.component(msg);
 	}
 	
@@ -265,16 +263,16 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		if(MC.player == null)
 			return;
 		
-		Vec3d pos = info.getLastPos();
+		Vec3 pos = info.getLastPos();
 		double dist = pos == null ? -1.0
 			: Math.round(pos.distanceTo(
-				new Vec3d(MC.player.getX(), MC.player.getY(), MC.player.getZ()))
+				new Vec3(MC.player.getX(), MC.player.getY(), MC.player.getZ()))
 				* 10.0) / 10.0;
 		int x = pos == null ? 0 : (int)Math.round(pos.x);
 		int y = pos == null ? 0 : (int)Math.round(pos.y);
 		int z = pos == null ? 0 : (int)Math.round(pos.z);
-		MutableText nameText =
-			MutableText.of(Text.literal(info.getName()).getContent());
+		MutableComponent nameText = MutableComponent
+			.create(Component.literal(info.getName()).getContents());
 		if(randomBrightColors.isChecked())
 		{
 			int idx = Math.abs(info.getUuid().hashCode());
@@ -284,11 +282,11 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 				(gen.getRed() << 16) | (gen.getGreen() << 8) | gen.getBlue())));
 		}
 		String distStr = dist < 0 ? "unknown" : (dist + " blocks");
-		Text msg = nameText.append(Text
+		Component msg = nameText.append(Component
 			.literal(" left range (" + distStr + ") at " + x + ", " + y + ", "
 				+ z + ".")
-			.styled(
-				s -> s.withColor(TextColor.fromFormatting(Formatting.WHITE))));
+			.withStyle(s -> s
+				.withColor(TextColor.fromLegacyFormat(ChatFormatting.WHITE))));
 		ChatUtils.component(msg);
 	}
 	
@@ -301,9 +299,9 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		long now = Util.getMeasuringTimeMs();
+		long now = Util.getMillis();
 		Map<UUID, PlayerVisual> visualCache = new HashMap<>(players.size());
 		
 		if(style.hasBoxes())
@@ -315,11 +313,11 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 			ArrayList<ColoredBox> solid = filledBoxes.isChecked()
 				? new ArrayList<>(players.size()) : null;
 			
-			for(PlayerEntity e : players)
+			for(Player e : players)
 			{
-				Box box = EntityUtils.getLerpedBox(e, partialTicks)
-					.offset(0, extraSize, 0).expand(extraSize);
-				PlayerVisual visual = visualCache.computeIfAbsent(e.getUuid(),
+				AABB box = EntityUtils.getLerpedBox(e, partialTicks)
+					.move(0, extraSize, 0).inflate(extraSize);
+				PlayerVisual visual = visualCache.computeIfAbsent(e.getUUID(),
 					id -> getVisual(e, now));
 				int boxColor = visual.boxColor();
 				
@@ -374,11 +372,11 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 				new ArrayList<>(players.size());
 			ArrayList<ColoredPoint> threatEnds = new ArrayList<>();
 			
-			for(PlayerEntity e : players)
+			for(Player e : players)
 			{
-				PlayerVisual visual = visualCache.computeIfAbsent(e.getUuid(),
+				PlayerVisual visual = visualCache.computeIfAbsent(e.getUUID(),
 					id -> getVisual(e, now));
-				Vec3d point =
+				Vec3 point =
 					EntityUtils.getLerpedBox(e, partialTicks).getCenter();
 				ColoredPoint colored =
 					new ColoredPoint(point, visual.tracerColor());
@@ -406,7 +404,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 			return null;
 		if(!style.hasGlow())
 			return null;
-		if(!(entity instanceof PlayerEntity player))
+		if(!(entity instanceof Player player))
 			return null;
 		if(!players.contains(player))
 			return null;
@@ -414,7 +412,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		return makeOpaque(getBaseColor(player));
 	}
 	
-	private int getBaseColor(PlayerEntity e)
+	private int getBaseColor(Player e)
 	{
 		if(WURST.getFriends().contains(e.getName().getString()))
 			return 0x800000FF;
@@ -423,7 +421,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		if(useStaticPlayerColor.isChecked())
 		{
 			java.awt.Color pc = playerColor.getColor();
-			net.wurstclient.util.PlayerColorRegistry.forceAssign(e.getUuid(),
+			net.wurstclient.util.PlayerColorRegistry.forceAssign(e.getUUID(),
 				pc, "PlayerESP");
 			return RenderUtils.toIntColor(new float[]{pc.getRed() / 255f,
 				pc.getGreen() / 255f, pc.getBlue() / 255f}, 0.85F);
@@ -434,10 +432,10 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		// Breadcrumbs.
 		if(randomBrightColors.isChecked())
 		{
-			int idx = Math.abs(e.getUuid().hashCode());
+			int idx = Math.abs(e.getUUID().hashCode());
 			java.awt.Color gen = net.wurstclient.util.PlayerColorRegistry
 				.generateBrightColor(idx);
-			net.wurstclient.util.PlayerColorRegistry.forceAssign(e.getUuid(),
+			net.wurstclient.util.PlayerColorRegistry.forceAssign(e.getUUID(),
 				gen, "PlayerESP");
 			return RenderUtils.toIntColor(new float[]{gen.getRed() / 255f,
 				gen.getGreen() / 255f, gen.getBlue() / 255f}, 0.9F);
@@ -459,7 +457,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		if(useStaticPlayerColor.isChecked() || randomBrightColors.isChecked())
 		{
 			java.awt.Color reg2 =
-				net.wurstclient.util.PlayerColorRegistry.get(e.getUuid());
+				net.wurstclient.util.PlayerColorRegistry.get(e.getUUID());
 			if(reg2 != null)
 			{
 				return RenderUtils
@@ -473,13 +471,13 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		// Otherwise fall back to the dynamic distance-based coloring (default).
 		
 		float f = MC.player.distanceTo(e) / 20F;
-		float r = MathHelper.clamp(2 - f, 0, 1);
-		float g = MathHelper.clamp(f, 0, 1);
+		float r = Mth.clamp(2 - f, 0, 1);
+		float g = Mth.clamp(f, 0, 1);
 		float[] rgb = {r, g, 0};
 		return RenderUtils.toIntColor(rgb, 0.5F);
 	}
 	
-	private PlayerVisual getVisual(PlayerEntity e, long now)
+	private PlayerVisual getVisual(Player e, long now)
 	{
 		int baseColor = getBaseColor(e);
 		if(!losThreatDetection.isChecked())
@@ -491,9 +489,9 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		return new PlayerVisual(boxColor, tracerColor, factor);
 	}
 	
-	private float getLosFactor(PlayerEntity e, long now)
+	private float getLosFactor(Player e, long now)
 	{
-		LosState state = losStates.get(e.getUuid());
+		LosState state = losStates.get(e.getUUID());
 		if(state == null)
 			return 0F;
 		
@@ -508,7 +506,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 			long fadeStart = state.fadeUntil - LOS_FADE_MS;
 			long elapsed = Math.max(0L, now - fadeStart);
 			float progress = 1F - (float)elapsed / (float)LOS_FADE_MS;
-			return MathHelper.clamp(progress, 0F, 1F);
+			return Mth.clamp(progress, 0F, 1F);
 		}
 		
 		return 0F;
@@ -516,7 +514,7 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 	
 	private float getFovDotThreshold()
 	{
-		double fovDegrees = MathHelper.clamp(losThreatFov.getValue(), 1, 180);
+		double fovDegrees = Mth.clamp(losThreatFov.getValue(), 1, 180);
 		double halfAngle = fovDegrees / 2.0;
 		return (float)Math.cos(Math.toRadians(halfAngle));
 	}
@@ -529,15 +527,14 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		if(tracer)
 			baseColor = makeOpaque(baseColor);
 		
-		float clampedFactor = MathHelper.clamp(factor, 0F, 1F);
+		float clampedFactor = Mth.clamp(factor, 0F, 1F);
 		
 		float baseA = ((baseColor >>> 24) & 0xFF) / 255F;
 		float baseR = ((baseColor >>> 16) & 0xFF) / 255F;
 		float baseG = ((baseColor >>> 8) & 0xFF) / 255F;
 		float baseB = (baseColor & 0xFF) / 255F;
 		
-		float threatAlpha =
-			MathHelper.clamp(baseA + (tracer ? 0.45F : 0.35F), 0F, 1F);
+		float threatAlpha = Mth.clamp(baseA + (tracer ? 0.45F : 0.35F), 0F, 1F);
 		
 		float inv = 1F - clampedFactor;
 		float r = 1F * clampedFactor + baseR * inv;
@@ -555,15 +552,15 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 	
 	private void updateLosStates(long now)
 	{
-		if(MC.player == null || MC.world == null)
+		if(MC.player == null || MC.level == null)
 			return;
 		
 		for(LosState state : losStates.values())
 			state.touched = false;
 		
-		for(PlayerEntity player : players)
+		for(Player player : players)
 		{
-			LosState state = losStates.computeIfAbsent(player.getUuid(),
+			LosState state = losStates.computeIfAbsent(player.getUUID(),
 				uuid -> new LosState(uuid, now));
 			state.touched = true;
 			updateLosState(player, state, now);
@@ -572,15 +569,15 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		losStates.entrySet().removeIf(entry -> !entry.getValue().touched);
 	}
 	
-	private void updateLosState(PlayerEntity target, LosState state, long now)
+	private void updateLosState(Player target, LosState state, long now)
 	{
-		PlayerEntity self = MC.player;
+		Player self = MC.player;
 		if(self == null)
 			return;
 		
 		double maxRange = losThreatRange.getValue();
 		double maxRangeSq = maxRange * maxRange;
-		double distSq = target.squaredDistanceTo(self);
+		double distSq = target.distanceToSqr(self);
 		
 		if(distSq > maxRangeSq)
 		{
@@ -597,50 +594,49 @@ public final class PlayerEspHack extends Hack implements UpdateListener,
 		state.scheduleNext(now);
 	}
 	
-	private boolean computeLineOfSight(PlayerEntity target)
+	private boolean computeLineOfSight(Player target)
 	{
-		PlayerEntity self = MC.player;
-		if(self == null || MC.world == null)
+		Player self = MC.player;
+		if(self == null || MC.level == null)
 			return false;
 		
-		Box myBox = self.getBoundingBox();
-		Vec3d eyePos = new Vec3d(target.getX(),
-			target.getY() + target.getStandingEyeHeight(), target.getZ());
+		AABB myBox = self.getBoundingBox();
+		Vec3 eyePos = new Vec3(target.getX(),
+			target.getY() + target.getEyeHeight(), target.getZ());
 		
 		if(myBox.contains(eyePos))
 			return true;
 		
-		double clampedX = MathHelper.clamp(eyePos.x, myBox.minX, myBox.maxX);
-		double clampedY = MathHelper.clamp(eyePos.y, myBox.minY, myBox.maxY);
-		double clampedZ = MathHelper.clamp(eyePos.z, myBox.minZ, myBox.maxZ);
-		Vec3d closestPoint = new Vec3d(clampedX, clampedY, clampedZ);
+		double clampedX = Mth.clamp(eyePos.x, myBox.minX, myBox.maxX);
+		double clampedY = Mth.clamp(eyePos.y, myBox.minY, myBox.maxY);
+		double clampedZ = Mth.clamp(eyePos.z, myBox.minZ, myBox.maxZ);
+		Vec3 closestPoint = new Vec3(clampedX, clampedY, clampedZ);
 		
-		Vec3d dirToYouVec = closestPoint.subtract(eyePos);
+		Vec3 dirToYouVec = closestPoint.subtract(eyePos);
 		double distance = dirToYouVec.length();
 		if(distance < 1e-4)
 			return true;
-		Vec3d dirToYou = dirToYouVec.normalize();
+		Vec3 dirToYou = dirToYouVec.normalize();
 		
-		Vec3d lookVec = target.getRotationVec(1.0F);
+		Vec3 lookVec = target.getViewVector(1.0F);
 		float fovThreshold = getFovDotThreshold();
-		if(lookVec.dotProduct(dirToYou) < fovThreshold)
+		if(lookVec.dot(dirToYou) < fovThreshold)
 			return false;
 		
-		Optional<Vec3d> hitOpt = myBox.raycast(eyePos, closestPoint);
+		Optional<Vec3> hitOpt = myBox.clip(eyePos, closestPoint);
 		if(hitOpt.isEmpty())
-			hitOpt = myBox.raycast(eyePos, myBox.getCenter());
-		Vec3d hitPos = hitOpt.orElse(closestPoint);
+			hitOpt = myBox.clip(eyePos, myBox.getCenter());
+		Vec3 hitPos = hitOpt.orElse(closestPoint);
 		
-		RaycastContext ctx =
-			new RaycastContext(eyePos, hitPos, RaycastContext.ShapeType.VISUAL,
-				RaycastContext.FluidHandling.NONE, target);
-		HitResult blockHit = MC.world.raycast(ctx);
+		ClipContext ctx = new ClipContext(eyePos, hitPos,
+			ClipContext.Block.VISUAL, ClipContext.Fluid.NONE, target);
+		HitResult blockHit = MC.level.clip(ctx);
 		
 		if(blockHit.getType() == HitResult.Type.MISS)
 			return true;
 		
-		double blockDistSq = blockHit.getPos().squaredDistanceTo(eyePos);
-		double targetDistSq = hitPos.squaredDistanceTo(eyePos);
+		double blockDistSq = blockHit.getLocation().distanceToSqr(eyePos);
+		double targetDistSq = hitPos.distanceToSqr(eyePos);
 		return blockDistSq >= targetDistSq - 1e-3;
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/PortalEspHack.java b/src/main/java/net/wurstclient/hacks/PortalEspHack.java
index 591219f2d..e13d2917b 100644
--- a/src/main/java/net/wurstclient/hacks/PortalEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/PortalEspHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -14,15 +15,13 @@ import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.function.BiPredicate;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
 import net.wurstclient.events.PacketInputListener;
@@ -118,7 +117,7 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 	{
 		groupsUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
 		EVENTS.add(RenderListener.class, this);
@@ -157,7 +156,7 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -172,7 +171,7 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(style.getSelected().hasBoxes())
 			renderBoxes(matrixStack);
@@ -181,14 +180,14 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(PortalEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				return;
 			
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			
@@ -198,14 +197,14 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(PortalEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
 			
-			List<Vec3d> ends = getTracerTargets(group);
+			List<Vec3> ends = getTracerTargets(group);
 			if(ends.isEmpty())
 				continue;
 			
@@ -236,10 +235,10 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 			}
 	}
 	
-	private List<Vec3d> getTracerTargets(PortalEspBlockGroup group)
+	private List<Vec3> getTracerTargets(PortalEspBlockGroup group)
 	{
 		if(!usesStructureCenter(group))
-			return group.getBoxes().stream().map(Box::getCenter).toList();
+			return group.getBoxes().stream().map(AABB::getCenter).toList();
 		
 		return getStructureCenters(group.getPositions());
 	}
@@ -250,13 +249,13 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 			|| group == endPortal;
 	}
 	
-	private List<Vec3d> getStructureCenters(List<BlockPos> positions)
+	private List<Vec3> getStructureCenters(List<BlockPos> positions)
 	{
 		if(positions.isEmpty())
 			return List.of();
 		
 		HashSet<BlockPos> remaining = new HashSet<>(positions);
-		ArrayList<Vec3d> centers = new ArrayList<>();
+		ArrayList<Vec3> centers = new ArrayList<>();
 		
 		while(!remaining.isEmpty())
 		{
@@ -281,15 +280,14 @@ public final class PortalEspHack extends Hack implements UpdateListener,
 				
 				for(Direction dir : Direction.values())
 				{
-					BlockPos neighbor = current.offset(dir);
+					BlockPos neighbor = current.relative(dir);
 					if(remaining.remove(neighbor))
 						queue.addLast(neighbor);
 				}
 			}
 			
 			if(count > 0)
-				centers
-					.add(new Vec3d(sumX / count, sumY / count, sumZ / count));
+				centers.add(new Vec3(sumX / count, sumY / count, sumZ / count));
 		}
 		
 		return centers;
diff --git a/src/main/java/net/wurstclient/hacks/PotionSaverHack.java b/src/main/java/net/wurstclient/hacks/PotionSaverHack.java
index 6b8d23830..a9f7671a0 100644
--- a/src/main/java/net/wurstclient/hacks/PotionSaverHack.java
+++ b/src/main/java/net/wurstclient/hacks/PotionSaverHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -40,14 +40,15 @@ public final class PotionSaverHack extends Hack implements PacketOutputListener
 		if(!isFrozen())
 			return;
 		
-		if(event.getPacket() instanceof PlayerMoveC2SPacket)
+		if(event.getPacket() instanceof ServerboundMovePlayerPacket)
 			event.cancel();
 	}
 	
 	public boolean isFrozen()
 	{
 		return isEnabled() && MC.player != null
-			&& !MC.player.getActiveStatusEffects().isEmpty()
-			&& MC.player.getVelocity().x == 0 && MC.player.getVelocity().z == 0;
+			&& !MC.player.getActiveEffectsMap().isEmpty()
+			&& MC.player.getDeltaMovement().x == 0
+			&& MC.player.getDeltaMovement().z == 0;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/ProphuntEspHack.java b/src/main/java/net/wurstclient/hacks/ProphuntEspHack.java
index 6bab090e8..7bddd5861 100644
--- a/src/main/java/net/wurstclient/hacks/ProphuntEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/ProphuntEspHack.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.MobEntity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -23,8 +22,8 @@ import net.wurstclient.util.RenderUtils;
 @SearchTags({"prophunt esp"})
 public final class ProphuntEspHack extends Hack implements RenderListener
 {
-	private static final Box FAKE_BLOCK_BOX =
-		new Box(-0.5, 0, -0.5, 0.5, 1, 0.5);
+	private static final AABB FAKE_BLOCK_BOX =
+		new AABB(-0.5, 0, -0.5, 0.5, 1, 0.5);
 	
 	public ProphuntEspHack()
 	{
@@ -45,27 +44,27 @@ public final class ProphuntEspHack extends Hack implements RenderListener
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		// set color
-		float alpha = 0.5F + 0.25F * MathHelper
-			.sin(System.currentTimeMillis() % 1000 / 500F * MathHelper.PI);
+		float alpha = 0.5F + 0.25F
+			* Mth.sin(System.currentTimeMillis() % 1000 / 500F * Mth.PI);
 		int color = RenderUtils.toIntColor(new float[]{1, 0, 0}, alpha);
 		
 		// draw boxes
-		ArrayList<Box> boxes = new ArrayList<>();
-		for(Entity entity : MC.world.getEntities())
+		ArrayList<AABB> boxes = new ArrayList<>();
+		for(Entity entity : MC.level.entitiesForRendering())
 		{
-			if(!(entity instanceof MobEntity))
+			if(!(entity instanceof Mob))
 				continue;
 			
 			if(!entity.isInvisible())
 				continue;
 			
-			if(MC.player.squaredDistanceTo(entity) < 0.25)
+			if(MC.player.distanceToSqr(entity) < 0.25)
 				continue;
 			
-			boxes.add(FAKE_BLOCK_BOX.offset(entity.getEntityPos()));
+			boxes.add(FAKE_BLOCK_BOX.move(entity.position()));
 		}
 		
 		RenderUtils.drawSolidBoxes(matrixStack, boxes, color, false);
diff --git a/src/main/java/net/wurstclient/hacks/ProtectHack.java b/src/main/java/net/wurstclient/hacks/ProtectHack.java
index 02ee09e09..6d6b15b17 100644
--- a/src/main/java/net/wurstclient/hacks/ProtectHack.java
+++ b/src/main/java/net/wurstclient/hacks/ProtectHack.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.ai.PathFinder;
 import net.wurstclient.ai.PathPos;
@@ -135,15 +134,15 @@ public final class ProtectHack extends Hack
 		if(friend == null)
 		{
 			Stream<Entity> stream = StreamSupport
-				.stream(MC.world.getEntities().spliterator(), true)
+				.stream(MC.level.entitiesForRendering().spliterator(), true)
 				.filter(LivingEntity.class::isInstance)
 				.filter(
 					e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
 				.filter(e -> e != MC.player)
 				.filter(e -> !(e instanceof FakePlayerEntity));
 			friend = stream
-				.min(Comparator
-					.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+				.min(
+					Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 				.orElse(null);
 		}
 		
@@ -169,7 +168,7 @@ public final class ProtectHack extends Hack
 		
 		if(friend != null)
 		{
-			MC.options.forwardKey.setPressed(false);
+			MC.options.keyUp.setDown(false);
 			friend = null;
 		}
 	}
@@ -196,19 +195,18 @@ public final class ProtectHack extends Hack
 		
 		// set enemy
 		Stream<Entity> stream = EntityUtils.getAttackableEntities()
-			.filter(e -> MC.player.squaredDistanceTo(e) <= 36)
+			.filter(e -> MC.player.distanceToSqr(e) <= 36)
 			.filter(e -> e != friend);
 		
 		stream = entityFilters.applyTo(stream);
 		
 		enemy = stream
-			.min(
-				Comparator.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+			.min(Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 			.orElse(null);
 		
 		Entity target =
-			enemy == null || MC.player.squaredDistanceTo(friend) >= 24 * 24
-				? friend : enemy;
+			enemy == null || MC.player.distanceToSqr(friend) >= 24 * 24 ? friend
+				: enemy;
 		
 		double distance = target == enemy ? distanceE : distanceF;
 		
@@ -244,35 +242,35 @@ public final class ProtectHack extends Hack
 		}else
 		{
 			// jump if necessary
-			if(MC.player.horizontalCollision && MC.player.isOnGround())
-				MC.player.jump();
+			if(MC.player.horizontalCollision && MC.player.onGround())
+				MC.player.jumpFromGround();
 			
 			// swim up if necessary
-			if(MC.player.isTouchingWater() && MC.player.getY() < target.getY())
-				MC.player.addVelocity(0, 0.04, 0);
+			if(MC.player.isInWater() && MC.player.getY() < target.getY())
+				MC.player.push(0, 0.04, 0);
 			
 			// control height if flying
-			if(!MC.player.isOnGround()
+			if(!MC.player.onGround()
 				&& (MC.player.getAbilities().flying
 					|| WURST.getHax().flightHack.isEnabled())
-				&& MC.player.squaredDistanceTo(target.getX(), MC.player.getY(),
-					target.getZ()) <= MC.player.squaredDistanceTo(
-						MC.player.getX(), target.getY(), MC.player.getZ()))
+				&& MC.player.distanceToSqr(target.getX(), MC.player.getY(),
+					target.getZ()) <= MC.player.distanceToSqr(MC.player.getX(),
+						target.getY(), MC.player.getZ()))
 			{
 				if(MC.player.getY() > target.getY() + 1D)
-					MC.options.sneakKey.setPressed(true);
+					MC.options.keyShift.setDown(true);
 				else if(MC.player.getY() < target.getY() - 1D)
-					MC.options.jumpKey.setPressed(true);
+					MC.options.keyJump.setDown(true);
 			}else
 			{
-				MC.options.sneakKey.setPressed(false);
-				MC.options.jumpKey.setPressed(false);
+				MC.options.keyShift.setDown(false);
+				MC.options.keyJump.setDown(false);
 			}
 			
 			// follow target
 			WURST.getRotationFaker()
 				.faceVectorClient(target.getBoundingBox().getCenter());
-			MC.options.forwardKey.setPressed(MC.player.distanceTo(
+			MC.options.keyUp.setDown(MC.player.distanceTo(
 				target) > (target == friend ? distanceF : distanceE));
 		}
 		
@@ -285,14 +283,14 @@ public final class ProtectHack extends Hack
 				return;
 			
 			// attack enemy
-			MC.interactionManager.attackEntity(MC.player, enemy);
-			swingHand.swing(Hand.MAIN_HAND);
+			MC.gameMode.attack(MC.player, enemy);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 			speed.resetTimer();
 		}
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(!useAi.isChecked())
 			return;
@@ -314,7 +312,7 @@ public final class ProtectHack extends Hack
 		
 		public EntityPathFinder(Entity entity, double distance)
 		{
-			super(BlockPos.ofFloored(entity.getEntityPos()));
+			super(BlockPos.containing(entity.position()));
 			this.entity = entity;
 			distanceSq = distance * distance;
 			setThinkTime(1);
@@ -324,7 +322,7 @@ public final class ProtectHack extends Hack
 		protected boolean checkDone()
 		{
 			return done =
-				entity.squaredDistanceTo(Vec3d.ofCenter(current)) <= distanceSq;
+				entity.distanceToSqr(Vec3.atCenterOf(current)) <= distanceSq;
 		}
 		
 		@Override
diff --git a/src/main/java/net/wurstclient/hacks/QuickShulkerHack.java b/src/main/java/net/wurstclient/hacks/QuickShulkerHack.java
index e7e09c4ae..6903e6cdf 100644
--- a/src/main/java/net/wurstclient/hacks/QuickShulkerHack.java
+++ b/src/main/java/net/wurstclient/hacks/QuickShulkerHack.java
@@ -10,30 +10,29 @@ package net.wurstclient.hacks;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.block.ShulkerBoxBlock;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.ContainerComponent;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.BlockItem;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.tag.ItemTags;
-import net.minecraft.screen.ScreenHandler;
-import net.minecraft.screen.ShulkerBoxScreenHandler;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.ShulkerBoxMenu;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.component.ItemContainerContents;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -119,7 +118,7 @@ public final class QuickShulkerHack extends Hack
 	
 	public boolean hasUsableShulker()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(player == null)
 			return false;
 		
@@ -178,14 +177,14 @@ public final class QuickShulkerHack extends Hack
 	
 	private void runTask() throws InterruptedException
 	{
-		ClientPlayerEntity player = MC.player;
-		if(player == null || MC.world == null)
+		LocalPlayer player = MC.player;
+		if(player == null || MC.level == null)
 		{
 			ChatUtils.error("Player not available.");
 			return;
 		}
 		
-		PlayerInventory inv = player.getInventory();
+		Inventory inv = player.getInventory();
 		int originalSlot = inv.getSelectedSlot();
 		int shulkerSlot = findShulkerSlot(inv);
 		if(shulkerSlot == -1)
@@ -199,12 +198,12 @@ public final class QuickShulkerHack extends Hack
 		// inventory and remember which inventory slots increased. This
 		// lets us later only move those items into the placed shulker,
 		// leaving the rest of the player's inventory untouched.
-		ScreenHandler openHandler = player.currentScreenHandler;
+		AbstractContainerMenu openHandler = player.containerMenu;
 		int[] chestOriginSnapshot = null;
 		int[] chestAfterSnapshot = null;
 		Set<Integer> slotsFromChest = null;
 		boolean hadOpenContainer =
-			openHandler != null && openHandler != player.playerScreenHandler
+			openHandler != null && openHandler != player.inventoryMenu
 				&& hasExternalSlots(openHandler, inv);
 		if(hadOpenContainer)
 		{
@@ -264,7 +263,7 @@ public final class QuickShulkerHack extends Hack
 				try
 				{
 					WurstClient.INSTANCE.getRotationFaker()
-						.faceVectorClient(Vec3d.ofCenter(placePos));
+						.faceVectorClient(Vec3.atCenterOf(placePos));
 				}catch(Throwable ignored)
 				{}
 			});
@@ -276,7 +275,7 @@ public final class QuickShulkerHack extends Hack
 				return;
 			}
 			
-			ScreenHandler handler = waitForShulkerHandler(player, 3000);
+			AbstractContainerMenu handler = waitForShulkerHandler(player, 3000);
 			if(handler == null)
 			{
 				ChatUtils.error("Timed out waiting for shulker UI.");
@@ -312,7 +311,7 @@ public final class QuickShulkerHack extends Hack
 				{
 					if(s < 0 || s >= 36)
 						continue;
-					if(!inv.getStack(s).isEmpty())
+					if(!inv.getItem(s).isEmpty())
 					{
 						anyLeft = true;
 						break;
@@ -349,11 +348,12 @@ public final class QuickShulkerHack extends Hack
 		ChatUtils.message("QuickShulker finished.");
 	}
 	
-	private void transferItems(ClientPlayerEntity player, ScreenHandler handler,
-		Set<String> blacklistSet, Set<String> whitelistSet, TransferMode mode,
+	private void transferItems(LocalPlayer player,
+		AbstractContainerMenu handler, Set<String> blacklistSet,
+		Set<String> whitelistSet, TransferMode mode,
 		Set<Integer> protectedSlots) throws InterruptedException
 	{
-		PlayerInventory inv = player.getInventory();
+		Inventory inv = player.getInventory();
 		boolean useBl = useBlacklist.isChecked();
 		boolean useWl = useWhitelist.isChecked();
 		for(int slot = 0; slot < 36; slot++)
@@ -364,7 +364,7 @@ public final class QuickShulkerHack extends Hack
 			if(protectedSlots.contains(slot))
 				continue;
 			
-			ItemStack stack = inv.getStack(slot);
+			ItemStack stack = inv.getItem(slot);
 			if(stack.isEmpty())
 				continue;
 			
@@ -376,7 +376,8 @@ public final class QuickShulkerHack extends Hack
 			if(mode == TransferMode.NON_STACKABLE && stack.isStackable())
 				continue;
 			
-			String id = Registries.ITEM.getId(stack.getItem()).toString();
+			String id =
+				BuiltInRegistries.ITEM.getKey(stack.getItem()).toString();
 			if(useBl && blacklistSet.contains(id))
 				continue;
 			if(useWl && !whitelistSet.isEmpty() && !whitelistSet.contains(id))
@@ -387,11 +388,11 @@ public final class QuickShulkerHack extends Hack
 				continue;
 			
 			int before = stack.getCount();
-			MC.interactionManager.clickSlot(handler.syncId, handlerSlot, 0,
-				SlotActionType.QUICK_MOVE, player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId,
+				handlerSlot, 0, ClickType.QUICK_MOVE, player);
 			safeSleep(70);
 			
-			ItemStack after = inv.getStack(slot);
+			ItemStack after = inv.getItem(slot);
 			if(after.getCount() == before)
 				continue;
 			
@@ -404,13 +405,13 @@ public final class QuickShulkerHack extends Hack
 	 * Transfer only the specified player inventory slots into the open
 	 * shulker handler.
 	 */
-	private void transferItemsFromSlots(ClientPlayerEntity player,
-		ScreenHandler handler, Set<String> blacklistSet,
+	private void transferItemsFromSlots(LocalPlayer player,
+		AbstractContainerMenu handler, Set<String> blacklistSet,
 		Set<String> whitelistSet, TransferMode mode,
 		Set<Integer> protectedSlots, Set<Integer> slotsToTransfer)
 		throws InterruptedException
 	{
-		PlayerInventory inv = player.getInventory();
+		Inventory inv = player.getInventory();
 		boolean useBl = useBlacklist.isChecked();
 		boolean useWl = useWhitelist.isChecked();
 		for(int slot : slotsToTransfer)
@@ -424,7 +425,7 @@ public final class QuickShulkerHack extends Hack
 			if(slot < 0 || slot >= 36)
 				continue;
 			
-			ItemStack stack = inv.getStack(slot);
+			ItemStack stack = inv.getItem(slot);
 			if(stack.isEmpty())
 				continue;
 			
@@ -436,7 +437,8 @@ public final class QuickShulkerHack extends Hack
 			if(mode == TransferMode.NON_STACKABLE && stack.isStackable())
 				continue;
 			
-			String id = Registries.ITEM.getId(stack.getItem()).toString();
+			String id =
+				BuiltInRegistries.ITEM.getKey(stack.getItem()).toString();
 			if(useBl && blacklistSet.contains(id))
 				continue;
 			if(useWl && !whitelistSet.isEmpty() && !whitelistSet.contains(id))
@@ -447,11 +449,11 @@ public final class QuickShulkerHack extends Hack
 				continue;
 			
 			int before = stack.getCount();
-			MC.interactionManager.clickSlot(handler.syncId, handlerSlot, 0,
-				SlotActionType.QUICK_MOVE, player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId,
+				handlerSlot, 0, ClickType.QUICK_MOVE, player);
 			safeSleep(70);
 			
-			ItemStack after = inv.getStack(slot);
+			ItemStack after = inv.getItem(slot);
 			if(after.getCount() == before)
 				continue;
 			
@@ -460,22 +462,23 @@ public final class QuickShulkerHack extends Hack
 		}
 	}
 	
-	private boolean hasExternalSlots(ScreenHandler handler, PlayerInventory inv)
+	private boolean hasExternalSlots(AbstractContainerMenu handler,
+		Inventory inv)
 	{
 		for(Slot slot : handler.slots)
 		{
-			if(slot.inventory != inv)
+			if(slot.container != inv)
 				return true;
 		}
 		return false;
 	}
 	
-	private int[] snapshotInventory(PlayerInventory inv)
+	private int[] snapshotInventory(Inventory inv)
 	{
 		int[] arr = new int[36];
 		for(int i = 0; i < 36; i++)
 		{
-			ItemStack s = inv.getStack(i);
+			ItemStack s = inv.getItem(i);
 			arr[i] = s == null ? 0 : s.getCount();
 		}
 		return arr;
@@ -495,12 +498,12 @@ public final class QuickShulkerHack extends Hack
 		return set;
 	}
 	
-	private void moveItemsFromOpenContainerToPlayer(ClientPlayerEntity player,
-		ScreenHandler handler, TransferMode mode, java.util.List<String> bl,
-		java.util.List<String> wl, boolean useBl, boolean useWl)
-		throws InterruptedException
+	private void moveItemsFromOpenContainerToPlayer(LocalPlayer player,
+		AbstractContainerMenu handler, TransferMode mode,
+		java.util.List<String> bl, java.util.List<String> wl, boolean useBl,
+		boolean useWl) throws InterruptedException
 	{
-		PlayerInventory inv = player.getInventory();
+		Inventory inv = player.getInventory();
 		Set<String> blacklistSet = new HashSet<>(bl);
 		Set<String> whitelistSet = new HashSet<>(wl);
 		for(int i = 0; i < handler.slots.size(); i++)
@@ -509,9 +512,9 @@ public final class QuickShulkerHack extends Hack
 				throw new InterruptedException();
 			
 			Slot slot = handler.slots.get(i);
-			if(slot.inventory == inv)
+			if(slot.container == inv)
 				continue;
-			ItemStack stack = slot.getStack();
+			ItemStack stack = slot.getItem();
 			if(stack.isEmpty())
 				continue;
 			
@@ -523,44 +526,45 @@ public final class QuickShulkerHack extends Hack
 			if(mode == TransferMode.NON_STACKABLE && stack.isStackable())
 				continue;
 			
-			String id = Registries.ITEM.getId(stack.getItem()).toString();
+			String id =
+				BuiltInRegistries.ITEM.getKey(stack.getItem()).toString();
 			if(useBl && blacklistSet.contains(id))
 				continue;
 			if(useWl && !whitelistSet.isEmpty() && !whitelistSet.contains(id))
 				continue;
 			
-			MC.interactionManager.clickSlot(handler.syncId, i, 0,
-				SlotActionType.QUICK_MOVE, player);
+			MC.gameMode.handleInventoryMouseClick(handler.containerId, i, 0,
+				ClickType.QUICK_MOVE, player);
 			safeSleep(70);
 		}
 	}
 	
-	private boolean hasContainerSpace(ScreenHandler handler,
-		PlayerInventory playerInventory)
+	private boolean hasContainerSpace(AbstractContainerMenu handler,
+		Inventory playerInventory)
 	{
 		for(Slot slot : handler.slots)
 		{
-			if(slot.inventory == playerInventory)
+			if(slot.container == playerInventory)
 				continue;
-			if(!slot.hasStack())
+			if(!slot.hasItem())
 				return true;
 		}
 		return false;
 	}
 	
-	private int toHandlerSlot(ScreenHandler handler, PlayerInventory inv,
+	private int toHandlerSlot(AbstractContainerMenu handler, Inventory inv,
 		int playerSlot)
 	{
 		for(int i = 0; i < handler.slots.size(); i++)
 		{
 			Slot slot = handler.slots.get(i);
-			if(slot.inventory == inv && slot.getIndex() == playerSlot)
+			if(slot.container == inv && slot.getContainerSlot() == playerSlot)
 				return i;
 		}
 		return -1;
 	}
 	
-	private ScreenHandler waitForShulkerHandler(ClientPlayerEntity player,
+	private AbstractContainerMenu waitForShulkerHandler(LocalPlayer player,
 		long timeoutMs) throws InterruptedException
 	{
 		long deadline = System.currentTimeMillis() + timeoutMs;
@@ -569,9 +573,9 @@ public final class QuickShulkerHack extends Hack
 			if(Thread.interrupted())
 				throw new InterruptedException();
 			
-			ScreenHandler current = player.currentScreenHandler;
-			if(current instanceof ShulkerBoxScreenHandler handler
-				&& current != player.playerScreenHandler)
+			AbstractContainerMenu current = player.containerMenu;
+			if(current instanceof ShulkerBoxMenu handler
+				&& current != player.inventoryMenu)
 				return handler;
 			
 			safeSleep(50);
@@ -590,11 +594,11 @@ public final class QuickShulkerHack extends Hack
 				try
 				{
 					BlockHitResult hit = new BlockHitResult(
-						Vec3d.ofCenter(fpos), Direction.UP, fpos, false);
-					ActionResult result =
-						WurstClient.MC.interactionManager.interactBlock(
-							WurstClient.MC.player, Hand.MAIN_HAND, hit);
-					accepted[0] = result.isAccepted();
+						Vec3.atCenterOf(fpos), Direction.UP, fpos, false);
+					InteractionResult result =
+						WurstClient.MC.gameMode.useItemOn(WurstClient.MC.player,
+							InteractionHand.MAIN_HAND, hit);
+					accepted[0] = result.consumesAction();
 				}catch(Throwable ignored)
 				{
 					accepted[0] = false;
@@ -636,7 +640,7 @@ public final class QuickShulkerHack extends Hack
 		return BlockUtils.getBlock(pos) instanceof ShulkerBoxBlock;
 	}
 	
-	private void closeCurrentScreen(ClientPlayerEntity player)
+	private void closeCurrentScreen(LocalPlayer player)
 	{
 		// Close current screen on the client thread and wait for it to be
 		// actually closed. This prevents the mouse/input from staying
@@ -644,14 +648,14 @@ public final class QuickShulkerHack extends Hack
 		if(WurstClient.MC == null)
 			return;
 		
-		if(WurstClient.MC.currentScreen == null)
+		if(WurstClient.MC.screen == null)
 			return;
 		
 		WurstClient.MC.execute(() -> {
 			try
 			{
 				if(WurstClient.MC.player != null)
-					WurstClient.MC.player.closeHandledScreen();
+					WurstClient.MC.player.closeContainer();
 			}catch(Throwable ignored)
 			{}
 		});
@@ -664,7 +668,7 @@ public final class QuickShulkerHack extends Hack
 				Thread.currentThread().interrupt();
 				return;
 			}
-			if(WurstClient.MC.currentScreen == null)
+			if(WurstClient.MC.screen == null)
 				return;
 			try
 			{
@@ -677,7 +681,7 @@ public final class QuickShulkerHack extends Hack
 		}
 	}
 	
-	private ItemSwap bringSlotToHand(PlayerInventory inv, int sourceSlot,
+	private ItemSwap bringSlotToHand(Inventory inv, int sourceSlot,
 		int targetHotbarSlot)
 	{
 		if(sourceSlot == -1)
@@ -696,7 +700,7 @@ public final class QuickShulkerHack extends Hack
 		return new ItemSwap(targetHotbarSlot, sourceSlot, true);
 	}
 	
-	private void restoreSwap(PlayerInventory inv, ItemSwap swap)
+	private void restoreSwap(Inventory inv, ItemSwap swap)
 	{
 		if(!swap.success())
 			return;
@@ -711,27 +715,27 @@ public final class QuickShulkerHack extends Hack
 		inv.setSelectedSlot(swap.restoreSlot);
 	}
 	
-	private BlockPos findPlacementPos(ClientPlayerEntity player)
+	private BlockPos findPlacementPos(LocalPlayer player)
 	{
-		BlockPos base = player.getBlockPos();
-		Direction facing = player.getHorizontalFacing();
-		BlockPos[] candidates = new BlockPos[]{base.offset(facing),
-			base.offset(facing.rotateYClockwise()),
-			base.offset(facing.rotateYCounterclockwise()),
-			base.offset(facing.getOpposite()), base.up(), base.down()};
+		BlockPos base = player.blockPosition();
+		Direction facing = player.getDirection();
+		BlockPos[] candidates = new BlockPos[]{base.relative(facing),
+			base.relative(facing.getClockWise()),
+			base.relative(facing.getCounterClockWise()),
+			base.relative(facing.getOpposite()), base.above(), base.below()};
 		
-		Box playerBox = player.getBoundingBox();
+		AABB playerBox = player.getBoundingBox();
 		for(BlockPos pos : candidates)
 		{
 			BlockState state = BlockUtils.getState(pos);
-			if(!state.isReplaceable())
+			if(!state.canBeReplaced())
 				continue;
 			
-			BlockState below = BlockUtils.getState(pos.down());
+			BlockState below = BlockUtils.getState(pos.below());
 			if(below.isAir())
 				continue;
 			
-			Box blockBox = new Box(pos);
+			AABB blockBox = new AABB(pos);
 			if(blockBox.intersects(playerBox))
 				continue;
 			
@@ -741,11 +745,11 @@ public final class QuickShulkerHack extends Hack
 		return null;
 	}
 	
-	private int findShulkerSlot(PlayerInventory inv)
+	private int findShulkerSlot(Inventory inv)
 	{
-		for(int slot = 0; slot < inv.size(); slot++)
+		for(int slot = 0; slot < inv.getContainerSize(); slot++)
 		{
-			ItemStack stack = inv.getStack(slot);
+			ItemStack stack = inv.getItem(slot);
 			if(stack.isEmpty())
 				continue;
 			if(!isShulkerItem(stack))
@@ -756,14 +760,14 @@ public final class QuickShulkerHack extends Hack
 		return -1;
 	}
 	
-	private int findPickaxeSlot(PlayerInventory inv)
+	private int findPickaxeSlot(Inventory inv)
 	{
 		int bestSlot = -1;
 		int bestPriority = -1;
-		for(int slot = 0; slot < inv.size(); slot++)
+		for(int slot = 0; slot < inv.getContainerSize(); slot++)
 		{
-			ItemStack stack = inv.getStack(slot);
-			if(stack.isEmpty() || !stack.isIn(ItemTags.PICKAXES))
+			ItemStack stack = inv.getItem(slot);
+			if(stack.isEmpty() || !stack.is(ItemTags.PICKAXES))
 				continue;
 			
 			int priority = getPickaxePriority(stack.getItem());
@@ -799,13 +803,12 @@ public final class QuickShulkerHack extends Hack
 	
 	private boolean isShulkerFull(ItemStack shulker)
 	{
-		ContainerComponent container =
-			shulker.get(DataComponentTypes.CONTAINER);
+		ItemContainerContents container = shulker.get(DataComponents.CONTAINER);
 		if(container == null)
 			return false;
 		
 		int occupied = 0;
-		for(ItemStack stack : container.iterateNonEmpty())
+		for(ItemStack stack : container.nonEmptyItems())
 		{
 			if(stack.isEmpty())
 				continue;
diff --git a/src/main/java/net/wurstclient/hacks/RadarHack.java b/src/main/java/net/wurstclient/hacks/RadarHack.java
index 5bd397769..a0c384e4a 100644
--- a/src/main/java/net/wurstclient/hacks/RadarHack.java
+++ b/src/main/java/net/wurstclient/hacks/RadarHack.java
@@ -12,11 +12,10 @@ import java.util.Collections;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.clickgui.Window;
@@ -83,16 +82,16 @@ public final class RadarHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
-		ClientWorld world = MC.world;
+		LocalPlayer player = MC.player;
+		ClientLevel world = MC.level;
 		
 		entities.clear();
-		Stream<Entity> stream =
-			StreamSupport.stream(world.getEntities().spliterator(), true)
-				.filter(e -> !e.isRemoved() && e != player)
-				.filter(e -> !(e instanceof FakePlayerEntity))
-				.filter(LivingEntity.class::isInstance)
-				.filter(e -> ((LivingEntity)e).getHealth() > 0);
+		Stream<Entity> stream = StreamSupport
+			.stream(world.entitiesForRendering().spliterator(), true)
+			.filter(e -> !e.isRemoved() && e != player)
+			.filter(e -> !(e instanceof FakePlayerEntity))
+			.filter(LivingEntity.class::isInstance)
+			.filter(e -> ((LivingEntity)e).getHealth() > 0);
 		
 		stream = entityFilters.applyTo(stream);
 		
diff --git a/src/main/java/net/wurstclient/hacks/RedstoneEspHack.java b/src/main/java/net/wurstclient/hacks/RedstoneEspHack.java
index ecf0f45c6..ff50b1f50 100644
--- a/src/main/java/net/wurstclient/hacks/RedstoneEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/RedstoneEspHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -14,15 +15,13 @@ import java.util.List;
 import java.util.Set;
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -243,7 +242,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 	{
 		groupsUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMatchesVersion = coordinator.getMatchesVersion();
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
@@ -277,7 +276,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -306,7 +305,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(style.getSelected().hasBoxes())
 			renderBoxes(matrixStack);
@@ -314,13 +313,13 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(RenderGroup group : renderGroups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			RenderUtils.drawSolidBoxes(matrixStack, boxes, quadsColor, false);
@@ -329,14 +328,14 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(RenderGroup group : renderGroups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
 				false);
@@ -387,7 +386,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 		
 		void clear();
 		
-		List<Box> getBoxes();
+		List<AABB> getBoxes();
 		
 		int getColorI(int alpha);
 		
@@ -424,7 +423,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 			}
 			
 			@Override
-			public List<Box> getBoxes()
+			public List<AABB> getBoxes()
 			{
 				return g.getBoxes();
 			}
@@ -446,7 +445,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 	// Group that matches any of multiple blocks
 	private static final class MultiBlockEspGroup implements RenderGroup
 	{
-		private final ArrayList<Box> boxes = new ArrayList<>();
+		private final ArrayList<AABB> boxes = new ArrayList<>();
 		private final Set<Block> blocks;
 		private final ColorSetting color;
 		private final CheckboxSetting enabled;
@@ -478,8 +477,8 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 				return;
 			if(!net.wurstclient.util.BlockUtils.canBeClicked(pos))
 				return;
-			Box box = net.wurstclient.util.BlockUtils.getBoundingBox(pos);
-			if(box.getAverageSideLength() == 0)
+			AABB box = net.wurstclient.util.BlockUtils.getBoundingBox(pos);
+			if(box.getSize() == 0)
 				return;
 			boxes.add(box);
 		}
@@ -491,7 +490,7 @@ public final class RedstoneEspHack extends Hack implements UpdateListener,
 		}
 		
 		@Override
-		public List<Box> getBoxes()
+		public List<AABB> getBoxes()
 		{
 			return java.util.Collections.unmodifiableList(boxes);
 		}
diff --git a/src/main/java/net/wurstclient/hacks/RemoteViewHack.java b/src/main/java/net/wurstclient/hacks/RemoteViewHack.java
index 720858b0a..dcdfa39ca 100644
--- a/src/main/java/net/wurstclient/hacks/RemoteViewHack.java
+++ b/src/main/java/net/wurstclient/hacks/RemoteViewHack.java
@@ -10,11 +10,10 @@ package net.wurstclient.hacks;
 import java.util.Comparator;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -53,7 +52,7 @@ public final class RemoteViewHack extends Hack
 		if(entity == null)
 		{
 			Stream<Entity> stream = StreamSupport
-				.stream(MC.world.getEntities().spliterator(), true)
+				.stream(MC.level.entitiesForRendering().spliterator(), true)
 				.filter(LivingEntity.class::isInstance)
 				.filter(
 					e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
@@ -63,8 +62,8 @@ public final class RemoteViewHack extends Hack
 			stream = entityFilters.applyTo(stream);
 			
 			entity = stream
-				.min(Comparator
-					.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+				.min(
+					Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 				.orElse(null);
 			
 			// check if entity was found
@@ -80,7 +79,7 @@ public final class RemoteViewHack extends Hack
 		wasInvisible = entity.isInvisible();
 		
 		// enable NoClip
-		MC.player.noClip = true;
+		MC.player.noPhysics = true;
 		
 		// spawn fake player
 		fakePlayer = new FakePlayerEntity();
@@ -110,7 +109,7 @@ public final class RemoteViewHack extends Hack
 		}
 		
 		// disable NoClip
-		MC.player.noClip = false;
+		MC.player.noPhysics = false;
 		
 		// remove fake player
 		if(fakePlayer != null)
@@ -126,15 +125,15 @@ public final class RemoteViewHack extends Hack
 		if(!isEnabled() && viewName != null && !viewName.isEmpty())
 		{
 			entity = StreamSupport
-				.stream(MC.world.getEntities().spliterator(), false)
+				.stream(MC.level.entitiesForRendering().spliterator(), false)
 				.filter(LivingEntity.class::isInstance)
 				.filter(
 					e -> !e.isRemoved() && ((LivingEntity)e).getHealth() > 0)
 				.filter(e -> e != MC.player)
 				.filter(e -> !(e instanceof FakePlayerEntity))
 				.filter(e -> viewName.equalsIgnoreCase(e.getName().getString()))
-				.min(Comparator
-					.comparingDouble(e -> MC.player.squaredDistanceTo(e)))
+				.min(
+					Comparator.comparingDouble(e -> MC.player.distanceToSqr(e)))
 				.orElse(null);
 			
 			if(entity == null)
@@ -160,13 +159,13 @@ public final class RemoteViewHack extends Hack
 		}
 		
 		// update position, rotation, etc.
-		MC.player.copyPositionAndRotation(entity);
-		MC.player.setPos(entity.getX(),
+		MC.player.copyPosition(entity);
+		MC.player.setPosRaw(entity.getX(),
 			entity.getY() - MC.player.getEyeHeight(MC.player.getPose())
 				+ entity.getEyeHeight(entity.getPose()),
 			entity.getZ());
-		MC.player.resetPosition();
-		MC.player.setVelocity(Vec3d.ZERO);
+		MC.player.setOldPosAndRot();
+		MC.player.setDeltaMovement(Vec3.ZERO);
 		
 		// set entity invisible
 		entity.setInvisible(true);
@@ -175,7 +174,7 @@ public final class RemoteViewHack extends Hack
 	@Override
 	public void onSentPacket(PacketOutputEvent event)
 	{
-		if(event.getPacket() instanceof PlayerMoveC2SPacket)
+		if(event.getPacket() instanceof ServerboundMovePlayerPacket)
 			event.cancel();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/RestockHack.java b/src/main/java/net/wurstclient/hacks/RestockHack.java
index 0ddf5cde4..01a6ae725 100644
--- a/src/main/java/net/wurstclient/hacks/RestockHack.java
+++ b/src/main/java/net/wurstclient/hacks/RestockHack.java
@@ -12,11 +12,10 @@ import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -30,7 +29,7 @@ import net.wurstclient.util.InventoryUtils;
 @SearchTags({"AutoRestock", "auto-restock", "auto restock"})
 public final class RestockHack extends Hack implements UpdateListener
 {
-	public static final int OFFHAND_ID = PlayerInventory.OFF_HAND_SLOT;
+	public static final int OFFHAND_ID = Inventory.SLOT_OFFHAND;
 	public static final int OFFHAND_PKT_ID = 45;
 	
 	private static final List<Integer> SEARCH_SLOTS =
@@ -82,10 +81,10 @@ public final class RestockHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// Don't mess with the inventory while it's open.
-		if(MC.currentScreen instanceof HandledScreen)
+		if(MC.screen instanceof AbstractContainerScreen)
 			return;
 		
-		PlayerInventory inv = MC.player.getInventory();
+		Inventory inv = MC.player.getInventory();
 		IClientPlayerInteractionManager im = IMC.getInteractionManager();
 		
 		int hotbarSlot = restockSlot.getValueI();
@@ -96,12 +95,12 @@ public final class RestockHack extends Hack implements UpdateListener
 		
 		for(String itemName : items.getItemNames())
 		{
-			ItemStack hotbarStack = inv.getStack(hotbarSlot);
+			ItemStack hotbarStack = inv.getItem(hotbarSlot);
 			
 			boolean wrongItem =
 				hotbarStack.isEmpty() || !itemEqual(itemName, hotbarStack);
 			if(!wrongItem && hotbarStack.getCount() >= Math
-				.min(restockAmount.getValueI(), hotbarStack.getMaxCount()))
+				.min(restockAmount.getValueI(), hotbarStack.getMaxStackSize()))
 				return;
 			
 			List<Integer> searchResult =
@@ -112,10 +111,10 @@ public final class RestockHack extends Hack implements UpdateListener
 				
 				im.windowClick_PICKUP(pickupIndex);
 				im.windowClick_PICKUP(InventoryUtils.toNetworkSlot(hotbarSlot));
-				if(!MC.player.playerScreenHandler.getCursorStack().isEmpty())
+				if(!MC.player.inventoryMenu.getCarried().isEmpty())
 					im.windowClick_PICKUP(pickupIndex);
 				
-				if(hotbarStack.getCount() >= hotbarStack.getMaxCount())
+				if(hotbarStack.getCount() >= hotbarStack.getMaxStackSize())
 					break;
 			}
 			
@@ -125,16 +124,16 @@ public final class RestockHack extends Hack implements UpdateListener
 			break;
 		}
 		
-		ItemStack restockStack = inv.getStack(hotbarSlot);
-		if(repairMode.getValueI() > 0 && restockStack.isDamageable()
+		ItemStack restockStack = inv.getItem(hotbarSlot);
+		if(repairMode.getValueI() > 0 && restockStack.isDamageableItem()
 			&& isTooDamaged(restockStack))
 			for(int i : SEARCH_SLOTS)
 			{
 				if(i == hotbarSlot || i == OFFHAND_ID)
 					continue;
 				
-				ItemStack stack = inv.getStack(i);
-				if(stack.isEmpty() || !stack.isDamageable())
+				ItemStack stack = inv.getItem(i);
+				if(stack.isEmpty() || !stack.isDamageableItem())
 				{
 					IMC.getInteractionManager().windowClick_SWAP(i,
 						InventoryUtils.toNetworkSlot(hotbarSlot));
@@ -145,7 +144,7 @@ public final class RestockHack extends Hack implements UpdateListener
 	
 	private boolean isTooDamaged(ItemStack stack)
 	{
-		return stack.getMaxDamage() - stack.getDamage() <= repairMode
+		return stack.getMaxDamage() - stack.getDamageValue() <= repairMode
 			.getValueI();
 	}
 	
@@ -158,7 +157,7 @@ public final class RestockHack extends Hack implements UpdateListener
 			if(i == slotToSkip)
 				continue;
 			
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			if(stack.isEmpty())
 				continue;
 			
@@ -171,11 +170,11 @@ public final class RestockHack extends Hack implements UpdateListener
 	
 	private boolean itemEqual(String itemName, ItemStack stack)
 	{
-		if(repairMode.getValueI() > 0 && stack.isDamageable()
+		if(repairMode.getValueI() > 0 && stack.isDamageableItem()
 			&& isTooDamaged(stack))
 			return false;
 		
-		return Registries.ITEM.getId(stack.getItem()).toString()
+		return BuiltInRegistries.ITEM.getKey(stack.getItem()).toString()
 			.equals(itemName);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/SafeTpHack.java b/src/main/java/net/wurstclient/hacks/SafeTpHack.java
index daf8b6636..720d5f343 100644
--- a/src/main/java/net/wurstclient/hacks/SafeTpHack.java
+++ b/src/main/java/net/wurstclient/hacks/SafeTpHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.ChatInputListener;
@@ -87,7 +87,7 @@ public final class SafeTpHack extends Hack
 			return;
 		}
 		
-		ClientPlayNetworkHandler netHandler = MC.getNetworkHandler();
+		ClientPacketListener netHandler = MC.getConnection();
 		if(netHandler == null)
 		{
 			setEnabled(false);
@@ -131,7 +131,7 @@ public final class SafeTpHack extends Hack
 			return;
 		}
 		
-		netHandler.sendChatCommand(commandToSend);
+		netHandler.sendCommand(commandToSend);
 		
 		EVENTS.add(UpdateListener.class, this);
 	}
@@ -170,10 +170,10 @@ public final class SafeTpHack extends Hack
 			|| (message.contains("akzeptiert") && message.contains("anfrage")))
 		{
 			ChatUtils.message("SaferTPAHere: TPA acceptance detected.");
-			if(MC.player == null || MC.getNetworkHandler() == null)
+			if(MC.player == null || MC.getConnection() == null)
 				return;
 			
-			trapPos = BlockPos.ofFloored(MC.player.getEntityPos());
+			trapPos = BlockPos.containing(MC.player.position());
 			
 			BlinkHack blinkHack = WURST.getHax().blinkHack;
 			boolean blinkAlready = blinkHack.isEnabled();
@@ -214,18 +214,16 @@ public final class SafeTpHack extends Hack
 	{
 		if(trapPos != null)
 		{
-			for(net.minecraft.entity.player.PlayerEntity p : MC.world
-				.getPlayers())
+			for(net.minecraft.world.entity.player.Player p : MC.level.players())
 			{
 				if(p == MC.player)
 					continue;
 				if(p instanceof net.wurstclient.util.FakePlayerEntity)
 					continue;
 				
-				BlockPos pPos = p.getBlockPos();
-				if(pPos.equals(trapPos)
-					|| p.squaredDistanceTo(trapPos.getX() + 0.5, trapPos.getY(),
-						trapPos.getZ() + 0.5) < 1.5)
+				BlockPos pPos = p.blockPosition();
+				if(pPos.equals(trapPos) || p.distanceToSqr(trapPos.getX() + 0.5,
+					trapPos.getY(), trapPos.getZ() + 0.5) < 1.5)
 				{
 					BlinkHack blinkHack = WURST.getHax().blinkHack;
 					if(weActivatedBlinkForTpa && blinkHack.isEnabled())
@@ -268,7 +266,7 @@ public final class SafeTpHack extends Hack
 			}
 		}
 		
-		if(MC.player == null || MC.getNetworkHandler() == null)
+		if(MC.player == null || MC.getConnection() == null)
 		{
 			setEnabled(false);
 			return;
diff --git a/src/main/java/net/wurstclient/hacks/SafeWalkHack.java b/src/main/java/net/wurstclient/hacks/SafeWalkHack.java
index a2216aba3..5938366e7 100644
--- a/src/main/java/net/wurstclient/hacks/SafeWalkHack.java
+++ b/src/main/java/net/wurstclient/hacks/SafeWalkHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -56,9 +56,9 @@ public final class SafeWalkHack extends Hack
 	
 	public void onClipAtLedge(boolean clipping)
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
-		if(!isEnabled() || !sneak.isChecked() || !player.isOnGround())
+		if(!isEnabled() || !sneak.isChecked() || !player.onGround())
 		{
 			if(sneaking)
 				setSneaking(false);
@@ -66,11 +66,11 @@ public final class SafeWalkHack extends Hack
 			return;
 		}
 		
-		Box box = player.getBoundingBox();
-		Box adjustedBox = box.stretch(0, -player.getStepHeight(), 0)
-			.expand(-edgeDistance.getValue(), 0, -edgeDistance.getValue());
+		AABB box = player.getBoundingBox();
+		AABB adjustedBox = box.expandTowards(0, -player.maxUpStep(), 0)
+			.inflate(-edgeDistance.getValue(), 0, -edgeDistance.getValue());
 		
-		if(MC.world.isSpaceEmpty(player, adjustedBox))
+		if(MC.level.noCollision(player, adjustedBox))
 			clipping = true;
 		
 		setSneaking(clipping);
@@ -78,7 +78,7 @@ public final class SafeWalkHack extends Hack
 	
 	private void setSneaking(boolean sneaking)
 	{
-		IKeyBinding sneakKey = IKeyBinding.get(MC.options.sneakKey);
+		IKeyBinding sneakKey = IKeyBinding.get(MC.options.keyShift);
 		
 		if(sneaking)
 			sneakKey.setPressed(true);
diff --git a/src/main/java/net/wurstclient/hacks/ScaffoldWalkHack.java b/src/main/java/net/wurstclient/hacks/ScaffoldWalkHack.java
index d72018cc5..87d9b2fcb 100644
--- a/src/main/java/net/wurstclient/hacks/ScaffoldWalkHack.java
+++ b/src/main/java/net/wurstclient/hacks/ScaffoldWalkHack.java
@@ -8,18 +8,17 @@
 package net.wurstclient.hacks;
 
 import java.util.Arrays;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.FallingBlock;
-import net.minecraft.block.ShulkerBoxBlock;
-import net.minecraft.item.BlockItem;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.EmptyBlockView;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.EmptyBlockGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.FallingBlock;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -53,10 +52,10 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		BlockPos belowPlayer =
-			BlockPos.ofFloored(MC.player.getEntityPos()).down();
+			BlockPos.containing(MC.player.position()).below();
 		
 		// check if block is already placed
-		if(!BlockUtils.getState(belowPlayer).isReplaceable())
+		if(!BlockUtils.getState(belowPlayer).canBeReplaced())
 			return;
 		
 		// search blocks in hotbar
@@ -64,14 +63,15 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 		for(int i = 0; i < 9; i++)
 		{
 			// filter out non-block items
-			ItemStack stack = MC.player.getInventory().getStack(i);
+			ItemStack stack = MC.player.getInventory().getItem(i);
 			if(stack.isEmpty() || !(stack.getItem() instanceof BlockItem))
 				continue;
 			
 			// filter out non-solid blocks
-			Block block = Block.getBlockFromItem(stack.getItem());
-			BlockState state = block.getDefaultState();
-			if(!state.isFullCube(EmptyBlockView.INSTANCE, BlockPos.ORIGIN))
+			Block block = Block.byItem(stack.getItem());
+			BlockState state = block.defaultBlockState();
+			if(!state.isCollisionShapeFullBlock(EmptyBlockGetter.INSTANCE,
+				BlockPos.ZERO))
 				continue;
 			
 			if(block instanceof ShulkerBoxBlock)
@@ -79,7 +79,7 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 			
 			// filter out blocks that would fall
 			if(block instanceof FallingBlock && FallingBlock
-				.canFallThrough(BlockUtils.getState(belowPlayer.down())))
+				.isFree(BlockUtils.getState(belowPlayer.below())))
 				continue;
 			
 			newSlot = i;
@@ -111,7 +111,7 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 		Direction[] sides = Direction.values();
 		for(Direction side : sides)
 		{
-			BlockPos neighbor = belowPlayer.offset(side);
+			BlockPos neighbor = belowPlayer.relative(side);
 			if(placeBlock(neighbor))
 				return;
 		}
@@ -124,7 +124,7 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 				if(side.getOpposite().equals(side2))
 					continue;
 				
-				BlockPos neighbor = belowPlayer.offset(side).offset(side2);
+				BlockPos neighbor = belowPlayer.relative(side).relative(side2);
 				if(placeBlock(neighbor))
 					return;
 			}
@@ -132,35 +132,35 @@ public final class ScaffoldWalkHack extends Hack implements UpdateListener
 	
 	private boolean placeBlock(BlockPos pos)
 	{
-		Vec3d eyesPos = RotationUtils.getEyesPos();
+		Vec3 eyesPos = RotationUtils.getEyesPos();
 		
 		for(Direction side : Direction.values())
 		{
-			BlockPos neighbor = pos.offset(side);
+			BlockPos neighbor = pos.relative(side);
 			Direction side2 = side.getOpposite();
 			
 			// check if side is visible (facing away from player)
-			if(eyesPos.squaredDistanceTo(Vec3d.ofCenter(pos)) >= eyesPos
-				.squaredDistanceTo(Vec3d.ofCenter(neighbor)))
+			if(eyesPos.distanceToSqr(Vec3.atCenterOf(pos)) >= eyesPos
+				.distanceToSqr(Vec3.atCenterOf(neighbor)))
 				continue;
 			
 			// check if neighbor can be right clicked
 			if(!BlockUtils.canBeClicked(neighbor))
 				continue;
 			
-			Vec3d hitVec = Vec3d.ofCenter(neighbor)
-				.add(Vec3d.of(side2.getVector()).multiply(0.5));
+			Vec3 hitVec = Vec3.atCenterOf(neighbor)
+				.add(Vec3.atLowerCornerOf(side2.getUnitVec3i()).scale(0.5));
 			
 			// check if hitVec is within range (4.25 blocks)
-			if(eyesPos.squaredDistanceTo(hitVec) > 18.0625)
+			if(eyesPos.distanceToSqr(hitVec) > 18.0625)
 				continue;
 			
 			// place block
 			RotationUtils.getNeededRotations(hitVec).sendPlayerLookPacket();
 			IMC.getInteractionManager().rightClickBlock(neighbor, side2,
 				hitVec);
-			MC.player.swingHand(Hand.MAIN_HAND);
-			MC.itemUseCooldown = 4;
+			MC.player.swing(InteractionHand.MAIN_HAND);
+			MC.rightClickDelay = 4;
 			
 			return true;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/SearchHack.java b/src/main/java/net/wurstclient/hacks/SearchHack.java
index 1174a640e..47f510a8e 100644
--- a/src/main/java/net/wurstclient/hacks/SearchHack.java
+++ b/src/main/java/net/wurstclient/hacks/SearchHack.java
@@ -7,6 +7,9 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -15,16 +18,11 @@ import java.util.Arrays;
 import java.util.PriorityQueue;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.ForkJoinTask;
-
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.block.Block;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstRenderLayers;
@@ -127,7 +125,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 	private RegionPos bufferRegion;
 	private boolean bufferUpToDate;
 	// Precomputed tracer endpoints
-	private java.util.List<net.minecraft.util.math.Vec3d> tracerEnds;
+	private java.util.List<net.minecraft.world.phys.Vec3> tracerEnds;
 	private ChunkPos lastPlayerChunk;
 	private int lastMatchesVersion;
 	
@@ -197,7 +195,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 		forkJoinPool = new ForkJoinPool();
 		bufferUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMode = mode.getSelected();
 		lastListHash = blockList.getBlockNames().hashCode();
 		applySearchCriteria(block.getBlock(), "");
@@ -250,7 +248,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 		}
 		
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -327,7 +325,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		boolean drawBoxes =
 			style.hasBoxes() && vertexBuffer != null && bufferRegion != null;
@@ -342,11 +340,11 @@ public final class SearchHack extends Hack implements UpdateListener,
 		
 		if(drawBoxes)
 		{
-			matrixStack.push();
+			matrixStack.pushPose();
 			RenderUtils.applyRegionalRenderOffset(matrixStack, bufferRegion);
 			vertexBuffer.draw(matrixStack, WurstRenderLayers.ESP_QUADS, rgb,
 				0.5F);
-			matrixStack.pop();
+			matrixStack.popPose();
 		}
 		
 		if(drawTracers)
@@ -392,8 +390,8 @@ public final class SearchHack extends Hack implements UpdateListener,
 				String raw = s.trim();
 				if(raw.isEmpty())
 					continue;
-				Identifier id = Identifier.tryParse(raw);
-				if(id != null && Registries.BLOCK.containsId(id))
+				ResourceLocation id = ResourceLocation.tryParse(raw);
+				if(id != null && BuiltInRegistries.BLOCK.containsKey(id))
 					exact.add(id.toString());
 				else
 					kw.add(raw.toLowerCase(Locale.ROOT));
@@ -410,7 +408,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 				String localId = idFull.contains(":")
 					? idFull.substring(idFull.indexOf(":") + 1) : idFull;
 				String localSpaced = localId.replace('_', ' ');
-				String transKey = state.getBlock().getTranslationKey();
+				String transKey = state.getBlock().getDescriptionId();
 				String display = state.getBlock().getName().getString();
 				for(String term : listKeywords)
 				{
@@ -461,7 +459,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 		if(terms.length == 0)
 			terms = new String[]{normalizedQuery};
 		String localSpaced = localId.replace('_', ' ');
-		String transKey = block.getTranslationKey();
+		String transKey = block.getDescriptionId();
 		String display = block.getName().getString();
 		for(String term : terms)
 			if(containsNormalized(id, term) || containsNormalized(localId, term)
@@ -483,12 +481,12 @@ public final class SearchHack extends Hack implements UpdateListener,
 		// Use a bounded max-heap to keep only the closest N matches without
 		// sorting the entire result set. This avoids long pauses when scanning
 		// very large areas.
-		BlockPos eyesPos = BlockPos.ofFloored(RotationUtils.getEyesPos());
+		BlockPos eyesPos = BlockPos.containing(RotationUtils.getEyesPos());
 		final int limitCount = limit.getValueLog();
 		getMatchingBlocksTask = forkJoinPool.submit(() -> {
 			PriorityQueue<BlockPos> heap = new PriorityQueue<>((limitCount + 1),
-				(a, b) -> Integer.compare(b.getManhattanDistance(eyesPos),
-					a.getManhattanDistance(eyesPos)));
+				(a, b) -> Integer.compare(b.distManhattan(eyesPos),
+					a.distManhattan(eyesPos)));
 			java.util.Iterator<ChunkSearcher.Result> it =
 				coordinator.getReadyMatches().iterator();
 			while(it.hasNext())
@@ -497,8 +495,8 @@ public final class SearchHack extends Hack implements UpdateListener,
 				BlockPos pos = r.pos();
 				if(heap.size() < limitCount)
 					heap.offer(pos);
-				else if(pos.getManhattanDistance(eyesPos) < heap.peek()
-					.getManhattanDistance(eyesPos))
+				else if(pos.distManhattan(eyesPos) < heap.peek()
+					.distManhattan(eyesPos))
 				{
 					heap.poll();
 					heap.offer(pos);
@@ -534,11 +532,11 @@ public final class SearchHack extends Hack implements UpdateListener,
 		RegionPos region = RenderUtils.getCameraRegion();
 		if(vertexBuffer != null)
 			vertexBuffer.close();
-		vertexBuffer = EasyVertexBuffer.createAndUpload(DrawMode.QUADS,
-			VertexFormats.POSITION_COLOR, buffer -> {
+		vertexBuffer = EasyVertexBuffer.createAndUpload(Mode.QUADS,
+			DefaultVertexFormat.POSITION_COLOR, buffer -> {
 				for(int[] vertex : vertices)
-					buffer.vertex(vertex[0] - region.x(), vertex[1],
-						vertex[2] - region.z()).color(0xFFFFFFFF);
+					buffer.addVertex(vertex[0] - region.x(), vertex[1],
+						vertex[2] - region.z()).setColor(0xFFFFFFFF);
 			});
 		bufferUpToDate = true;
 		bufferRegion = region;
@@ -549,7 +547,7 @@ public final class SearchHack extends Hack implements UpdateListener,
 				if(net.wurstclient.util.BlockUtils.canBeClicked(pos))
 					return net.wurstclient.util.BlockUtils.getBoundingBox(pos)
 						.getCenter();
-				return pos.toCenterPos();
+				return pos.getCenter();
 			}).collect(java.util.stream.Collectors.toList());
 			// update count for HUD (clamped to 999)
 			foundCount = Math.min(lastMatchingBlocks.size(), 999);
diff --git a/src/main/java/net/wurstclient/hacks/SignEspHack.java b/src/main/java/net/wurstclient/hacks/SignEspHack.java
index 7bbaf7714..57b481866 100644
--- a/src/main/java/net/wurstclient/hacks/SignEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/SignEspHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -14,16 +15,14 @@ import java.util.List;
 import java.util.Objects;
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
-
-import net.minecraft.block.AbstractSignBlock;
-import net.minecraft.block.BlockState;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.entity.decoration.ItemFrameEntity;
-import net.minecraft.entity.decoration.GlowItemFrameEntity;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.decoration.GlowItemFrame;
+import net.minecraft.world.entity.decoration.ItemFrame;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.SignBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -79,7 +78,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 		"Appends the number of found signs/frames to this hack's entry in the HackList.",
 		false);
 	private final BiPredicate<BlockPos, BlockState> query =
-		(pos, state) -> state.getBlock() instanceof AbstractSignBlock;
+		(pos, state) -> state.getBlock() instanceof SignBlock;
 	private final ChunkSearcherCoordinator coordinator =
 		new ChunkSearcherCoordinator(query, area);
 	private boolean groupsUpToDate;
@@ -116,7 +115,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 	{
 		groupsUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMatchesVersion = coordinator.getMatchesVersion();
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
@@ -151,7 +150,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -180,7 +179,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		// Update entity-group boxes each frame for smooth rendering
 		entityGroups.stream().filter(FrameEspEntityGroup::isEnabled)
@@ -191,13 +190,13 @@ public final class SignEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(SignEspGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			RenderUtils.drawSolidBoxes(matrixStack, boxes, quadsColor, false);
@@ -209,7 +208,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			RenderUtils.drawSolidBoxes(matrixStack, boxes, quadsColor, false);
@@ -218,14 +217,14 @@ public final class SignEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(SignEspGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
 				false);
@@ -235,8 +234,8 @@ public final class SignEspHack extends Hack implements UpdateListener,
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
 				false);
@@ -278,7 +277,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 	
 	private static final class SignEspGroup
 	{
-		private final ArrayList<Box> boxes = new ArrayList<>();
+		private final ArrayList<AABB> boxes = new ArrayList<>();
 		private final ColorSetting color;
 		private final CheckboxSetting enabled;
 		
@@ -294,8 +293,8 @@ public final class SignEspHack extends Hack implements UpdateListener,
 				return;
 			if(!BlockUtils.canBeClicked(pos))
 				return;
-			Box box = BlockUtils.getBoundingBox(pos);
-			if(box.getAverageSideLength() == 0)
+			AABB box = BlockUtils.getBoundingBox(pos);
+			if(box.getSize() == 0)
 				return;
 			boxes.add(box);
 		}
@@ -320,7 +319,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 			return color.getColorI(alpha);
 		}
 		
-		public List<Box> getBoxes()
+		public List<AABB> getBoxes()
 		{
 			return java.util.Collections.unmodifiableList(boxes);
 		}
@@ -328,7 +327,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 	
 	private final class FrameEspEntityGroup
 	{
-		private final ArrayList<Box> boxes = new ArrayList<>();
+		private final ArrayList<AABB> boxes = new ArrayList<>();
 		private final ColorSetting color;
 		private final CheckboxSetting enabled;
 		
@@ -343,15 +342,15 @@ public final class SignEspHack extends Hack implements UpdateListener,
 			boxes.clear();
 			if(!isEnabled())
 				return;
-			for(var e : net.wurstclient.WurstClient.MC.world.getEntities())
+			for(var e : net.wurstclient.WurstClient.MC.level
+				.entitiesForRendering())
 			{
-				if(e instanceof ItemFrameEntity
-					|| e instanceof GlowItemFrameEntity)
+				if(e instanceof ItemFrame || e instanceof GlowItemFrame)
 				{
 					if(onlyAboveGround.isChecked()
 						&& e.getY() < aboveGroundY.getValue())
 						continue;
-					Box b = EntityUtils.getLerpedBox(e, partialTicks);
+					AABB b = EntityUtils.getLerpedBox(e, partialTicks);
 					boxes.add(b);
 				}
 			}
@@ -377,7 +376,7 @@ public final class SignEspHack extends Hack implements UpdateListener,
 			return color.getColorI(alpha);
 		}
 		
-		public List<Box> getBoxes()
+		public List<AABB> getBoxes()
 		{
 			return java.util.Collections.unmodifiableList(boxes);
 		}
diff --git a/src/main/java/net/wurstclient/hacks/SignFramePTHack.java b/src/main/java/net/wurstclient/hacks/SignFramePTHack.java
index 4801f32bc..a1631423f 100644
--- a/src/main/java/net/wurstclient/hacks/SignFramePTHack.java
+++ b/src/main/java/net/wurstclient/hacks/SignFramePTHack.java
@@ -7,15 +7,15 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.decoration.ItemFrameEntity;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.block.AbstractSignBlock;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.decoration.ItemFrame;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.SignBlock;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.RightClickListener;
 import net.wurstclient.hack.Hack;
@@ -62,14 +62,14 @@ public class SignFramePTHack extends Hack implements RightClickListener
 	public void onRightClick(RightClickEvent event)
 	{
 		// Respect vanilla item use cooldown
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
 		// Only when the use key is pressed
-		if(!MC.options.useKey.isPressed())
+		if(!MC.options.keyUse.isDown())
 			return;
 		
-		HitResult hr = MC.crosshairTarget;
+		HitResult hr = MC.hitResult;
 		if(hr == null)
 			return;
 		
@@ -87,19 +87,19 @@ public class SignFramePTHack extends Hack implements RightClickListener
 			// position (if frames are enabled). If not found and signs are
 			// enabled, check whether the block is a sign.
 			bh = (BlockHitResult)hr;
-			Vec3d hitPos = bh.getPos();
+			Vec3 hitPos = bh.getLocation();
 			if(framesEnabled.isChecked())
 			{
-				for(Entity e : MC.world.getEntities())
+				for(Entity e : MC.level.entitiesForRendering())
 				{
-					if(!(e instanceof ItemFrameEntity))
+					if(!(e instanceof ItemFrame))
 						continue;
-					ItemFrameEntity frame = (ItemFrameEntity)e;
+					ItemFrame frame = (ItemFrame)e;
 					// Only consider frames that actually hold an item
-					ItemStack held = frame.getHeldItemStack();
+					ItemStack held = frame.getItem();
 					if(held == null || held.isEmpty())
 						continue;
-					Box box = EntityUtils.getLerpedBox(frame, 0.0f);
+					AABB box = EntityUtils.getLerpedBox(frame, 0.0f);
 					if(box.contains(hitPos))
 					{
 						ehr = new EntityHitResult(frame, hitPos);
@@ -113,8 +113,8 @@ public class SignFramePTHack extends Hack implements RightClickListener
 				if(blockResult != null && blockResult.getBlockPos() != null)
 				{
 					var pos = blockResult.getBlockPos();
-					var state = MC.world.getBlockState(pos);
-					if(state.getBlock() instanceof AbstractSignBlock)
+					var state = MC.level.getBlockState(pos);
+					if(state.getBlock() instanceof SignBlock)
 					{
 						signHit = true;
 					}
@@ -129,39 +129,39 @@ public class SignFramePTHack extends Hack implements RightClickListener
 		// enabled
 		if(ehr != null)
 		{
-			if(!(ehr.getEntity() instanceof ItemFrameEntity frame))
+			if(!(ehr.getEntity() instanceof ItemFrame frame))
 				return;
 			if(!framesEnabled.isChecked())
 				return;
-			ItemStack stack = frame.getHeldItemStack();
+			ItemStack stack = frame.getItem();
 			if(stack == null || stack.isEmpty())
 				return;
 			// If the player is sneaking (sneak key pressed), keep normal
 			// behavior
-			if(MC.options.sneakKey.isPressed())
+			if(MC.options.keyShift.isDown())
 				return;
 		}
 		
 		// For sign hits, also respect sneaking (keep normal interaction)
-		if(signHit && MC.options.sneakKey.isPressed())
+		if(signHit && MC.options.keyShift.isDown())
 			return;
 			
 		// Raycast from the player's eyes past the entity/block hit position to
 		// find the underlying block (the block the frame or sign is attached
 		// to). We extend the ray a bit past the hit so that the block behind
 		// the object is detected.
-		Vec3d eyes = RotationUtils.getEyesPos();
-		Vec3d target = null;
+		Vec3 eyes = RotationUtils.getEyesPos();
+		Vec3 target = null;
 		if(ehr != null)
-			target = ehr.getPos();
+			target = ehr.getLocation();
 		else if(bh != null)
-			target = bh.getPos();
+			target = bh.getLocation();
 		if(target == null)
 			return;
-		Vec3d look = RotationUtils.getServerLookVec();
+		Vec3 look = RotationUtils.getServerLookVec();
 		double dist = eyes.distanceTo(target);
 		double extend = 1.5; // extend beyond the frame/sign
-		Vec3d end = eyes.add(look.multiply(dist + extend));
+		Vec3 end = eyes.add(look.scale(dist + extend));
 		BlockHitResult bhit = BlockUtils.raycast(eyes, end);
 		if(bhit == null || bhit.getType() != HitResult.Type.BLOCK)
 			return;
@@ -172,7 +172,7 @@ public class SignFramePTHack extends Hack implements RightClickListener
 		// carrot) after opening the container.
 		event.cancel();
 		// match vanilla: set item use cooldown before simulating
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 		net.wurstclient.util.InteractionSimulator.rightClickBlock(bhit);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/SkinDerpHack.java b/src/main/java/net/wurstclient/hacks/SkinDerpHack.java
index 8347c01a7..3629bae98 100644
--- a/src/main/java/net/wurstclient/hacks/SkinDerpHack.java
+++ b/src/main/java/net/wurstclient/hacks/SkinDerpHack.java
@@ -8,8 +8,7 @@
 package net.wurstclient.hacks;
 
 import java.util.Random;
-
-import net.minecraft.entity.player.PlayerModelPart;
+import net.minecraft.world.entity.player.PlayerModelPart;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -38,7 +37,7 @@ public final class SkinDerpHack extends Hack implements UpdateListener
 		EVENTS.remove(UpdateListener.class, this);
 		
 		for(PlayerModelPart part : PlayerModelPart.values())
-			MC.options.setPlayerModelPart(part, true);
+			MC.options.setModelPart(part, true);
 	}
 	
 	@Override
@@ -48,7 +47,6 @@ public final class SkinDerpHack extends Hack implements UpdateListener
 			return;
 		
 		for(PlayerModelPart part : PlayerModelPart.values())
-			MC.options.setPlayerModelPart(part,
-				!MC.options.isPlayerModelPartEnabled(part));
+			MC.options.setModelPart(part, !MC.options.isModelPartEnabled(part));
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/SneakHack.java b/src/main/java/net/wurstclient/hacks/SneakHack.java
index c856730ea..df2417bd1 100644
--- a/src/main/java/net/wurstclient/hacks/SneakHack.java
+++ b/src/main/java/net/wurstclient/hacks/SneakHack.java
@@ -63,7 +63,7 @@ public final class SneakHack extends Hack
 		switch(mode.getSelected())
 		{
 			case LEGIT:
-			IKeyBinding.get(MC.options.sneakKey).resetPressedState();
+			IKeyBinding.get(MC.options.keyShift).resetPressedState();
 			break;
 			
 			case PACKET:
@@ -75,7 +75,7 @@ public final class SneakHack extends Hack
 	@Override
 	public void onPreMotion()
 	{
-		IKeyBinding sneakKey = IKeyBinding.get(MC.options.sneakKey);
+		IKeyBinding sneakKey = IKeyBinding.get(MC.options.keyShift);
 		
 		switch(mode.getSelected())
 		{
diff --git a/src/main/java/net/wurstclient/hacks/SpeedHackHack.java b/src/main/java/net/wurstclient/hacks/SpeedHackHack.java
index af5a141ae..8ba3f4780 100644
--- a/src/main/java/net/wurstclient/hacks/SpeedHackHack.java
+++ b/src/main/java/net/wurstclient/hacks/SpeedHackHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -38,22 +38,22 @@ public final class SpeedHackHack extends Hack implements UpdateListener
 	public void onUpdate()
 	{
 		// return if sneaking or not walking
-		if(MC.player.isSneaking()
-			|| MC.player.forwardSpeed == 0 && MC.player.sidewaysSpeed == 0)
+		if(MC.player.isShiftKeyDown()
+			|| MC.player.zza == 0 && MC.player.xxa == 0)
 			return;
 		
 		// activate sprint if walking forward
-		if(MC.player.forwardSpeed > 0 && !MC.player.horizontalCollision)
+		if(MC.player.zza > 0 && !MC.player.horizontalCollision)
 			MC.player.setSprinting(true);
 		
 		// activate mini jump if on ground
-		if(!MC.player.isOnGround())
+		if(!MC.player.onGround())
 			return;
 		
-		Vec3d v = MC.player.getVelocity();
-		MC.player.setVelocity(v.x * 1.8, v.y + 0.1, v.z * 1.8);
+		Vec3 v = MC.player.getDeltaMovement();
+		MC.player.setDeltaMovement(v.x * 1.8, v.y + 0.1, v.z * 1.8);
 		
-		v = MC.player.getVelocity();
+		v = MC.player.getDeltaMovement();
 		double currentSpeed = Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.z, 2));
 		
 		// limit speed to highest value that works on NoCheat+ version
@@ -62,7 +62,7 @@ public final class SpeedHackHack extends Hack implements UpdateListener
 		double maxSpeed = 0.66F;
 		
 		if(currentSpeed > maxSpeed)
-			MC.player.setVelocity(v.x / currentSpeed * maxSpeed, v.y,
+			MC.player.setDeltaMovement(v.x / currentSpeed * maxSpeed, v.y,
 				v.z / currentSpeed * maxSpeed);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/SpeedNukerHack.java b/src/main/java/net/wurstclient/hacks/SpeedNukerHack.java
index 03353b906..b3695eddd 100644
--- a/src/main/java/net/wurstclient/hacks/SpeedNukerHack.java
+++ b/src/main/java/net/wurstclient/hacks/SpeedNukerHack.java
@@ -11,10 +11,9 @@ import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.LeftClickListener;
@@ -111,8 +110,8 @@ public final class SpeedNukerHack extends Hack implements UpdateListener
 		if(commonSettings.isIdModeWithAir())
 			return;
 		
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
@@ -122,12 +121,12 @@ public final class SpeedNukerHack extends Hack implements UpdateListener
 				.filter(commonSettings::shouldBreakBlock);
 		
 		if(commonSettings.isSphereShape())
-			stream = stream
-				.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq);
+			stream =
+				stream.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq);
 		
 		ArrayList<BlockPos> blocks = stream
-			.sorted(Comparator
-				.comparingDouble(pos -> pos.getSquaredDistance(eyesVec)))
+			.sorted(
+				Comparator.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 			.collect(Collectors.toCollection(ArrayList::new));
 		
 		if(blocks.isEmpty())
@@ -145,6 +144,6 @@ public final class SpeedNukerHack extends Hack implements UpdateListener
 		}
 		
 		BlockBreaker.breakBlocksWithPacketSpam(blocks);
-		swingHand.swing(Hand.MAIN_HAND);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/SpiderHack.java b/src/main/java/net/wurstclient/hacks/SpiderHack.java
index 7fee7f5d5..cf3eeafac 100644
--- a/src/main/java/net/wurstclient/hacks/SpiderHack.java
+++ b/src/main/java/net/wurstclient/hacks/SpiderHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -36,14 +36,14 @@ public final class SpiderHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(!player.horizontalCollision)
 			return;
 		
-		Vec3d velocity = player.getVelocity();
+		Vec3 velocity = player.getDeltaMovement();
 		if(velocity.y >= 0.2)
 			return;
 		
-		player.setVelocity(velocity.x, 0.2, velocity.z);
+		player.setDeltaMovement(velocity.x, 0.2, velocity.z);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/StepHack.java b/src/main/java/net/wurstclient/hacks/StepHack.java
index 015c78c80..7b8b5ffb5 100644
--- a/src/main/java/net/wurstclient/hacks/StepHack.java
+++ b/src/main/java/net/wurstclient/hacks/StepHack.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -56,22 +56,22 @@ public final class StepHack extends Hack implements UpdateListener
 		if(mode.getSelected() == Mode.SIMPLE)
 			return;
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(!player.horizontalCollision)
 			return;
 		
-		if(!player.isOnGround() || player.isClimbing()
-			|| player.isTouchingWater() || player.isInLava())
+		if(!player.onGround() || player.onClimbable() || player.isInWater()
+			|| player.isInLava())
 			return;
 		
-		if(player.input.getMovementInput().length() <= 1e-5F)
+		if(player.input.getMoveVector().length() <= 1e-5F)
 			return;
 		
 		if(player.jumping)
 			return;
 		
-		Box box = player.getBoundingBox().offset(0, 0.05, 0).expand(0.05);
-		if(!MC.world.isSpaceEmpty(player, box.offset(0, 1, 0)))
+		AABB box = player.getBoundingBox().move(0, 0.05, 0).inflate(0.05);
+		if(!MC.level.noCollision(player, box.move(0, 1, 0)))
 			return;
 		
 		double stepHeight = BlockUtils.getBlockCollisions(box)
@@ -82,18 +82,17 @@ public final class StepHack extends Hack implements UpdateListener
 		if(stepHeight < 0 || stepHeight > 1)
 			return;
 		
-		ClientPlayNetworkHandler netHandler = player.networkHandler;
+		ClientPacketListener netHandler = player.connection;
 		
-		netHandler.sendPacket(new PlayerMoveC2SPacket.PositionAndOnGround(
-			player.getX(), player.getY() + 0.42 * stepHeight, player.getZ(),
-			player.isOnGround(), MC.player.horizontalCollision));
+		netHandler.send(new ServerboundMovePlayerPacket.Pos(player.getX(),
+			player.getY() + 0.42 * stepHeight, player.getZ(), player.onGround(),
+			MC.player.horizontalCollision));
 		
-		netHandler.sendPacket(new PlayerMoveC2SPacket.PositionAndOnGround(
-			player.getX(), player.getY() + 0.753 * stepHeight, player.getZ(),
-			player.isOnGround(), MC.player.horizontalCollision));
+		netHandler.send(new ServerboundMovePlayerPacket.Pos(player.getX(),
+			player.getY() + 0.753 * stepHeight, player.getZ(),
+			player.onGround(), MC.player.horizontalCollision));
 		
-		player.setPosition(player.getX(), player.getY() + stepHeight,
-			player.getZ());
+		player.setPos(player.getX(), player.getY() + stepHeight, player.getZ());
 	}
 	
 	public float adjustStepHeight(float stepHeight)
diff --git a/src/main/java/net/wurstclient/hacks/SurfaceXrayHack.java b/src/main/java/net/wurstclient/hacks/SurfaceXrayHack.java
index 0a8a5c66d..c072570ab 100644
--- a/src/main/java/net/wurstclient/hacks/SurfaceXrayHack.java
+++ b/src/main/java/net/wurstclient/hacks/SurfaceXrayHack.java
@@ -14,14 +14,13 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.clickgui.screens.EditBlockListScreen;
@@ -124,7 +123,7 @@ public final class SurfaceXrayHack extends Hack
 	private final ConcurrentHashMap<Long, CacheEntry> visibilityCache =
 		new ConcurrentHashMap<>();
 	
-	private ClientWorld cachedWorld;
+	private ClientLevel cachedWorld;
 	private long lastCleanupTick;
 	
 	public SurfaceXrayHack()
@@ -166,7 +165,7 @@ public final class SurfaceXrayHack extends Hack
 	@Override
 	public void onUpdate()
 	{
-		ClientWorld world = MC.world;
+		ClientLevel world = MC.level;
 		if(world == null || world != cachedWorld)
 		{
 			clearCache();
@@ -175,7 +174,7 @@ public final class SurfaceXrayHack extends Hack
 			return;
 		}
 		
-		long time = world.getTime();
+		long time = world.getGameTime();
 		if(time - lastCleanupTick >= CACHE_CLEAN_INTERVAL)
 		{
 			pruneCache(time);
@@ -231,7 +230,7 @@ public final class SurfaceXrayHack extends Hack
 		if(!isEnabled() || state == null || pos == null)
 			return SurfaceState.NONE;
 		
-		Block block = state.getBlockState().getBlock();
+		Block block = state.createLegacyBlock().getBlock();
 		if(!targetBlocks.matchesBlock(block))
 			return SurfaceState.NONE;
 		
@@ -267,13 +266,13 @@ public final class SurfaceXrayHack extends Hack
 	
 	private SurfaceState classifyPos(BlockPos pos, Block block)
 	{
-		ClientWorld world = MC.world;
+		ClientLevel world = MC.level;
 		if(world == null)
 			return SurfaceState.NONE;
 		
 		long key = pos.asLong();
 		CacheEntry cached = visibilityCache.get(key);
-		long time = world.getTime();
+		long time = world.getGameTime();
 		
 		if(cached != null)
 		{
@@ -294,7 +293,7 @@ public final class SurfaceXrayHack extends Hack
 		return fallback;
 	}
 	
-	private void computeComponent(ClientWorld world, BlockPos start,
+	private void computeComponent(ClientLevel world, BlockPos start,
 		Block block, long time)
 	{
 		ArrayDeque<BlockPos> queue = new ArrayDeque<>();
@@ -324,7 +323,7 @@ public final class SurfaceXrayHack extends Hack
 			
 			for(Direction dir : Direction.values())
 			{
-				BlockPos neighbor = current.offset(dir);
+				BlockPos neighbor = current.relative(dir);
 				long key = neighbor.asLong();
 				if(!visited.add(key))
 					continue;
@@ -357,7 +356,7 @@ public final class SurfaceXrayHack extends Hack
 		}
 	}
 	
-	private void fillWithColumnFallback(ClientWorld world,
+	private void fillWithColumnFallback(ClientLevel world,
 		ArrayList<BlockPos> component, Block block, long time)
 	{
 		for(BlockPos pos : component)
@@ -368,10 +367,10 @@ public final class SurfaceXrayHack extends Hack
 		}
 	}
 	
-	private SurfaceState classifyColumn(ClientWorld world, BlockPos pos,
+	private SurfaceState classifyColumn(ClientLevel world, BlockPos pos,
 		Block block)
 	{
-		BlockPos above = pos.up();
+		BlockPos above = pos.above();
 		if(world.getBlockState(above).getBlock() == block)
 			return SurfaceState.INTERIOR;
 		
@@ -407,8 +406,8 @@ public final class SurfaceXrayHack extends Hack
 			lastCleanupTick = 0;
 		}
 		
-		if(MC.worldRenderer != null)
-			MC.worldRenderer.reload();
+		if(MC.levelRenderer != null)
+			MC.levelRenderer.allChanged();
 	}
 	
 	private static final class CacheEntry
diff --git a/src/main/java/net/wurstclient/hacks/TemplateToolHack.java b/src/main/java/net/wurstclient/hacks/TemplateToolHack.java
index 6f01819ed..31ce111e5 100644
--- a/src/main/java/net/wurstclient/hacks/TemplateToolHack.java
+++ b/src/main/java/net/wurstclient/hacks/TemplateToolHack.java
@@ -7,15 +7,14 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.io.File;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.events.GUIRenderListener;
 import net.wurstclient.events.RenderListener;
@@ -84,7 +83,7 @@ public final class TemplateToolHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		int black = 0x80000000;
 		int green15 = 0x2600FF00;
@@ -92,14 +91,15 @@ public final class TemplateToolHack extends Hack
 		// Draw template bounds
 		if(startPos != null && endPos != null)
 		{
-			Box bounds = Box.enclosing(startPos, endPos).contract(1 / 16.0);
+			AABB bounds = AABB.encapsulatingFullBlocks(startPos, endPos)
+				.deflate(1 / 16.0);
 			RenderUtils.drawOutlinedBox(matrixStack, bounds, black, true);
 		}
 		
 		// Draw origin
 		if(originPos != null)
 		{
-			Box box = new Box(originPos).contract(1 / 16.0);
+			AABB box = new AABB(originPos).deflate(1 / 16.0);
 			RenderUtils.drawOutlinedBox(matrixStack, box, black, false);
 			RenderUtils.drawSolidBox(matrixStack, box, green15, false);
 		}
@@ -110,7 +110,7 @@ public final class TemplateToolHack extends Hack
 	}
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
 		if(state != null)
 			state.onRenderGUI(this, context, partialTicks);
diff --git a/src/main/java/net/wurstclient/hacks/ThrowHack.java b/src/main/java/net/wurstclient/hacks/ThrowHack.java
index 024b4ec16..66b6e4fdc 100644
--- a/src/main/java/net/wurstclient/hacks/ThrowHack.java
+++ b/src/main/java/net/wurstclient/hacks/ThrowHack.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.Category;
 import net.wurstclient.events.RightClickListener;
 import net.wurstclient.hack.Hack;
@@ -49,20 +49,20 @@ public final class ThrowHack extends Hack implements RightClickListener
 	@Override
 	public void onRightClick(RightClickEvent event)
 	{
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
-		if(!MC.options.useKey.isPressed())
+		if(!MC.options.keyUse.isDown())
 			return;
 		
 		for(int i = 0; i < amount.getValueI(); i++)
 		{
-			if(MC.crosshairTarget.getType() == HitResult.Type.BLOCK)
+			if(MC.hitResult.getType() == HitResult.Type.BLOCK)
 			{
-				BlockHitResult hitResult = (BlockHitResult)MC.crosshairTarget;
+				BlockHitResult hitResult = (BlockHitResult)MC.hitResult;
 				IMC.getInteractionManager().rightClickBlock(
-					hitResult.getBlockPos(), hitResult.getSide(),
-					hitResult.getPos());
+					hitResult.getBlockPos(), hitResult.getDirection(),
+					hitResult.getLocation());
 			}
 			
 			IMC.getInteractionManager().rightClickItem();
diff --git a/src/main/java/net/wurstclient/hacks/TillauraHack.java b/src/main/java/net/wurstclient/hacks/TillauraHack.java
index eec25b6dc..4985e7f36 100644
--- a/src/main/java/net/wurstclient/hacks/TillauraHack.java
+++ b/src/main/java/net/wurstclient/hacks/TillauraHack.java
@@ -11,13 +11,12 @@ import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
 import java.util.stream.Collectors;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.HoeItem;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.HoeItem;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleInputListener;
@@ -80,11 +79,11 @@ public final class TillauraHack extends Hack implements HandleInputListener
 	public void onHandleInput()
 	{
 		// wait for right click timer
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
 		// don't till while breaking or riding
-		if(MC.interactionManager.isBreakingBlock() || MC.player.isRiding())
+		if(MC.gameMode.isDestroying() || MC.player.isHandsBusy())
 			return;
 		
 		// check held item
@@ -105,7 +104,7 @@ public final class TillauraHack extends Hack implements HandleInputListener
 				
 			// swing arm
 			if(shouldSwing)
-				MC.player.swingHand(Hand.MAIN_HAND);
+				MC.player.swing(InteractionHand.MAIN_HAND);
 		}else
 			// till next valid block
 			for(BlockPos pos : validBlocks)
@@ -115,16 +114,16 @@ public final class TillauraHack extends Hack implements HandleInputListener
 	
 	private ArrayList<BlockPos> getValidBlocks()
 	{
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
 		return BlockUtils.getAllInBoxStream(eyesBlock, blockRange)
-			.filter(pos -> pos.getSquaredDistance(eyesVec) <= rangeSq)
+			.filter(pos -> pos.distToCenterSqr(eyesVec) <= rangeSq)
 			.filter(this::isCorrectBlock)
-			.sorted(Comparator
-				.comparingDouble(pos -> pos.getSquaredDistance(eyesVec)))
+			.sorted(
+				Comparator.comparingDouble(pos -> pos.distToCenterSqr(eyesVec)))
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
 	
@@ -133,7 +132,7 @@ public final class TillauraHack extends Hack implements HandleInputListener
 		if(!tillableBlocks.contains(BlockUtils.getBlock(pos)))
 			return false;
 		
-		if(!BlockUtils.getState(pos.up()).isAir())
+		if(!BlockUtils.getState(pos.above()).isAir())
 			return false;
 		
 		return true;
@@ -149,7 +148,7 @@ public final class TillauraHack extends Hack implements HandleInputListener
 			return false;
 		
 		// face and right click the block
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 		WURST.getRotationFaker().faceVectorPacket(params.hitVec());
 		InteractionSimulator.rightClickBlock(params.toHitResult());
 		return true;
diff --git a/src/main/java/net/wurstclient/hacks/TiredHack.java b/src/main/java/net/wurstclient/hacks/TiredHack.java
index 93ef945d5..8651a551b 100644
--- a/src/main/java/net/wurstclient/hacks/TiredHack.java
+++ b/src/main/java/net/wurstclient/hacks/TiredHack.java
@@ -39,7 +39,7 @@ public final class TiredHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		new Rotation(MC.player.getYaw(), MC.player.age % 100)
+		new Rotation(MC.player.getYRot(), MC.player.tickCount % 100)
 			.sendPlayerLookPacket();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/TooManyHaxHack.java b/src/main/java/net/wurstclient/hacks/TooManyHaxHack.java
index af08958a2..d86cb3832 100644
--- a/src/main/java/net/wurstclient/hacks/TooManyHaxHack.java
+++ b/src/main/java/net/wurstclient/hacks/TooManyHaxHack.java
@@ -22,9 +22,8 @@ import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.input.MouseButtonEvent;
 import net.wurstclient.Category;
 import net.wurstclient.DontBlock;
 import net.wurstclient.Feature;
@@ -297,7 +296,7 @@ public final class TooManyHaxHack extends Hack
 		
 		@Override
 		public void handleMouseClick(double mouseX, double mouseY,
-			int mouseButton, Click context)
+			int mouseButton, MouseButtonEvent context)
 		{
 			if(mouseButton != GLFW.GLFW_MOUSE_BUTTON_LEFT)
 				return;
@@ -333,7 +332,7 @@ public final class TooManyHaxHack extends Hack
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void render(GuiGraphics context, int mouseX, int mouseY,
 			float partialTicks)
 		{
 			List<Hack> hacks = getSortedHacks();
@@ -341,9 +340,8 @@ public final class TooManyHaxHack extends Hack
 			
 			if(hacks.isEmpty())
 			{
-				context.drawText(MC.textRenderer, "No hacks available.",
-					getX() + 2, getY() + 2, WURST.getGui().getTxtColor(),
-					false);
+				context.drawString(MC.font, "No hacks available.", getX() + 2,
+					getY() + 2, WURST.getGui().getTxtColor(), false);
 				return;
 			}
 			
@@ -398,8 +396,8 @@ public final class TooManyHaxHack extends Hack
 				if(!hack.isSafeToBlock())
 					textColor = (textColor & 0x00FFFFFF) | 0x55000000;
 				
-				context.drawText(MC.textRenderer, hack.getName(), boxX2 + 2,
-					y1 + 2, textColor, false);
+				context.drawString(MC.font, hack.getName(), boxX2 + 2, y1 + 2,
+					textColor, false);
 			}
 		}
 		
@@ -410,8 +408,8 @@ public final class TooManyHaxHack extends Hack
 			
 			int maxNameWidth = 0;
 			for(Hack hack : hacks)
-				maxNameWidth = Math.max(maxNameWidth,
-					MC.textRenderer.getWidth(hack.getName()));
+				maxNameWidth =
+					Math.max(maxNameWidth, MC.font.width(hack.getName()));
 			
 			return Math.max(130, BOX_SIZE + 4 + maxNameWidth);
 		}
diff --git a/src/main/java/net/wurstclient/hacks/TpAuraHack.java b/src/main/java/net/wurstclient/hacks/TpAuraHack.java
index c005db171..29f7d14ad 100644
--- a/src/main/java/net/wurstclient/hacks/TpAuraHack.java
+++ b/src/main/java/net/wurstclient/hacks/TpAuraHack.java
@@ -11,11 +11,10 @@ import java.util.Comparator;
 import java.util.Random;
 import java.util.function.ToDoubleFunction;
 import java.util.stream.Stream;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.Hand;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -106,12 +105,12 @@ public final class TpAuraHack extends Hack implements UpdateListener
 		if(pauseOnContainers.shouldPause())
 			return;
 		
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		// set entity
 		Stream<Entity> stream = EntityUtils.getAttackableEntities();
 		double rangeSq = Math.pow(range.getValue(), 2);
-		stream = stream.filter(e -> MC.player.squaredDistanceTo(e) <= rangeSq);
+		stream = stream.filter(e -> MC.player.distanceToSqr(e) <= rangeSq);
 		
 		stream = entityFilters.applyTo(stream);
 		
@@ -123,25 +122,25 @@ public final class TpAuraHack extends Hack implements UpdateListener
 		WURST.getHax().autoSwordHack.setSlot(entity);
 		
 		// teleport
-		player.setPosition(entity.getX() + random.nextInt(3) * 2 - 2,
-			entity.getY(), entity.getZ() + random.nextInt(3) * 2 - 2);
+		player.setPos(entity.getX() + random.nextInt(3) * 2 - 2, entity.getY(),
+			entity.getZ() + random.nextInt(3) * 2 - 2);
 		
 		// check cooldown
-		if(player.getAttackCooldownProgress(0) < 1)
+		if(player.getAttackStrengthScale(0) < 1)
 			return;
 		
 		// attack entity
 		RotationUtils.getNeededRotations(entity.getBoundingBox().getCenter())
 			.sendPlayerLookPacket();
 		
-		MC.interactionManager.attackEntity(player, entity);
-		swingHand.swing(Hand.MAIN_HAND);
+		MC.gameMode.attack(player, entity);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		speed.resetTimer();
 	}
 	
 	private enum Priority
 	{
-		DISTANCE("Distance", e -> MC.player.squaredDistanceTo(e)),
+		DISTANCE("Distance", e -> MC.player.distanceToSqr(e)),
 		
 		ANGLE("Angle",
 			e -> RotationUtils
diff --git a/src/main/java/net/wurstclient/hacks/TrajectoriesHack.java b/src/main/java/net/wurstclient/hacks/TrajectoriesHack.java
index a310c2617..ee5212f7d 100644
--- a/src/main/java/net/wurstclient/hacks/TrajectoriesHack.java
+++ b/src/main/java/net/wurstclient/hacks/TrajectoriesHack.java
@@ -7,23 +7,30 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.function.Predicate;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.projectile.ProjectileUtil;
-import net.minecraft.item.*;
-import net.minecraft.util.Arm;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.RaycastContext.FluidHandling;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.HumanoidArm;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.item.EggItem;
+import net.minecraft.world.item.EnderpearlItem;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.ProjectileWeaponItem;
+import net.minecraft.world.item.SnowballItem;
+import net.minecraft.world.item.ThrowablePotionItem;
+import net.minecraft.world.item.TridentItem;
+import net.minecraft.world.level.ClipContext.Fluid;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.RenderListener;
@@ -71,7 +78,7 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		Trajectory trajectory = getTrajectory(partialTicks);
 		if(trajectory.isEmpty())
@@ -81,8 +88,8 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 		int lineColor = color.getColorI(0xC0);
 		int quadColor = color.getColorI(0x40);
 		
-		Box endBox = trajectory.getEndBox();
-		ArrayList<Vec3d> path = trajectory.path();
+		AABB endBox = trajectory.getEndBox();
+		ArrayList<Vec3> path = trajectory.path();
 		
 		RenderUtils.drawSolidBox(matrixStack, endBox, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, endBox, lineColor, false);
@@ -92,17 +99,17 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 	
 	private Trajectory getTrajectory(float partialTicks)
 	{
-		ClientPlayerEntity player = MC.player;
-		ArrayList<Vec3d> path = new ArrayList<>();
+		LocalPlayer player = MC.player;
+		ArrayList<Vec3> path = new ArrayList<>();
 		HitResult.Type type = HitResult.Type.MISS;
 		
 		// Find the hand with a throwable item
-		Hand hand = Hand.MAIN_HAND;
-		ItemStack stack = player.getMainHandStack();
+		InteractionHand hand = InteractionHand.MAIN_HAND;
+		ItemStack stack = player.getMainHandItem();
 		if(!isThrowable(stack))
 		{
-			hand = Hand.OFF_HAND;
-			stack = player.getOffHandStack();
+			hand = InteractionHand.OFF_HAND;
+			stack = player.getOffhandItem();
 			
 			// If neither hand has a throwable item, return empty path
 			if(!isThrowable(stack))
@@ -113,18 +120,18 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 		Item item = stack.getItem();
 		double throwPower = getThrowPower(item);
 		double gravity = getProjectileGravity(item);
-		FluidHandling fluidHandling = getFluidHandling(item);
+		Fluid fluidHandling = getFluidHandling(item);
 		
 		// Prepare yaw and pitch
-		double yaw = Math.toRadians(player.getYaw());
-		double pitch = Math.toRadians(player.getPitch());
+		double yaw = Math.toRadians(player.getYRot());
+		double pitch = Math.toRadians(player.getXRot());
 		
 		// Calculate starting position
-		Vec3d arrowPos = EntityUtils.getLerpedPos(player, partialTicks)
+		Vec3 arrowPos = EntityUtils.getLerpedPos(player, partialTicks)
 			.add(getHandOffset(hand, yaw));
 		
 		// Calculate starting motion
-		Vec3d arrowMotion = getStartingMotion(yaw, pitch, throwPower);
+		Vec3 arrowMotion = getStartingMotion(yaw, pitch, throwPower);
 		
 		// Build the path
 		for(int i = 0; i < 1000; i++)
@@ -133,15 +140,15 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 			path.add(arrowPos);
 			
 			// Apply motion
-			arrowPos = arrowPos.add(arrowMotion.multiply(0.1));
+			arrowPos = arrowPos.add(arrowMotion.scale(0.1));
 			
 			// Apply air friction
-			arrowMotion = arrowMotion.multiply(0.999);
+			arrowMotion = arrowMotion.scale(0.999);
 			
 			// Apply gravity
 			arrowMotion = arrowMotion.add(0, -gravity * 0.1, 0);
 			
-			Vec3d lastPos = path.size() > 1 ? path.get(path.size() - 2)
+			Vec3 lastPos = path.size() > 1 ? path.get(path.size() - 2)
 				: RotationUtils.getEyesPos();
 			
 			// Check for block collision
@@ -151,21 +158,22 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 			{
 				// Replace last pos with the collision point
 				type = HitResult.Type.BLOCK;
-				path.set(path.size() - 1, bResult.getPos());
+				path.set(path.size() - 1, bResult.getLocation());
 				break;
 			}
 			
 			// Check for entity collision
-			Box box = new Box(lastPos, arrowPos);
-			Predicate<Entity> predicate = e -> !e.isSpectator() && e.canHit();
+			AABB box = new AABB(lastPos, arrowPos);
+			Predicate<Entity> predicate =
+				e -> !e.isSpectator() && e.isPickable();
 			double maxDistSq = 64 * 64;
-			EntityHitResult eResult = ProjectileUtil.raycast(player, lastPos,
-				arrowPos, box, predicate, maxDistSq);
+			EntityHitResult eResult = ProjectileUtil.getEntityHitResult(player,
+				lastPos, arrowPos, box, predicate, maxDistSq);
 			if(eResult != null && eResult.getType() != HitResult.Type.MISS)
 			{
 				// Replace last pos with the collision point
 				type = HitResult.Type.ENTITY;
-				path.set(path.size() - 1, eResult.getPos());
+				path.set(path.size() - 1, eResult.getLocation());
 				break;
 			}
 		}
@@ -179,8 +187,9 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 			return false;
 		
 		Item item = stack.getItem();
-		return item instanceof RangedWeaponItem || item instanceof SnowballItem
-			|| item instanceof EggItem || item instanceof EnderPearlItem
+		return item instanceof ProjectileWeaponItem
+			|| item instanceof SnowballItem || item instanceof EggItem
+			|| item instanceof EnderpearlItem
 			|| item instanceof ThrowablePotionItem
 			|| item instanceof FishingRodItem || item instanceof TridentItem;
 	}
@@ -188,11 +197,11 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 	private double getThrowPower(Item item)
 	{
 		// Use a static 1.5x for snowballs and such
-		if(!(item instanceof RangedWeaponItem))
+		if(!(item instanceof ProjectileWeaponItem))
 			return 1.5;
 		
 		// Calculate bow power
-		float bowPower = (72000 - MC.player.getItemUseTimeLeft()) / 20F;
+		float bowPower = (72000 - MC.player.getUseItemRemainingTicks()) / 20F;
 		bowPower = bowPower * bowPower + bowPower * 2F;
 		
 		// Clamp value if fully charged or not charged at all
@@ -204,7 +213,7 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 	
 	private double getProjectileGravity(Item item)
 	{
-		if(item instanceof RangedWeaponItem)
+		if(item instanceof ProjectileWeaponItem)
 			return 0.05;
 		
 		if(item instanceof ThrowablePotionItem)
@@ -219,30 +228,31 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 		return 0.03;
 	}
 	
-	private FluidHandling getFluidHandling(Item item)
+	private Fluid getFluidHandling(Item item)
 	{
 		if(item instanceof FishingRodItem)
-			return FluidHandling.ANY;
+			return Fluid.ANY;
 		
-		return FluidHandling.NONE;
+		return Fluid.NONE;
 	}
 	
-	private Vec3d getHandOffset(Hand hand, double yaw)
+	private Vec3 getHandOffset(InteractionHand hand, double yaw)
 	{
-		Arm mainArm = MC.options.getMainArm().getValue();
+		HumanoidArm mainArm = MC.options.mainHand().get();
 		
-		boolean rightSide = mainArm == Arm.RIGHT && hand == Hand.MAIN_HAND
-			|| mainArm == Arm.LEFT && hand == Hand.OFF_HAND;
+		boolean rightSide = mainArm == HumanoidArm.RIGHT
+			&& hand == InteractionHand.MAIN_HAND
+			|| mainArm == HumanoidArm.LEFT && hand == InteractionHand.OFF_HAND;
 		
 		double sideMultiplier = rightSide ? -1 : 1;
 		double handOffsetX = Math.cos(yaw) * 0.16 * sideMultiplier;
-		double handOffsetY = MC.player.getStandingEyeHeight() - 0.1;
+		double handOffsetY = MC.player.getEyeHeight() - 0.1;
 		double handOffsetZ = Math.sin(yaw) * 0.16 * sideMultiplier;
 		
-		return new Vec3d(handOffsetX, handOffsetY, handOffsetZ);
+		return new Vec3(handOffsetX, handOffsetY, handOffsetZ);
 	}
 	
-	private Vec3d getStartingMotion(double yaw, double pitch, double throwPower)
+	private Vec3 getStartingMotion(double yaw, double pitch, double throwPower)
 	{
 		double cosOfPitch = Math.cos(pitch);
 		
@@ -250,8 +260,8 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 		double arrowMotionY = -Math.sin(pitch);
 		double arrowMotionZ = Math.cos(yaw) * cosOfPitch;
 		
-		return new Vec3d(arrowMotionX, arrowMotionY, arrowMotionZ).normalize()
-			.multiply(throwPower);
+		return new Vec3(arrowMotionX, arrowMotionY, arrowMotionZ).normalize()
+			.scale(throwPower);
 	}
 	
 	private ColorSetting getColor(Trajectory trajectory)
@@ -264,17 +274,17 @@ public final class TrajectoriesHack extends Hack implements RenderListener
 		};
 	}
 	
-	private record Trajectory(ArrayList<Vec3d> path, HitResult.Type type)
+	private record Trajectory(ArrayList<Vec3> path, HitResult.Type type)
 	{
 		public boolean isEmpty()
 		{
 			return path.isEmpty();
 		}
 		
-		public Box getEndBox()
+		public AABB getEndBox()
 		{
-			Vec3d end = path.get(path.size() - 1);
-			return new Box(end.subtract(0.5), end.add(0.5));
+			Vec3 end = path.get(path.size() - 1);
+			return new AABB(end.subtract(0.5), end.add(0.5));
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/TreeBotHack.java b/src/main/java/net/wurstclient/hacks/TreeBotHack.java
index 06a2cc294..f96585c5d 100644
--- a/src/main/java/net/wurstclient/hacks/TreeBotHack.java
+++ b/src/main/java/net/wurstclient/hacks/TreeBotHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -14,12 +15,10 @@ import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -114,8 +113,8 @@ public final class TreeBotHack extends Hack
 		
 		if(currentBlock != null)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			currentBlock = null;
 		}
 		
@@ -226,9 +225,8 @@ public final class TreeBotHack extends Hack
 		faceTarget.face(params.hitVec());
 		
 		// damage block and swing hand
-		if(MC.interactionManager.updateBlockBreakingProgress(pos,
-			params.side()))
-			swingHand.swing(Hand.MAIN_HAND);
+		if(MC.gameMode.continueDestroyBlock(pos, params.side()))
+			swingHand.swing(InteractionHand.MAIN_HAND);
 		
 		// update progress
 		overlay.updateProgress();
@@ -237,7 +235,7 @@ public final class TreeBotHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		PathCmd pathCmd = WURST.getCmds().pathCmd;
 		
@@ -258,7 +256,7 @@ public final class TreeBotHack extends Hack
 	private ArrayList<BlockPos> getNeighbors(BlockPos pos)
 	{
 		return BlockUtils
-			.getAllInBoxStream(pos.add(-1, -1, -1), pos.add(1, 1, 1))
+			.getAllInBoxStream(pos.offset(-1, -1, -1), pos.offset(1, 1, 1))
 			.filter(TreeBotUtils::isLog)
 			.collect(Collectors.toCollection(ArrayList::new));
 	}
@@ -326,7 +324,7 @@ public final class TreeBotHack extends Hack
 			List<PathPos> path = pathFinder.getPath();
 			path = path.subList(processor.getIndex(), path.size());
 			
-			return path.stream().flatMap(pos -> Stream.of(pos, pos.up()))
+			return path.stream().flatMap(pos -> Stream.of(pos, pos.above()))
 				.distinct().filter(TreeBotUtils::isLeaves)
 				.collect(Collectors.toCollection(ArrayList::new));
 		}
@@ -341,7 +339,7 @@ public final class TreeBotHack extends Hack
 	{
 		public TreeFinder()
 		{
-			super(BlockPos.ofFloored(WurstClient.MC.player.getEntityPos()));
+			super(BlockPos.containing(WurstClient.MC.player.position()));
 		}
 		
 		public TreeFinder(TreeBotPathFinder pathFinder)
@@ -372,7 +370,7 @@ public final class TreeBotHack extends Hack
 			if(!TreeBotUtils.isLog(pos))
 				return false;
 			
-			if(TreeBotUtils.isLog(pos.down()))
+			if(TreeBotUtils.isLog(pos.below()))
 				return false;
 			
 			analyzeTree(pos);
@@ -420,7 +418,7 @@ public final class TreeBotHack extends Hack
 	{
 		public AngleFinder()
 		{
-			super(BlockPos.ofFloored(WurstClient.MC.player.getEntityPos()));
+			super(BlockPos.containing(WurstClient.MC.player.position()));
 			setThinkSpeed(512);
 			setThinkTime(1);
 		}
@@ -445,8 +443,8 @@ public final class TreeBotHack extends Hack
 		private boolean hasAngle(PathPos pos)
 		{
 			double rangeSq = range.getValueSq();
-			ClientPlayerEntity player = WurstClient.MC.player;
-			Vec3d eyes = Vec3d.ofBottomCenter(pos).add(0,
+			LocalPlayer player = WurstClient.MC.player;
+			Vec3 eyes = Vec3.atBottomCenterOf(pos).add(0,
 				player.getEyeHeight(player.getPose()), 0);
 			
 			for(BlockPos log : tree.getLogs())
diff --git a/src/main/java/net/wurstclient/hacks/TrialSpawnerEspHack.java b/src/main/java/net/wurstclient/hacks/TrialSpawnerEspHack.java
index ad802b644..2d9cda942 100644
--- a/src/main/java/net/wurstclient/hacks/TrialSpawnerEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/TrialSpawnerEspHack.java
@@ -19,34 +19,30 @@ import java.util.Optional;
 import java.util.UUID;
 import java.util.Timer;
 import java.util.TimerTask;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.VaultBlock;
-import net.minecraft.block.entity.TrialSpawnerBlockEntity;
-import net.minecraft.block.entity.VaultBlockEntity;
-import net.minecraft.block.enums.TrialSpawnerState;
-import net.minecraft.block.enums.VaultState;
-import net.minecraft.block.spawner.TrialSpawnerConfig;
-import net.minecraft.block.spawner.TrialSpawnerData;
-import net.minecraft.block.spawner.TrialSpawnerLogic;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.font.TextRenderer.TextLayerType;
-import net.minecraft.client.render.VertexConsumerProvider.Immediate;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.EntityType;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.nbt.NbtCompound;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.RegistryKey;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RotationAxis;
-import net.minecraft.util.math.Vec3d;
-
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.Font.DisplayMode;
+import net.minecraft.client.renderer.MultiBufferSource.BufferSource;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.VaultBlock;
+import net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity;
+import net.minecraft.world.level.block.entity.trialspawner.TrialSpawner;
+import net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig;
+import net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState;
+import net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerStateData;
+import net.minecraft.world.level.block.entity.vault.VaultBlockEntity;
+import net.minecraft.world.level.block.entity.vault.VaultState;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
 import net.wurstclient.events.CameraTransformViewBobbingListener.CameraTransformViewBobbingEvent;
@@ -66,6 +62,8 @@ import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.math.Axis;
 import java.io.File;
 import java.io.FileReader;
 import java.io.FileWriter;
@@ -207,7 +205,7 @@ public final class TrialSpawnerEspHack extends Hack
 	public void onUpdate()
 	{
 		spawners.clear();
-		if(MC.world == null || MC.player == null)
+		if(MC.level == null || MC.player == null)
 		{
 			vaults.clear();
 			foundCount = 0;
@@ -225,19 +223,19 @@ public final class TrialSpawnerEspHack extends Hack
 		ChunkUtils.getLoadedBlockEntities()
 			.filter(be -> be instanceof VaultBlockEntity)
 			.map(be -> (VaultBlockEntity)be).forEach(be -> {
-				BlockPos vpos = be.getPos().toImmutable();
+				BlockPos vpos = be.getBlockPos().immutable();
 				vaults.add(new VaultInfo(vpos));
 				// detect ominous vaults that have been opened / ejected
-				if(MC.world != null)
+				if(MC.level != null)
 				{
-					BlockState state = MC.world.getBlockState(vpos);
-					if(state.isOf(Blocks.VAULT)
-						&& state.contains(VaultBlock.OMINOUS)
-						&& state.get(VaultBlock.OMINOUS))
+					BlockState state = MC.level.getBlockState(vpos);
+					if(state.is(Blocks.VAULT)
+						&& state.hasProperty(VaultBlock.OMINOUS)
+						&& state.getValue(VaultBlock.OMINOUS))
 					{
-						if(state.contains(VaultBlock.VAULT_STATE))
+						if(state.hasProperty(VaultBlock.STATE))
 						{
-							VaultState vs = state.get(VaultBlock.VAULT_STATE);
+							VaultState vs = state.getValue(VaultBlock.STATE);
 							// treat any non-INACTIVE /
 							// ejecting/unlocking/active as opened
 							if(vs == VaultState.EJECTING)
@@ -245,9 +243,9 @@ public final class TrialSpawnerEspHack extends Hack
 								String dim = "unknown";
 								try
 								{
-									if(MC != null && MC.world != null)
-										dim = MC.world.getRegistryKey()
-											.getValue().toString();
+									if(MC != null && MC.level != null)
+										dim = MC.level.dimension().location()
+											.toString();
 								}catch(Throwable ignored)
 								{}
 								String key = dim + "|" + vpos.getX() + ","
@@ -274,8 +272,8 @@ public final class TrialSpawnerEspHack extends Hack
 				String dim = "unknown";
 				try
 				{
-					if(MC != null && MC.world != null)
-						dim = MC.world.getRegistryKey().getValue().toString();
+					if(MC != null && MC.level != null)
+						dim = MC.level.dimension().location().toString();
 				}catch(Throwable ignored)
 				{}
 				String key = dim + "|" + vpos.getX() + "," + vpos.getY() + ","
@@ -283,12 +281,12 @@ public final class TrialSpawnerEspHack extends Hack
 				if(openedVaultKeys.contains(key)
 					|| approachScheduledKeys.contains(key))
 					continue;
-				if(MC.player.squaredDistanceTo(vpos.getX() + 0.5,
-					vpos.getY() + 0.5, vpos.getZ() + 0.5) <= rangeSq)
+				if(MC.player.distanceToSqr(vpos.getX() + 0.5, vpos.getY() + 0.5,
+					vpos.getZ() + 0.5) <= rangeSq)
 				{
-					BlockState state = MC.world.getBlockState(vpos);
-					VaultState prev = state.contains(VaultBlock.VAULT_STATE)
-						? state.get(VaultBlock.VAULT_STATE) : null;
+					BlockState state = MC.level.getBlockState(vpos);
+					VaultState prev = state.hasProperty(VaultBlock.STATE)
+						? state.getValue(VaultBlock.STATE) : null;
 					// make final copies for inner class
 					final VaultState prevFinal = prev;
 					final String keyFinal = key;
@@ -301,13 +299,13 @@ public final class TrialSpawnerEspHack extends Hack
 						{
 							try
 							{
-								if(MC == null || MC.world == null)
+								if(MC == null || MC.level == null)
 									return;
 								BlockState after =
-									MC.world.getBlockState(vposFinal);
+									MC.level.getBlockState(vposFinal);
 								VaultState afterState =
-									after.contains(VaultBlock.VAULT_STATE)
-										? after.get(VaultBlock.VAULT_STATE)
+									after.hasProperty(VaultBlock.STATE)
+										? after.getValue(VaultBlock.STATE)
 										: null;
 								boolean prevIdle = prevFinal == null
 									|| prevFinal == VaultState.INACTIVE;
@@ -334,13 +332,13 @@ public final class TrialSpawnerEspHack extends Hack
 		ChunkUtils.getLoadedBlockEntities()
 			.filter(be -> be instanceof TrialSpawnerBlockEntity)
 			.map(be -> (TrialSpawnerBlockEntity)be).forEach(spawner -> {
-				BlockPos pos = spawner.getPos();
-				double distSq = MC.player.squaredDistanceTo(pos.getX() + 0.5,
+				BlockPos pos = spawner.getBlockPos();
+				double distSq = MC.player.distanceToSqr(pos.getX() + 0.5,
 					pos.getY() + 0.5, pos.getZ() + 0.5);
 				if(limit && distSq > maxDistanceSq)
 					return;
 				
-				BlockPos immutablePos = pos.toImmutable();
+				BlockPos immutablePos = pos.immutable();
 				VaultInfo link = showVaultLink.isChecked()
 					? findLinkedVault(immutablePos) : null;
 				String decorMob = detectMobFromDecor(immutablePos);
@@ -350,20 +348,20 @@ public final class TrialSpawnerEspHack extends Hack
 		
 		foundCount = spawners.size();
 		// detect transitions and predict cooldown end when configured
-		if(MC.world != null && estimateCooldownOnTransition.isChecked())
+		if(MC.level != null && estimateCooldownOnTransition.isChecked())
 		{
-			long worldTime = MC.world.getTime();
+			long worldTime = MC.level.getGameTime();
 			for(TrialSpawnerInfo info : spawners)
 			{
 				var be = info.blockEntity();
-				if(be == null || be.isRemoved() || be.getWorld() != MC.world)
+				if(be == null || be.isRemoved() || be.getLevel() != MC.level)
 					continue;
-				TrialSpawnerLogic logic = be.getSpawner();
+				TrialSpawner logic = be.getTrialSpawner();
 				if(logic == null)
 					continue;
-				TrialSpawnerState state = logic.getSpawnerState() == null
-					? TrialSpawnerState.INACTIVE : logic.getSpawnerState();
-				TrialSpawnerData data = logic.getData();
+				TrialSpawnerState state = logic.getState() == null
+					? TrialSpawnerState.INACTIVE : logic.getState();
+				TrialSpawnerStateData data = logic.getStateData();
 				long cooldownEnd = 0;
 				if(data != null)
 				{
@@ -379,7 +377,8 @@ public final class TrialSpawnerEspHack extends Hack
 					&& state != TrialSpawnerState.ACTIVE
 					&& cooldownEnd <= worldTime)
 				{
-					long predicted = worldTime + logic.getCooldownLength();
+					long predicted =
+						worldTime + logic.getTargetCooldownLength();
 					predictedCooldownEnds.put(pos, predicted);
 				}
 				// if server set a cooldown, prefer that and remove any
@@ -391,7 +390,7 @@ public final class TrialSpawnerEspHack extends Hack
 			}
 			// cleanup expired predictions
 			predictedCooldownEnds.entrySet()
-				.removeIf(e -> e.getValue() <= MC.world.getTime());
+				.removeIf(e -> e.getValue() <= MC.level.getGameTime());
 		}
 	}
 	
@@ -407,23 +406,23 @@ public final class TrialSpawnerEspHack extends Hack
 	public void onRightClick(
 		net.wurstclient.events.RightClickListener.RightClickEvent event)
 	{
-		if(MC == null || MC.world == null || MC.player == null)
+		if(MC == null || MC.level == null || MC.player == null)
 			return;
-		var hit = MC.crosshairTarget;
-		if(!(hit instanceof net.minecraft.util.hit.BlockHitResult bhr))
+		var hit = MC.hitResult;
+		if(!(hit instanceof net.minecraft.world.phys.BlockHitResult bhr))
 			return;
 		BlockPos pos = bhr.getBlockPos();
-		BlockState state = MC.world.getBlockState(pos);
-		if(!state.isOf(Blocks.VAULT))
+		BlockState state = MC.level.getBlockState(pos);
+		if(!state.is(Blocks.VAULT))
 			return;
 		// remember initial state and schedule a check after 1.5s
-		VaultState before = state.contains(VaultBlock.VAULT_STATE)
-			? state.get(VaultBlock.VAULT_STATE) : null;
+		VaultState before = state.hasProperty(VaultBlock.STATE)
+			? state.getValue(VaultBlock.STATE) : null;
 		String dim = "unknown";
 		try
 		{
-			if(MC.world != null)
-				dim = MC.world.getRegistryKey().getValue().toString();
+			if(MC.level != null)
+				dim = MC.level.dimension().location().toString();
 		}catch(Throwable ignored)
 		{}
 		// make final copies for inner class
@@ -437,12 +436,11 @@ public final class TrialSpawnerEspHack extends Hack
 			{
 				try
 				{
-					if(MC == null || MC.world == null)
+					if(MC == null || MC.level == null)
 						return;
-					BlockState after = MC.world.getBlockState(posFinal);
-					VaultState afterState =
-						after.contains(VaultBlock.VAULT_STATE)
-							? after.get(VaultBlock.VAULT_STATE) : null;
+					BlockState after = MC.level.getBlockState(posFinal);
+					VaultState afterState = after.hasProperty(VaultBlock.STATE)
+						? after.getValue(VaultBlock.STATE) : null;
 					// Only mark as opened if the vault was idle/inactive when
 					// we checked and the state stayed unchanged. If it was
 					// ACTIVE (mouth opened) or transitioned to ACTIVE/EJECTING,
@@ -466,9 +464,9 @@ public final class TrialSpawnerEspHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrices, float partialTicks)
+	public void onRender(PoseStack matrices, float partialTicks)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return;
 		
 		ArrayList<ColoredBox> outlineBoxes = new ArrayList<>();
@@ -483,10 +481,10 @@ public final class TrialSpawnerEspHack extends Hack
 			for(VaultInfo v : vaults)
 			{
 				BlockPos vpos = v.pos();
-				BlockState vstate = MC.world.getBlockState(vpos);
+				BlockState vstate = MC.level.getBlockState(vpos);
 				int vcolor = vaultBoxColor.getColorI();
-				boolean ominous = vstate.contains(VaultBlock.OMINOUS)
-					&& vstate.get(VaultBlock.OMINOUS);
+				boolean ominous = vstate.hasProperty(VaultBlock.OMINOUS)
+					&& vstate.getValue(VaultBlock.OMINOUS);
 				if(ominous)
 					vcolor = ominousVaultBoxColor.getColorI();
 				// if we know this ominous vault was opened before, mark it
@@ -494,8 +492,8 @@ public final class TrialSpawnerEspHack extends Hack
 				String dim = "unknown";
 				try
 				{
-					if(MC != null && MC.world != null)
-						dim = MC.world.getRegistryKey().getValue().toString();
+					if(MC != null && MC.level != null)
+						dim = MC.level.dimension().location().toString();
 				}catch(Throwable ignored)
 				{}
 				String key = dim + "|" + vpos.getX() + "," + vpos.getY() + ","
@@ -505,7 +503,7 @@ public final class TrialSpawnerEspHack extends Hack
 					// darken color to indicate opened
 					vcolor = mixWithWhite(vcolor, 0.6F);
 				}
-				Box vbox = new Box(vpos);
+				AABB vbox = new AABB(vpos);
 				outlineBoxes.add(new ColoredBox(vbox, vcolor));
 				if(filledBoxes != null)
 					filledBoxes
@@ -518,7 +516,7 @@ public final class TrialSpawnerEspHack extends Hack
 				lines.add(new OverlayLine(status, 0xFFFFFFFF));
 				if(ominous && openedVaultKeys.contains(key))
 					lines.add(new OverlayLine("Opened", 0xFFDD4444));
-				Vec3d labelPos = Vec3d.ofCenter(vpos).add(0, 1.0, 0);
+				Vec3 labelPos = Vec3.atCenterOf(vpos).add(0, 1.0, 0);
 				labelPos = resolveLabelPosition(labelPos);
 				drawLabel(matrices, labelPos, lines, overlayScale.getValueF());
 			}
@@ -527,24 +525,24 @@ public final class TrialSpawnerEspHack extends Hack
 		for(TrialSpawnerInfo info : spawners)
 		{
 			TrialSpawnerBlockEntity be = info.blockEntity();
-			if(be == null || be.isRemoved() || be.getWorld() != MC.world)
+			if(be == null || be.isRemoved() || be.getLevel() != MC.level)
 				continue;
 			
-			TrialSpawnerLogic logic = be.getSpawner();
+			TrialSpawner logic = be.getTrialSpawner();
 			if(logic == null)
 				continue;
 			
-			TrialSpawnerState state = logic.getSpawnerState() == null
-				? TrialSpawnerState.INACTIVE : logic.getSpawnerState();
+			TrialSpawnerState state = logic.getState() == null
+				? TrialSpawnerState.INACTIVE : logic.getState();
 			TrialStatus status = TrialStatus.fromState(state);
 			int color = getColorForStatus(status);
-			Box box = new Box(info.pos());
+			AABB box = new AABB(info.pos());
 			outlineBoxes.add(new ColoredBox(box, color));
 			if(filledBoxes != null)
 				filledBoxes.add(new ColoredBox(box, withAlpha(color, 0.18F)));
 			if(tracerTargets != null)
 				tracerTargets
-					.add(new ColoredPoint(Vec3d.ofCenter(info.pos()), color));
+					.add(new ColoredPoint(Vec3.atCenterOf(info.pos()), color));
 			
 			if(showActivationRadius.isChecked())
 				drawActivationRadius(matrices, info, logic, color);
@@ -567,71 +565,71 @@ public final class TrialSpawnerEspHack extends Hack
 				false);
 	}
 	
-	private void drawActivationRadius(MatrixStack matrices,
-		TrialSpawnerInfo info, TrialSpawnerLogic logic, int stateColor)
+	private void drawActivationRadius(PoseStack matrices, TrialSpawnerInfo info,
+		TrialSpawner logic, int stateColor)
 	{
-		int radius = logic.getDetectionRadius();
+		int radius = logic.getRequiredPlayerRange();
 		if(radius <= 0)
 			return;
 		
-		Vec3d center = Vec3d.ofCenter(info.pos()).add(0, 0.05, 0);
+		Vec3 center = Vec3.atCenterOf(info.pos()).add(0, 0.05, 0);
 		double radiusSq = radius * radius;
-		Vec3d playerPos = MC.player == null ? null
-			: new Vec3d(MC.player.getX(), MC.player.getY(), MC.player.getZ());
-		boolean inside = playerPos != null
-			&& playerPos.squaredDistanceTo(center) <= radiusSq;
+		Vec3 playerPos = MC.player == null ? null
+			: new Vec3(MC.player.getX(), MC.player.getY(), MC.player.getZ());
+		boolean inside =
+			playerPos != null && playerPos.distanceToSqr(center) <= radiusSq;
 		int color = withAlpha(
 			inside ? mixWithWhite(stateColor, 0.35F) : radiusColor.getColorI(),
 			inside ? 0.65F : 0.35F);
 		int segments = Math.max(32, radius * 12);
 		double step = (Math.PI * 2) / segments;
 		
-		Vec3d prev = center.add(radius, 0, 0);
+		Vec3 prev = center.add(radius, 0, 0);
 		for(int i = 1; i <= segments; i++)
 		{
 			double angle = i * step;
-			Vec3d next = center.add(radius * Math.cos(angle), 0,
+			Vec3 next = center.add(radius * Math.cos(angle), 0,
 				radius * Math.sin(angle));
 			RenderUtils.drawLine(matrices, prev, next, color, false);
 			prev = next;
 		}
 	}
 	
-	private void drawVaultLink(MatrixStack matrices, TrialSpawnerInfo info,
+	private void drawVaultLink(PoseStack matrices, TrialSpawnerInfo info,
 		int stateColor)
 	{
-		if(MC.world == null || info.vault() == null)
+		if(MC.level == null || info.vault() == null)
 			return;
 		
 		BlockPos vaultPos = info.vault().pos();
-		Vec3d start = Vec3d.ofCenter(info.pos());
-		Vec3d end = Vec3d.ofCenter(vaultPos).add(0, 0.25, 0);
+		Vec3 start = Vec3.atCenterOf(info.pos());
+		Vec3 end = Vec3.atCenterOf(vaultPos).add(0, 0.25, 0);
 		int color = vaultLinkColor.getColorI();
 		RenderUtils.drawLine(matrices, start, end, color, false);
 		
-		BlockState state = MC.world.getBlockState(vaultPos);
-		if(!state.isOf(Blocks.VAULT))
+		BlockState state = MC.level.getBlockState(vaultPos);
+		if(!state.is(Blocks.VAULT))
 			return;
 		
 		String status = describeVaultState(state);
 		List<OverlayLine> lines = List.of(new OverlayLine("Vault", stateColor),
 			new OverlayLine(status, color));
-		Vec3d labelPos = end.add(0, 0.6, 0);
+		Vec3 labelPos = end.add(0, 0.6, 0);
 		drawLabel(matrices, labelPos, lines, overlayScale.getValueF());
 	}
 	
-	private void drawOverlay(MatrixStack matrices, TrialSpawnerInfo info,
-		TrialSpawnerLogic logic, TrialSpawnerState state, int headerColor)
+	private void drawOverlay(PoseStack matrices, TrialSpawnerInfo info,
+		TrialSpawner logic, TrialSpawnerState state, int headerColor)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return;
 		
-		TrialSpawnerData data = logic.getData();
+		TrialSpawnerStateData data = logic.getStateData();
 		if(data == null)
 			return;
 		
 		TrialSpawnerDataAccessor accessor = (TrialSpawnerDataAccessor)data;
-		long worldTime = MC.world.getTime();
+		long worldTime = MC.level.getGameTime();
 		long cooldownTicks = accessor.getCooldownEnd() - worldTime;
 		double cooldownSeconds = Math.max(0, cooldownTicks / 20.0);
 		boolean cooldownEstimated = false;
@@ -648,20 +646,21 @@ public final class TrialSpawnerEspHack extends Hack
 		long nextSpawnTicks = accessor.getNextMobSpawnsAt() - worldTime;
 		double nextSpawnSeconds = Math.max(0, nextSpawnTicks / 20.0);
 		
-		int additionalPlayers = data.getAdditionalPlayers(info.pos());
-		TrialSpawnerConfig config = logic.getConfig();
-		int totalMobs = Math.max(1, config.getTotalMobs(additionalPlayers));
-		int simultaneous =
-			Math.max(1, config.getSimultaneousMobs(additionalPlayers));
+		int additionalPlayers = data.countAdditionalPlayers(info.pos());
+		TrialSpawnerConfig config = logic.activeConfig();
+		int totalMobs =
+			Math.max(1, config.calculateTargetTotalMobs(additionalPlayers));
+		int simultaneous = Math.max(1,
+			config.calculateTargetSimultaneousMobs(additionalPlayers));
 		int trackedSpawned =
-			MathHelper.clamp(accessor.getTotalSpawnedMobs(), 0, totalMobs);
+			Mth.clamp(accessor.getTotalSpawnedMobs(), 0, totalMobs);
 		Set<UUID> aliveSet = accessor.getSpawnedMobsAlive();
 		int aliveFromData =
 			aliveSet == null ? 0 : Math.min(aliveSet.size(), totalMobs);
 		int totalWaves =
 			Math.max(1, (int)Math.ceil(totalMobs / (double)simultaneous));
 		String decorMob = info.decorMob() == null ? "" : info.decorMob();
-		String spawnId = readMobId(data.getSpawnDataNbt(state));
+		String spawnId = readMobId(data.getUpdateTag(state));
 		String resolvedMob = resolveMobName(spawnId);
 		String mobName = !decorMob.isEmpty() ? decorMob
 			: (resolvedMob == null ? "" : resolvedMob);
@@ -674,8 +673,8 @@ public final class TrialSpawnerEspHack extends Hack
 		if(trackedSpawned <= 0 && alive > 0)
 			trackedSpawned = alive;
 		int mobsProgress =
-			MathHelper.clamp(Math.max(trackedSpawned, alive), 0, totalMobs);
-		int currentWave = MathHelper.clamp(
+			Mth.clamp(Math.max(trackedSpawned, alive), 0, totalMobs);
+		int currentWave = Mth.clamp(
 			(int)Math.ceil(Math.max(1, mobsProgress) / (double)simultaneous),
 			mobsProgress > 0 ? 1 : 0, totalWaves);
 		
@@ -728,72 +727,69 @@ public final class TrialSpawnerEspHack extends Hack
 		if(showVaultLink.isChecked() && info.vault() != null)
 		{
 			String vaultInfo =
-				describeVaultState(MC.world.getBlockState(info.vault().pos()));
+				describeVaultState(MC.level.getBlockState(info.vault().pos()));
 			lines.add(new OverlayLine("Vault: " + vaultInfo, 0xFFFFFFFF));
 		}
 		
-		Vec3d labelPos = Vec3d.ofCenter(info.pos()).add(0, 1.6, 0);
+		Vec3 labelPos = Vec3.atCenterOf(info.pos()).add(0, 1.6, 0);
 		labelPos = resolveLabelPosition(labelPos);
 		drawLabel(matrices, labelPos, lines, overlayScale.getValueF());
 	}
 	
-	private void drawLabel(MatrixStack matrices, Vec3d position,
+	private void drawLabel(PoseStack matrices, Vec3 position,
 		List<OverlayLine> lines, float scale)
 	{
-		if(lines.isEmpty() || MC.textRenderer == null)
+		if(lines.isEmpty() || MC.font == null)
 			return;
 		
-		matrices.push();
-		Vec3d cam = RenderUtils.getCameraPos();
+		matrices.pushPose();
+		Vec3 cam = RenderUtils.getCameraPos();
 		matrices.translate(position.x - cam.x, position.y - cam.y,
 			position.z - cam.z);
 		var camEntity = MC.getCameraEntity();
 		if(camEntity != null)
 		{
-			matrices.multiply(
-				RotationAxis.POSITIVE_Y.rotationDegrees(-camEntity.getYaw()));
-			matrices.multiply(
-				RotationAxis.POSITIVE_X.rotationDegrees(camEntity.getPitch()));
+			matrices.mulPose(Axis.YP.rotationDegrees(-camEntity.getYRot()));
+			matrices.mulPose(Axis.XP.rotationDegrees(camEntity.getXRot()));
 		}
-		matrices.multiply(RotationAxis.POSITIVE_Y.rotationDegrees(180));
+		matrices.mulPose(Axis.YP.rotationDegrees(180));
 		float s = 0.025F * scale;
 		matrices.scale(s, -s, s);
 		
-		TextRenderer tr = MC.textRenderer;
-		int bg = (int)(MC.options.getTextBackgroundOpacity(0.25F) * 255) << 24;
-		int lineHeight = tr.fontHeight + 2;
-		int maxWidth = lines.stream().mapToInt(line -> tr.getWidth(line.text()))
+		Font tr = MC.font;
+		int bg = (int)(MC.options.getBackgroundOpacity(0.25F) * 255) << 24;
+		int lineHeight = tr.lineHeight + 2;
+		int maxWidth = lines.stream().mapToInt(line -> tr.width(line.text()))
 			.max().orElse(0);
 		int x = -maxWidth / 2;
 		
-		Immediate vcp = RenderUtils.getVCP();
+		BufferSource vcp = RenderUtils.getVCP();
 		for(int i = 0; i < lines.size(); i++)
 		{
 			OverlayLine line = lines.get(i);
 			int y = i * lineHeight;
-			TextLayerType layerType = TextLayerType.SEE_THROUGH;
-			tr.draw(line.text(), x, y, line.color(), false,
-				matrices.peek().getPositionMatrix(), vcp, layerType, bg,
-				0xF000F0);
+			DisplayMode layerType = DisplayMode.SEE_THROUGH;
+			tr.drawInBatch(line.text(), x, y, line.color(), false,
+				matrices.last().pose(), vcp, layerType, bg, 0xF000F0);
 		}
-		vcp.draw();
-		matrices.pop();
+		vcp.endBatch();
+		matrices.popPose();
 	}
 	
-	private Vec3d resolveLabelPosition(Vec3d target)
+	private Vec3 resolveLabelPosition(Vec3 target)
 	{
-		Vec3d cam = RenderUtils.getCameraPos();
+		Vec3 cam = RenderUtils.getCameraPos();
 		double distance = cam.distanceTo(target);
 		double anchor = 12;
 		if(distance <= anchor)
 			return target;
 		
-		Vec3d dir = target.subtract(cam);
+		Vec3 dir = target.subtract(cam);
 		double len = dir.length();
 		if(len < 1e-4)
 			return target;
 		
-		return cam.add(dir.multiply(anchor / len));
+		return cam.add(dir.scale(anchor / len));
 	}
 	
 	private VaultInfo findLinkedVault(BlockPos spawnerPos)
@@ -807,7 +803,7 @@ public final class TrialSpawnerEspHack extends Hack
 		double best = maxRangeSq;
 		for(VaultInfo info : vaults)
 		{
-			double distSq = info.pos().getSquaredDistance(spawnerPos);
+			double distSq = info.pos().distSqr(spawnerPos);
 			if(distSq <= best)
 			{
 				closest = info;
@@ -822,8 +818,8 @@ public final class TrialSpawnerEspHack extends Hack
 		String server = null;
 		try
 		{
-			if(MC != null && MC.getCurrentServerEntry() != null)
-				server = MC.getCurrentServerEntry().address;
+			if(MC != null && MC.getCurrentServer() != null)
+				server = MC.getCurrentServer().ip;
 		}catch(Throwable ignored)
 		{}
 		String name = sanitizeServer(server);
@@ -854,9 +850,9 @@ public final class TrialSpawnerEspHack extends Hack
 					{
 						try
 						{
-							if(MC != null && MC.world != null)
-								dim = MC.world.getRegistryKey().getValue()
-									.toString();
+							if(MC != null && MC.level != null)
+								dim =
+									MC.level.dimension().location().toString();
 						}catch(Throwable ignored)
 						{}
 						if(dim == null)
@@ -876,8 +872,8 @@ public final class TrialSpawnerEspHack extends Hack
 		String server = null;
 		try
 		{
-			if(MC != null && MC.getCurrentServerEntry() != null)
-				server = MC.getCurrentServerEntry().address;
+			if(MC != null && MC.getCurrentServer() != null)
+				server = MC.getCurrentServer().ip;
 		}catch(Throwable ignored)
 		{}
 		String name = sanitizeServer(server);
@@ -933,10 +929,10 @@ public final class TrialSpawnerEspHack extends Hack
 	
 	private String detectMobFromDecor(BlockPos spawnerPos)
 	{
-		if(MC.world == null || spawnerPos == null)
+		if(MC.level == null || spawnerPos == null)
 			return "";
 		
-		BlockPos base = spawnerPos.down();
+		BlockPos base = spawnerPos.below();
 		boolean hasCobble = false;
 		boolean hasMossyCobble = false;
 		boolean hasStone = false;
@@ -957,33 +953,33 @@ public final class TrialSpawnerEspHack extends Hack
 				if(dx == 0 && dz == 0)
 					continue;
 				
-				BlockPos check = base.add(dx, 0, dz);
-				BlockState state = MC.world.getBlockState(check);
-				BlockState above = MC.world.getBlockState(check.up());
+				BlockPos check = base.offset(dx, 0, dz);
+				BlockState state = MC.level.getBlockState(check);
+				BlockState above = MC.level.getBlockState(check.above());
 				
-				if(state.isOf(Blocks.COBBLESTONE))
+				if(state.is(Blocks.COBBLESTONE))
 					hasCobble = true;
-				if(state.isOf(Blocks.MOSSY_COBBLESTONE))
+				if(state.is(Blocks.MOSSY_COBBLESTONE))
 					hasMossyCobble = true;
-				if(state.isOf(Blocks.STONE))
+				if(state.is(Blocks.STONE))
 					hasStone = true;
-				if(state.isOf(Blocks.COBWEB) || above.isOf(Blocks.COBWEB))
+				if(state.is(Blocks.COBWEB) || above.is(Blocks.COBWEB))
 					hasCobweb = true;
-				if(state.isOf(Blocks.PODZOL))
+				if(state.is(Blocks.PODZOL))
 					hasPodzol = true;
 				if(isMushroom(state) || isMushroom(above))
 					hasMushroom = true;
-				if(state.isOf(Blocks.CHISELED_SANDSTONE))
+				if(state.is(Blocks.CHISELED_SANDSTONE))
 					hasChiseledSandstone = true;
-				if(state.isOf(Blocks.CHISELED_TUFF))
+				if(state.is(Blocks.CHISELED_TUFF))
 					hasChiseledTuff = true;
-				if(state.isOf(Blocks.PACKED_ICE))
+				if(state.is(Blocks.PACKED_ICE))
 					hasPackedIce = true;
-				if(state.isOf(Blocks.STONE_BRICKS))
+				if(state.is(Blocks.STONE_BRICKS))
 					hasStoneBricks = true;
-				if(state.isOf(Blocks.MOSS_BLOCK))
+				if(state.is(Blocks.MOSS_BLOCK))
 					hasMossBlock = true;
-				if(state.isOf(Blocks.BONE_BLOCK))
+				if(state.is(Blocks.BONE_BLOCK))
 					hasBoneBlock = true;
 			}
 		}
@@ -1016,8 +1012,7 @@ public final class TrialSpawnerEspHack extends Hack
 	
 	private boolean isMushroom(BlockState state)
 	{
-		return state.isOf(Blocks.BROWN_MUSHROOM)
-			|| state.isOf(Blocks.RED_MUSHROOM);
+		return state.is(Blocks.BROWN_MUSHROOM) || state.is(Blocks.RED_MUSHROOM);
 	}
 	
 	private int getColorForStatus(TrialStatus status)
@@ -1031,11 +1026,11 @@ public final class TrialSpawnerEspHack extends Hack
 		};
 	}
 	
-	private String readMobId(NbtCompound spawnData)
+	private String readMobId(CompoundTag spawnData)
 	{
 		if(spawnData == null)
 			return "";
-		Optional<NbtCompound> entity = spawnData.getCompound("entity");
+		Optional<CompoundTag> entity = spawnData.getCompound("entity");
 		if(entity.isPresent())
 		{
 			Optional<String> id = entity.get().getString("id");
@@ -1050,12 +1045,12 @@ public final class TrialSpawnerEspHack extends Hack
 		if(mobId == null || mobId.isEmpty())
 			return "Unknown";
 		
-		Identifier id = Identifier.tryParse(mobId);
+		ResourceLocation id = ResourceLocation.tryParse(mobId);
 		if(id != null)
 		{
-			EntityType<?> entity = Registries.ENTITY_TYPE.get(id);
+			EntityType<?> entity = BuiltInRegistries.ENTITY_TYPE.getValue(id);
 			if(entity != null)
-				return entity.getName().getString();
+				return entity.getDescription().getString();
 		}
 		
 		return prettifyId(mobId);
@@ -1117,12 +1112,12 @@ public final class TrialSpawnerEspHack extends Hack
 	{
 		if(mobId == null || mobId.isEmpty())
 			return null;
-		Identifier id = Identifier.tryParse(mobId);
+		ResourceLocation id = ResourceLocation.tryParse(mobId);
 		if(id == null)
 			return null;
-		RegistryKey<EntityType<?>> key =
-			RegistryKey.of(RegistryKeys.ENTITY_TYPE, id);
-		return Registries.ENTITY_TYPE.get(key);
+		ResourceKey<EntityType<?>> key =
+			ResourceKey.create(Registries.ENTITY_TYPE, id);
+		return BuiltInRegistries.ENTITY_TYPE.getValue(key);
 	}
 	
 	private EntityType<?> mapDecorMobToType(String decorMob)
@@ -1146,17 +1141,17 @@ public final class TrialSpawnerEspHack extends Hack
 		};
 	}
 	
-	private int countWorldMobs(BlockPos pos, TrialSpawnerLogic logic,
+	private int countWorldMobs(BlockPos pos, TrialSpawner logic,
 		EntityType<?> mobType, String mobName)
 	{
-		if(MC.world == null || pos == null)
+		if(MC.level == null || pos == null)
 			return 0;
 		
 		double radius =
-			logic == null ? 8 : Math.max(6, logic.getDetectionRadius() + 4);
-		Box box =
-			Box.of(Vec3d.ofCenter(pos), radius * 2, radius * 2, radius * 2);
-		return MC.world.getEntitiesByClass(LivingEntity.class, box,
+			logic == null ? 8 : Math.max(6, logic.getRequiredPlayerRange() + 4);
+		AABB box = AABB.ofSize(Vec3.atCenterOf(pos), radius * 2, radius * 2,
+			radius * 2);
+		return MC.level.getEntitiesOfClass(LivingEntity.class, box,
 			entity -> matchesMob(entity, mobType, mobName)).size();
 	}
 	
@@ -1170,18 +1165,18 @@ public final class TrialSpawnerEspHack extends Hack
 		if(mobName == null || mobName.isEmpty())
 			return false;
 		
-		String typeName = entity.getType().getName().getString();
+		String typeName = entity.getType().getDescription().getString();
 		return typeName.equalsIgnoreCase(mobName);
 	}
 	
 	private String describeVaultState(BlockState state)
 	{
-		if(!state.isOf(Blocks.VAULT) || !state.contains(VaultBlock.VAULT_STATE))
+		if(!state.is(Blocks.VAULT) || !state.hasProperty(VaultBlock.STATE))
 			return "Missing";
 		
-		VaultState vaultState = state.get(VaultBlock.VAULT_STATE);
-		boolean ominous =
-			state.contains(VaultBlock.OMINOUS) && state.get(VaultBlock.OMINOUS);
+		VaultState vaultState = state.getValue(VaultBlock.STATE);
+		boolean ominous = state.hasProperty(VaultBlock.OMINOUS)
+			&& state.getValue(VaultBlock.OMINOUS);
 		String prefix = ominous ? "Ominous " : "";
 		return switch(vaultState)
 		{
@@ -1225,7 +1220,7 @@ public final class TrialSpawnerEspHack extends Hack
 	{
 		final int segments = 10;
 		int filled =
-			MathHelper.clamp((int)Math.round(progress * segments), 0, segments);
+			Mth.clamp((int)Math.round(progress * segments), 0, segments);
 		StringBuilder sb = new StringBuilder("[");
 		for(int i = 0; i < segments; i++)
 			sb.append(i < filled ? "#" : "-");
@@ -1235,7 +1230,7 @@ public final class TrialSpawnerEspHack extends Hack
 	
 	private int withAlpha(int color, float alpha)
 	{
-		int a = MathHelper.clamp((int)(alpha * 255), 0, 255);
+		int a = Mth.clamp((int)(alpha * 255), 0, 255);
 		return (color & 0x00FFFFFF) | (a << 24);
 	}
 	
@@ -1245,9 +1240,9 @@ public final class TrialSpawnerEspHack extends Hack
 		int r = (color >> 16) & 0xFF;
 		int g = (color >> 8) & 0xFF;
 		int b = color & 0xFF;
-		r = MathHelper.clamp((int)MathHelper.lerp(factor, r, 255), 0, 255);
-		g = MathHelper.clamp((int)MathHelper.lerp(factor, g, 255), 0, 255);
-		b = MathHelper.clamp((int)MathHelper.lerp(factor, b, 255), 0, 255);
+		r = Mth.clamp((int)Mth.lerpInt(factor, r, 255), 0, 255);
+		g = Mth.clamp((int)Mth.lerpInt(factor, g, 255), 0, 255);
+		b = Mth.clamp((int)Mth.lerpInt(factor, b, 255), 0, 255);
 		return (a << 24) | (r << 16) | (g << 8) | b;
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/TridentEspHack.java b/src/main/java/net/wurstclient/hacks/TridentEspHack.java
index b5d4eeeb0..526dd9014 100644
--- a/src/main/java/net/wurstclient/hacks/TridentEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/TridentEspHack.java
@@ -7,21 +7,20 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.ArrayList;
 import java.util.List;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.entity.projectile.TridentEntity;
-import net.minecraft.item.Items;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.Arm;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.HumanoidArm;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.ThrownTrident;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -71,7 +70,7 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		false);
 	
 	// Cached per-tick results
-	private final ArrayList<TridentEntity> thrown = new ArrayList<>();
+	private final ArrayList<ThrownTrident> thrown = new ArrayList<>();
 	private final ArrayList<LivingEntity> holders = new ArrayList<>();
 	
 	public TridentEspHack()
@@ -113,10 +112,10 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		thrown.clear();
 		holders.clear();
 		
-		for(Entity e : MC.world.getEntities())
+		for(Entity e : MC.level.entitiesForRendering())
 		{
-			if(e instanceof TridentEntity)
-				thrown.add((TridentEntity)e);
+			if(e instanceof ThrownTrident)
+				thrown.add((ThrownTrident)e);
 			if(includeHeld.isChecked() && e instanceof LivingEntity)
 			{
 				LivingEntity le = (LivingEntity)e;
@@ -130,8 +129,8 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 	
 	private boolean isHoldingTrident(LivingEntity e)
 	{
-		ItemStack main = e.getMainHandStack();
-		ItemStack off = e.getOffHandStack();
+		ItemStack main = e.getMainHandItem();
+		ItemStack off = e.getOffhandItem();
 		return (main != null && main.getItem() == Items.TRIDENT)
 			|| (off != null && off.getItem() == Items.TRIDENT);
 	}
@@ -145,7 +144,7 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(!style.hasBoxes() && !style.hasLines())
 			return;
@@ -156,7 +155,7 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 			renderSingleColor(matrixStack, partialTicks);
 	}
 	
-	private void renderSingleColor(MatrixStack matrixStack, float partialTicks)
+	private void renderSingleColor(PoseStack matrixStack, float partialTicks)
 	{
 		int lineColor;
 		if(useFixedColor.isChecked())
@@ -167,13 +166,13 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		
 		if(style.hasBoxes())
 		{
-			List<Box> boxes = new ArrayList<>();
-			for(TridentEntity t : thrown)
+			List<AABB> boxes = new ArrayList<>();
+			for(ThrownTrident t : thrown)
 				boxes.add(
 					applyExtraSize(EntityUtils.getLerpedBox(t, partialTicks)));
 			for(LivingEntity h : holders)
 			{
-				Box handBox = getHeldTridentBox(h, partialTicks);
+				AABB handBox = getHeldTridentBox(h, partialTicks);
 				if(handBox != null)
 					boxes.add(applyExtraSize(handBox));
 			}
@@ -184,12 +183,12 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		
 		if(style.hasLines())
 		{
-			List<Vec3d> ends = new ArrayList<>();
-			for(TridentEntity t : thrown)
+			List<Vec3> ends = new ArrayList<>();
+			for(ThrownTrident t : thrown)
 				ends.add(EntityUtils.getLerpedBox(t, partialTicks).getCenter());
 			for(LivingEntity h : holders)
 			{
-				Vec3d hand = getHeldTridentPos(h, partialTicks);
+				Vec3 hand = getHeldTridentPos(h, partialTicks);
 				if(hand != null)
 					ends.add(hand);
 			}
@@ -199,21 +198,22 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderByOwner(MatrixStack matrixStack, float partialTicks)
+	private void renderByOwner(PoseStack matrixStack, float partialTicks)
 	{
-		ArrayList<Box> selfBoxes = new ArrayList<>();
-		ArrayList<Box> playerBoxes = new ArrayList<>();
-		ArrayList<Box> mobBoxes = new ArrayList<>();
-		ArrayList<Vec3d> selfEnds = new ArrayList<>();
-		ArrayList<Vec3d> playerEnds = new ArrayList<>();
-		ArrayList<Vec3d> mobEnds = new ArrayList<>();
+		ArrayList<AABB> selfBoxes = new ArrayList<>();
+		ArrayList<AABB> playerBoxes = new ArrayList<>();
+		ArrayList<AABB> mobBoxes = new ArrayList<>();
+		ArrayList<Vec3> selfEnds = new ArrayList<>();
+		ArrayList<Vec3> playerEnds = new ArrayList<>();
+		ArrayList<Vec3> mobEnds = new ArrayList<>();
 		
-		for(TridentEntity t : thrown)
+		for(ThrownTrident t : thrown)
 		{
 			Entity owner = t.getOwner();
-			Box box = applyExtraSize(EntityUtils.getLerpedBox(t, partialTicks));
-			Vec3d end = box.getCenter();
-			if(owner instanceof PlayerEntity)
+			AABB box =
+				applyExtraSize(EntityUtils.getLerpedBox(t, partialTicks));
+			Vec3 end = box.getCenter();
+			if(owner instanceof Player)
 			{
 				if(owner == MC.player)
 				{
@@ -240,11 +240,11 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		{
 			for(LivingEntity h : holders)
 			{
-				Box handBox = getHeldTridentBox(h, partialTicks);
-				Vec3d end = getHeldTridentPos(h, partialTicks);
+				AABB handBox = getHeldTridentBox(h, partialTicks);
+				Vec3 end = getHeldTridentPos(h, partialTicks);
 				if(handBox == null || end == null)
 					continue;
-				if(h instanceof PlayerEntity)
+				if(h instanceof Player)
 				{
 					playerBoxes.add(applyExtraSize(handBox));
 					playerEnds.add(end);
@@ -288,36 +288,38 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private Box applyExtraSize(Box box)
+	private AABB applyExtraSize(AABB box)
 	{
 		double extra = boxSize.getExtraSize() / 2.0;
-		return box.offset(0, extra, 0).expand(extra);
+		return box.move(0, extra, 0).inflate(extra);
 	}
 	
 	// New helpers: approximate where the held trident is, and make a small box
 	// there
-	private Vec3d getHeldTridentPos(LivingEntity e, float partialTicks)
+	private Vec3 getHeldTridentPos(LivingEntity e, float partialTicks)
 	{
-		Hand hand = null;
-		if(!e.getMainHandStack().isEmpty()
-			&& e.getMainHandStack().isOf(Items.TRIDENT))
-			hand = Hand.MAIN_HAND;
-		else if(!e.getOffHandStack().isEmpty()
-			&& e.getOffHandStack().isOf(Items.TRIDENT))
-			hand = Hand.OFF_HAND;
+		InteractionHand hand = null;
+		if(!e.getMainHandItem().isEmpty()
+			&& e.getMainHandItem().is(Items.TRIDENT))
+			hand = InteractionHand.MAIN_HAND;
+		else if(!e.getOffhandItem().isEmpty()
+			&& e.getOffhandItem().is(Items.TRIDENT))
+			hand = InteractionHand.OFF_HAND;
 		if(hand == null)
 			return null;
 		
 		// Base position at entity feet (lerped), then add eye height - 0.1
-		Vec3d base = EntityUtils.getLerpedPos(e, partialTicks);
-		double yawRad = Math.toRadians(e.getYaw());
+		Vec3 base = EntityUtils.getLerpedPos(e, partialTicks);
+		double yawRad = Math.toRadians(e.getYRot());
 		
 		// Determine which side the given hand is on.
-		Arm mainArm = Arm.RIGHT;
-		if(e instanceof PlayerEntity pe)
+		HumanoidArm mainArm = HumanoidArm.RIGHT;
+		if(e instanceof Player pe)
 			mainArm = pe.getMainArm();
-		boolean rightSide = (mainArm == Arm.RIGHT && hand == Hand.MAIN_HAND)
-			|| (mainArm == Arm.LEFT && hand == Hand.OFF_HAND);
+		boolean rightSide =
+			(mainArm == HumanoidArm.RIGHT && hand == InteractionHand.MAIN_HAND)
+				|| (mainArm == HumanoidArm.LEFT
+					&& hand == InteractionHand.OFF_HAND);
 		double side = rightSide ? -1 : 1;
 		
 		double eyeH = e.getEyeHeight(e.getPose());
@@ -327,13 +329,13 @@ public final class TridentEspHack extends Hack implements UpdateListener,
 		return base.add(offX, offY, offZ);
 	}
 	
-	private Box getHeldTridentBox(LivingEntity e, float partialTicks)
+	private AABB getHeldTridentBox(LivingEntity e, float partialTicks)
 	{
-		Vec3d c = getHeldTridentPos(e, partialTicks);
+		Vec3 c = getHeldTridentPos(e, partialTicks);
 		if(c == null)
 			return null;
 		// Small cube around hand
 		double r = 0.18; // half-size
-		return new Box(c.x - r, c.y - r, c.z - r, c.x + r, c.y + r, c.z + r);
+		return new AABB(c.x - r, c.y - r, c.z - r, c.x + r, c.y + r, c.z + r);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/TriggerBotHack.java b/src/main/java/net/wurstclient/hacks/TriggerBotHack.java
index c3318df5b..3f86e1181 100644
--- a/src/main/java/net/wurstclient/hacks/TriggerBotHack.java
+++ b/src/main/java/net/wurstclient/hacks/TriggerBotHack.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.EntityHitResult;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.EntityHitResult;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.HandleInputListener;
@@ -125,7 +125,7 @@ public final class TriggerBotHack extends Hack
 	{
 		if(simulatingMouseClick)
 		{
-			IKeyBinding.get(MC.options.attackKey).simulatePress(false);
+			IKeyBinding.get(MC.options.keyAttack).simulatePress(false);
 			simulatingMouseClick = false;
 		}
 		
@@ -142,7 +142,7 @@ public final class TriggerBotHack extends Hack
 		if(!simulatingMouseClick)
 			return;
 		
-		IKeyBinding.get(MC.options.attackKey).simulatePress(false);
+		IKeyBinding.get(MC.options.keyAttack).simulatePress(false);
 		simulatingMouseClick = false;
 	}
 	
@@ -150,7 +150,7 @@ public final class TriggerBotHack extends Hack
 	public void onHandleInput()
 	{
 		speed.updateTimer();
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		if(player == null)
 		{
 			releaseWeaponRules();
@@ -158,7 +158,7 @@ public final class TriggerBotHack extends Hack
 		}
 		
 		// don't attack when a container/inventory screen is open
-		if(MC.currentScreen instanceof HandledScreen)
+		if(MC.screen instanceof AbstractContainerScreen)
 		{
 			releaseWeaponRules();
 			return;
@@ -183,13 +183,13 @@ public final class TriggerBotHack extends Hack
 		
 		if(simulateMouseClick.isChecked())
 		{
-			IKeyBinding.get(MC.options.attackKey).simulatePress(true);
+			IKeyBinding.get(MC.options.keyAttack).simulatePress(true);
 			simulatingMouseClick = true;
 			
 		}else
 		{
-			MC.interactionManager.attackEntity(player, target);
-			swingHand.swing(Hand.MAIN_HAND);
+			MC.gameMode.attack(player, target);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 		}
 		
 		speed.resetTimer(speedRandMS.getValue());
@@ -200,7 +200,7 @@ public final class TriggerBotHack extends Hack
 		if(!EntityUtils.IS_ATTACKABLE.test(entity))
 			return false;
 		
-		if(MC.player.squaredDistanceTo(entity) > range.getValueSq())
+		if(MC.player.distanceToSqr(entity) > range.getValueSq())
 			return false;
 		
 		return entityFilters.testOne(entity);
@@ -208,8 +208,8 @@ public final class TriggerBotHack extends Hack
 	
 	private Entity getTargetUnderCrosshair()
 	{
-		if(MC.crosshairTarget == null
-			|| !(MC.crosshairTarget instanceof EntityHitResult eResult))
+		if(MC.hitResult == null
+			|| !(MC.hitResult instanceof EntityHitResult eResult))
 			return null;
 		
 		Entity entity = eResult.getEntity();
@@ -255,7 +255,7 @@ public final class TriggerBotHack extends Hack
 			if(target == null || !setting.isActiveFor(target))
 				return false;
 			
-			ClientPlayerEntity player = MC.player;
+			LocalPlayer player = MC.player;
 			if(player == null)
 				return false;
 			
diff --git a/src/main/java/net/wurstclient/hacks/TrollPotionHack.java b/src/main/java/net/wurstclient/hacks/TrollPotionHack.java
index e6b755fa2..60319ec3f 100644
--- a/src/main/java/net/wurstclient/hacks/TrollPotionHack.java
+++ b/src/main/java/net/wurstclient/hacks/TrollPotionHack.java
@@ -9,18 +9,17 @@ package net.wurstclient.hacks;
 
 import java.util.ArrayList;
 import java.util.Optional;
-
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.text.Text;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.alchemy.PotionContents;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
@@ -46,7 +45,7 @@ public final class TrollPotionHack extends Hack
 	protected void onEnable()
 	{
 		// check gamemode
-		if(!MC.player.getAbilities().creativeMode)
+		if(!MC.player.getAbilities().instabuild)
 		{
 			ChatUtils.error("Creative mode only.");
 			setEnabled(false);
@@ -57,8 +56,8 @@ public final class TrollPotionHack extends Hack
 		ItemStack stack = potionType.getSelected().createPotionStack();
 		
 		// give potion
-		PlayerInventory inventory = MC.player.getInventory();
-		int slot = inventory.getEmptySlot();
+		Inventory inventory = MC.player.getInventory();
+		int slot = inventory.getFreeSlot();
 		if(slot < 0)
 			ChatUtils.error("Cannot give potion. Your inventory is full.");
 		else
@@ -101,24 +100,23 @@ public final class TrollPotionHack extends Hack
 		{
 			ItemStack stack = new ItemStack(item);
 			
-			ArrayList<StatusEffectInstance> effects = new ArrayList<>();
+			ArrayList<MobEffectInstance> effects = new ArrayList<>();
 			for(int i = 1; i <= 23; i++)
 			{
-				StatusEffect effect =
-					Registries.STATUS_EFFECT.getEntry(i).get().value();
-				RegistryEntry<StatusEffect> entry =
-					Registries.STATUS_EFFECT.getEntry(effect);
+				MobEffect effect =
+					BuiltInRegistries.MOB_EFFECT.get(i).get().value();
+				Holder<MobEffect> entry =
+					BuiltInRegistries.MOB_EFFECT.wrapAsHolder(effect);
 				
-				effects.add(new StatusEffectInstance(entry, Integer.MAX_VALUE,
+				effects.add(new MobEffectInstance(entry, Integer.MAX_VALUE,
 					Integer.MAX_VALUE));
 			}
 			
-			stack.set(DataComponentTypes.POTION_CONTENTS,
-				new PotionContentsComponent(Optional.empty(), Optional.empty(),
-					effects, Optional.empty()));
+			stack.set(DataComponents.POTION_CONTENTS, new PotionContents(
+				Optional.empty(), Optional.empty(), effects, Optional.empty()));
 			
 			String name = "\u00a7f" + itemName + " of Trolling";
-			stack.set(DataComponentTypes.CUSTOM_NAME, Text.literal(name));
+			stack.set(DataComponents.CUSTOM_NAME, Component.literal(name));
 			
 			return stack;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/TrueSightHack.java b/src/main/java/net/wurstclient/hacks/TrueSightHack.java
index b826d54ad..c9e4b371b 100644
--- a/src/main/java/net/wurstclient/hacks/TrueSightHack.java
+++ b/src/main/java/net/wurstclient/hacks/TrueSightHack.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.hack.Hack;
diff --git a/src/main/java/net/wurstclient/hacks/TunnellerHack.java b/src/main/java/net/wurstclient/hacks/TunnellerHack.java
index ca976391b..243ead44e 100644
--- a/src/main/java/net/wurstclient/hacks/TunnellerHack.java
+++ b/src/main/java/net/wurstclient/hacks/TunnellerHack.java
@@ -7,34 +7,32 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.DefaultVertexFormat;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.stream.StreamSupport;
-
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.FallingBlock;
-import net.minecraft.block.TorchBlock;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.option.GameOptions;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.client.render.VertexFormats;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.FallingBlockEntity;
-import net.minecraft.item.BlockItem;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.Vec3i;
-import net.minecraft.util.shape.VoxelShape;
-import net.minecraft.world.EmptyBlockView;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.Options;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Vec3i;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.item.FallingBlockEntity;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.EmptyBlockGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.FallingBlock;
+import net.minecraft.world.level.block.TorchBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.Category;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.events.RenderListener;
@@ -120,9 +118,9 @@ public final class TunnellerHack extends Hack
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(RenderListener.class, this);
 		
-		ClientPlayerEntity player = MC.player;
-		start = BlockPos.ofFloored(player.getEntityPos());
-		direction = player.getHorizontalFacing();
+		LocalPlayer player = MC.player;
+		start = BlockPos.containing(player.position());
+		direction = player.getDirection();
 		length = 0;
 		lastTorch = null;
 		nextTorch = start;
@@ -144,8 +142,8 @@ public final class TunnellerHack extends Hack
 		overlay.resetProgress();
 		if(currentBlock != null)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			currentBlock = null;
 		}
 		
@@ -172,11 +170,11 @@ public final class TunnellerHack extends Hack
 		if(hax.freecamHack.isEnabled() || hax.remoteViewHack.isEnabled())
 			return;
 		
-		GameOptions gs = MC.options;
-		KeyBinding[] bindings = {gs.forwardKey, gs.backKey, gs.leftKey,
-			gs.rightKey, gs.jumpKey, gs.sneakKey};
-		for(KeyBinding binding : bindings)
-			binding.setPressed(false);
+		Options gs = MC.options;
+		KeyMapping[] bindings = {gs.keyUp, gs.keyDown, gs.keyLeft, gs.keyRight,
+			gs.keyJump, gs.keyShift};
+		for(KeyMapping binding : bindings)
+			binding.setDown(false);
 		
 		for(Task task : tasks)
 		{
@@ -189,9 +187,9 @@ public final class TunnellerHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
-		matrixStack.push();
+		matrixStack.pushPose();
 		RenderUtils.applyRegionalRenderOffset(matrixStack);
 		
 		for(EasyVertexBuffer buffer : vertexBuffers)
@@ -202,7 +200,7 @@ public final class TunnellerHack extends Hack
 			buffer.draw(matrixStack, WurstRenderLayers.ESP_LINES);
 		}
 		
-		matrixStack.pop();
+		matrixStack.popPose();
 		
 		overlay.render(matrixStack, partialTicks, currentBlock);
 	}
@@ -213,17 +211,17 @@ public final class TunnellerHack extends Hack
 			vertexBuffers[0].close();
 		
 		RegionPos region = RenderUtils.getCameraRegion();
-		Vec3d offset = Vec3d.ofCenter(start).subtract(region.toVec3d());
+		Vec3 offset = Vec3.atCenterOf(start).subtract(region.toVec3d());
 		int cyan = 0x8000FFFF;
 		
-		Box nodeBox =
-			new Box(-0.25, -0.25, -0.25, 0.25, 0.25, 0.25).offset(offset);
-		Vec3d dirVec = Vec3d.of(direction.getVector());
-		Vec3d arrowStart = dirVec.multiply(0.25).add(offset);
-		Vec3d arrowEnd = dirVec.multiply(Math.max(0.5, length)).add(offset);
+		AABB nodeBox =
+			new AABB(-0.25, -0.25, -0.25, 0.25, 0.25, 0.25).move(offset);
+		Vec3 dirVec = Vec3.atLowerCornerOf(direction.getUnitVec3i());
+		Vec3 arrowStart = dirVec.scale(0.25).add(offset);
+		Vec3 arrowEnd = dirVec.scale(Math.max(0.5, length)).add(offset);
 		
-		vertexBuffers[0] = EasyVertexBuffer.createAndUpload(DrawMode.LINES,
-			VertexFormats.POSITION_COLOR_NORMAL, buffer -> {
+		vertexBuffers[0] = EasyVertexBuffer.createAndUpload(Mode.LINES,
+			DefaultVertexFormat.POSITION_COLOR_NORMAL, buffer -> {
 				RenderUtils.drawNode(buffer, nodeBox, cyan);
 				RenderUtils.drawArrow(buffer, arrowStart, arrowEnd, cyan, 0.1F);
 			});
@@ -231,8 +229,8 @@ public final class TunnellerHack extends Hack
 	
 	private BlockPos offset(BlockPos pos, Vec3i vec)
 	{
-		return pos.offset(direction.rotateYCounterclockwise(), vec.getX())
-			.up(vec.getY());
+		return pos.relative(direction.getCounterClockWise(), vec.getX())
+			.above(vec.getY());
 	}
 	
 	private int getDistance(BlockPos pos1, BlockPos pos2)
@@ -251,16 +249,15 @@ public final class TunnellerHack extends Hack
 		ArrayList<BlockPos> blocks = new ArrayList<>();
 		
 		Direction front = direction;
-		Direction left = front.rotateYCounterclockwise();
+		Direction left = front.getCounterClockWise();
 		
 		int fromFront =
-			from.getX() * front.getOffsetX() + from.getZ() * front.getOffsetZ();
+			from.getX() * front.getStepX() + from.getZ() * front.getStepZ();
 		int toFront =
-			to.getX() * front.getOffsetX() + to.getZ() * front.getOffsetZ();
+			to.getX() * front.getStepX() + to.getZ() * front.getStepZ();
 		int fromLeft =
-			from.getX() * left.getOffsetX() + from.getZ() * left.getOffsetZ();
-		int toLeft =
-			to.getX() * left.getOffsetX() + to.getZ() * left.getOffsetZ();
+			from.getX() * left.getStepX() + from.getZ() * left.getStepZ();
+		int toLeft = to.getX() * left.getStepX() + to.getZ() * left.getStepZ();
 		
 		int minFront = Math.min(fromFront, toFront);
 		int maxFront = Math.max(fromFront, toFront);
@@ -273,8 +270,8 @@ public final class TunnellerHack extends Hack
 			for(int y = maxY; y >= minY; y--)
 				for(int l = maxLeft; l >= minLeft; l--)
 				{
-					int x = f * front.getOffsetX() + l * left.getOffsetX();
-					int z = f * front.getOffsetZ() + l * left.getOffsetZ();
+					int x = f * front.getStepX() + l * left.getStepX();
+					int z = f * front.getStepZ() + l * left.getStepZ();
 					blocks.add(new BlockPos(x, y, z));
 				}
 			
@@ -295,8 +292,8 @@ public final class TunnellerHack extends Hack
 		@Override
 		public boolean canRun()
 		{
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
-			BlockPos base = start.offset(direction, length);
+			BlockPos player = BlockPos.containing(MC.player.position());
+			BlockPos base = start.relative(direction, length);
 			int distance = getDistance(player, base);
 			
 			if(distance <= 1)
@@ -310,8 +307,8 @@ public final class TunnellerHack extends Hack
 		@Override
 		public void run()
 		{
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
-			BlockPos base = start.offset(direction, length);
+			BlockPos player = BlockPos.containing(MC.player.position());
+			BlockPos base = start.relative(direction, length);
 			BlockPos from = offset(player, size.getSelected().from);
 			BlockPos to = offset(base, size.getSelected().to);
 			
@@ -319,11 +316,11 @@ public final class TunnellerHack extends Hack
 			getAllInBox(from, to).forEach(blocks::add);
 			
 			RegionPos region = RenderUtils.getCameraRegion();
-			Box blockBox = new Box(BlockPos.ORIGIN).contract(0.1)
-				.offset(region.negate().toVec3d());
+			AABB blockBox = new AABB(BlockPos.ZERO).deflate(0.1)
+				.move(region.negate().toVec3d());
 			
 			currentBlock = null;
-			ArrayList<Box> boxes = new ArrayList<>();
+			ArrayList<AABB> boxes = new ArrayList<>();
 			for(BlockPos pos : blocks)
 			{
 				if(!BlockUtils.canBeClicked(pos))
@@ -336,7 +333,7 @@ public final class TunnellerHack extends Hack
 				if(currentBlock == null)
 					currentBlock = pos;
 				
-				boxes.add(blockBox.offset(pos));
+				boxes.add(blockBox.move(pos));
 			}
 			
 			if(vertexBuffers[1] != null)
@@ -347,16 +344,15 @@ public final class TunnellerHack extends Hack
 			
 			int green = 0x8000FF00;
 			if(!boxes.isEmpty())
-				vertexBuffers[1] =
-					EasyVertexBuffer.createAndUpload(DrawMode.LINES,
-						VertexFormats.POSITION_COLOR_NORMAL, buffer -> {
-							for(Box box : boxes)
-								RenderUtils.drawOutlinedBox(buffer, box, green);
-						});
+				vertexBuffers[1] = EasyVertexBuffer.createAndUpload(Mode.LINES,
+					DefaultVertexFormat.POSITION_COLOR_NORMAL, buffer -> {
+						for(AABB box : boxes)
+							RenderUtils.drawOutlinedBox(buffer, box, green);
+					});
 			
 			if(currentBlock == null)
 			{
-				MC.interactionManager.cancelBlockBreaking();
+				MC.gameMode.stopDestroyBlock();
 				overlay.resetProgress();
 				
 				length++;
@@ -375,7 +371,7 @@ public final class TunnellerHack extends Hack
 				0);
 			breakBlock(currentBlock);
 			
-			if(MC.player.getAbilities().creativeMode
+			if(MC.player.getAbilities().instabuild
 				|| BlockUtils.getHardness(currentBlock) >= 1)
 			{
 				overlay.resetProgress();
@@ -391,8 +387,8 @@ public final class TunnellerHack extends Hack
 		@Override
 		public boolean canRun()
 		{
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
-			BlockPos base = start.offset(direction, length);
+			BlockPos player = BlockPos.containing(MC.player.position());
+			BlockPos base = start.relative(direction, length);
 			
 			return getDistance(player, base) > 1;
 		}
@@ -400,11 +396,11 @@ public final class TunnellerHack extends Hack
 		@Override
 		public void run()
 		{
-			BlockPos base = start.offset(direction, length);
-			Vec3d vec = Vec3d.ofCenter(base);
+			BlockPos base = start.relative(direction, length);
+			Vec3 vec = Vec3.atCenterOf(base);
 			WURST.getRotationFaker().faceVectorClientIgnorePitch(vec);
 			
-			MC.options.forwardKey.setPressed(true);
+			MC.options.keyUp.setDown(true);
 		}
 	}
 	
@@ -415,13 +411,14 @@ public final class TunnellerHack extends Hack
 		@Override
 		public boolean canRun()
 		{
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
+			BlockPos player = BlockPos.containing(MC.player.position());
 			BlockPos from = offsetFloor(player, size.getSelected().from);
 			BlockPos to = offsetFloor(player, size.getSelected().to);
 			
 			blocks.clear();
 			for(BlockPos pos : BlockUtils.getAllInBox(from, to))
-				if(!BlockUtils.getState(pos).isFullCube(MC.world, pos))
+				if(!BlockUtils.getState(pos).isCollisionShapeFullBlock(MC.level,
+					pos))
 					blocks.add(pos);
 				
 			if(vertexBuffers[2] != null)
@@ -433,17 +430,16 @@ public final class TunnellerHack extends Hack
 			if(!blocks.isEmpty())
 			{
 				RegionPos region = RenderUtils.getCameraRegion();
-				Box box = new Box(BlockPos.ORIGIN).contract(0.1)
-					.offset(region.negate().toVec3d());
+				AABB box = new AABB(BlockPos.ZERO).deflate(0.1)
+					.move(region.negate().toVec3d());
 				
 				int yellow = 0x80FFFF00;
-				vertexBuffers[2] =
-					EasyVertexBuffer.createAndUpload(DrawMode.LINES,
-						VertexFormats.POSITION_COLOR_NORMAL, buffer -> {
-							for(BlockPos pos : blocks)
-								RenderUtils.drawOutlinedBox(buffer,
-									box.offset(pos), yellow);
-						});
+				vertexBuffers[2] = EasyVertexBuffer.createAndUpload(Mode.LINES,
+					DefaultVertexFormat.POSITION_COLOR_NORMAL, buffer -> {
+						for(BlockPos pos : blocks)
+							RenderUtils.drawOutlinedBox(buffer, box.move(pos),
+								yellow);
+					});
 				
 				return true;
 			}
@@ -453,21 +449,21 @@ public final class TunnellerHack extends Hack
 		
 		private BlockPos offsetFloor(BlockPos pos, Vec3i vec)
 		{
-			return pos.offset(direction.rotateYCounterclockwise(), vec.getX())
-				.down();
+			return pos.relative(direction.getCounterClockWise(), vec.getX())
+				.below();
 		}
 		
 		@Override
 		public void run()
 		{
-			MC.options.sneakKey.setPressed(true);
-			Vec3d velocity = MC.player.getVelocity();
-			MC.player.setVelocity(0, velocity.y, 0);
+			MC.options.keyShift.setDown(true);
+			Vec3 velocity = MC.player.getDeltaMovement();
+			MC.player.setDeltaMovement(0, velocity.y, 0);
 			
-			Vec3d eyes = RotationUtils.getEyesPos().add(-0.5, -0.5, -0.5);
+			Vec3 eyes = RotationUtils.getEyesPos().add(-0.5, -0.5, -0.5);
 			Comparator<BlockPos> comparator =
 				Comparator.<BlockPos> comparingDouble(
-					p -> eyes.squaredDistanceTo(Vec3d.of(p)));
+					p -> eyes.distanceToSqr(Vec3.atLowerCornerOf(p)));
 			
 			BlockPos pos = blocks.stream().max(comparator).get();
 			
@@ -479,7 +475,7 @@ public final class TunnellerHack extends Hack
 				return;
 			}
 			
-			if(BlockUtils.getState(pos).isReplaceable())
+			if(BlockUtils.getState(pos).canBeReplaced())
 				placeBlockSimple(pos);
 			else
 			{
@@ -493,20 +489,21 @@ public final class TunnellerHack extends Hack
 			for(int slot = 0; slot < 9; slot++)
 			{
 				// filter out non-block items
-				ItemStack stack = MC.player.getInventory().getStack(slot);
+				ItemStack stack = MC.player.getInventory().getItem(slot);
 				if(stack.isEmpty() || !(stack.getItem() instanceof BlockItem))
 					continue;
 				
-				Block block = Block.getBlockFromItem(stack.getItem());
+				Block block = Block.byItem(stack.getItem());
 				
 				// filter out non-solid blocks
-				BlockState state = block.getDefaultState();
-				if(!state.isFullCube(EmptyBlockView.INSTANCE, BlockPos.ORIGIN))
+				BlockState state = block.defaultBlockState();
+				if(!state.isCollisionShapeFullBlock(EmptyBlockGetter.INSTANCE,
+					BlockPos.ZERO))
 					continue;
 				
 				// filter out blocks that would fall
-				if(block instanceof FallingBlock && FallingBlock
-					.canFallThrough(BlockUtils.getState(pos.down())))
+				if(block instanceof FallingBlock
+					&& FallingBlock.isFree(BlockUtils.getState(pos.below())))
 					continue;
 				
 				MC.player.getInventory().setSelectedSlot(slot);
@@ -528,7 +525,7 @@ public final class TunnellerHack extends Hack
 			if(!liquids.isEmpty())
 				return true;
 			
-			BlockPos base = start.offset(direction, length);
+			BlockPos base = start.relative(direction, length);
 			BlockPos from = offset(base, size.getSelected().from);
 			BlockPos to = offset(base, size.getSelected().to);
 			int maxY = Math.max(from.getY(), to.getY());
@@ -539,24 +536,25 @@ public final class TunnellerHack extends Hack
 				int maxOffset = Math.min(size.getSelected().maxRange, length);
 				for(int i = 0; i <= maxOffset; i++)
 				{
-					BlockPos pos2 = pos.offset(direction.getOpposite(), i);
+					BlockPos pos2 = pos.relative(direction.getOpposite(), i);
 					
 					if(!BlockUtils.getState(pos2).getFluidState().isEmpty())
 						liquids.add(pos2);
 				}
 				
-				if(BlockUtils.getState(pos).isFullCube(MC.world, pos))
+				if(BlockUtils.getState(pos).isCollisionShapeFullBlock(MC.level,
+					pos))
 					continue;
 				
 				// check next blocks
-				BlockPos pos3 = pos.offset(direction);
+				BlockPos pos3 = pos.relative(direction);
 				if(!BlockUtils.getState(pos3).getFluidState().isEmpty())
 					liquids.add(pos3);
 				
 				// check ceiling blocks
 				if(pos.getY() == maxY)
 				{
-					BlockPos pos4 = pos.up();
+					BlockPos pos4 = pos.above();
 					
 					if(!BlockUtils.getState(pos4).getFluidState().isEmpty())
 						liquids.add(pos4);
@@ -577,17 +575,16 @@ public final class TunnellerHack extends Hack
 			if(!liquids.isEmpty())
 			{
 				RegionPos region = RenderUtils.getCameraRegion();
-				Box box = new Box(BlockPos.ORIGIN).contract(0.1)
-					.offset(region.negate().toVec3d());
+				AABB box = new AABB(BlockPos.ZERO).deflate(0.1)
+					.move(region.negate().toVec3d());
 				
 				int red = 0x80FF0000;
-				vertexBuffers[3] =
-					EasyVertexBuffer.createAndUpload(DrawMode.LINES,
-						VertexFormats.POSITION_COLOR_NORMAL, buffer -> {
-							for(BlockPos pos : liquids)
-								RenderUtils.drawOutlinedBox(buffer,
-									box.offset(pos), red);
-						});
+				vertexBuffers[3] = EasyVertexBuffer.createAndUpload(Mode.LINES,
+					DefaultVertexFormat.POSITION_COLOR_NORMAL, buffer -> {
+						for(BlockPos pos : liquids)
+							RenderUtils.drawOutlinedBox(buffer, box.move(pos),
+								red);
+					});
 			}
 			
 			return true;
@@ -596,35 +593,35 @@ public final class TunnellerHack extends Hack
 		@Override
 		public void run()
 		{
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
-			KeyBinding forward = MC.options.forwardKey;
+			BlockPos player = BlockPos.containing(MC.player.position());
+			KeyMapping forward = MC.options.keyUp;
 			
-			Vec3d diffVec = Vec3d.of(player.subtract(start));
-			Vec3d dirVec = Vec3d.of(direction.getVector());
-			double dotProduct = diffVec.dotProduct(dirVec);
+			Vec3 diffVec = Vec3.atLowerCornerOf(player.subtract(start));
+			Vec3 dirVec = Vec3.atLowerCornerOf(direction.getUnitVec3i());
+			double dotProduct = diffVec.dot(dirVec);
 			
-			BlockPos pos1 = start.offset(direction, (int)dotProduct);
+			BlockPos pos1 = start.relative(direction, (int)dotProduct);
 			if(!player.equals(pos1))
 			{
 				WURST.getRotationFaker()
 					.faceVectorClientIgnorePitch(toVec3d(pos1));
-				forward.setPressed(true);
+				forward.setDown(true);
 				return;
 			}
 			
-			BlockPos pos2 = start.offset(direction, Math.max(0, length - 10));
+			BlockPos pos2 = start.relative(direction, Math.max(0, length - 10));
 			if(!player.equals(pos2))
 			{
 				WURST.getRotationFaker()
 					.faceVectorClientIgnorePitch(toVec3d(pos2));
-				forward.setPressed(true);
+				forward.setDown(true);
 				MC.player.setSprinting(true);
 				return;
 			}
 			
-			BlockPos pos3 = start.offset(direction, length + 1);
+			BlockPos pos3 = start.relative(direction, length + 1);
 			WURST.getRotationFaker().faceVectorClientIgnorePitch(toVec3d(pos3));
-			forward.setPressed(false);
+			forward.setDown(false);
 			MC.player.setSprinting(false);
 			
 			if(disableTimer > 0)
@@ -636,9 +633,9 @@ public final class TunnellerHack extends Hack
 			setEnabled(false);
 		}
 		
-		private Vec3d toVec3d(BlockPos pos)
+		private Vec3 toVec3d(BlockPos pos)
 		{
-			return Vec3d.ofCenter(pos);
+			return Vec3.atCenterOf(pos);
 		}
 	}
 	
@@ -656,7 +653,7 @@ public final class TunnellerHack extends Hack
 			if(!torches.isChecked())
 			{
 				lastTorch = null;
-				nextTorch = BlockPos.ofFloored(MC.player.getEntityPos());
+				nextTorch = BlockPos.containing(MC.player.position());
 				return false;
 			}
 			
@@ -664,29 +661,29 @@ public final class TunnellerHack extends Hack
 				lastTorch = nextTorch;
 			
 			if(lastTorch != null)
-				nextTorch = lastTorch.offset(direction,
+				nextTorch = lastTorch.relative(direction,
 					size.getSelected().torchDistance);
 			
 			RegionPos region = RenderUtils.getCameraRegion();
-			Vec3d torchVec =
-				Vec3d.ofBottomCenter(nextTorch).subtract(region.toVec3d());
+			Vec3 torchVec =
+				Vec3.atBottomCenterOf(nextTorch).subtract(region.toVec3d());
 			
 			int yellow = 0x80FFFF00;
-			vertexBuffers[4] = EasyVertexBuffer.createAndUpload(DrawMode.LINES,
-				VertexFormats.POSITION_COLOR_NORMAL, buffer -> {
+			vertexBuffers[4] = EasyVertexBuffer.createAndUpload(Mode.LINES,
+				DefaultVertexFormat.POSITION_COLOR_NORMAL, buffer -> {
 					RenderUtils.drawArrow(buffer, torchVec,
 						torchVec.add(0, 0.5, 0), yellow, 0.1F);
 				});
 			
-			BlockPos player = BlockPos.ofFloored(MC.player.getEntityPos());
+			BlockPos player = BlockPos.containing(MC.player.position());
 			if(getDistance(player, nextTorch) > 4)
 				return false;
 			
 			BlockState state = BlockUtils.getState(nextTorch);
-			if(!state.isReplaceable())
+			if(!state.canBeReplaced())
 				return false;
 			
-			return Blocks.TORCH.getDefaultState().canPlaceAt(MC.world,
+			return Blocks.TORCH.defaultBlockState().canSurvive(MC.level,
 				nextTorch);
 		}
 		
@@ -700,7 +697,7 @@ public final class TunnellerHack extends Hack
 				return;
 			}
 			
-			MC.options.sneakKey.setPressed(true);
+			MC.options.keyShift.setDown(true);
 			placeBlockSimple(nextTorch);
 		}
 		
@@ -709,12 +706,12 @@ public final class TunnellerHack extends Hack
 			for(int slot = 0; slot < 9; slot++)
 			{
 				// filter out non-block items
-				ItemStack stack = MC.player.getInventory().getStack(slot);
+				ItemStack stack = MC.player.getInventory().getItem(slot);
 				if(stack.isEmpty() || !(stack.getItem() instanceof BlockItem))
 					continue;
 				
 				// filter out non-torch blocks
-				Block block = Block.getBlockFromItem(stack.getItem());
+				Block block = Block.byItem(stack.getItem());
 				if(!(block instanceof TorchBlock))
 					continue;
 				
@@ -733,9 +730,9 @@ public final class TunnellerHack extends Hack
 		{
 			// check for nearby falling blocks
 			return StreamSupport
-				.stream(MC.world.getEntities().spliterator(), false)
+				.stream(MC.level.entitiesForRendering().spliterator(), false)
 				.filter(FallingBlockEntity.class::isInstance)
-				.anyMatch(e -> MC.player.squaredDistanceTo(e) < 36);
+				.anyMatch(e -> MC.player.distanceToSqr(e) < 36);
 		}
 		
 		@Override
@@ -750,28 +747,28 @@ public final class TunnellerHack extends Hack
 		Direction side = null;
 		Direction[] sides = Direction.values();
 		
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		Vec3d posVec = Vec3d.ofCenter(pos);
-		double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		Vec3 posVec = Vec3.atCenterOf(pos);
+		double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 		
-		Vec3d[] hitVecs = new Vec3d[sides.length];
+		Vec3[] hitVecs = new Vec3[sides.length];
 		for(int i = 0; i < sides.length; i++)
-			hitVecs[i] =
-				posVec.add(Vec3d.of(sides[i].getVector()).multiply(0.5));
+			hitVecs[i] = posVec
+				.add(Vec3.atLowerCornerOf(sides[i].getUnitVec3i()).scale(0.5));
 		
 		for(int i = 0; i < sides.length; i++)
 		{
 			// check if neighbor can be right clicked
-			BlockPos neighbor = pos.offset(sides[i]);
+			BlockPos neighbor = pos.relative(sides[i]);
 			if(!BlockUtils.canBeClicked(neighbor))
 				continue;
 			
 			// check line of sight
 			BlockState neighborState = BlockUtils.getState(neighbor);
 			VoxelShape neighborShape =
-				neighborState.getOutlineShape(MC.world, neighbor);
-			if(MC.world.raycastBlock(eyesPos, hitVecs[i], neighbor,
-				neighborShape, neighborState) != null)
+				neighborState.getShape(MC.level, neighbor);
+			if(MC.level.clipWithInteractionOverride(eyesPos, hitVecs[i],
+				neighbor, neighborShape, neighborState) != null)
 				continue;
 			
 			side = sides[i];
@@ -782,11 +779,11 @@ public final class TunnellerHack extends Hack
 			for(int i = 0; i < sides.length; i++)
 			{
 				// check if neighbor can be right clicked
-				if(!BlockUtils.canBeClicked(pos.offset(sides[i])))
+				if(!BlockUtils.canBeClicked(pos.relative(sides[i])))
 					continue;
 				
 				// check if side is facing away from player
-				if(distanceSqPosVec > eyesPos.squaredDistanceTo(hitVecs[i]))
+				if(distanceSqPosVec > eyesPos.distanceToSqr(hitVecs[i]))
 					continue;
 				
 				side = sides[i];
@@ -796,7 +793,7 @@ public final class TunnellerHack extends Hack
 		if(side == null)
 			return;
 		
-		Vec3d hitVec = hitVecs[side.ordinal()];
+		Vec3 hitVec = hitVecs[side.ordinal()];
 		
 		// face block
 		WURST.getRotationFaker().faceVectorPacket(hitVec);
@@ -804,34 +801,34 @@ public final class TunnellerHack extends Hack
 			return;
 		
 		// check timer
-		if(MC.itemUseCooldown > 0)
+		if(MC.rightClickDelay > 0)
 			return;
 		
 		// place block
-		IMC.getInteractionManager().rightClickBlock(pos.offset(side),
+		IMC.getInteractionManager().rightClickBlock(pos.relative(side),
 			side.getOpposite(), hitVec);
 		
 		// swing arm
-		SwingHand.SERVER.swing(Hand.MAIN_HAND);
+		SwingHand.SERVER.swing(InteractionHand.MAIN_HAND);
 		
 		// reset timer
-		MC.itemUseCooldown = 4;
+		MC.rightClickDelay = 4;
 	}
 	
 	private boolean breakBlock(BlockPos pos)
 	{
 		Direction[] sides = Direction.values();
 		
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		Vec3d relCenter = BlockUtils.getBoundingBox(pos)
-			.offset(-pos.getX(), -pos.getY(), -pos.getZ()).getCenter();
-		Vec3d center = Vec3d.of(pos).add(relCenter);
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		Vec3 relCenter = BlockUtils.getBoundingBox(pos)
+			.move(-pos.getX(), -pos.getY(), -pos.getZ()).getCenter();
+		Vec3 center = Vec3.atLowerCornerOf(pos).add(relCenter);
 		
-		Vec3d[] hitVecs = new Vec3d[sides.length];
+		Vec3[] hitVecs = new Vec3[sides.length];
 		for(int i = 0; i < sides.length; i++)
 		{
-			Vec3i dirVec = sides[i].getVector();
-			Vec3d relHitVec = new Vec3d(relCenter.x * dirVec.getX(),
+			Vec3i dirVec = sides[i].getUnitVec3i();
+			Vec3 relHitVec = new Vec3(relCenter.x * dirVec.getX(),
 				relCenter.y * dirVec.getY(), relCenter.z * dirVec.getZ());
 			hitVecs[i] = center.add(relHitVec);
 		}
@@ -839,10 +836,10 @@ public final class TunnellerHack extends Hack
 		double[] distancesSq = new double[sides.length];
 		boolean[] linesOfSight = new boolean[sides.length];
 		
-		double distanceSqToCenter = eyesPos.squaredDistanceTo(center);
+		double distanceSqToCenter = eyesPos.distanceToSqr(center);
 		for(int i = 0; i < sides.length; i++)
 		{
-			distancesSq[i] = eyesPos.squaredDistanceTo(hitVecs[i]);
+			distancesSq[i] = eyesPos.distanceToSqr(hitVecs[i]);
 			
 			// no need to raytrace the rear sides,
 			// they can't possibly have line of sight
@@ -873,11 +870,11 @@ public final class TunnellerHack extends Hack
 		WURST.getRotationFaker().faceVectorPacket(hitVecs[side.ordinal()]);
 		
 		// damage block
-		if(!MC.interactionManager.updateBlockBreakingProgress(pos, side))
+		if(!MC.gameMode.continueDestroyBlock(pos, side))
 			return false;
 		
 		// swing arm
-		SwingHand.SERVER.swing(Hand.MAIN_HAND);
+		SwingHand.SERVER.swing(InteractionHand.MAIN_HAND);
 		
 		return true;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/VeinMinerHack.java b/src/main/java/net/wurstclient/hacks/VeinMinerHack.java
index 9708897e7..ec7742618 100644
--- a/src/main/java/net/wurstclient/hacks/VeinMinerHack.java
+++ b/src/main/java/net/wurstclient/hacks/VeinMinerHack.java
@@ -7,22 +7,21 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.events.LeftClickListener;
 import net.wurstclient.events.RenderListener;
@@ -45,8 +44,8 @@ import net.wurstclient.util.RotationUtils;
 public final class VeinMinerHack extends Hack
 	implements UpdateListener, LeftClickListener, RenderListener
 {
-	private static final Box BLOCK_BOX =
-		new Box(1 / 16.0, 1 / 16.0, 1 / 16.0, 15 / 16.0, 15 / 16.0, 15 / 16.0);
+	private static final AABB BLOCK_BOX =
+		new AABB(1 / 16.0, 1 / 16.0, 1 / 16.0, 15 / 16.0, 15 / 16.0, 15 / 16.0);
 	
 	private final SliderSetting range =
 		new SliderSetting("Range", 5, 1, 6, 0.05, ValueDisplay.DECIMAL);
@@ -111,8 +110,8 @@ public final class VeinMinerHack extends Hack
 		currentVein.clear();
 		if(currentBlock != null)
 		{
-			MC.interactionManager.breakingBlock = true;
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.isDestroying = true;
+			MC.gameMode.stopDestroyBlock();
 			currentBlock = null;
 		}
 		
@@ -124,13 +123,13 @@ public final class VeinMinerHack extends Hack
 	public void onUpdate()
 	{
 		currentBlock = null;
-		currentVein.removeIf(pos -> BlockUtils.getState(pos).isReplaceable());
+		currentVein.removeIf(pos -> BlockUtils.getState(pos).canBeReplaced());
 		
-		if(MC.options.attackKey.isPressed())
+		if(MC.options.keyAttack.isDown())
 			return;
 		
-		Vec3d eyesVec = RotationUtils.getEyesPos();
-		BlockPos eyesBlock = BlockPos.ofFloored(eyesVec);
+		Vec3 eyesVec = RotationUtils.getEyesPos();
+		BlockPos eyesBlock = BlockPos.containing(eyesVec);
 		double rangeSq = range.getValueSq();
 		int blockRange = range.getValueCeil();
 		
@@ -146,9 +145,9 @@ public final class VeinMinerHack extends Hack
 		stream = stream.sorted(BlockBreaker.comparingParams());
 		
 		// Break all blocks in creative mode
-		if(MC.player.getAbilities().creativeMode)
+		if(MC.player.getAbilities().instabuild)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			
 			ArrayList<BlockPos> blocks = cache
@@ -158,7 +157,7 @@ public final class VeinMinerHack extends Hack
 			
 			currentBlock = blocks.get(0);
 			BlockBreaker.breakBlocksWithPacketSpam(blocks);
-			swingHand.swing(Hand.MAIN_HAND);
+			swingHand.swing(InteractionHand.MAIN_HAND);
 			return;
 		}
 		
@@ -168,7 +167,7 @@ public final class VeinMinerHack extends Hack
 		
 		if(currentBlock == null)
 		{
-			MC.interactionManager.cancelBlockBreaking();
+			MC.gameMode.stopDestroyBlock();
 			overlay.resetProgress();
 			return;
 		}
@@ -188,11 +187,10 @@ public final class VeinMinerHack extends Hack
 	{
 		WURST.getRotationFaker().faceVectorPacket(params.hitVec());
 		
-		if(!MC.interactionManager.updateBlockBreakingProgress(params.pos(),
-			params.side()))
+		if(!MC.gameMode.continueDestroyBlock(params.pos(), params.side()))
 			return false;
 		
-		swingHand.swing(Hand.MAIN_HAND);
+		swingHand.swing(InteractionHand.MAIN_HAND);
 		return true;
 	}
 	
@@ -202,7 +200,7 @@ public final class VeinMinerHack extends Hack
 		if(!currentVein.isEmpty())
 			return;
 		
-		if(!(MC.crosshairTarget instanceof BlockHitResult bHitResult)
+		if(!(MC.hitResult instanceof BlockHitResult bHitResult)
 			|| bHitResult.getType() != HitResult.Type.BLOCK)
 			return;
 		
@@ -227,7 +225,7 @@ public final class VeinMinerHack extends Hack
 			
 			for(Direction direction : Direction.values())
 			{
-				BlockPos neighbor = current.offset(direction);
+				BlockPos neighbor = current.relative(direction);
 				if(!currentVein.contains(neighbor)
 					&& BlockUtils.getBlock(neighbor) == targetBlock)
 				{
@@ -239,14 +237,14 @@ public final class VeinMinerHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		overlay.render(matrixStack, partialTicks, currentBlock);
 		if(currentVein.isEmpty())
 			return;
 		
-		List<Box> boxes =
-			currentVein.stream().map(pos -> BLOCK_BOX.offset(pos)).toList();
+		List<AABB> boxes =
+			currentVein.stream().map(pos -> BLOCK_BOX.move(pos)).toList();
 		RenderUtils.drawOutlinedBoxes(matrixStack, boxes, 0x80000000, false);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/WaypointsHack.java b/src/main/java/net/wurstclient/hacks/WaypointsHack.java
index 0e7d59ac4..e456d92ce 100644
--- a/src/main/java/net/wurstclient/hacks/WaypointsHack.java
+++ b/src/main/java/net/wurstclient/hacks/WaypointsHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
 import java.util.ArrayList;
@@ -16,18 +17,16 @@ import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.Locale;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.hud.BossBarHud;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.text.Text;
-import net.minecraft.text.MutableText;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.BossHealthOverlay;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.DeathListener;
@@ -235,16 +234,16 @@ public final class WaypointsHack extends Hack
 			applyDeathWaypointLinesSetting();
 		}
 		// Detect deaths of other players
-		if(trackOtherDeaths.isChecked() && MC.world != null
+		if(trackOtherDeaths.isChecked() && MC.level != null
 			&& MC.player != null)
 		{
 			long now = System.currentTimeMillis();
-			for(var p : MC.world.getPlayers())
+			for(var p : MC.level.players())
 			{
 				if(p == MC.player)
 					continue;
-				UUID id = p.getUuid();
-				boolean deadNow = p.getHealth() <= 0 || p.isDead();
+				UUID id = p.getUUID();
+				boolean deadNow = p.getHealth() <= 0 || p.isDeadOrDying();
 				boolean wasDead = knownDead.contains(id);
 				if(deadNow && !wasDead)
 				{
@@ -252,7 +251,7 @@ public final class WaypointsHack extends Hack
 					long last = otherDeathCooldown.getOrDefault(id, 0L);
 					if(now - last >= 10000)
 					{
-						BlockPos at = p.getBlockPos().up(2);
+						BlockPos at = p.blockPosition().above(2);
 						Waypoint w = new Waypoint(UUID.randomUUID(), now);
 						String name = p.getName().getString();
 						w.setName("Death of " + name + " "
@@ -274,9 +273,10 @@ public final class WaypointsHack extends Hack
 							sendingOwnChat = true;
 							try
 							{
-								MC.player.sendMessage(
-									Text.literal(name + " died at " + at.getX()
-										+ ", " + at.getY() + ", " + at.getZ()),
+								MC.player.displayClientMessage(
+									Component.literal(
+										name + " died at " + at.getX() + ", "
+											+ at.getY() + ", " + at.getZ()),
 									false);
 							}finally
 							{
@@ -299,7 +299,7 @@ public final class WaypointsHack extends Hack
 	{
 		if(sendingOwnChat)
 			return; // don't react to our own injected messages
-		if(!trackOtherDeaths.isChecked() || MC.world == null
+		if(!trackOtherDeaths.isChecked() || MC.level == null
 			|| MC.player == null)
 			return;
 		String msg = event.getComponent().getString();
@@ -329,7 +329,7 @@ public final class WaypointsHack extends Hack
 		
 		long now = System.currentTimeMillis();
 		// Try to match standard death messages: "<name> ..."
-		for(var p : MC.world.getPlayers())
+		for(var p : MC.level.players())
 		{
 			if(p == MC.player)
 				continue;
@@ -338,11 +338,11 @@ public final class WaypointsHack extends Hack
 				continue;
 			if(!msg.startsWith(name + " "))
 				continue;
-			UUID id = p.getUuid();
+			UUID id = p.getUUID();
 			long last = otherDeathCooldown.getOrDefault(id, 0L);
 			if(now - last < 10000)
 				return; // cooldown
-			BlockPos at = p.getBlockPos().up(2);
+			BlockPos at = p.blockPosition().above(2);
 			Waypoint w = new Waypoint(UUID.randomUUID(), now);
 			w.setName(
 				"Death of " + name + " " + TIME_FMT.format(LocalTime.now()));
@@ -363,8 +363,10 @@ public final class WaypointsHack extends Hack
 			if(chatOnDeath.isChecked())
 			{
 				// Safe-append to avoid immutable siblings crash
-				MutableText oldText = (MutableText)event.getComponent();
-				MutableText newText = MutableText.of(oldText.getContent());
+				MutableComponent oldText =
+					(MutableComponent)event.getComponent();
+				MutableComponent newText =
+					MutableComponent.create(oldText.getContents());
 				newText.setStyle(oldText.getStyle());
 				oldText.getSiblings().forEach(newText::append);
 				newText.append(
@@ -376,9 +378,9 @@ public final class WaypointsHack extends Hack
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrices, float partialTicks)
+	public void onRender(PoseStack matrices, float partialTicks)
 	{
-		if(MC.player == null || MC.world == null)
+		if(MC.player == null || MC.level == null)
 			return;
 		
 		var list = new ArrayList<>(manager.all());
@@ -397,7 +399,7 @@ public final class WaypointsHack extends Hack
 			if(wp == null)
 				continue;
 			
-			double distSq = MC.player.squaredDistanceTo(wp.getX() + 0.5,
+			double distSq = MC.player.distanceToSqr(wp.getX() + 0.5,
 				wp.getY() + 0.5, wp.getZ() + 0.5);
 			double dist = Math.sqrt(distSq);
 			double trd = waypointRenderDistance.getValue();
@@ -417,11 +419,10 @@ public final class WaypointsHack extends Hack
 			if(w.isLines())
 			{
 				RenderUtils.drawTracer(matrices, partialTicks,
-					new Vec3d(wp.getX() + 0.5, wp.getY() + 0.5,
-						wp.getZ() + 0.5),
+					new Vec3(wp.getX() + 0.5, wp.getY() + 0.5, wp.getZ() + 0.5),
 					applyFade(w.getColor(), distSq), false);
 				RenderUtils.drawOutlinedBoxes(matrices,
-					java.util.List.of(new Box(wp)),
+					java.util.List.of(new AABB(wp)),
 					applyFade(w.getColor(), distSq), false);
 			}
 			
@@ -470,14 +471,14 @@ public final class WaypointsHack extends Hack
 				boolean needAnchor = infiniteLabels || dist > 256.0;
 				if(needAnchor)
 				{
-					Vec3d cam = RenderUtils.getCameraPos();
-					Vec3d target = new Vec3d(lx, ly, lz);
-					Vec3d dir = target.subtract(cam);
+					Vec3 cam = RenderUtils.getCameraPos();
+					Vec3 target = new Vec3(lx, ly, lz);
+					Vec3 dir = target.subtract(cam);
 					double len = dir.length();
 					if(len > 1e-3)
 					{
 						double anchor = Math.min(len, 12.0);
-						Vec3d anchored = cam.add(dir.multiply(anchor / len));
+						Vec3 anchored = cam.add(dir.scale(anchor / len));
 						lx = anchored.x;
 						ly = anchored.y;
 						lz = anchored.z;
@@ -489,8 +490,8 @@ public final class WaypointsHack extends Hack
 				// remains approximately constant.
 				if(!anchored)
 				{
-					Vec3d cam2 = RenderUtils.getCameraPos();
-					double dLabel = cam2.distanceTo(new Vec3d(lx, ly, lz));
+					Vec3 cam2 = RenderUtils.getCameraPos();
+					double dLabel = cam2.distanceTo(new Vec3(lx, ly, lz));
 					double compensate = Math.max(1.0, dLabel * 0.1);
 					scale *= (float)compensate;
 				}
@@ -510,7 +511,7 @@ public final class WaypointsHack extends Hack
 		if(MC.player == null)
 			return;
 		
-		BlockPos at = MC.player.getBlockPos().up(2);
+		BlockPos at = MC.player.blockPosition().above(2);
 		long now = System.currentTimeMillis();
 		if(lastDeathAt != null && lastDeathAt.equals(at)
 			&& now - lastDeathCreatedMs < 10000)
@@ -518,7 +519,7 @@ public final class WaypointsHack extends Hack
 			
 		// Optional death chat, regardless of creating a waypoint
 		if(chatOnDeath.isChecked())
-			MC.player.sendMessage(Text.literal(
+			MC.player.displayClientMessage(Component.literal(
 				"Died at " + at.getX() + ", " + at.getY() + ", " + at.getZ()),
 				false);
 		
@@ -544,9 +545,9 @@ public final class WaypointsHack extends Hack
 	
 	private WaypointDimension currentDim()
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return WaypointDimension.OVERWORLD;
-		String key = MC.world.getRegistryKey().getValue().getPath();
+		String key = MC.level.dimension().location().getPath();
 		return switch(key)
 		{
 			case "the_nether" -> WaypointDimension.NETHER;
@@ -557,9 +558,9 @@ public final class WaypointsHack extends Hack
 	
 	private String resolveWorldId()
 	{
-		ServerInfo s = MC.getCurrentServerEntry();
-		if(s != null && s.address != null && !s.address.isEmpty())
-			return s.address.replace(':', '_');
+		ServerData s = MC.getCurrentServer();
+		if(s != null && s.ip != null && !s.ip.isEmpty())
+			return s.ip.replace(':', '_');
 		return "singleplayer";
 	}
 	
@@ -620,43 +621,42 @@ public final class WaypointsHack extends Hack
 			saveExcludingTemporaries();
 	}
 	
-	private void drawWorldLabel(MatrixStack matrices, String text, double x,
+	private void drawWorldLabel(PoseStack matrices, String text, double x,
 		double y, double z, int argb, float scale, float offsetPx)
 	{
-		matrices.push();
-		Vec3d cam = RenderUtils.getCameraPos();
+		matrices.pushPose();
+		Vec3 cam = RenderUtils.getCameraPos();
 		matrices.translate(x - cam.x, y - cam.y, z - cam.z);
 		// Face the camera (billboard)
 		var camEntity = MC.getCameraEntity();
 		if(camEntity != null)
 		{
-			matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_Y
-				.rotationDegrees(-camEntity.getYaw()));
-			matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_X
-				.rotationDegrees(camEntity.getPitch()));
+			matrices.mulPose(
+				com.mojang.math.Axis.YP.rotationDegrees(-camEntity.getYRot()));
+			matrices.mulPose(
+				com.mojang.math.Axis.XP.rotationDegrees(camEntity.getXRot()));
 		}
-		matrices.multiply(net.minecraft.util.math.RotationAxis.POSITIVE_Y
-			.rotationDegrees(180.0F));
+		matrices.mulPose(com.mojang.math.Axis.YP.rotationDegrees(180.0F));
 		float s = 0.025F * scale;
 		matrices.scale(s, -s, s);
 		// After scaling, translate by pixel offset to separate lines
 		// consistently.
 		matrices.translate(0, offsetPx, 0);
-		TextRenderer tr = MC.textRenderer;
-		VertexConsumerProvider.Immediate vcp = RenderUtils.getVCP();
-		float w = tr.getWidth(text) / 2F;
-		int bg = (int)(MC.options.getTextBackgroundOpacity(0.25F) * 255) << 24;
-		var matrix = matrices.peek().getPositionMatrix();
-		tr.draw(text, -w, 0, argb, false, matrix, vcp,
-			TextRenderer.TextLayerType.SEE_THROUGH, bg, 0xF000F0);
-		vcp.draw();
-		matrices.pop();
+		Font tr = MC.font;
+		MultiBufferSource.BufferSource vcp = RenderUtils.getVCP();
+		float w = tr.width(text) / 2F;
+		int bg = (int)(MC.options.getBackgroundOpacity(0.25F) * 255) << 24;
+		var matrix = matrices.last().pose();
+		tr.drawInBatch(text, -w, 0, argb, false, matrix, vcp,
+			Font.DisplayMode.SEE_THROUGH, bg, 0xF000F0);
+		vcp.endBatch();
+		matrices.popPose();
 	}
 	
-	private void drawBeaconBeam(MatrixStack matrices, BlockPos pos, int color,
+	private void drawBeaconBeam(PoseStack matrices, BlockPos pos, int color,
 		Waypoint.BeaconMode mode)
 	{
-		if(MC.world == null)
+		if(MC.level == null)
 			return;
 		@SuppressWarnings("all")
 		// noinspection RedundantQualifierName
@@ -664,8 +664,8 @@ public final class WaypointsHack extends Hack
 			mode == null ? Waypoint.BeaconMode.OFF : mode;
 		if(safeMode == Waypoint.BeaconMode.OFF)
 			return;
-		int minY = MC.world.getBottomY();
-		int maxY = MC.world.getTopYInclusive() + 1;
+		int minY = MC.level.getMinY();
+		int maxY = MC.level.getMaxY() + 1;
 		double baseX = pos.getX();
 		double baseZ = pos.getZ();
 		double centerX = baseX + 0.5;
@@ -679,30 +679,30 @@ public final class WaypointsHack extends Hack
 			new java.util.ArrayList<>();
 		boxes
 			.add(new RenderUtils.ColoredBox(
-				new Box(centerX - 0.18, minY, centerZ - 0.18, centerX + 0.18,
+				new AABB(centerX - 0.18, minY, centerZ - 0.18, centerX + 0.18,
 					maxY, centerZ + 0.18),
 				withAlpha(rgb, Math.min(255, alpha + 100))));
 		boxes
 			.add(
 				new RenderUtils.ColoredBox(
-					new Box(centerX - 0.32, minY, centerZ - 0.05,
+					new AABB(centerX - 0.32, minY, centerZ - 0.05,
 						centerX + 0.32, maxY, centerZ + 0.05),
 					withAlpha(rgb, alpha / 2)));
 		boxes
 			.add(
 				new RenderUtils.ColoredBox(
-					new Box(centerX - 0.05, minY, centerZ - 0.32,
+					new AABB(centerX - 0.05, minY, centerZ - 0.32,
 						centerX + 0.05, maxY, centerZ + 0.32),
 					withAlpha(rgb, alpha / 2)));
 		boxes.add(new RenderUtils.ColoredBox(
-			new Box(baseX, minY, baseZ, baseX + 1, maxY, baseZ + 1),
+			new AABB(baseX, minY, baseZ, baseX + 1, maxY, baseZ + 1),
 			withAlpha(rgb, Math.max(30, alpha / 6))));
 		RenderUtils.drawSolidBoxes(matrices, boxes, depthTest);
 		if(safeMode == Waypoint.BeaconMode.ESP)
 		{
 			RenderUtils.drawOutlinedBoxes(matrices,
 				java.util.List.of(
-					new Box(baseX, minY, baseZ, baseX + 1, maxY, baseZ + 1)),
+					new AABB(baseX, minY, baseZ, baseX + 1, maxY, baseZ + 1)),
 				withAlpha(rgb, Math.max(alpha, 120)), false);
 		}
 	}
@@ -775,18 +775,18 @@ public final class WaypointsHack extends Hack
 	public void openManager()
 	{
 		MC.setScreen(new net.wurstclient.clickgui.screens.WaypointsScreen(
-			MC.currentScreen, manager));
+			MC.screen, manager));
 	}
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
-		if(!compassMode.isChecked() || MC.player == null || MC.world == null)
+		if(!compassMode.isChecked() || MC.player == null || MC.level == null)
 			return;
 		
-		TextRenderer tr = MC.textRenderer;
-		int sw = context.getScaledWindowWidth();
-		int sh = context.getScaledWindowHeight();
+		Font tr = MC.font;
+		int sw = context.guiWidth();
+		int sh = context.guiHeight();
 		// Position from settings (percent of screen)
 		int centerX =
 			(int)Math.round(sw * (compassXPercent.getValue() / 100.0));
@@ -810,15 +810,15 @@ public final class WaypointsHack extends Hack
 		// Optionally draw player coords above the bar
 		if(showPlayerCoordsAboveCompass.isChecked())
 		{
-			String dir = cardinalFromYaw(MC.player.getYaw());
+			String dir = cardinalFromYaw(MC.player.getYRot());
 			int ix = (int)Math.floor(MC.player.getX());
 			int iy = (int)Math.floor(MC.player.getY());
 			int iz = (int)Math.floor(MC.player.getZ());
 			String coords = dir + ": " + ix + " " + iy + " " + iz;
-			int cw = tr.getWidth(coords);
+			int cw = tr.width(coords);
 			int cx = centerX - cw / 2;
 			int cy = Math.max(2, barY - 13); // was 12, now 13
-			context.drawText(tr, coords, cx, cy, 0xFFFFFFFF, false);
+			context.drawString(tr, coords, cx, cy, 0xFFFFFFFF, false);
 		}
 		
 		var list = new ArrayList<>(manager.all());
@@ -831,7 +831,7 @@ public final class WaypointsHack extends Hack
 		
 		double px = MC.player.getX();
 		double pz = MC.player.getZ();
-		double playerYaw = MC.player.getYaw();
+		double playerYaw = MC.player.getYRot();
 		
 		for(Waypoint w : list)
 		{
@@ -842,7 +842,7 @@ public final class WaypointsHack extends Hack
 				continue;
 			double dx = (wpb.getX() + 0.5) - px;
 			double dz = (wpb.getZ() + 0.5) - pz;
-			double distSq = MC.player.squaredDistanceTo(wpb.getX() + 0.5,
+			double distSq = MC.player.distanceToSqr(wpb.getX() + 0.5,
 				wpb.getY() + 0.5, wpb.getZ() + 0.5);
 			int waypointMax = w.getMaxVisible();
 			double waypointMaxSq = (double)(waypointMax * waypointMax);
@@ -902,10 +902,10 @@ public final class WaypointsHack extends Hack
 			if(icon == null)
 				icon = "";
 			int color = e.w.getColor();
-			int iconW = tr.getWidth(icon);
+			int iconW = tr.width(icon);
 			int iconY =
-				(int)Math.round(barY + barH / 2.0 - tr.fontHeight / 2.0);
-			context.drawText(tr, icon, ix - iconW / 2, iconY, color, false);
+				(int)Math.round(barY + barH / 2.0 - tr.lineHeight / 2.0);
+			context.drawString(tr, icon, ix - iconW / 2, iconY, color, false);
 		}
 		
 		// Draw selected name and distance
@@ -920,12 +920,12 @@ public final class WaypointsHack extends Hack
 			BlockPos wpb = worldSpace(selected.w);
 			int distBlocks = 0;
 			if(wpb != null)
-				distBlocks = (int)Math.round(
-					Math.sqrt(MC.player.squaredDistanceTo(wpb.getX() + 0.5,
+				distBlocks = (int)Math
+					.round(Math.sqrt(MC.player.distanceToSqr(wpb.getX() + 0.5,
 						wpb.getY() + 0.5, wpb.getZ() + 0.5)));
 			String distText = distBlocks + " blocks";
-			int tw = tr.getWidth(title);
-			int dw = tr.getWidth(distText);
+			int tw = tr.width(title);
+			int dw = tr.width(distText);
 			int titleX = centerX - tw / 2;
 			int distX = centerX - dw / 2;
 			int titleY = barY + barH + 3; // was 2, now 3 for 1.21.9
@@ -935,12 +935,12 @@ public final class WaypointsHack extends Hack
 				Math.max(0.0, Math.min(1.0, compassOpacity.getValue() / 100.0));
 			int aText = (int)Math.round(255 * opaText);
 			int textColor = (aText << 24) | 0x00FFFFFF;
-			context.drawText(tr, title, titleX, titleY, textColor, false);
-			context.drawText(tr, distText, distX, distY, textColor, false);
+			context.drawString(tr, title, titleX, titleY, textColor, false);
+			context.drawString(tr, distText, distX, distY, textColor, false);
 		}
 	}
 	
-	private int adjustCompassYForOverlays(DrawContext context, int baseY)
+	private int adjustCompassYForOverlays(GuiGraphics context, int baseY)
 	{
 		int adjusted = baseY;
 		int bossBarBottom = getBossBarBottom(context);
@@ -952,18 +952,18 @@ public final class WaypointsHack extends Hack
 		return adjusted;
 	}
 	
-	private int getBossBarBottom(DrawContext context)
+	private int getBossBarBottom(GuiGraphics context)
 	{
-		if(MC.inGameHud == null)
+		if(MC.gui == null)
 			return 0;
-		BossBarHud bossBarHud = MC.inGameHud.getBossBarHud();
-		if(bossBarHud == null || bossBarHud.bossBars.isEmpty())
+		BossHealthOverlay bossBarHud = MC.gui.getBossOverlay();
+		if(bossBarHud == null || bossBarHud.events.isEmpty())
 			return 0;
-		int screenHeight = context.getScaledWindowHeight();
+		int screenHeight = context.guiHeight();
 		int maxY = screenHeight / 3;
 		// Vanilla boss bars start at y=12 and advance by 19px per entry.
 		int y = 12;
-		for(int i = 0; i < bossBarHud.bossBars.size(); i++)
+		for(int i = 0; i < bossBarHud.events.size(); i++)
 		{
 			if(y >= maxY)
 				return maxY;
diff --git a/src/main/java/net/wurstclient/hacks/WindChargeKeyHack.java b/src/main/java/net/wurstclient/hacks/WindChargeKeyHack.java
index f33a38b59..94e147bec 100644
--- a/src/main/java/net/wurstclient/hacks/WindChargeKeyHack.java
+++ b/src/main/java/net/wurstclient/hacks/WindChargeKeyHack.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks;
 
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
+import com.mojang.blaze3d.platform.InputConstants;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.UpdateListener;
@@ -105,21 +105,21 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 	@Override
 	public void onUpdate()
 	{
-		if(MC.player == null || MC.world == null)
+		if(MC.player == null || MC.level == null)
 			return;
 		
-		if(MC.currentScreen != null)
+		if(MC.screen != null)
 		{
 			keyPressed = false;
 			return;
 		}
 		
-		InputUtil.Key key = getBoundKey();
+		InputConstants.Key key = getBoundKey();
 		if(key == null)
 			return;
 		
 		boolean currentlyPressed =
-			InputUtil.isKeyPressed(MC.getWindow(), key.getCode());
+			InputConstants.isKeyDown(MC.getWindow(), key.getValue());
 		
 		if(currentlyPressed && !keyPressed)
 			handleWindChargeThrow();
@@ -131,14 +131,14 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 		{
 			jumpScheduled = false;
 			
-			if(MC.player.isOnGround())
-				MC.player.jump();
+			if(MC.player.onGround())
+				MC.player.jumpFromGround();
 		}
 		
 		if(awaitingLaunch)
 		{
-			boolean airborne = !MC.player.isOnGround();
-			boolean upward = MC.player.getVelocity().y > 0.08;
+			boolean airborne = !MC.player.onGround();
+			boolean upward = MC.player.getDeltaMovement().y > 0.08;
 			boolean ready = upward || (!autoJump.isChecked() && airborne)
 				|| now >= launchDeadline;
 			
@@ -186,7 +186,7 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 		boolean silent = silentMode.isChecked();
 		boolean lookDown = lookDownBeforeThrow.isChecked();
 		
-		if(autoJump.isChecked() && MC.player.isOnGround())
+		if(autoJump.isChecked() && MC.player.onGround())
 		{
 			clearPending();
 			pendingSlot = windChargeSlot;
@@ -206,8 +206,8 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 		long delay = getJumpDelay();
 		if(delay <= 0)
 		{
-			if(MC.player.isOnGround())
-				MC.player.jump();
+			if(MC.player.onGround())
+				MC.player.jumpFromGround();
 			return;
 		}
 		
@@ -259,8 +259,8 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 	{
 		if(preferredSlot >= 0 && preferredSlot < 9)
 		{
-			ItemStack stack = MC.player.getInventory().getStack(preferredSlot);
-			if(stack.isOf(Items.WIND_CHARGE))
+			ItemStack stack = MC.player.getInventory().getItem(preferredSlot);
+			if(stack.is(Items.WIND_CHARGE))
 				return preferredSlot;
 		}
 		
@@ -269,13 +269,12 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 	
 	private float applyLookDown()
 	{
-		float oldPitch = MC.player.getPitch();
+		float oldPitch = MC.player.getXRot();
 		float downwardPitch = 90F;
-		MC.player.setPitch(downwardPitch);
-		MC.player.networkHandler.sendPacket(
-			new PlayerMoveC2SPacket.LookAndOnGround(MC.player.getYaw(),
-				downwardPitch, MC.player.isOnGround(),
-				MC.player.horizontalCollision));
+		MC.player.setXRot(downwardPitch);
+		MC.player.connection.send(new ServerboundMovePlayerPacket.Rot(
+			MC.player.getYRot(), downwardPitch, MC.player.onGround(),
+			MC.player.horizontalCollision));
 		return oldPitch;
 	}
 	
@@ -284,10 +283,10 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 		if(MC.player == null)
 			return;
 		
-		MC.player.setPitch(pitch);
-		MC.player.networkHandler.sendPacket(
-			new PlayerMoveC2SPacket.LookAndOnGround(MC.player.getYaw(), pitch,
-				MC.player.isOnGround(), MC.player.horizontalCollision));
+		MC.player.setXRot(pitch);
+		MC.player.connection
+			.send(new ServerboundMovePlayerPacket.Rot(MC.player.getYRot(),
+				pitch, MC.player.onGround(), MC.player.horizontalCollision));
 		restorePitch = false;
 		restorePitchAt = 0;
 	}
@@ -333,39 +332,39 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 	
 	private boolean useSelectedItem()
 	{
-		if(MC.player == null || MC.interactionManager == null)
+		if(MC.player == null || MC.gameMode == null)
 			return false;
 		
-		ItemStack stack = MC.player.getMainHandStack();
+		ItemStack stack = MC.player.getMainHandItem();
 		if(stack.isEmpty())
 			return false;
 		
-		ActionResult result =
-			MC.interactionManager.interactItem(MC.player, Hand.MAIN_HAND);
+		InteractionResult result =
+			MC.gameMode.useItem(MC.player, InteractionHand.MAIN_HAND);
 		
-		if(result.isAccepted())
-			MC.player.swingHand(Hand.MAIN_HAND);
+		if(result.consumesAction())
+			MC.player.swing(InteractionHand.MAIN_HAND);
 		
-		return result.isAccepted();
+		return result.consumesAction();
 	}
 	
 	private int findWindChargeInHotbar()
 	{
 		for(int i = 0; i < 9; i++)
 		{
-			ItemStack stack = MC.player.getInventory().getStack(i);
-			if(stack.isOf(Items.WIND_CHARGE))
+			ItemStack stack = MC.player.getInventory().getItem(i);
+			if(stack.is(Items.WIND_CHARGE))
 				return i;
 		}
 		
 		return -1;
 	}
 	
-	private InputUtil.Key getBoundKey()
+	private InputConstants.Key getBoundKey()
 	{
 		try
 		{
-			return InputUtil.fromTranslationKey(keybind.getValue());
+			return InputConstants.getKey(keybind.getValue());
 			
 		}catch(IllegalArgumentException e)
 		{
@@ -392,7 +391,7 @@ public final class WindChargeKeyHack extends Hack implements UpdateListener
 	{
 		try
 		{
-			return InputUtil.fromTranslationKey(translationKey) != null;
+			return InputConstants.getKey(translationKey) != null;
 			
 		}catch(IllegalArgumentException e)
 		{
diff --git a/src/main/java/net/wurstclient/hacks/WorkstationEspHack.java b/src/main/java/net/wurstclient/hacks/WorkstationEspHack.java
index bb676081f..8358f813f 100644
--- a/src/main/java/net/wurstclient/hacks/WorkstationEspHack.java
+++ b/src/main/java/net/wurstclient/hacks/WorkstationEspHack.java
@@ -7,19 +7,18 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.awt.Color;
 import java.util.Arrays;
 import java.util.List;
 import java.util.function.BiPredicate;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.CameraTransformViewBobbingListener;
@@ -218,7 +217,7 @@ public final class WorkstationEspHack extends Hack implements UpdateListener,
 	{
 		groupsUpToDate = false;
 		lastAreaSelection = area.getSelected();
-		lastPlayerChunk = new ChunkPos(MC.player.getBlockPos());
+		lastPlayerChunk = new ChunkPos(MC.player.blockPosition());
 		lastMatchesVersion = coordinator.getMatchesVersion();
 		EVENTS.add(UpdateListener.class, this);
 		EVENTS.add(CameraTransformViewBobbingListener.class, this);
@@ -252,7 +251,7 @@ public final class WorkstationEspHack extends Hack implements UpdateListener,
 			groupsUpToDate = false;
 		}
 		// Recenter per chunk when sticky is off
-		ChunkPos currentChunk = new ChunkPos(MC.player.getBlockPos());
+		ChunkPos currentChunk = new ChunkPos(MC.player.blockPosition());
 		if(!stickyArea.isChecked() && !currentChunk.equals(lastPlayerChunk))
 		{
 			lastPlayerChunk = currentChunk;
@@ -281,7 +280,7 @@ public final class WorkstationEspHack extends Hack implements UpdateListener,
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrixStack, float partialTicks)
+	public void onRender(PoseStack matrixStack, float partialTicks)
 	{
 		if(style.getSelected().hasBoxes())
 			renderBoxes(matrixStack);
@@ -289,13 +288,13 @@ public final class WorkstationEspHack extends Hack implements UpdateListener,
 			renderTracers(matrixStack, partialTicks);
 	}
 	
-	private void renderBoxes(MatrixStack matrixStack)
+	private void renderBoxes(PoseStack matrixStack)
 	{
 		for(PortalEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
+			List<AABB> boxes = group.getBoxes();
 			int quadsColor = group.getColorI(0x40);
 			int linesColor = group.getColorI(0x80);
 			RenderUtils.drawSolidBoxes(matrixStack, boxes, quadsColor, false);
@@ -304,14 +303,14 @@ public final class WorkstationEspHack extends Hack implements UpdateListener,
 		}
 	}
 	
-	private void renderTracers(MatrixStack matrixStack, float partialTicks)
+	private void renderTracers(PoseStack matrixStack, float partialTicks)
 	{
 		for(PortalEspBlockGroup group : groups)
 		{
 			if(!group.isEnabled())
 				continue;
-			List<Box> boxes = group.getBoxes();
-			List<Vec3d> ends = boxes.stream().map(Box::getCenter).toList();
+			List<AABB> boxes = group.getBoxes();
+			List<Vec3> ends = boxes.stream().map(AABB::getCenter).toList();
 			int color = group.getColorI(0x80);
 			RenderUtils.drawTracers(matrixStack, partialTicks, ends, color,
 				false);
diff --git a/src/main/java/net/wurstclient/hacks/XCarryHack.java b/src/main/java/net/wurstclient/hacks/XCarryHack.java
index 45abb1539..e5fd3582e 100644
--- a/src/main/java/net/wurstclient/hacks/XCarryHack.java
+++ b/src/main/java/net/wurstclient/hacks/XCarryHack.java
@@ -11,11 +11,10 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.ItemStack;
-import net.minecraft.network.packet.c2s.play.CloseHandledScreenC2SPacket;
-import net.minecraft.screen.slot.Slot;
+import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.PacketOutputListener;
@@ -75,14 +74,13 @@ public final class XCarryHack extends Hack
 	public void onSentPacket(PacketOutputEvent event)
 	{
 		if(!(event
-			.getPacket() instanceof CloseHandledScreenC2SPacket closeScreenPacket))
+			.getPacket() instanceof ServerboundContainerClosePacket closeScreenPacket))
 			return;
 		
 		if(MC.player == null)
 			return;
 		
-		if(disableInCreative.isChecked()
-			&& MC.player.getAbilities().creativeMode)
+		if(disableInCreative.isChecked() && MC.player.getAbilities().instabuild)
 			return;
 		
 		if(dangerousMode.isChecked())
@@ -91,15 +89,15 @@ public final class XCarryHack extends Hack
 			return;
 		}
 		
-		if(MC.player.playerScreenHandler != null && closeScreenPacket
-			.getSyncId() == MC.player.playerScreenHandler.syncId)
+		if(MC.player.inventoryMenu != null && closeScreenPacket
+			.getContainerId() == MC.player.inventoryMenu.containerId)
 			event.cancel();
 	}
 	
 	@Override
 	public void onUpdate()
 	{
-		if(MC.player == null || MC.world == null)
+		if(MC.player == null || MC.level == null)
 		{
 			resetTracking();
 			return;
@@ -115,7 +113,7 @@ public final class XCarryHack extends Hack
 	private void monitorCraftingGrid(List<ItemStack> previousInventory,
 		List<ItemStack> currentInventory)
 	{
-		if(MC.player == null || MC.player.playerScreenHandler == null)
+		if(MC.player == null || MC.player.inventoryMenu == null)
 			return;
 		
 		List<ItemStack> removedStacks = new ArrayList<>();
@@ -125,8 +123,7 @@ public final class XCarryHack extends Hack
 			ItemStack previous = trackedCraftingStacks[i];
 			trackedCraftingStacks[i] = current.copy();
 			
-			if(MC.currentScreen != null || previous.isEmpty()
-				|| !current.isEmpty())
+			if(MC.screen != null || previous.isEmpty() || !current.isEmpty())
 				continue;
 			
 			removedStacks.add(previous);
@@ -179,15 +176,15 @@ public final class XCarryHack extends Hack
 	
 	private ItemStack getCraftingSlotStack(int offset)
 	{
-		if(MC.player == null || MC.player.playerScreenHandler == null)
+		if(MC.player == null || MC.player.inventoryMenu == null)
 			return ItemStack.EMPTY;
 		
-		List<Slot> slots = MC.player.playerScreenHandler.slots;
+		List<Slot> slots = MC.player.inventoryMenu.slots;
 		int index = CRAFTING_SLOT_START + offset;
 		if(index < 0 || index >= slots.size())
 			return ItemStack.EMPTY;
 		
-		return slots.get(index).getStack();
+		return slots.get(index).getItem();
 	}
 	
 	private List<ItemStack> captureInventorySnapshot()
@@ -195,10 +192,10 @@ public final class XCarryHack extends Hack
 		if(MC.player == null)
 			return Collections.emptyList();
 		
-		PlayerInventory inv = MC.player.getInventory();
-		List<ItemStack> snapshot = new ArrayList<>(inv.size());
-		for(int i = 0; i < inv.size(); i++)
-			snapshot.add(inv.getStack(i).copy());
+		Inventory inv = MC.player.getInventory();
+		List<ItemStack> snapshot = new ArrayList<>(inv.getContainerSize());
+		for(int i = 0; i < inv.getContainerSize(); i++)
+			snapshot.add(inv.getItem(i).copy());
 		
 		return snapshot;
 	}
@@ -276,7 +273,7 @@ public final class XCarryHack extends Hack
 	
 	private static String formatStack(ItemStack stack, int count)
 	{
-		return count + "x " + stack.getName().getString();
+		return count + "x " + stack.getHoverName().getString();
 	}
 	
 	private void resetTracking()
diff --git a/src/main/java/net/wurstclient/hacks/XRayHack.java b/src/main/java/net/wurstclient/hacks/XRayHack.java
index 8acce605a..e3a62096e 100644
--- a/src/main/java/net/wurstclient/hacks/XRayHack.java
+++ b/src/main/java/net/wurstclient/hacks/XRayHack.java
@@ -7,6 +7,7 @@
  */
 package net.wurstclient.hacks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
@@ -14,12 +15,11 @@ import java.util.stream.Stream;
 import net.fabricmc.loader.api.FabricLoader;
 import net.fabricmc.loader.api.ModContainer;
 import net.fabricmc.loader.api.metadata.ModMetadata;
-import net.minecraft.block.Block;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.Box;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.Category;
 import net.wurstclient.SearchTags;
 import net.wurstclient.clickgui.screens.EditBlockListScreen;
@@ -108,8 +108,8 @@ public final class XRayHack extends Hack implements UpdateListener,
 	private String[] oreKeywords;
 	private double lastOpacityVal;
 	private int lastOresHash;
-	private final ThreadLocal<BlockPos.Mutable> mutablePosForExposedCheck =
-		ThreadLocal.withInitial(BlockPos.Mutable::new);
+	private final ThreadLocal<BlockPos.MutableBlockPos> mutablePosForExposedCheck =
+		ThreadLocal.withInitial(BlockPos.MutableBlockPos::new);
 	
 	// Track last selected mode so switching triggers reloads
 	private Mode lastMode = null;
@@ -153,7 +153,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 	private java.util.List<BlockPos> highlightPositions =
 		new java.util.ArrayList<>();
 	private boolean visibleBoxesUpToDate = false;
-	private java.util.List<Box> visibleBoxes = new java.util.ArrayList<>();
+	private java.util.List<AABB> visibleBoxes = new java.util.ArrayList<>();
 	private int lastMatchesVersion;
 	
 	// Debounce to avoid flashing when coordinator updates rapidly (e.g., on
@@ -263,7 +263,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 		EVENTS.add(RenderBlockEntityListener.class, this);
 		
 		// reload chunks
-		MC.worldRenderer.reload();
+		MC.levelRenderer.allChanged();
 		
 		// display warning if OptiFine is detected
 		if(optiFineWarning != null)
@@ -283,12 +283,12 @@ public final class XRayHack extends Hack implements UpdateListener,
 		EVENTS.remove(RenderBlockEntityListener.class, this);
 		
 		// reload chunks
-		MC.worldRenderer.reload();
+		MC.levelRenderer.allChanged();
 		
 		// reset gamma
 		FullbrightHack fullbright = WURST.getHax().fullbrightHack;
 		if(!fullbright.isChangingGamma())
-			ISimpleOption.get(MC.options.getGamma())
+			ISimpleOption.get(MC.options.gamma())
 				.forceSetValue(fullbright.getDefaultGamma());
 	}
 	
@@ -313,7 +313,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 		}
 		
 		// force gamma to 16 so that ores are bright enough to see
-		ISimpleOption.get(MC.options.getGamma()).forceSetValue(16.0);
+		ISimpleOption.get(MC.options.gamma()).forceSetValue(16.0);
 		// Live-apply changes to list and opacity
 		// Detect mode changes and handle switching
 		Mode curMode = mode.getSelected();
@@ -327,7 +327,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 				rebuildOreCaches();
 				// reset search and highlights
 				resetCoordinatorAndHighlights();
-				MC.worldRenderer.reload();
+				MC.levelRenderer.allChanged();
 			}else // switched to QUERY
 			{
 				oreNamesCache = null; // avoid fallback to list
@@ -341,7 +341,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 						.filter(s -> !s.isEmpty()).toArray(String[]::new);
 				// reset search and highlights
 				resetCoordinatorAndHighlights();
-				MC.worldRenderer.reload();
+				MC.levelRenderer.allChanged();
 			}
 		}
 		
@@ -355,7 +355,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 				rebuildOreCaches();
 				// reset so results update instantly
 				resetCoordinatorAndHighlights();
-				MC.worldRenderer.reload();
+				MC.levelRenderer.allChanged();
 			}else
 			{
 				// safety: if caches are missing (e.g., after a reload), rebuild
@@ -390,7 +390,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 				oreExactIds = null; // force keyword path
 				// reset so results update instantly
 				resetCoordinatorAndHighlights();
-				MC.worldRenderer.reload();
+				MC.levelRenderer.allChanged();
 			}
 		}
 		
@@ -398,7 +398,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 		if(currentOpacity != lastOpacityVal)
 		{
 			lastOpacityVal = currentOpacity;
-			MC.worldRenderer.reload();
+			MC.levelRenderer.allChanged();
 		}
 		// Detect only-exposed toggle changes and reload chunks so mixins
 		// re-evaluate visibility based on the new setting.
@@ -409,12 +409,12 @@ public final class XRayHack extends Hack implements UpdateListener,
 			// Rebuild visible boxes immediately from known positions so the
 			// ESP updates without waiting for a full coordinator pass.
 			rebuildVisibleBoxes();
-			MC.worldRenderer.reload();
+			MC.levelRenderer.allChanged();
 		}
 	}
 	
 	@Override
-	public void onRender(MatrixStack matrices, float partialTicks)
+	public void onRender(PoseStack matrices, float partialTicks)
 	{
 		long now = System.currentTimeMillis();
 		
@@ -423,9 +423,9 @@ public final class XRayHack extends Hack implements UpdateListener,
 		{
 			highlightPositions.clear();
 			// collect nearest N positions (limit controlled by renderAmount)
-			BlockPos playerPos = MC.player.getBlockPos();
+			BlockPos playerPos = MC.player.blockPosition();
 			java.util.Comparator<BlockPos> comparator = java.util.Comparator
-				.comparingInt(p -> playerPos.getManhattanDistance(p));
+				.comparingInt(p -> playerPos.distManhattan(p));
 			coordinator.getMatches().map(r -> r.pos()).sorted(comparator)
 				.limit(renderAmount.getValueLog())
 				.forEach(highlightPositions::add);
@@ -438,12 +438,12 @@ public final class XRayHack extends Hack implements UpdateListener,
 		// recently, keep existing boxes until debounce expires.
 		if(!visibleBoxesUpToDate)
 		{
-			java.util.List<Box> newBoxes = new java.util.ArrayList<>();
+			java.util.List<AABB> newBoxes = new java.util.ArrayList<>();
 			for(BlockPos p : highlightPositions)
 			{
 				if(onlyExposed.isChecked() && !isExposed(p))
 					continue;
-				newBoxes.add(new Box(p));
+				newBoxes.add(new AABB(p));
 			}
 			
 			// If newBoxes empty but coordinator changed very recently, skip
@@ -483,7 +483,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 		{
 			if(onlyExposed.isChecked() && !isExposed(p))
 				continue;
-			visibleBoxes.add(new Box(p));
+			visibleBoxes.add(new AABB(p));
 		}
 		visibleBoxesUpToDate = true;
 	}
@@ -515,7 +515,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 	@Override
 	public void onRenderBlockEntity(RenderBlockEntityEvent event)
 	{
-		BlockPos pos = event.getState().pos;
+		BlockPos pos = event.getState().blockPos;
 		if(!isVisible(BlockUtils.getBlock(pos), pos))
 			event.cancel();
 	}
@@ -543,7 +543,7 @@ public final class XRayHack extends Hack implements UpdateListener,
 				String localId = idFull.contains(":")
 					? idFull.substring(idFull.indexOf(":") + 1) : idFull;
 				String localSpaced = localId.replace('_', ' ');
-				String transKey = block.getTranslationKey();
+				String transKey = block.getDescriptionId();
 				String display = block.getName().getString();
 				for(String term : oreKeywords)
 					if(containsNormalized(idFull, term)
@@ -566,9 +566,10 @@ public final class XRayHack extends Hack implements UpdateListener,
 	
 	private boolean isExposed(BlockPos pos)
 	{
-		BlockPos.Mutable mutablePos = mutablePosForExposedCheck.get();
+		BlockPos.MutableBlockPos mutablePos = mutablePosForExposedCheck.get();
 		for(Direction direction : Direction.values())
-			if(!BlockUtils.isOpaqueFullCube(mutablePos.set(pos, direction)))
+			if(!BlockUtils
+				.isOpaqueFullCube(mutablePos.setWithOffset(pos, direction)))
 				return true;
 			
 		return false;
@@ -580,8 +581,8 @@ public final class XRayHack extends Hack implements UpdateListener,
 		java.util.ArrayList<String> kw = new java.util.ArrayList<>();
 		for(String s : oreNamesCache)
 		{
-			net.minecraft.util.Identifier id =
-				net.minecraft.util.Identifier.tryParse(s);
+			net.minecraft.resources.ResourceLocation id =
+				net.minecraft.resources.ResourceLocation.tryParse(s);
 			if(id != null)
 				exact.add(id.toString());
 			else if(s != null && !s.isBlank())
diff --git a/src/main/java/net/wurstclient/hacks/autocomplete/MessageCompleter.java b/src/main/java/net/wurstclient/hacks/autocomplete/MessageCompleter.java
index 0ee269700..3067d7e5f 100644
--- a/src/main/java/net/wurstclient/hacks/autocomplete/MessageCompleter.java
+++ b/src/main/java/net/wurstclient/hacks/autocomplete/MessageCompleter.java
@@ -11,9 +11,8 @@ import java.io.IOException;
 import java.util.List;
 
 import com.google.gson.JsonObject;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.hud.ChatHudLine;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.client.Minecraft;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.ChatUtils;
 import net.wurstclient.util.json.JsonException;
@@ -21,7 +20,7 @@ import net.wurstclient.util.json.WsonObject;
 
 public abstract class MessageCompleter
 {
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	
 	protected final ModelSettings modelSettings;
 	
@@ -60,8 +59,7 @@ public abstract class MessageCompleter
 		String prompt = "=== Minecraft chat log ===\n";
 		
 		// add chat history
-		List<ChatHudLine.Visible> chatHistory =
-			MC.inGameHud.getChatHud().visibleMessages;
+		List<GuiMessage.Line> chatHistory = MC.gui.getChat().trimmedMessages;
 		int messages = 0;
 		for(int i = chatHistory.size() - 1; i >= 0; i--)
 		{
@@ -90,11 +88,11 @@ public abstract class MessageCompleter
 		
 		// if the chat history is empty, add a dummy system message
 		if(chatHistory.isEmpty())
-			prompt += "<System> " + MC.getSession().getUsername()
-				+ " joined the game.\n";
+			prompt +=
+				"<System> " + MC.getUser().getName() + " joined the game.\n";
 		
 		// add draft message
-		prompt += "<" + MC.getSession().getUsername() + "> " + draftMessage;
+		prompt += "<" + MC.getUser().getName() + "> " + draftMessage;
 		
 		return prompt;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/autocomplete/SuggestionHandler.java b/src/main/java/net/wurstclient/hacks/autocomplete/SuggestionHandler.java
index 0468b75d2..01c74a5b8 100644
--- a/src/main/java/net/wurstclient/hacks/autocomplete/SuggestionHandler.java
+++ b/src/main/java/net/wurstclient/hacks/autocomplete/SuggestionHandler.java
@@ -13,8 +13,7 @@ import java.util.List;
 import java.util.function.BiConsumer;
 
 import com.mojang.brigadier.suggestion.SuggestionsBuilder;
-
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.settings.Setting;
 import net.wurstclient.settings.SliderSetting;
 import net.wurstclient.settings.SliderSetting.ValueDisplay;
@@ -57,7 +56,7 @@ public final class SuggestionHandler
 				.filter(s -> s.startsWith(draftMessage.toLowerCase())).count();
 			int maxPerDraft = maxSuggestionsPerDraft.getValueI();
 			
-			return MathHelper.clamp(maxPerDraft - existing, 0, maxPerDraft);
+			return Mth.clamp(maxPerDraft - existing, 0, maxPerDraft);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantType.java
index afba14a25..cdb525a02 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantType.java
@@ -9,10 +9,9 @@ package net.wurstclient.hacks.autofarm;
 
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.item.Item;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.settings.PlantTypeSetting;
 
 public abstract class AutoFarmPlantType
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantTypeManager.java b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantTypeManager.java
index 7c622b27d..39be50128 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantTypeManager.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmPlantTypeManager.java
@@ -9,9 +9,8 @@ package net.wurstclient.hacks.autofarm;
 
 import java.util.List;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.plants.*;
 import net.wurstclient.settings.Setting;
 import net.wurstclient.settings.ToggleAllPlantTypesSetting;
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmRenderer.java b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmRenderer.java
index 86a6376b8..f6a32d29c 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/AutoFarmRenderer.java
@@ -7,22 +7,21 @@
  */
 package net.wurstclient.hacks.autofarm;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Collection;
 import java.util.List;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.Setting;
 import net.wurstclient.util.RenderUtils;
 
 public final class AutoFarmRenderer
 {
-	private static final Box BLOCK_BOX =
-		new Box(BlockPos.ORIGIN).contract(1 / 16.0);
-	private static final Box NODE_BOX = new Box(BlockPos.ORIGIN).contract(0.25);
+	private static final AABB BLOCK_BOX =
+		new AABB(BlockPos.ZERO).deflate(1 / 16.0);
+	private static final AABB NODE_BOX = new AABB(BlockPos.ZERO).deflate(0.25);
 	
 	public final CheckboxSetting drawReplantingSpots =
 		new CheckboxSetting("Draw replanting spots", true);
@@ -31,23 +30,23 @@ public final class AutoFarmRenderer
 	public final CheckboxSetting drawBlocksToReplant =
 		new CheckboxSetting("Draw blocks to replant", true);
 	
-	private List<Box> replantingSpots = List.of();
-	private List<Box> blocksToHarvest = List.of();
-	private List<Box> blocksToReplant = List.of();
+	private List<AABB> replantingSpots = List.of();
+	private List<AABB> blocksToHarvest = List.of();
+	private List<AABB> blocksToReplant = List.of();
 	
 	public void update(Collection<BlockPos> replantingSpots,
 		Collection<BlockPos> blocksToHarvest,
 		Collection<BlockPos> blocksToReplant)
 	{
 		this.replantingSpots =
-			replantingSpots.stream().map(NODE_BOX::offset).toList();
+			replantingSpots.stream().map(NODE_BOX::move).toList();
 		this.blocksToHarvest =
-			blocksToHarvest.stream().map(BLOCK_BOX::offset).toList();
+			blocksToHarvest.stream().map(BLOCK_BOX::move).toList();
 		this.blocksToReplant =
-			blocksToReplant.stream().map(BLOCK_BOX::offset).toList();
+			blocksToReplant.stream().map(BLOCK_BOX::move).toList();
 	}
 	
-	public void render(MatrixStack matrixStack)
+	public void render(PoseStack matrixStack)
 	{
 		if(drawReplantingSpots.isChecked())
 			RenderUtils.drawNodes(matrixStack, replantingSpots, 0x8000FFFF,
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/AmethystPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/AmethystPlantType.java
index f73419bde..085a5b10a 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/AmethystPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/AmethystPlantType.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 
@@ -20,7 +20,7 @@ public final class AmethystPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.BUDDING_AMETHYST);
+		return state.is(Blocks.BUDDING_AMETHYST);
 	}
 	
 	@Override
@@ -38,7 +38,7 @@ public final class AmethystPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.AMETHYST_CLUSTER);
+		return state.is(Blocks.AMETHYST_CLUSTER);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/BambooPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/BambooPlantType.java
index b8b2547cb..f596bfacb 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/BambooPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/BambooPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -25,19 +25,19 @@ public final class BambooPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.BAMBOO) && !state.isOf(Blocks.BAMBOO_SAPLING))
+		if(!state.is(Blocks.BAMBOO) && !state.is(Blocks.BAMBOO_SAPLING))
 			return false;
 		
-		BlockState floor = BlockUtils.getState(pos.down());
-		return !floor.isOf(Blocks.BAMBOO) && !floor.isOf(Blocks.BAMBOO_SAPLING)
-			&& floor.isIn(BlockTags.BAMBOO_PLANTABLE_ON);
+		BlockState floor = BlockUtils.getState(pos.below());
+		return !floor.is(Blocks.BAMBOO) && !floor.is(Blocks.BAMBOO_SAPLING)
+			&& floor.is(BlockTags.BAMBOO_PLANTABLE_ON);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down())
-			.isIn(BlockTags.BAMBOO_PLANTABLE_ON);
+		return BlockUtils.getState(pos.below())
+			.is(BlockTags.BAMBOO_PLANTABLE_ON);
 	}
 	
 	@Override
@@ -49,10 +49,10 @@ public final class BambooPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.BAMBOO))
+		if(!state.is(Blocks.BAMBOO))
 			return false;
 		
-		BlockPos below = pos.down();
+		BlockPos below = pos.below();
 		return isReplantingSpot(below, BlockUtils.getState(below));
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/BeetrootsPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/BeetrootsPlantType.java
index 53dbb2791..0c1d030fa 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/BeetrootsPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/BeetrootsPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BeetrootsBlock;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.BeetrootBlock;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -22,13 +22,13 @@ public final class BeetrootsPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.getBlock() instanceof BeetrootsBlock;
+		return state.getBlock() instanceof BeetrootBlock;
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,10 +40,10 @@ public final class BeetrootsPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!(state.getBlock() instanceof BeetrootsBlock beetroots))
+		if(!(state.getBlock() instanceof BeetrootBlock beetroots))
 			return false;
 		
-		return beetroots.isMature(state);
+		return beetroots.isMaxAge(state);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/CactusPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/CactusPlantType.java
index e70475f81..0dd7b7c99 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/CactusPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/CactusPlantType.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.registry.tag.FluidTags;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -24,10 +24,10 @@ public final class CactusPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.CACTUS))
+		if(!state.is(Blocks.CACTUS))
 			return false;
 		
-		return !BlockUtils.getState(pos.down()).isOf(Blocks.CACTUS)
+		return !BlockUtils.getState(pos.below()).is(Blocks.CACTUS)
 			&& hasPlantingSurface(pos);
 	}
 	
@@ -36,14 +36,14 @@ public final class CactusPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockPos floorPos = pos.down();
+		BlockPos floorPos = pos.below();
 		BlockState floor = BlockUtils.getState(floorPos);
-		if(!floor.isIn(BlockTags.SAND))
+		if(!floor.is(BlockTags.SAND))
 			return false;
 		
-		return Direction.Type.HORIZONTAL.stream().map(pos::offset)
+		return Direction.Plane.HORIZONTAL.stream().map(pos::relative)
 			.map(BlockUtils::getState).noneMatch(neighbor -> neighbor.isSolid()
-				|| neighbor.getFluidState().isIn(FluidTags.LAVA));
+				|| neighbor.getFluidState().is(FluidTags.LAVA));
 	}
 	
 	@Override
@@ -55,10 +55,10 @@ public final class CactusPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.CACTUS) && !state.isOf(Blocks.CACTUS_FLOWER))
+		if(!state.is(Blocks.CACTUS) && !state.is(Blocks.CACTUS_FLOWER))
 			return false;
 		
-		BlockPos below = pos.down();
+		BlockPos below = pos.below();
 		return isReplantingSpot(below, BlockUtils.getState(below));
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/CarrotsPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/CarrotsPlantType.java
index 7314c443e..c622f75f3 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/CarrotsPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/CarrotsPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.CarrotsBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.CarrotBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -22,13 +22,13 @@ public final class CarrotsPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.getBlock() instanceof CarrotsBlock;
+		return state.getBlock() instanceof CarrotBlock;
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,10 +40,10 @@ public final class CarrotsPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!(state.getBlock() instanceof CarrotsBlock carrots))
+		if(!(state.getBlock() instanceof CarrotBlock carrots))
 			return false;
 		
-		return carrots.isMature(state);
+		return carrots.isMaxAge(state);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/ChorusPlantPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/ChorusPlantPlantType.java
index 02adb8dcd..b4ffee3c4 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/ChorusPlantPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/ChorusPlantPlantType.java
@@ -13,16 +13,15 @@ import java.util.Map;
 import java.util.Map.Entry;
 
 import com.google.common.collect.Maps;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.ChorusFlowerBlock;
-import net.minecraft.block.ConnectingBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.state.property.BooleanProperty;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.ChorusFlowerBlock;
+import net.minecraft.world.level.block.PipeBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -30,22 +29,21 @@ import net.wurstclient.util.BlockUtils;
 public final class ChorusPlantPlantType extends AutoFarmPlantType
 {
 	private static final EnumMap<Direction, BooleanProperty> CHORUS_GROWING_DIRECTIONS =
-		Maps.newEnumMap(Map.of(Direction.NORTH, ConnectingBlock.NORTH,
-			Direction.SOUTH, ConnectingBlock.SOUTH, Direction.WEST,
-			ConnectingBlock.WEST, Direction.EAST, ConnectingBlock.EAST,
-			Direction.UP, ConnectingBlock.UP));
+		Maps.newEnumMap(Map.of(Direction.NORTH, PipeBlock.NORTH,
+			Direction.SOUTH, PipeBlock.SOUTH, Direction.WEST, PipeBlock.WEST,
+			Direction.EAST, PipeBlock.EAST, Direction.UP, PipeBlock.UP));
 	
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.CHORUS_FLOWER)
-			|| state.isOf(Blocks.CHORUS_PLANT)) && hasPlantingSurface(pos);
+		return (state.is(Blocks.CHORUS_FLOWER) || state.is(Blocks.CHORUS_PLANT))
+			&& hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.END_STONE);
+		return BlockUtils.getState(pos.below()).is(Blocks.END_STONE);
 	}
 	
 	@Override
@@ -57,10 +55,10 @@ public final class ChorusPlantPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(state.isOf(Blocks.CHORUS_FLOWER))
+		if(state.is(Blocks.CHORUS_FLOWER))
 			return isFlowerFullyGrown(pos, state);
 		
-		if(state.isOf(Blocks.CHORUS_PLANT))
+		if(state.is(Blocks.CHORUS_PLANT))
 			return !hasAttachedFlowers(pos, state, new HashSet<>());
 		
 		return false;
@@ -68,8 +66,9 @@ public final class ChorusPlantPlantType extends AutoFarmPlantType
 	
 	private boolean isFlowerFullyGrown(BlockPos pos, BlockState state)
 	{
-		return state.get(ChorusFlowerBlock.AGE, 0) == ChorusFlowerBlock.MAX_AGE
-			|| !BlockUtils.getState(pos.up()).isAir();
+		return state.getValueOrElse(ChorusFlowerBlock.AGE,
+			0) == ChorusFlowerBlock.DEAD_AGE
+			|| !BlockUtils.getState(pos.above()).isAir();
 	}
 	
 	private boolean hasAttachedFlowers(BlockPos pos, BlockState state,
@@ -86,23 +85,23 @@ public final class ChorusPlantPlantType extends AutoFarmPlantType
 		for(Entry<Direction, BooleanProperty> entry : CHORUS_GROWING_DIRECTIONS
 			.entrySet())
 		{
-			if(!state.get(entry.getValue(), false))
+			if(!state.getValueOrElse(entry.getValue(), false))
 				continue;
 			
 			Direction direction = entry.getKey();
-			BlockPos neighborPos = pos.offset(direction);
+			BlockPos neighborPos = pos.relative(direction);
 			BlockState neighborState = BlockUtils.getState(neighborPos);
-			if(neighborState.isOf(Blocks.CHORUS_FLOWER))
+			if(neighborState.is(Blocks.CHORUS_FLOWER))
 				return true;
 			
-			if(!neighborState.isOf(Blocks.CHORUS_PLANT))
+			if(!neighborState.is(Blocks.CHORUS_PLANT))
 				continue;
 				
 			// A horizontally adjacent neighbor that connects down is probably
 			// connected to the stem, so we can ignore any flowers that it
 			// supports.
 			if(direction.getAxis().isHorizontal()
-				&& neighborState.get(ConnectingBlock.DOWN, false))
+				&& neighborState.getValueOrElse(PipeBlock.DOWN, false))
 				continue;
 			
 			if(hasAttachedFlowers(neighborPos, neighborState, visited))
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/CocoaBeanPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/CocoaBeanPlantType.java
index 98f430bac..0ebeacbec 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/CocoaBeanPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/CocoaBeanPlantType.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.CocoaBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.CocoaBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -29,9 +29,9 @@ public final class CocoaBeanPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return Direction.Type.HORIZONTAL.stream().map(pos::offset)
+		return Direction.Plane.HORIZONTAL.stream().map(pos::relative)
 			.map(BlockUtils::getState)
-			.anyMatch(neighbor -> neighbor.isIn(BlockTags.JUNGLE_LOGS));
+			.anyMatch(neighbor -> neighbor.is(BlockTags.JUNGLE_LOGS));
 	}
 	
 	@Override
@@ -46,7 +46,7 @@ public final class CocoaBeanPlantType extends AutoFarmPlantType
 		if(!(state.getBlock() instanceof CocoaBlock))
 			return false;
 		
-		return state.get(CocoaBlock.AGE) >= CocoaBlock.MAX_AGE;
+		return state.getValue(CocoaBlock.AGE) >= CocoaBlock.MAX_AGE;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/GlowBerryPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/GlowBerryPlantType.java
index 1e7188977..09fcdf25f 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/GlowBerryPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/GlowBerryPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.CaveVines;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.CaveVines;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
@@ -29,9 +29,9 @@ public final class GlowBerryPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockState ceiling = BlockUtils.getState(pos.up());
-		return !(ceiling.getBlock() instanceof CaveVines) && ceiling
-			.isSideSolidFullSquare(WurstClient.MC.world, pos, Direction.DOWN);
+		BlockState ceiling = BlockUtils.getState(pos.above());
+		return !(ceiling.getBlock() instanceof CaveVines)
+			&& ceiling.isFaceSturdy(WurstClient.MC.level, pos, Direction.DOWN);
 	}
 	
 	@Override
@@ -45,7 +45,7 @@ public final class GlowBerryPlantType extends AutoFarmPlantType
 	{
 		// Right-click-harvest the top-most part so we don't have to replant it.
 		return state.getBlock() instanceof CaveVines
-			&& CaveVines.hasBerries(state) && isReplantingSpot(pos, state);
+			&& CaveVines.hasGlowBerries(state) && isReplantingSpot(pos, state);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/KelpPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/KelpPlantType.java
index 078372063..3300707b6 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/KelpPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/KelpPlantType.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.FluidTags;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
@@ -28,11 +28,11 @@ public final class KelpPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.KELP) && !state.isOf(Blocks.KELP_PLANT))
+		if(!state.is(Blocks.KELP) && !state.is(Blocks.KELP_PLANT))
 			return false;
 		
-		BlockState floor = BlockUtils.getState(pos.down());
-		return !floor.isOf(Blocks.KELP) && !floor.isOf(Blocks.KELP_PLANT)
+		BlockState floor = BlockUtils.getState(pos.below());
+		return !floor.is(Blocks.KELP) && !floor.is(Blocks.KELP_PLANT)
 			&& hasPlantingSurface(pos);
 	}
 	
@@ -40,12 +40,12 @@ public final class KelpPlantType extends AutoFarmPlantType
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
 		FluidState fluid = BlockUtils.getState(pos).getFluidState();
-		if(!fluid.isIn(FluidTags.WATER) || fluid.getLevel() != 8)
+		if(!fluid.is(FluidTags.WATER) || fluid.getAmount() != 8)
 			return false;
 		
-		BlockState floor = BlockUtils.getState(pos.down());
-		return !floor.isOf(Blocks.MAGMA_BLOCK) && floor
-			.isSideSolidFullSquare(WurstClient.MC.world, pos, Direction.UP);
+		BlockState floor = BlockUtils.getState(pos.below());
+		return !floor.is(Blocks.MAGMA_BLOCK)
+			&& floor.isFaceSturdy(WurstClient.MC.level, pos, Direction.UP);
 	}
 	
 	@Override
@@ -57,10 +57,10 @@ public final class KelpPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.KELP) && !state.isOf(Blocks.KELP_PLANT))
+		if(!state.is(Blocks.KELP) && !state.is(Blocks.KELP_PLANT))
 			return false;
 		
-		BlockPos below = pos.down();
+		BlockPos below = pos.below();
 		return isReplantingSpot(below, BlockUtils.getState(below));
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/MelonPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/MelonPlantType.java
index 0b4f3941b..7a052445f 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/MelonPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/MelonPlantType.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -21,14 +21,14 @@ public final class MelonPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.MELON_STEM)
-			|| state.isOf(Blocks.ATTACHED_MELON_STEM);
+		return state.is(Blocks.MELON_STEM)
+			|| state.is(Blocks.ATTACHED_MELON_STEM);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,7 +40,7 @@ public final class MelonPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.MELON);
+		return state.is(Blocks.MELON);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/NetherWartPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/NetherWartPlantType.java
index d366a1133..c5f2631cd 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/NetherWartPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/NetherWartPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.NetherWartBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.NetherWartBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -28,7 +28,7 @@ public final class NetherWartPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.SOUL_SAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.SOUL_SAND);
 	}
 	
 	@Override
@@ -43,7 +43,7 @@ public final class NetherWartPlantType extends AutoFarmPlantType
 		if(!(state.getBlock() instanceof NetherWartBlock))
 			return false;
 		
-		return state.get(NetherWartBlock.AGE) >= NetherWartBlock.MAX_AGE;
+		return state.getValue(NetherWartBlock.AGE) >= NetherWartBlock.MAX_AGE;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/PitcherPlantPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/PitcherPlantPlantType.java
index 47fc687a6..0d0a54030 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/PitcherPlantPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/PitcherPlantPlantType.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.PitcherCropBlock;
-import net.minecraft.block.enums.DoubleBlockHalf;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.PitcherCropBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -23,15 +23,15 @@ public final class PitcherPlantPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.PITCHER_CROP)
-			&& state.get(PitcherCropBlock.HALF) == DoubleBlockHalf.LOWER
+		return state.is(Blocks.PITCHER_CROP)
+			&& state.getValue(PitcherCropBlock.HALF) == DoubleBlockHalf.LOWER
 			&& hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -44,8 +44,8 @@ public final class PitcherPlantPlantType extends AutoFarmPlantType
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
 		// field_43240 is MAX_AGE
-		return state.isOf(Blocks.PITCHER_CROP)
-			&& state.get(PitcherCropBlock.AGE) >= PitcherCropBlock.field_43240;
+		return state.is(Blocks.PITCHER_CROP)
+			&& state.getValue(PitcherCropBlock.AGE) >= PitcherCropBlock.MAX_AGE;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/PotatoesPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/PotatoesPlantType.java
index e06881833..f96d32f3f 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/PotatoesPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/PotatoesPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.PotatoesBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.PotatoBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -22,13 +22,13 @@ public final class PotatoesPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.getBlock() instanceof PotatoesBlock;
+		return state.getBlock() instanceof PotatoBlock;
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,10 +40,10 @@ public final class PotatoesPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!(state.getBlock() instanceof PotatoesBlock potato))
+		if(!(state.getBlock() instanceof PotatoBlock potato))
 			return false;
 		
-		return potato.isMature(state);
+		return potato.isMaxAge(state);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/PumpkinPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/PumpkinPlantType.java
index 2b192a84d..095848499 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/PumpkinPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/PumpkinPlantType.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -21,14 +21,14 @@ public final class PumpkinPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.PUMPKIN_STEM)
-			|| state.isOf(Blocks.ATTACHED_PUMPKIN_STEM);
+		return state.is(Blocks.PUMPKIN_STEM)
+			|| state.is(Blocks.ATTACHED_PUMPKIN_STEM);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,7 +40,7 @@ public final class PumpkinPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.PUMPKIN);
+		return state.is(Blocks.PUMPKIN);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/SugarCanePlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/SugarCanePlantType.java
index af6bc50b8..111952ba3 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/SugarCanePlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/SugarCanePlantType.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.registry.tag.FluidTags;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -24,28 +24,28 @@ public final class SugarCanePlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.SUGAR_CANE))
+		if(!state.is(Blocks.SUGAR_CANE))
 			return false;
 		
-		return !BlockUtils.getState(pos.down()).isOf(Blocks.SUGAR_CANE)
+		return !BlockUtils.getState(pos.below()).is(Blocks.SUGAR_CANE)
 			&& hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockPos floorPos = pos.down();
+		BlockPos floorPos = pos.below();
 		BlockState floor = BlockUtils.getState(floorPos);
-		if(!floor.isIn(BlockTags.DIRT) && !floor.isIn(BlockTags.SAND))
+		if(!floor.is(BlockTags.DIRT) && !floor.is(BlockTags.SAND))
 			return false;
 		
-		for(Direction side : Direction.Type.HORIZONTAL)
+		for(Direction side : Direction.Plane.HORIZONTAL)
 		{
 			BlockState floorNeighbor =
-				BlockUtils.getState(floorPos.offset(side));
+				BlockUtils.getState(floorPos.relative(side));
 			
-			if(floorNeighbor.getFluidState().isIn(FluidTags.WATER)
-				|| floorNeighbor.isOf(Blocks.FROSTED_ICE))
+			if(floorNeighbor.getFluidState().is(FluidTags.WATER)
+				|| floorNeighbor.is(Blocks.FROSTED_ICE))
 				return true;
 		}
 		
@@ -61,10 +61,10 @@ public final class SugarCanePlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		if(!state.isOf(Blocks.SUGAR_CANE))
+		if(!state.is(Blocks.SUGAR_CANE))
 			return false;
 		
-		BlockPos below = pos.down();
+		BlockPos below = pos.below();
 		return isReplantingSpot(below, BlockUtils.getState(below));
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/SweetBerryPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/SweetBerryPlantType.java
index 2a52d78e9..8c60645f4 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/SweetBerryPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/SweetBerryPlantType.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.SweetBerryBushBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.SweetBerryBushBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -30,8 +30,8 @@ public final class SweetBerryPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockState floor = BlockUtils.getState(pos.down());
-		return floor.isIn(BlockTags.DIRT) || floor.isOf(Blocks.FARMLAND);
+		BlockState floor = BlockUtils.getState(pos.below());
+		return floor.is(BlockTags.DIRT) || floor.is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -52,7 +52,7 @@ public final class SweetBerryPlantType extends AutoFarmPlantType
 		if(!(state.getBlock() instanceof SweetBerryBushBlock))
 			return false;
 		
-		return state.get(SweetBerryBushBlock.AGE) > 1;
+		return state.getValue(SweetBerryBushBlock.AGE) > 1;
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/TorchflowerPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/TorchflowerPlantType.java
index 9ec8d7c7d..a09ec5a38 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/TorchflowerPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/TorchflowerPlantType.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -21,14 +21,14 @@ public final class TorchflowerPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.TORCHFLOWER)
-			|| state.isOf(Blocks.TORCHFLOWER_CROP)) && hasPlantingSurface(pos);
+		return (state.is(Blocks.TORCHFLOWER)
+			|| state.is(Blocks.TORCHFLOWER_CROP)) && hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -40,7 +40,7 @@ public final class TorchflowerPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.TORCHFLOWER);
+		return state.is(Blocks.TORCHFLOWER);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/TwistingVinesPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/TwistingVinesPlantType.java
index 9609d4bbc..5db9dc3c2 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/TwistingVinesPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/TwistingVinesPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
@@ -23,18 +23,18 @@ public final class TwistingVinesPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.TWISTING_VINES)
-			|| state.isOf(Blocks.TWISTING_VINES_PLANT))
+		return (state.is(Blocks.TWISTING_VINES)
+			|| state.is(Blocks.TWISTING_VINES_PLANT))
 			&& hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockState floor = BlockUtils.getState(pos.down());
-		return !floor.isOf(Blocks.TWISTING_VINES)
-			&& !floor.isOf(Blocks.TWISTING_VINES_PLANT) && floor
-				.isSideSolidFullSquare(WurstClient.MC.world, pos, Direction.UP);
+		BlockState floor = BlockUtils.getState(pos.below());
+		return !floor.is(Blocks.TWISTING_VINES)
+			&& !floor.is(Blocks.TWISTING_VINES_PLANT)
+			&& floor.isFaceSturdy(WurstClient.MC.level, pos, Direction.UP);
 	}
 	
 	@Override
@@ -46,8 +46,8 @@ public final class TwistingVinesPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.TWISTING_VINES)
-			|| state.isOf(Blocks.TWISTING_VINES_PLANT))
+		return (state.is(Blocks.TWISTING_VINES)
+			|| state.is(Blocks.TWISTING_VINES_PLANT))
 			&& !isReplantingSpot(pos, state);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/WeepingVinesPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/WeepingVinesPlantType.java
index 7a471d1be..f12ac9a7e 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/WeepingVinesPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/WeepingVinesPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
@@ -23,19 +23,17 @@ public final class WeepingVinesPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.WEEPING_VINES)
-			|| state.isOf(Blocks.WEEPING_VINES_PLANT))
-			&& hasPlantingSurface(pos);
+		return (state.is(Blocks.WEEPING_VINES)
+			|| state.is(Blocks.WEEPING_VINES_PLANT)) && hasPlantingSurface(pos);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		BlockState ceiling = BlockUtils.getState(pos.up());
-		return !ceiling.isOf(Blocks.WEEPING_VINES)
-			&& !ceiling.isOf(Blocks.WEEPING_VINES_PLANT)
-			&& ceiling.isSideSolidFullSquare(WurstClient.MC.world, pos,
-				Direction.DOWN);
+		BlockState ceiling = BlockUtils.getState(pos.above());
+		return !ceiling.is(Blocks.WEEPING_VINES)
+			&& !ceiling.is(Blocks.WEEPING_VINES_PLANT)
+			&& ceiling.isFaceSturdy(WurstClient.MC.level, pos, Direction.DOWN);
 	}
 	
 	@Override
@@ -47,8 +45,8 @@ public final class WeepingVinesPlantType extends AutoFarmPlantType
 	@Override
 	public boolean shouldHarvestByMining(BlockPos pos, BlockState state)
 	{
-		return (state.isOf(Blocks.WEEPING_VINES)
-			|| state.isOf(Blocks.WEEPING_VINES_PLANT))
+		return (state.is(Blocks.WEEPING_VINES)
+			|| state.is(Blocks.WEEPING_VINES_PLANT))
 			&& !isReplantingSpot(pos, state);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/autofarm/plants/WheatPlantType.java b/src/main/java/net/wurstclient/hacks/autofarm/plants/WheatPlantType.java
index 84c3778ac..96b1d3b72 100644
--- a/src/main/java/net/wurstclient/hacks/autofarm/plants/WheatPlantType.java
+++ b/src/main/java/net/wurstclient/hacks/autofarm/plants/WheatPlantType.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.hacks.autofarm.plants;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.block.CropBlock;
-import net.minecraft.item.Item;
-import net.minecraft.item.Items;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.CropBlock;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.autofarm.AutoFarmPlantType;
 import net.wurstclient.settings.PlantTypeSetting;
 import net.wurstclient.util.BlockUtils;
@@ -22,13 +22,13 @@ public final class WheatPlantType extends AutoFarmPlantType
 	@Override
 	public final boolean isReplantingSpot(BlockPos pos, BlockState state)
 	{
-		return state.isOf(Blocks.WHEAT);
+		return state.is(Blocks.WHEAT);
 	}
 	
 	@Override
 	public final boolean hasPlantingSurface(BlockPos pos)
 	{
-		return BlockUtils.getState(pos.down()).isOf(Blocks.FARMLAND);
+		return BlockUtils.getState(pos.below()).is(Blocks.FARMLAND);
 	}
 	
 	@Override
@@ -43,7 +43,7 @@ public final class WheatPlantType extends AutoFarmPlantType
 		if(!(state.getBlock() instanceof CropBlock crop))
 			return false;
 		
-		return crop.isMature(state) && state.isOf(Blocks.WHEAT);
+		return crop.isMaxAge(state) && state.is(Blocks.WHEAT);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/hacks/autofish/AutoFishDebugDraw.java b/src/main/java/net/wurstclient/hacks/autofish/AutoFishDebugDraw.java
index 206b439b9..030e07e92 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/AutoFishDebugDraw.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/AutoFishDebugDraw.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks.autofish;
 
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.awt.Color;
 import java.util.stream.Stream;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.projectile.FishingBobberEntity;
-import net.minecraft.network.packet.s2c.play.PlaySoundS2CPacket;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.network.protocol.game.ClientboundSoundPacket;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.settings.CheckboxSetting;
@@ -29,7 +28,7 @@ import net.wurstclient.util.RenderUtils;
 
 public final class AutoFishDebugDraw
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final CheckboxSetting debugDraw = new CheckboxSetting("Debug draw",
 		"Shows where bites are occurring and where they will be detected."
@@ -41,7 +40,7 @@ public final class AutoFishDebugDraw
 	
 	private final SliderSetting validRange;
 	private final FishingSpotManager fishingSpots;
-	private Vec3d lastSoundPos;
+	private Vec3 lastSoundPos;
 	
 	public AutoFishDebugDraw(SliderSetting validRange,
 		FishingSpotManager fishingSpots)
@@ -60,19 +59,19 @@ public final class AutoFishDebugDraw
 		lastSoundPos = null;
 	}
 	
-	public void updateSoundPos(PlaySoundS2CPacket sound)
+	public void updateSoundPos(ClientboundSoundPacket sound)
 	{
-		lastSoundPos = new Vec3d(sound.getX(), sound.getY(), sound.getZ());
+		lastSoundPos = new Vec3(sound.getX(), sound.getY(), sound.getZ());
 	}
 	
-	public void render(MatrixStack matrices, float partialTicks)
+	public void render(PoseStack matrices, float partialTicks)
 	{
 		if(!debugDraw.isChecked() && !fishingSpots.isMcmmoMode())
 			return;
 		
 		if(debugDraw.isChecked())
 		{
-			FishingBobberEntity bobber = MC.player.fishHook;
+			FishingHook bobber = MC.player.fishing;
 			if(bobber != null)
 				drawValidRange(matrices, partialTicks, bobber);
 			
@@ -86,20 +85,20 @@ public final class AutoFishDebugDraw
 			drawMcmmoRange(matrices);
 	}
 	
-	private void drawValidRange(MatrixStack matrices, float partialTicks,
-		FishingBobberEntity bobber)
+	private void drawValidRange(PoseStack matrices, float partialTicks,
+		FishingHook bobber)
 	{
 		double vr = validRange.getValue();
-		Vec3d pos = EntityUtils.getLerpedPos(bobber, partialTicks);
-		Box vrBox = new Box(-vr, -1 / 16.0, -vr, vr, 1 / 16.0, vr).offset(pos);
+		Vec3 pos = EntityUtils.getLerpedPos(bobber, partialTicks);
+		AABB vrBox = new AABB(-vr, -1 / 16.0, -vr, vr, 1 / 16.0, vr).move(pos);
 		
 		RenderUtils.drawOutlinedBox(matrices, vrBox, ddColor.getColorI(0x80),
 			false);
 	}
 	
-	private void drawLastBite(MatrixStack matrixStack)
+	private void drawLastBite(PoseStack matrixStack)
 	{
-		Vec3d pos = lastSoundPos;
+		Vec3 pos = lastSoundPos;
 		int color = ddColor.getColorI(0x80);
 		
 		RenderUtils.drawLine(matrixStack, pos.add(-0.125, 0, -0.125),
@@ -108,26 +107,26 @@ public final class AutoFishDebugDraw
 			pos.add(-0.125, 0, 0.125), color, false);
 	}
 	
-	private void drawFishingSpots(MatrixStack matrices)
+	private void drawFishingSpots(PoseStack matrices)
 	{
-		Box headBox = new Box(-0.25, 0, -0.25, 0.25, 0.5, 0.25);
-		Box noseBox =
-			headBox.offset(0.125, 0.125, 0.5).shrink(0.25, 0.35, 0.45);
+		AABB headBox = new AABB(-0.25, 0, -0.25, 0.25, 0.5, 0.25);
+		AABB noseBox =
+			headBox.move(0.125, 0.125, 0.5).contract(0.25, 0.35, 0.45);
 		
 		int color = ddColor.getColorI(0xC0);
 		
-		VertexConsumerProvider.Immediate vcp = RenderUtils.getVCP();
-		Vec3d camPos = RenderUtils.getCameraPos();
+		MultiBufferSource.BufferSource vcp = RenderUtils.getVCP();
+		Vec3 camPos = RenderUtils.getCameraPos();
 		
 		for(FishingSpot spot : fishingSpots.getFishingSpots())
 		{
-			Vec3d playerPos = spot.input().pos();
-			Vec3d bobberPos = spot.bobberPos();
+			Vec3 playerPos = spot.input().pos();
+			Vec3 bobberPos = spot.bobberPos();
 			
-			matrices.push();
+			matrices.pushPose();
 			matrices.translate(playerPos.x - camPos.x, playerPos.y - camPos.y,
 				playerPos.z - camPos.z);
-			matrices.multiply(spot.input().rotation().toQuaternion());
+			matrices.mulPose(spot.input().rotation().toQuaternion());
 			
 			VertexConsumer lineBuffer =
 				vcp.getBuffer(WurstRenderLayers.ESP_LINES);
@@ -137,17 +136,17 @@ public final class AutoFishDebugDraw
 			if(!spot.openWater())
 				RenderUtils.drawCrossBox(matrices, lineBuffer, headBox, color);
 			
-			matrices.pop();
+			matrices.popPose();
 			
 			RenderUtils.drawArrow(matrices, lineBuffer,
 				playerPos.subtract(camPos), bobberPos.subtract(camPos), color,
 				0.1F);
 			
-			vcp.draw(WurstRenderLayers.ESP_LINES);
+			vcp.endBatch(WurstRenderLayers.ESP_LINES);
 		}
 	}
 	
-	private void drawMcmmoRange(MatrixStack matrices)
+	private void drawMcmmoRange(PoseStack matrices)
 	{
 		FishingSpot lastSpot = fishingSpots.getLastSpot();
 		if(lastSpot == null)
@@ -158,16 +157,16 @@ public final class AutoFishDebugDraw
 			return;
 		
 		int mcmmoRange = fishingSpots.getRange();
-		Vec3d bobberPos = lastSpot.bobberPos();
-		Box rangeBox = new Box(0, 0, 0, 0, 0, 0)
-			.expand(mcmmoRange, 1, mcmmoRange).offset(bobberPos);
+		Vec3 bobberPos = lastSpot.bobberPos();
+		AABB rangeBox = new AABB(0, 0, 0, 0, 0, 0)
+			.inflate(mcmmoRange, 1, mcmmoRange).move(bobberPos);
 		
 		int quadsColor = 0x40FF0000;
 		RenderUtils.drawSolidBox(matrices, rangeBox, quadsColor, false);
 		
 		int linesColor = 0x80FF0000;
 		RenderUtils.drawOutlinedBox(matrices, rangeBox, linesColor, false);
-		RenderUtils.drawOutlinedBox(matrices, rangeBox.contract(0, 1, 0),
+		RenderUtils.drawOutlinedBox(matrices, rangeBox.deflate(0, 1, 0),
 			linesColor, false);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/autofish/AutoFishRodSelector.java b/src/main/java/net/wurstclient/hacks/autofish/AutoFishRodSelector.java
index 0ce8832e9..c774108d1 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/AutoFishRodSelector.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/AutoFishRodSelector.java
@@ -10,19 +10,18 @@ package net.wurstclient.hacks.autofish;
 import java.util.Optional;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.component.EnchantmentEffectComponentTypes;
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.enchantment.EnchantmentHelper;
-import net.minecraft.enchantment.Enchantments;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.FishingRodItem;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.entry.RegistryEntry.Reference;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.Holder.Reference;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentEffectComponents;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.item.enchantment.Enchantments;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoFishHack;
 import net.wurstclient.settings.CheckboxSetting;
@@ -32,7 +31,7 @@ import net.wurstclient.util.InventoryUtils;
 
 public final class AutoFishRodSelector
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final CheckboxSetting stopWhenOutOfRods = new CheckboxSetting(
 		"Stop when out of rods",
@@ -75,9 +74,9 @@ public final class AutoFishRodSelector
 	 */
 	public boolean update()
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		int selectedSlot = inventory.getSelectedSlot();
-		ItemStack selectedStack = inventory.getStack(selectedSlot);
+		ItemStack selectedStack = inventory.getItem(selectedSlot);
 		
 		// evaluate selected rod (or lack thereof)
 		int bestRodValue = getRodValue(selectedStack);
@@ -90,7 +89,7 @@ public final class AutoFishRodSelector
 		// search inventory for better rod
 		for(int slot : stream.toArray())
 		{
-			ItemStack stack = inventory.getStack(slot);
+			ItemStack stack = inventory.getItem(slot);
 			int rodValue = getRodValue(stack);
 			
 			if(rodValue > bestRodValue)
@@ -113,7 +112,7 @@ public final class AutoFishRodSelector
 		}
 		
 		// stop if inventory is full
-		if(stopWhenInvFull.isChecked() && inventory.getEmptySlot() == -1)
+		if(stopWhenInvFull.isChecked() && inventory.getFreeSlot() == -1)
 		{
 			ChatUtils.message(
 				"AutoFish has stopped because your inventory is full.");
@@ -135,32 +134,35 @@ public final class AutoFishRodSelector
 		if(stack.isEmpty() || !(stack.getItem() instanceof FishingRodItem))
 			return -1;
 		
-		DynamicRegistryManager drm = MC.world.getRegistryManager();
+		RegistryAccess drm = MC.level.registryAccess();
 		Registry<Enchantment> registry =
-			drm.getOrThrow(RegistryKeys.ENCHANTMENT);
+			drm.lookupOrThrow(Registries.ENCHANTMENT);
 		
 		Optional<Reference<Enchantment>> luckOTS =
-			registry.getOptional(Enchantments.LUCK_OF_THE_SEA);
-		int luckOTSLvl = luckOTS
-			.map(entry -> EnchantmentHelper.getLevel(entry, stack)).orElse(0);
+			registry.get(Enchantments.LUCK_OF_THE_SEA);
+		int luckOTSLvl = luckOTS.map(
+			entry -> EnchantmentHelper.getItemEnchantmentLevel(entry, stack))
+			.orElse(0);
 		
-		Optional<Reference<Enchantment>> lure =
-			registry.getOptional(Enchantments.LURE);
-		int lureLvl = lure
-			.map(entry -> EnchantmentHelper.getLevel(entry, stack)).orElse(0);
+		Optional<Reference<Enchantment>> lure = registry.get(Enchantments.LURE);
+		int lureLvl = lure.map(
+			entry -> EnchantmentHelper.getItemEnchantmentLevel(entry, stack))
+			.orElse(0);
 		
 		Optional<Reference<Enchantment>> unbreaking =
-			registry.getOptional(Enchantments.UNBREAKING);
-		int unbreakingLvl = unbreaking
-			.map(entry -> EnchantmentHelper.getLevel(entry, stack)).orElse(0);
+			registry.get(Enchantments.UNBREAKING);
+		int unbreakingLvl = unbreaking.map(
+			entry -> EnchantmentHelper.getItemEnchantmentLevel(entry, stack))
+			.orElse(0);
 		
 		Optional<Reference<Enchantment>> mending =
-			registry.getOptional(Enchantments.MENDING);
-		int mendingBonus = mending
-			.map(entry -> EnchantmentHelper.getLevel(entry, stack)).orElse(0);
+			registry.get(Enchantments.MENDING);
+		int mendingBonus = mending.map(
+			entry -> EnchantmentHelper.getItemEnchantmentLevel(entry, stack))
+			.orElse(0);
 		
-		int noVanishBonus = EnchantmentHelper.hasAnyEnchantmentsWith(stack,
-			EnchantmentEffectComponentTypes.PREVENT_EQUIPMENT_DROP) ? 0 : 1;
+		int noVanishBonus = EnchantmentHelper.has(stack,
+			EnchantmentEffectComponents.PREVENT_EQUIPMENT_DROP) ? 0 : 1;
 		
 		return luckOTSLvl * 9 + lureLvl * 9 + unbreakingLvl * 2 + mendingBonus
 			+ noVanishBonus;
diff --git a/src/main/java/net/wurstclient/hacks/autofish/FishingSpot.java b/src/main/java/net/wurstclient/hacks/autofish/FishingSpot.java
index 66e29fa03..db2788252 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/FishingSpot.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/FishingSpot.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.hacks.autofish;
 
-import net.minecraft.entity.projectile.FishingBobberEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.phys.Vec3;
 
-public record FishingSpot(PositionAndRotation input, Vec3d bobberPos,
+public record FishingSpot(PositionAndRotation input, Vec3 bobberPos,
 	boolean openWater)
 {
-	public FishingSpot(PositionAndRotation input, FishingBobberEntity bobber)
+	public FishingSpot(PositionAndRotation input, FishingHook bobber)
 	{
-		this(input, bobber.getEntityPos(), bobber.isInOpenWater());
+		this(input, bobber.position(), bobber.isOpenWaterFishing());
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/autofish/FishingSpotManager.java b/src/main/java/net/wurstclient/hacks/autofish/FishingSpotManager.java
index 713638fe5..92561f7cd 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/FishingSpotManager.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/FishingSpotManager.java
@@ -12,10 +12,9 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.stream.Stream;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.projectile.FishingBobberEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IKeyBinding;
 import net.wurstclient.settings.CheckboxSetting;
@@ -28,7 +27,7 @@ import net.wurstclient.util.RotationUtils;
 
 public final class FishingSpotManager
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final CheckboxSetting mcmmoMode = new CheckboxSetting("mcMMO mode",
 		"If enabled, AutoFish will cycle between two different fishing spots"
@@ -129,15 +128,15 @@ public final class FishingSpotManager
 	
 	private void moveToNextSpot()
 	{
-		IKeyBinding forwardKey = IKeyBinding.get(MC.options.forwardKey);
-		IKeyBinding jumpKey = IKeyBinding.get(MC.options.jumpKey);
+		IKeyBinding forwardKey = IKeyBinding.get(MC.options.keyUp);
+		IKeyBinding jumpKey = IKeyBinding.get(MC.options.keyJump);
 		
 		PositionAndRotation nextPosRot = nextSpot.input();
 		forwardKey.resetPressedState();
 		jumpKey.resetPressedState();
 		
 		// match position
-		Vec3d nextPos = nextPosRot.pos();
+		Vec3 nextPos = nextPosRot.pos();
 		double distance = nextPos.distanceTo(castPosRot.pos());
 		if(distance > 0.1)
 		{
@@ -153,12 +152,12 @@ public final class FishingSpotManager
 			
 			// jump if necessary
 			jumpKey.setPressed(
-				MC.player.isTouchingWater() || MC.player.horizontalCollision);
+				MC.player.isInWater() || MC.player.horizontalCollision);
 			
 			// walk or teleport depending on distance
 			if(distance < 0.2)
-				MC.player.setPosition(nextPos.x, nextPos.y, nextPos.z);
-			else if(distance > 0.7 || MC.player.age % 10 == 0)
+				MC.player.setPos(nextPos.x, nextPos.y, nextPos.z);
+			else if(distance > 0.7 || MC.player.tickCount % 10 == 0)
 				forwardKey.setPressed(true);
 			return;
 		}
@@ -177,12 +176,12 @@ public final class FishingSpotManager
 		fishCaughtAtLastSpot = 0;
 	}
 	
-	public void onBite(FishingBobberEntity bobber)
+	public void onBite(FishingHook bobber)
 	{
 		boolean samePlayerInput = lastSpot != null
 			&& lastSpot.input().isNearlyIdenticalTo(castPosRot);
 		boolean sameBobberPos = lastSpot != null
-			&& isInRange(lastSpot.bobberPos(), bobber.getEntityPos());
+			&& isInRange(lastSpot.bobberPos(), bobber.position());
 		
 		// update counter based on bobber position
 		if(sameBobberPos)
@@ -229,7 +228,7 @@ public final class FishingSpotManager
 			.orElse(null);
 	}
 	
-	private boolean isInRange(Vec3d pos1, Vec3d pos2)
+	private boolean isInRange(Vec3 pos1, Vec3 pos2)
 	{
 		double dy = Math.abs(pos1.y - pos2.y);
 		if(dy > 2)
diff --git a/src/main/java/net/wurstclient/hacks/autofish/PositionAndRotation.java b/src/main/java/net/wurstclient/hacks/autofish/PositionAndRotation.java
index d358f3431..e27a4f34f 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/PositionAndRotation.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/PositionAndRotation.java
@@ -7,16 +7,16 @@
  */
 package net.wurstclient.hacks.autofish;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.util.Rotation;
 
-public record PositionAndRotation(Vec3d pos, Rotation rotation)
+public record PositionAndRotation(Vec3 pos, Rotation rotation)
 {
 	public PositionAndRotation(Entity entity)
 	{
-		this(entity.getEntityPos(),
-			Rotation.wrapped(entity.getYaw(), entity.getPitch()));
+		this(entity.position(),
+			Rotation.wrapped(entity.getYRot(), entity.getXRot()));
 	}
 	
 	public boolean isNearlyIdenticalTo(PositionAndRotation other)
diff --git a/src/main/java/net/wurstclient/hacks/autofish/ShallowWaterWarningCheckbox.java b/src/main/java/net/wurstclient/hacks/autofish/ShallowWaterWarningCheckbox.java
index 3bdf105c2..caa8e5ea1 100644
--- a/src/main/java/net/wurstclient/hacks/autofish/ShallowWaterWarningCheckbox.java
+++ b/src/main/java/net/wurstclient/hacks/autofish/ShallowWaterWarningCheckbox.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks.autofish;
 
-import net.minecraft.entity.projectile.FishingBobberEntity;
+import net.minecraft.world.entity.projectile.FishingHook;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.util.ChatUtils;
@@ -31,8 +31,8 @@ public class ShallowWaterWarningCheckbox extends CheckboxSetting
 	
 	public void checkWaterType()
 	{
-		FishingBobberEntity bobber = WurstClient.MC.player.fishHook;
-		if(bobber.isOpenOrWaterAround(bobber.getBlockPos()))
+		FishingHook bobber = WurstClient.MC.player.fishing;
+		if(bobber.calculateOpenWater(bobber.blockPosition()))
 		{
 			hasAlreadyWarned = false;
 			return;
diff --git a/src/main/java/net/wurstclient/hacks/autolibrarian/BookOffer.java b/src/main/java/net/wurstclient/hacks/autolibrarian/BookOffer.java
index 3b5a07faa..c3f0a4244 100644
--- a/src/main/java/net/wurstclient/hacks/autolibrarian/BookOffer.java
+++ b/src/main/java/net/wurstclient/hacks/autolibrarian/BookOffer.java
@@ -9,15 +9,14 @@ package net.wurstclient.hacks.autolibrarian;
 
 import java.util.Objects;
 import java.util.Optional;
-
-import net.minecraft.enchantment.Enchantment;
-import net.minecraft.registry.DynamicRegistryManager;
-import net.minecraft.registry.Registry;
-import net.minecraft.registry.RegistryKeys;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.text.Text;
-import net.minecraft.text.TranslatableTextContent;
-import net.minecraft.util.Identifier;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.enchantment.Enchantment;
 import net.wurstclient.WurstClient;
 import net.wurstclient.WurstTranslator;
 
@@ -26,34 +25,34 @@ public record BookOffer(String id, int level, int price)
 {
 	public static BookOffer create(Enchantment enchantment)
 	{
-		DynamicRegistryManager drm = WurstClient.MC.world.getRegistryManager();
+		RegistryAccess drm = WurstClient.MC.level.registryAccess();
 		Registry<Enchantment> registry =
-			drm.getOrThrow(RegistryKeys.ENCHANTMENT);
-		Identifier id = registry.getId(enchantment);
+			drm.lookupOrThrow(Registries.ENCHANTMENT);
+		ResourceLocation id = registry.getKey(enchantment);
 		return new BookOffer("" + id, enchantment.getMaxLevel(), 64);
 	}
 	
-	public Optional<? extends RegistryEntry<Enchantment>> getEnchantmentEntry()
+	public Optional<? extends Holder<Enchantment>> getEnchantmentEntry()
 	{
-		if(WurstClient.MC.world == null)
+		if(WurstClient.MC.level == null)
 			return Optional.empty();
 		
-		DynamicRegistryManager drm = WurstClient.MC.world.getRegistryManager();
-		Identifier identifier = Identifier.tryParse(id);
+		RegistryAccess drm = WurstClient.MC.level.registryAccess();
+		ResourceLocation identifier = ResourceLocation.tryParse(id);
 		if(identifier == null)
 			return Optional.empty();
 		
 		Optional<Registry<Enchantment>> registryOpt =
-			drm.getOptional(RegistryKeys.ENCHANTMENT);
+			drm.lookup(Registries.ENCHANTMENT);
 		if(registryOpt.isEmpty())
 			return Optional.empty();
 		
-		return registryOpt.get().getEntry(identifier);
+		return registryOpt.get().get(identifier);
 	}
 	
 	public Enchantment getEnchantment()
 	{
-		return getEnchantmentEntry().map(RegistryEntry::value).orElse(null);
+		return getEnchantmentEntry().map(Holder::value).orElse(null);
 	}
 	
 	public String getEnchantmentName()
@@ -62,8 +61,8 @@ public record BookOffer(String id, int level, int price)
 		if(enchantment == null)
 			return id;
 		
-		Text description = enchantment.description();
-		if(description.getContent() instanceof TranslatableTextContent tr)
+		Component description = enchantment.description();
+		if(description.getContents() instanceof TranslatableContents tr)
 			return WurstClient.INSTANCE.getTranslator()
 				.translateMcEnglish(tr.getKey());
 		
@@ -80,7 +79,7 @@ public record BookOffer(String id, int level, int price)
 		{
 			name = id;
 		}else if(enchantment.description()
-			.getContent() instanceof TranslatableTextContent tr)
+			.getContents() instanceof TranslatableContents tr)
 			name = translator.translateMcEnglish(tr.getKey());
 		else
 			name = enchantment.description().getString();
@@ -117,7 +116,7 @@ public record BookOffer(String id, int level, int price)
 	 */
 	public boolean isMostlyValid()
 	{
-		return Identifier.tryParse(id) != null && level >= 1 && price >= 1
+		return ResourceLocation.tryParse(id) != null && level >= 1 && price >= 1
 			&& price <= 64;
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/bedesp/BedEspBlockGroup.java b/src/main/java/net/wurstclient/hacks/bedesp/BedEspBlockGroup.java
index a31e61340..fba0dccb6 100644
--- a/src/main/java/net/wurstclient/hacks/bedesp/BedEspBlockGroup.java
+++ b/src/main/java/net/wurstclient/hacks/bedesp/BedEspBlockGroup.java
@@ -12,13 +12,12 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BedBlock;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.enums.BedPart;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BedPart;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.settings.Setting;
@@ -27,7 +26,7 @@ import net.wurstclient.util.chunk.ChunkSearcher.Result;
 
 public final class BedEspBlockGroup
 {
-	private final ArrayList<Box> boxes = new ArrayList<>();
+	private final ArrayList<AABB> boxes = new ArrayList<>();
 	private final ColorSetting color;
 	private final CheckboxSetting enabled = null;
 	
@@ -45,25 +44,25 @@ public final class BedEspBlockGroup
 		if(!(state.getBlock() instanceof BedBlock))
 			return;
 		
-		if(state.get(BedBlock.PART) == BedPart.FOOT)
+		if(state.getValue(BedBlock.PART) == BedPart.FOOT)
 			return;
 		
 		BlockPos headPos = result.pos();
 		if(!BlockUtils.canBeClicked(headPos))
 			return;
 		
-		Box box = BlockUtils.getBoundingBox(headPos);
-		Direction facing = state.get(BedBlock.FACING);
-		BlockPos footPos = headPos.offset(facing.getOpposite());
+		AABB box = BlockUtils.getBoundingBox(headPos);
+		Direction facing = state.getValue(BedBlock.FACING);
+		BlockPos footPos = headPos.relative(facing.getOpposite());
 		
 		if(BlockUtils.canBeClicked(footPos))
 		{
 			BlockState otherState = BlockUtils.getState(footPos);
 			if(otherState.getBlock() instanceof BedBlock
-				&& otherState.get(BedBlock.PART) == BedPart.FOOT)
+				&& otherState.getValue(BedBlock.PART) == BedPart.FOOT)
 			{
-				Box footBox = BlockUtils.getBoundingBox(footPos);
-				box = box.union(footBox);
+				AABB footBox = BlockUtils.getBoundingBox(footPos);
+				box = box.minmax(footBox);
 			}
 		}
 		
@@ -90,7 +89,7 @@ public final class BedEspBlockGroup
 		return color.getColorI(alpha);
 	}
 	
-	public List<Box> getBoxes()
+	public List<AABB> getBoxes()
 	{
 		return Collections.unmodifiableList(boxes);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/chattranslator/FilterOwnMessagesSetting.java b/src/main/java/net/wurstclient/hacks/chattranslator/FilterOwnMessagesSetting.java
index 5a9ddcdf6..7ce9291a4 100644
--- a/src/main/java/net/wurstclient/hacks/chattranslator/FilterOwnMessagesSetting.java
+++ b/src/main/java/net/wurstclient/hacks/chattranslator/FilterOwnMessagesSetting.java
@@ -32,7 +32,7 @@ public class FilterOwnMessagesSetting extends CheckboxSetting
 	
 	private void updateOwnMessagePattern()
 	{
-		String username = WurstClient.MC.getSession().getUsername();
+		String username = WurstClient.MC.getUser().getName();
 		if(username.equals(lastUsername))
 			return;
 		
diff --git a/src/main/java/net/wurstclient/hacks/chattranslator/LanguageSetting.java b/src/main/java/net/wurstclient/hacks/chattranslator/LanguageSetting.java
index a5fe574d7..48b246f48 100644
--- a/src/main/java/net/wurstclient/hacks/chattranslator/LanguageSetting.java
+++ b/src/main/java/net/wurstclient/hacks/chattranslator/LanguageSetting.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks.chattranslator;
 
-import net.minecraft.text.Text;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.settings.EnumSetting;
 
 public final class LanguageSetting extends EnumSetting<LanguageSetting.Language>
@@ -93,9 +93,9 @@ public final class LanguageSetting extends EnumSetting<LanguageSetting.Language>
 			return prefix;
 		}
 		
-		public Text prefixText(String s)
+		public Component prefixText(String s)
 		{
-			return Text.literal(prefix + s);
+			return Component.literal(prefix + s);
 		}
 		
 		@Override
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspBlockGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspBlockGroup.java
index e7cbbae63..c1e34de3c 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspBlockGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspBlockGroup.java
@@ -7,13 +7,13 @@
  */
 package net.wurstclient.hacks.chestesp;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.block.ChestBlock;
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.ChestBlockEntity;
-import net.minecraft.block.enums.ChestType;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.ChestBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.ChestType;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.util.BlockUtils;
 
 public abstract class ChestEspBlockGroup extends ChestEspGroup
@@ -25,16 +25,16 @@ public abstract class ChestEspBlockGroup extends ChestEspGroup
 		if(!matches(be))
 			return;
 		
-		Box box = getBox(be);
+		AABB box = getBox(be);
 		if(box == null)
 			return;
 		
 		boxes.add(box);
 	}
 	
-	private Box getBox(BlockEntity be)
+	private AABB getBox(BlockEntity be)
 	{
-		BlockPos pos = be.getPos();
+		BlockPos pos = be.getBlockPos();
 		
 		if(!BlockUtils.canBeClicked(pos))
 			return null;
@@ -45,30 +45,31 @@ public abstract class ChestEspBlockGroup extends ChestEspGroup
 		return BlockUtils.getBoundingBox(pos);
 	}
 	
-	private Box getChestBox(ChestBlockEntity chestBE)
+	private AABB getChestBox(ChestBlockEntity chestBE)
 	{
-		BlockState state = chestBE.getCachedState();
-		if(!state.contains(ChestBlock.CHEST_TYPE))
+		BlockState state = chestBE.getBlockState();
+		if(!state.hasProperty(ChestBlock.TYPE))
 			return null;
 		
-		ChestType chestType = state.get(ChestBlock.CHEST_TYPE);
+		ChestType chestType = state.getValue(ChestBlock.TYPE);
 		
 		// ignore other block in double chest
 		if(chestType == ChestType.LEFT)
 			return null;
 		
-		BlockPos pos = chestBE.getPos();
-		Box box = BlockUtils.getBoundingBox(pos);
+		BlockPos pos = chestBE.getBlockPos();
+		AABB box = BlockUtils.getBoundingBox(pos);
 		
 		// larger box for double chest
 		if(chestType != ChestType.SINGLE)
 		{
-			BlockPos pos2 = pos.offset(ChestBlock.getFacing(state));
+			BlockPos pos2 =
+				pos.relative(ChestBlock.getConnectedDirection(state));
 			
 			if(BlockUtils.canBeClicked(pos2))
 			{
-				Box box2 = BlockUtils.getBoundingBox(pos2);
-				box = box.union(box2);
+				AABB box2 = BlockUtils.getBoundingBox(pos2);
+				box = box.minmax(box2);
 			}
 		}
 		
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspEntityGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspEntityGroup.java
index 0b08a4095..d4e8770fd 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspEntityGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspEntityGroup.java
@@ -8,8 +8,7 @@
 package net.wurstclient.hacks.chestesp;
 
 import java.util.ArrayList;
-
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.util.EntityUtils;
 
 public abstract class ChestEspEntityGroup extends ChestEspGroup
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspGroup.java
index 66ade45d8..703ceae90 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/ChestEspGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/ChestEspGroup.java
@@ -12,15 +12,14 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.util.math.Box;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.settings.Setting;
 
 public abstract class ChestEspGroup
 {
-	protected final ArrayList<Box> boxes = new ArrayList<>();
+	protected final ArrayList<AABB> boxes = new ArrayList<>();
 	private final ColorSetting color;
 	private final CheckboxSetting enabled;
 	
@@ -54,7 +53,7 @@ public abstract class ChestEspGroup
 		return color.getColorI(alpha);
 	}
 	
-	public final List<Box> getBoxes()
+	public final List<AABB> getBoxes()
 	{
 		return Collections.unmodifiableList(boxes);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/BarrelsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/BarrelsGroup.java
index 9ed920405..0a4002ff0 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/BarrelsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/BarrelsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BarrelBlockEntity;
-import net.minecraft.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.BarrelBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestBoatsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestBoatsGroup.java
index af5e4774a..5cdc977c5 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestBoatsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestBoatsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.vehicle.AbstractChestBoatEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.vehicle.AbstractChestBoat;
 import net.wurstclient.hacks.chestesp.ChestEspEntityGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
@@ -34,6 +33,6 @@ public final class ChestBoatsGroup extends ChestEspEntityGroup
 	@Override
 	protected boolean matches(Entity e)
 	{
-		return e instanceof AbstractChestBoatEntity;
+		return e instanceof AbstractChestBoat;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestCartsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestCartsGroup.java
index 35459568c..459e36272 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestCartsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/ChestCartsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.vehicle.ChestMinecartEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.vehicle.MinecartChest;
 import net.wurstclient.hacks.chestesp.ChestEspEntityGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
@@ -34,6 +33,6 @@ public final class ChestCartsGroup extends ChestEspEntityGroup
 	@Override
 	protected boolean matches(Entity e)
 	{
-		return e instanceof ChestMinecartEntity;
+		return e instanceof MinecartChest;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/CraftersGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/CraftersGroup.java
index 11bea8592..a592c092b 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/CraftersGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/CraftersGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.CrafterBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.CrafterBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/DispensersGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/DispensersGroup.java
index f0d0f9582..e68a8a3c3 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/DispensersGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/DispensersGroup.java
@@ -8,10 +8,9 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.DispenserBlockEntity;
-import net.minecraft.block.entity.DropperBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.DispenserBlockEntity;
+import net.minecraft.world.level.block.entity.DropperBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/DroppersGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/DroppersGroup.java
index bfb4c2a97..a67091f6f 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/DroppersGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/DroppersGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.DropperBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.DropperBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/EnderChestsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/EnderChestsGroup.java
index a0e1f3ae4..c7c4a492e 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/EnderChestsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/EnderChestsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.EnderChestBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.EnderChestBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/FurnacesGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/FurnacesGroup.java
index ddb8377b1..6dcfaea7b 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/FurnacesGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/FurnacesGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.AbstractFurnaceBlockEntity;
-import net.minecraft.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/HopperCartsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/HopperCartsGroup.java
index 1a27a62e3..c0c4f22cd 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/HopperCartsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/HopperCartsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.vehicle.HopperMinecartEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.vehicle.MinecartHopper;
 import net.wurstclient.hacks.chestesp.ChestEspEntityGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
@@ -34,6 +33,6 @@ public final class HopperCartsGroup extends ChestEspEntityGroup
 	@Override
 	protected boolean matches(Entity e)
 	{
-		return e instanceof HopperMinecartEntity;
+		return e instanceof MinecartHopper;
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/HoppersGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/HoppersGroup.java
index b224d22c2..7bf38e516 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/HoppersGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/HoppersGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.HopperBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.HopperBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/NormalChestsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/NormalChestsGroup.java
index 02f00a0ec..35666dc2c 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/NormalChestsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/NormalChestsGroup.java
@@ -8,10 +8,9 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.ChestBlockEntity;
-import net.minecraft.block.entity.TrappedChestBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.ChestBlockEntity;
+import net.minecraft.world.level.block.entity.TrappedChestBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/PotsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/PotsGroup.java
index 2d13c3270..9d3f80d0e 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/PotsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/PotsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.DecoratedPotBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.DecoratedPotBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/ShulkerBoxesGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/ShulkerBoxesGroup.java
index 3e345cb1d..d1282f944 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/ShulkerBoxesGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/ShulkerBoxesGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.ShulkerBoxBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/chestesp/groups/TrapChestsGroup.java b/src/main/java/net/wurstclient/hacks/chestesp/groups/TrapChestsGroup.java
index 0add596d4..9850637ba 100644
--- a/src/main/java/net/wurstclient/hacks/chestesp/groups/TrapChestsGroup.java
+++ b/src/main/java/net/wurstclient/hacks/chestesp/groups/TrapChestsGroup.java
@@ -8,9 +8,8 @@
 package net.wurstclient.hacks.chestesp.groups;
 
 import java.awt.Color;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.entity.TrappedChestBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TrappedChestBlockEntity;
 import net.wurstclient.hacks.chestesp.ChestEspBlockGroup;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
diff --git a/src/main/java/net/wurstclient/hacks/mobspawnesp/HitboxCheckSetting.java b/src/main/java/net/wurstclient/hacks/mobspawnesp/HitboxCheckSetting.java
index 0b99fee1f..d173d0f06 100644
--- a/src/main/java/net/wurstclient/hacks/mobspawnesp/HitboxCheckSetting.java
+++ b/src/main/java/net/wurstclient/hacks/mobspawnesp/HitboxCheckSetting.java
@@ -8,10 +8,9 @@
 package net.wurstclient.hacks.mobspawnesp;
 
 import java.util.function.Function;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.EntityType;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.EntityType;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.EnumSetting;
 import net.wurstclient.util.text.WText;
@@ -19,7 +18,7 @@ import net.wurstclient.util.text.WText;
 public final class HitboxCheckSetting
 	extends EnumSetting<HitboxCheckSetting.HitboxCheck>
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	private static final WText DESCRIPTION =
 		WText.translated("description.wurst.setting.mobspawnesp.hitbox_check")
 			.append(buildDescriptionSuffix());
@@ -43,8 +42,8 @@ public final class HitboxCheckSetting
 	// "unstable" because isSpaceEmpty() is not thread-safe
 	private static boolean unstableHitboxCheck(BlockPos pos)
 	{
-		return MC.world.isSpaceEmpty(EntityType.CREEPER
-			.getSpawnBox(pos.getX() + 0.5, pos.getY(), pos.getZ() + 0.5));
+		return MC.level.noCollision(EntityType.CREEPER
+			.getSpawnAABB(pos.getX() + 0.5, pos.getY(), pos.getZ() + 0.5));
 	}
 	
 	private static WText buildDescriptionSuffix()
diff --git a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksChunkRenderer.java b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksChunkRenderer.java
index 0fcebc66a..0c61dc780 100644
--- a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksChunkRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksChunkRenderer.java
@@ -7,16 +7,15 @@
  */
 package net.wurstclient.hacks.newchunks;
 
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.Set;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.world.level.ChunkPos;
 
 public interface NewChunksChunkRenderer
 {
 	public void buildBuffer(VertexConsumer buffer, Set<ChunkPos> chunks,
 		int drawDistance);
 	
-	public RenderLayer.MultiPhase getLayer();
+	public RenderType.CompositeRenderType getLayer();
 }
diff --git a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksOutlineRenderer.java b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksOutlineRenderer.java
index 463df65c8..cae9380e3 100644
--- a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksOutlineRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksOutlineRenderer.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks.newchunks;
 
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.Set;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.util.RegionPos;
 import net.wurstclient.util.RenderUtils;
@@ -28,11 +27,11 @@ public final class NewChunksOutlineRenderer implements NewChunksChunkRenderer
 		
 		for(ChunkPos chunkPos : chunks)
 		{
-			if(chunkPos.getChebyshevDistance(camChunkPos) > drawDistance)
+			if(chunkPos.getChessboardDistance(camChunkPos) > drawDistance)
 				continue;
 			
 			BlockPos blockPos =
-				chunkPos.getBlockPos(-region.x(), 0, -region.z());
+				chunkPos.getBlockAt(-region.x(), 0, -region.z());
 			float x1 = blockPos.getX() + 0.5F;
 			float x2 = x1 + 15;
 			float z1 = blockPos.getZ() + 0.5F;
@@ -47,7 +46,7 @@ public final class NewChunksOutlineRenderer implements NewChunksChunkRenderer
 	}
 	
 	@Override
-	public RenderLayer.MultiPhase getLayer()
+	public RenderType.CompositeRenderType getLayer()
 	{
 		return WurstRenderLayers.ESP_LINES;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksReasonsRenderer.java b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksReasonsRenderer.java
index 9ba7ea9b8..a642a36b4 100644
--- a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksReasonsRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksReasonsRenderer.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.hacks.newchunks;
 
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.List;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.settings.SliderSetting;
 import net.wurstclient.util.RegionPos;
@@ -37,15 +36,15 @@ public final class NewChunksReasonsRenderer
 		for(BlockPos pos : reasons)
 		{
 			ChunkPos chunkPos = new ChunkPos(pos);
-			if(chunkPos.getChebyshevDistance(camChunkPos) > drawDistance)
+			if(chunkPos.getChessboardDistance(camChunkPos) > drawDistance)
 				continue;
 			
-			Box box = new Box(pos).offset(-region.x(), 0, -region.z());
+			AABB box = new AABB(pos).move(-region.x(), 0, -region.z());
 			RenderUtils.drawSolidBox(buffer, box, 0xFFFFFFFF);
 		}
 	}
 	
-	public RenderLayer.MultiPhase getLayer()
+	public RenderType.CompositeRenderType getLayer()
 	{
 		return WurstRenderLayers.ESP_QUADS;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksRenderer.java b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksRenderer.java
index 32f1482cb..2033bfa5a 100644
--- a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksRenderer.java
@@ -7,11 +7,10 @@
  */
 package net.wurstclient.hacks.newchunks;
 
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.function.Consumer;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.util.math.MatrixStack;
+import net.minecraft.client.renderer.RenderType;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.settings.SliderSetting;
 import net.wurstclient.util.BufferWithLayer;
@@ -35,7 +34,7 @@ public final class NewChunksRenderer
 		this.oldChunksColor = oldChunksColor;
 	}
 	
-	public void updateBuffer(int i, RenderLayer.MultiPhase layer,
+	public void updateBuffer(int i, RenderType.CompositeRenderType layer,
 		Consumer<VertexConsumer> callback)
 	{
 		vertexBuffers[i] = BufferWithLayer.createAndUpload(layer, callback);
@@ -53,9 +52,9 @@ public final class NewChunksRenderer
 		}
 	}
 	
-	public void render(MatrixStack matrixStack, float partialTicks)
+	public void render(PoseStack matrixStack, float partialTicks)
 	{
-		matrixStack.push();
+		matrixStack.pushPose();
 		RenderUtils.applyRegionalRenderOffset(matrixStack);
 		
 		float alpha = opacity.getValueF();
@@ -67,7 +66,7 @@ public final class NewChunksRenderer
 			if(buffer == null)
 				continue;
 			
-			matrixStack.push();
+			matrixStack.pushPose();
 			if(i == 0 || i == 2)
 				matrixStack.translate(0, altitudeD, 0);
 			
@@ -76,9 +75,9 @@ public final class NewChunksRenderer
 			
 			buffer.draw(matrixStack, rgb, alpha);
 			
-			matrixStack.pop();
+			matrixStack.popPose();
 		}
 		
-		matrixStack.pop();
+		matrixStack.popPose();
 	}
 }
diff --git a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksSquareRenderer.java b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksSquareRenderer.java
index ca30224e1..46cc542b7 100644
--- a/src/main/java/net/wurstclient/hacks/newchunks/NewChunksSquareRenderer.java
+++ b/src/main/java/net/wurstclient/hacks/newchunks/NewChunksSquareRenderer.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks.newchunks;
 
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.Set;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.util.RegionPos;
 import net.wurstclient.util.RenderUtils;
@@ -28,26 +27,26 @@ public final class NewChunksSquareRenderer implements NewChunksChunkRenderer
 		
 		for(ChunkPos chunkPos : chunks)
 		{
-			if(chunkPos.getChebyshevDistance(camChunkPos) > drawDistance)
+			if(chunkPos.getChessboardDistance(camChunkPos) > drawDistance)
 				continue;
 			
 			BlockPos blockPos =
-				chunkPos.getBlockPos(-region.x(), 0, -region.z());
+				chunkPos.getBlockAt(-region.x(), 0, -region.z());
 			float x1 = blockPos.getX() + 0.5F;
 			float x2 = x1 + 15;
 			float z1 = blockPos.getZ() + 0.5F;
 			float z2 = z1 + 15;
 			int color = 0xFFFFFFFF;
 			
-			buffer.vertex(x1, 0, z1).color(color);
-			buffer.vertex(x2, 0, z1).color(color);
-			buffer.vertex(x2, 0, z2).color(color);
-			buffer.vertex(x1, 0, z2).color(color);
+			buffer.addVertex(x1, 0, z1).setColor(color);
+			buffer.addVertex(x2, 0, z1).setColor(color);
+			buffer.addVertex(x2, 0, z2).setColor(color);
+			buffer.addVertex(x1, 0, z2).setColor(color);
 		}
 	}
 	
 	@Override
-	public RenderLayer.MultiPhase getLayer()
+	public RenderType.CompositeRenderType getLayer()
 	{
 		return WurstRenderLayers.ESP_QUADS_NO_CULLING;
 	}
diff --git a/src/main/java/net/wurstclient/hacks/nukers/CommonNukerSettings.java b/src/main/java/net/wurstclient/hacks/nukers/CommonNukerSettings.java
index bcd395898..dc4797af2 100644
--- a/src/main/java/net/wurstclient/hacks/nukers/CommonNukerSettings.java
+++ b/src/main/java/net/wurstclient/hacks/nukers/CommonNukerSettings.java
@@ -8,12 +8,11 @@
 package net.wurstclient.hacks.nukers;
 
 import java.util.stream.Stream;
-
-import net.minecraft.block.Blocks;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.LeftClickListener;
 import net.wurstclient.hacks.nukers.NukerModeSetting.NukerMode;
@@ -25,7 +24,7 @@ import net.wurstclient.util.BlockUtils;
 
 public final class CommonNukerSettings implements LeftClickListener
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final NukerShapeSetting shape = new NukerShapeSetting();
 	
@@ -106,7 +105,7 @@ public final class CommonNukerSettings implements LeftClickListener
 		if(lockId.isChecked() || mode.getSelected() != NukerMode.ID)
 			return;
 		
-		if(!(MC.crosshairTarget instanceof BlockHitResult bHitResult)
+		if(!(MC.hitResult instanceof BlockHitResult bHitResult)
 			|| bHitResult.getType() != HitResult.Type.BLOCK)
 			return;
 		
diff --git a/src/main/java/net/wurstclient/hacks/portalesp/LiquidEspBlockGroup.java b/src/main/java/net/wurstclient/hacks/portalesp/LiquidEspBlockGroup.java
index a8eca5415..26ed9a4d2 100644
--- a/src/main/java/net/wurstclient/hacks/portalesp/LiquidEspBlockGroup.java
+++ b/src/main/java/net/wurstclient/hacks/portalesp/LiquidEspBlockGroup.java
@@ -12,10 +12,9 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.settings.Setting;
@@ -23,7 +22,7 @@ import net.wurstclient.util.BlockUtils;
 
 public final class LiquidEspBlockGroup
 {
-	protected final ArrayList<Box> boxes = new ArrayList<>();
+	protected final ArrayList<AABB> boxes = new ArrayList<>();
 	private final Block block;
 	private final ColorSetting color;
 	private final CheckboxSetting enabled;
@@ -38,19 +37,19 @@ public final class LiquidEspBlockGroup
 	
 	public void add(BlockPos pos)
 	{
-		Box box = getBox(pos);
+		AABB box = getBox(pos);
 		if(box == null)
 			return;
 		boxes.add(box);
 	}
 	
-	private Box getBox(BlockPos pos)
+	private AABB getBox(BlockPos pos)
 	{
 		// fluids often have empty outline shapes; fall back to full block box
 		if(BlockUtils.canBeClicked(pos))
 			return BlockUtils.getBoundingBox(pos);
 		
-		return new Box(pos.getX(), pos.getY(), pos.getZ(), pos.getX() + 1.0,
+		return new AABB(pos.getX(), pos.getY(), pos.getZ(), pos.getX() + 1.0,
 			pos.getY() + 1.0, pos.getZ() + 1.0);
 	}
 	
@@ -79,7 +78,7 @@ public final class LiquidEspBlockGroup
 		return color.getColorI(alpha);
 	}
 	
-	public List<Box> getBoxes()
+	public List<AABB> getBoxes()
 	{
 		return Collections.unmodifiableList(boxes);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/portalesp/PortalEspBlockGroup.java b/src/main/java/net/wurstclient/hacks/portalesp/PortalEspBlockGroup.java
index 93102c66f..64874795f 100644
--- a/src/main/java/net/wurstclient/hacks/portalesp/PortalEspBlockGroup.java
+++ b/src/main/java/net/wurstclient/hacks/portalesp/PortalEspBlockGroup.java
@@ -12,10 +12,9 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.ColorSetting;
 import net.wurstclient.settings.Setting;
@@ -23,7 +22,7 @@ import net.wurstclient.util.BlockUtils;
 
 public final class PortalEspBlockGroup
 {
-	protected final ArrayList<Box> boxes = new ArrayList<>();
+	protected final ArrayList<AABB> boxes = new ArrayList<>();
 	protected final ArrayList<BlockPos> positions = new ArrayList<>();
 	private final Block block;
 	private final ColorSetting color;
@@ -39,15 +38,15 @@ public final class PortalEspBlockGroup
 	
 	public void add(BlockPos pos)
 	{
-		Box box = getBox(pos);
+		AABB box = getBox(pos);
 		if(box == null)
 			return;
 		
 		boxes.add(box);
-		positions.add(pos.toImmutable());
+		positions.add(pos.immutable());
 	}
 	
-	private Box getBox(BlockPos pos)
+	private AABB getBox(BlockPos pos)
 	{
 		if(!BlockUtils.canBeClicked(pos))
 			return null;
@@ -81,7 +80,7 @@ public final class PortalEspBlockGroup
 		return color.getColorI(alpha);
 	}
 	
-	public List<Box> getBoxes()
+	public List<AABB> getBoxes()
 	{
 		return Collections.unmodifiableList(boxes);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/SelectPositionState.java b/src/main/java/net/wurstclient/hacks/templatetool/SelectPositionState.java
index 9cdf3c060..fe277c52f 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/SelectPositionState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/SelectPositionState.java
@@ -8,12 +8,11 @@
 package net.wurstclient.hacks.templatetool;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import com.mojang.blaze3d.platform.InputConstants;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.util.RenderUtils;
 
@@ -26,7 +25,7 @@ public abstract class SelectPositionState extends TemplateToolState
 	{
 		crosshairBlock = getCrosshairBlock();
 		
-		if(MC.options.useKey.isPressed() && crosshairBlock != null)
+		if(MC.options.keyUse.isDown() && crosshairBlock != null)
 		{
 			setSelectedPos(hack, crosshairBlock);
 			return;
@@ -38,29 +37,29 @@ public abstract class SelectPositionState extends TemplateToolState
 	
 	private BlockPos getCrosshairBlock()
 	{
-		if(!(MC.crosshairTarget instanceof BlockHitResult bHitResult))
+		if(!(MC.hitResult instanceof BlockHitResult bHitResult))
 			return null;
 		
 		BlockPos pos = bHitResult.getBlockPos();
-		if(MC.options.sneakKey.isPressed())
-			pos = pos.offset(bHitResult.getSide());
+		if(MC.options.keyShift.isDown())
+			pos = pos.relative(bHitResult.getDirection());
 		
 		return pos;
 	}
 	
 	private boolean isPressingEnter()
 	{
-		return InputUtil.isKeyPressed(MC.getWindow(), GLFW.GLFW_KEY_ENTER);
+		return InputConstants.isKeyDown(MC.getWindow(), GLFW.GLFW_KEY_ENTER);
 	}
 	
 	@Override
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		if(crosshairBlock == null)
 			return;
 		
-		Box box = new Box(crosshairBlock).contract(1 / 16.0);
+		AABB box = new AABB(crosshairBlock).deflate(1 / 16.0);
 		int black = 0x80000000;
 		int gray = 0x26404040;
 		RenderUtils.drawOutlinedBox(matrixStack, box, black, false);
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/TemplateToolState.java b/src/main/java/net/wurstclient/hacks/templatetool/TemplateToolState.java
index 2f6740346..837572f4b 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/TemplateToolState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/TemplateToolState.java
@@ -7,18 +7,18 @@
  */
 package net.wurstclient.hacks.templatetool;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.Colors;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.TemplateToolHack;
 
 public abstract class TemplateToolState
 {
 	protected static final WurstClient WURST = WurstClient.INSTANCE;
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	
 	public void onEnter(TemplateToolHack hack)
 	{
@@ -35,27 +35,27 @@ public abstract class TemplateToolState
 		
 	}
 	
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		
 	}
 	
-	public final void onRenderGUI(TemplateToolHack hack, DrawContext context,
+	public final void onRenderGUI(TemplateToolHack hack, GuiGraphics context,
 		float partialTicks)
 	{
 		String message = getMessage(hack);
-		TextRenderer tr = MC.textRenderer;
-		int msgWidth = tr.getWidth(message);
+		Font tr = MC.font;
+		int msgWidth = tr.width(message);
 		
-		int msgX1 = context.getScaledWindowWidth() / 2 - msgWidth / 2;
+		int msgX1 = context.guiWidth() / 2 - msgWidth / 2;
 		int msgX2 = msgX1 + msgWidth + 2;
-		int msgY1 = context.getScaledWindowHeight() / 2 + 1;
+		int msgY1 = context.guiHeight() / 2 + 1;
 		int msgY2 = msgY1 + 10;
 		
 		context.fill(msgX1, msgY1, msgX2, msgY2, 0x80000000);
-		context.drawText(tr, message, msgX1 + 2, msgY1 + 1, Colors.WHITE,
-			false);
+		context.drawString(tr, message, msgX1 + 2, msgY1 + 1,
+			CommonColors.WHITE, false);
 	}
 	
 	protected abstract String getMessage(TemplateToolHack hack);
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/ChooseNameState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/ChooseNameState.java
index be62932d3..548fd430f 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/ChooseNameState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/ChooseNameState.java
@@ -12,17 +12,16 @@ import java.nio.file.InvalidPathException;
 import java.nio.file.Path;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.CheckboxWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.screen.ScreenTexts;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Checkbox;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.CommonComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
@@ -56,46 +55,46 @@ public final class ChooseNameState extends TemplateToolState
 		private static final WurstClient WURST = WurstClient.INSTANCE;
 		private final TemplateToolHack hack;
 		
-		private TextFieldWidget nameField;
-		private CheckboxWidget includeTypesBox;
-		private ButtonWidget doneButton;
-		private ButtonWidget cancelButton;
+		private EditBox nameField;
+		private Checkbox includeTypesBox;
+		private Button doneButton;
+		private Button cancelButton;
 		
 		public ChooseNameScreen(TemplateToolHack hack)
 		{
-			super(ScreenTexts.EMPTY);
+			super(CommonComponents.EMPTY);
 			this.hack = hack;
 		}
 		
 		@Override
 		public void init()
 		{
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			int middleX = width / 2;
 			int middleY = height / 2;
 			
-			nameField = new TextFieldWidget(tr, middleX - 99, middleY + 16, 198,
-				16, Text.empty());
-			nameField.setDrawsBackground(false);
+			nameField = new EditBox(tr, middleX - 99, middleY + 16, 198, 16,
+				Component.empty());
+			nameField.setBordered(false);
 			nameField.setMaxLength(32);
 			nameField.setFocused(true);
-			nameField.setEditableColor(Colors.WHITE);
-			addSelectableChild(nameField);
+			nameField.setTextColor(CommonColors.WHITE);
+			addWidget(nameField);
 			setFocused(nameField);
 			
 			includeTypesBox =
-				CheckboxWidget.builder(Text.literal("Include block types"), tr)
-					.pos(middleX - 99, middleY + 32).checked(true).build();
-			addDrawableChild(includeTypesBox);
+				Checkbox.builder(Component.literal("Include block types"), tr)
+					.pos(middleX - 99, middleY + 32).selected(true).build();
+			addRenderableWidget(includeTypesBox);
 			
-			doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-				.dimensions(middleX - 75, middleY + 56, 150, 20).build();
-			addDrawableChild(doneButton);
+			doneButton = Button.builder(Component.literal("Done"), b -> done())
+				.bounds(middleX - 75, middleY + 56, 150, 20).build();
+			addRenderableWidget(doneButton);
 			
 			cancelButton =
-				ButtonWidget.builder(Text.literal("Cancel"), b -> cancel())
-					.dimensions(middleX - 50, middleY + 80, 100, 15).build();
-			addDrawableChild(cancelButton);
+				Button.builder(Component.literal("Cancel"), b -> cancel())
+					.bounds(middleX - 50, middleY + 80, 100, 15).build();
+			addRenderableWidget(cancelButton);
 		}
 		
 		private void done()
@@ -103,7 +102,7 @@ public final class ChooseNameState extends TemplateToolState
 			if(hack.getFile() == null)
 				return;
 			
-			hack.setBlockTypesEnabled(includeTypesBox.isChecked());
+			hack.setBlockTypesEnabled(includeTypesBox.selected());
 			hack.setState(new SavingFileState());
 		}
 		
@@ -115,13 +114,13 @@ public final class ChooseNameState extends TemplateToolState
 		@Override
 		public void tick()
 		{
-			if(nameField.getText().isEmpty())
+			if(nameField.getValue().isEmpty())
 				hack.setFile(null);
 			else
 				try
 				{
 					Path folder = WURST.getHax().autoBuildHack.getFolder();
-					Path file = folder.resolve(nameField.getText() + ".json");
+					Path file = folder.resolve(nameField.getValue() + ".json");
 					hack.setFile(file.toFile());
 					
 				}catch(InvalidPathException e)
@@ -133,7 +132,7 @@ public final class ChooseNameState extends TemplateToolState
 		}
 		
 		@Override
-		public boolean keyPressed(KeyInput context)
+		public boolean keyPressed(KeyEvent context)
 		{
 			switch(context.key())
 			{
@@ -150,7 +149,7 @@ public final class ChooseNameState extends TemplateToolState
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void render(GuiGraphics context, int mouseX, int mouseY,
 			float partialTicks)
 		{
 			super.render(context, mouseX, mouseY, partialTicks);
@@ -173,14 +172,14 @@ public final class ChooseNameState extends TemplateToolState
 		}
 		
 		@Override
-		public void renderBackground(DrawContext context, int mouseX,
+		public void renderBackground(GuiGraphics context, int mouseX,
 			int mouseY, float deltaTicks)
 		{
 			// Don't blur
 		}
 		
 		@Override
-		public boolean shouldPause()
+		public boolean isPauseScreen()
 		{
 			return false;
 		}
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/CreatingTemplateState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/CreatingTemplateState.java
index 91cabbeda..52bfa7115 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/CreatingTemplateState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/CreatingTemplateState.java
@@ -7,17 +7,16 @@
  */
 package net.wurstclient.hacks.templatetool.states;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayDeque;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.TreeSet;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
 import net.wurstclient.util.RenderUtils;
@@ -34,14 +33,14 @@ public final class CreatingTemplateState extends TemplateToolState
 	public void onEnter(TemplateToolHack hack)
 	{
 		totalBlocks = hack.getNonEmptyBlocks().size();
-		blocksPerTick = MathHelper.clamp(totalBlocks / 15, 1, 1024);
+		blocksPerTick = Mth.clamp(totalBlocks / 15, 1, 1024);
 		
 		unsortedBlocks = new ArrayDeque<>(hack.getNonEmptyBlocks().keySet());
 		
 		BlockPos origin = hack.getOriginPos();
-		sortingHelper = new TreeSet<>(Comparator
-			.<BlockPos> comparingDouble(pos -> pos.getSquaredDistance(origin))
-			.thenComparing(pos -> pos));
+		sortingHelper = new TreeSet<>(
+			Comparator.<BlockPos> comparingDouble(pos -> pos.distSqr(origin))
+				.thenComparing(pos -> pos));
 	}
 	
 	@Override
@@ -74,13 +73,13 @@ public final class CreatingTemplateState extends TemplateToolState
 			
 			for(BlockPos pos : sortingHelper)
 			{
-				double dPos = sortedBlocks.getLast().getSquaredDistance(pos);
+				double dPos = sortedBlocks.getLast().distSqr(pos);
 				if(dPos >= dCurrent)
 					continue;
 				
 				for(Direction side : Direction.values())
 				{
-					BlockPos next = pos.offset(side);
+					BlockPos next = pos.relative(side);
 					if(!sortedBlocks.contains(next))
 						continue;
 					
@@ -99,7 +98,7 @@ public final class CreatingTemplateState extends TemplateToolState
 	}
 	
 	@Override
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		int black = 0x80000000;
@@ -107,17 +106,18 @@ public final class CreatingTemplateState extends TemplateToolState
 		
 		BlockPos start = hack.getStartPos();
 		BlockPos end = hack.getEndPos();
-		Box bounds = Box.enclosing(start, end).contract(1 / 16.0);
+		AABB bounds =
+			AABB.encapsulatingFullBlocks(start, end).deflate(1 / 16.0);
 		
 		// Draw scanner
-		double scannerX = MathHelper.lerp(progress, bounds.minX, bounds.maxX);
-		Box scanner = bounds.withMinX(scannerX).withMaxX(scannerX);
+		double scannerX = Mth.lerp(progress, bounds.minX, bounds.maxX);
+		AABB scanner = bounds.setMinX(scannerX).setMaxX(scannerX);
 		RenderUtils.drawOutlinedBox(matrixStack, scanner, black, true);
 		RenderUtils.drawSolidBox(matrixStack, scanner, green30, true);
 		
 		// Draw recently sorted blocks
-		List<Box> boxes = hack.getSortedBlocks().reversed().stream()
-			.map(pos -> new Box(pos).contract(1 / 16.0)).limit(1024).toList();
+		List<AABB> boxes = hack.getSortedBlocks().reversed().stream()
+			.map(pos -> new AABB(pos).deflate(1 / 16.0)).limit(1024).toList();
 		RenderUtils.drawOutlinedBoxes(matrixStack, boxes, black, false);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/SavingFileState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/SavingFileState.java
index 8a76a319d..a4c534abb 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/SavingFileState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/SavingFileState.java
@@ -13,13 +13,12 @@ import java.io.PrintWriter;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.text.ClickEvent;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.Text;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
 import net.wurstclient.util.BlockUtils;
@@ -54,11 +53,11 @@ public final class SavingFileState extends TemplateToolState
 		}
 		
 		// Show success message
-		MutableText message = Text.literal("Saved template as ");
+		MutableComponent message = Component.literal("Saved template as ");
 		ClickEvent event = new ClickEvent.OpenFile(
 			hack.getFile().getParentFile().getAbsolutePath());
-		MutableText link = Text.literal(hack.getFile().getName())
-			.styled(s -> s.withUnderline(true).withClickEvent(event));
+		MutableComponent link = Component.literal(hack.getFile().getName())
+			.withStyle(s -> s.withUnderlined(true).withClickEvent(event));
 		message.append(link);
 		ChatUtils.component(message);
 		
@@ -70,7 +69,7 @@ public final class SavingFileState extends TemplateToolState
 		JsonObject json = new JsonObject();
 		json.addProperty("version", 2);
 		
-		Direction front = MC.player.getHorizontalFacing();
+		Direction front = MC.player.getDirection();
 		BlockPos origin = hack.getOriginPos();
 		
 		JsonArray jsonBlocks = new JsonArray();
@@ -103,7 +102,7 @@ public final class SavingFileState extends TemplateToolState
 		JsonObject json = new JsonObject();
 		json.addProperty("version", 1);
 		
-		Direction front = MC.player.getHorizontalFacing();
+		Direction front = MC.player.getDirection();
 		BlockPos origin = hack.getOriginPos();
 		
 		JsonArray jsonBlocks = new JsonArray();
@@ -124,13 +123,13 @@ public final class SavingFileState extends TemplateToolState
 		Direction front)
 	{
 		BlockPos translated = pos.subtract(origin);
-		Direction left = front.rotateYCounterclockwise();
+		Direction left = front.getCounterClockWise();
 		
-		int leftDist = translated.getX() * left.getOffsetX()
-			+ translated.getZ() * left.getOffsetZ();
+		int leftDist = translated.getX() * left.getStepX()
+			+ translated.getZ() * left.getStepZ();
 		int upDist = translated.getY();
-		int frontDist = translated.getX() * front.getOffsetX()
-			+ translated.getZ() * front.getOffsetZ();
+		int frontDist = translated.getX() * front.getStepX()
+			+ translated.getZ() * front.getStepZ();
 		
 		return new BlockPos(leftDist, upDist, frontDist);
 	}
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/ScanningAreaState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/ScanningAreaState.java
index 1066ef939..4ba8dcd33 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/ScanningAreaState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/ScanningAreaState.java
@@ -7,15 +7,14 @@
  */
 package net.wurstclient.hacks.templatetool.states;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
 import net.wurstclient.util.BlockUtils;
@@ -38,7 +37,7 @@ public final class ScanningAreaState extends TemplateToolState
 		int lengthY = Math.abs(start.getY() - end.getY()) + 1;
 		int lengthZ = Math.abs(start.getZ() - end.getZ()) + 1;
 		totalBlocks = lengthX * lengthY * lengthZ;
-		blocksPerTick = MathHelper.clamp(totalBlocks / 30, 1, 1024);
+		blocksPerTick = Mth.clamp(totalBlocks / 30, 1, 1024);
 		iterator = BlockUtils.getAllInBox(start, end).iterator();
 	}
 	
@@ -51,7 +50,7 @@ public final class ScanningAreaState extends TemplateToolState
 			BlockPos pos = iterator.next();
 			BlockState state = BlockUtils.getState(pos);
 			
-			if(!state.isReplaceable())
+			if(!state.canBeReplaced())
 				hack.getNonEmptyBlocks().put(pos, state);
 		}
 		
@@ -62,7 +61,7 @@ public final class ScanningAreaState extends TemplateToolState
 	}
 	
 	@Override
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		int black = 0x80000000;
@@ -72,8 +71,8 @@ public final class ScanningAreaState extends TemplateToolState
 		// Draw recently scanned blocks
 		LinkedHashMap<BlockPos, BlockState> blocks = hack.getNonEmptyBlocks();
 		int offset = Math.max(0, blocks.size() - blocksPerTick);
-		List<Box> boxes = blocks.keySet().stream().skip(offset)
-			.map(pos -> new Box(pos).expand(0.005)).toList();
+		List<AABB> boxes = blocks.keySet().stream().skip(offset)
+			.map(pos -> new AABB(pos).inflate(0.005)).toList();
 		
 		RenderUtils.drawOutlinedBoxes(matrixStack, boxes, black, true);
 		RenderUtils.drawSolidBoxes(matrixStack, boxes, green15, true);
@@ -81,9 +80,10 @@ public final class ScanningAreaState extends TemplateToolState
 		// Draw scanner
 		BlockPos start = hack.getStartPos();
 		BlockPos end = hack.getEndPos();
-		Box bounds = Box.enclosing(start, end).contract(1 / 16.0);
-		double scannerX = MathHelper.lerp(progress, bounds.minX, bounds.maxX);
-		Box scanner = bounds.withMinX(scannerX).withMaxX(scannerX);
+		AABB bounds =
+			AABB.encapsulatingFullBlocks(start, end).deflate(1 / 16.0);
+		double scannerX = Mth.lerp(progress, bounds.minX, bounds.maxX);
+		AABB scanner = bounds.setMinX(scannerX).setMaxX(scannerX);
 		
 		RenderUtils.drawOutlinedBox(matrixStack, scanner, black, true);
 		RenderUtils.drawSolidBox(matrixStack, scanner, green30, true);
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxEndState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxEndState.java
index f39decc9f..6e3d99ca2 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxEndState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxEndState.java
@@ -7,13 +7,12 @@
  */
 package net.wurstclient.hacks.templatetool.states;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.SelectPositionState;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
@@ -22,15 +21,15 @@ import net.wurstclient.util.RenderUtils;
 public final class SelectBoxEndState extends SelectPositionState
 {
 	@Override
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		super.onRender(hack, matrixStack, partialTicks);
 		
 		BlockPos start = hack.getStartPos();
 		BlockPos end = hack.getEndPos();
-		List<Box> selections = Stream.of(start, end).filter(Objects::nonNull)
-			.map(pos -> new Box(pos).contract(1 / 16.0)).toList();
+		List<AABB> selections = Stream.of(start, end).filter(Objects::nonNull)
+			.map(pos -> new AABB(pos).deflate(1 / 16.0)).toList();
 		
 		int black = 0x80000000;
 		int green15 = 0x2600FF00;
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxStartState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxStartState.java
index 03866f1d1..6aead9a1b 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxStartState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectBoxStartState.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks.templatetool.states;
 
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.SelectPositionState;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
@@ -18,7 +18,7 @@ import net.wurstclient.util.RenderUtils;
 public final class SelectBoxStartState extends SelectPositionState
 {
 	@Override
-	public void onRender(TemplateToolHack hack, MatrixStack matrixStack,
+	public void onRender(TemplateToolHack hack, PoseStack matrixStack,
 		float partialTicks)
 	{
 		super.onRender(hack, matrixStack, partialTicks);
@@ -27,7 +27,7 @@ public final class SelectBoxStartState extends SelectPositionState
 		if(start == null)
 			return;
 		
-		Box box = new Box(start).contract(1 / 16.0);
+		AABB box = new AABB(start).deflate(1 / 16.0);
 		int black = 0x80000000;
 		int green15 = 0x2600FF00;
 		RenderUtils.drawOutlinedBox(matrixStack, box, black, false);
diff --git a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectOriginState.java b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectOriginState.java
index 0e5a80e7c..95d8bf9b4 100644
--- a/src/main/java/net/wurstclient/hacks/templatetool/states/SelectOriginState.java
+++ b/src/main/java/net/wurstclient/hacks/templatetool/states/SelectOriginState.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hacks.templatetool.states;
 
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.hacks.TemplateToolHack;
 import net.wurstclient.hacks.templatetool.SelectPositionState;
 import net.wurstclient.hacks.templatetool.TemplateToolState;
diff --git a/src/main/java/net/wurstclient/hacks/treebot/Tree.java b/src/main/java/net/wurstclient/hacks/treebot/Tree.java
index 86944f666..ec3b2e155 100644
--- a/src/main/java/net/wurstclient/hacks/treebot/Tree.java
+++ b/src/main/java/net/wurstclient/hacks/treebot/Tree.java
@@ -7,12 +7,11 @@
  */
 package net.wurstclient.hacks.treebot;
 
+import com.mojang.blaze3d.vertex.PoseStack;
 import java.util.ArrayList;
 import java.util.List;
-
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.util.RenderUtils;
 
 public class Tree
@@ -26,15 +25,15 @@ public class Tree
 		this.logs = logs;
 	}
 	
-	public void draw(MatrixStack matrixStack)
+	public void draw(PoseStack matrixStack)
 	{
 		int green = 0x8000FF00;
-		Box box = new Box(BlockPos.ORIGIN).contract(1 / 16.0);
+		AABB box = new AABB(BlockPos.ZERO).deflate(1 / 16.0);
 		
-		Box stumpBox = box.offset(stump);
+		AABB stumpBox = box.move(stump);
 		RenderUtils.drawCrossBox(matrixStack, stumpBox, green, false);
 		
-		List<Box> logBoxes = logs.stream().map(pos -> box.offset(pos)).toList();
+		List<AABB> logBoxes = logs.stream().map(pos -> box.move(pos)).toList();
 		RenderUtils.drawOutlinedBoxes(matrixStack, logBoxes, green, false);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hacks/treebot/TreeBotUtils.java b/src/main/java/net/wurstclient/hacks/treebot/TreeBotUtils.java
index c2b847984..03249522b 100644
--- a/src/main/java/net/wurstclient/hacks/treebot/TreeBotUtils.java
+++ b/src/main/java/net/wurstclient/hacks/treebot/TreeBotUtils.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.hacks.treebot;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.registry.tag.BlockTags;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.util.BlockUtils;
 
 public enum TreeBotUtils
@@ -18,13 +18,12 @@ public enum TreeBotUtils
 	
 	public static boolean isLog(BlockPos pos)
 	{
-		return BlockUtils.getState(pos).isIn(BlockTags.LOGS);
+		return BlockUtils.getState(pos).is(BlockTags.LOGS);
 	}
 	
 	public static boolean isLeaves(BlockPos pos)
 	{
 		BlockState state = BlockUtils.getState(pos);
-		return state.isIn(BlockTags.LEAVES)
-			|| state.isIn(BlockTags.WART_BLOCKS);
+		return state.is(BlockTags.LEAVES) || state.is(BlockTags.WART_BLOCKS);
 	}
 }
diff --git a/src/main/java/net/wurstclient/hud/HackListHUD.java b/src/main/java/net/wurstclient/hud/HackListHUD.java
index af6727090..1635efc3b 100644
--- a/src/main/java/net/wurstclient/hud/HackListHUD.java
+++ b/src/main/java/net/wurstclient/hud/HackListHUD.java
@@ -11,10 +11,9 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
-
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.font.TextRenderer;
 import net.wurstclient.ui.UiScale;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.hack.Hack;
@@ -36,7 +35,7 @@ public final class HackListHUD implements UpdateListener
 		WurstClient.INSTANCE.getEventManager().add(UpdateListener.class, this);
 	}
 	
-	public void render(DrawContext context, float partialTicks)
+	public void render(GuiGraphics context, float partialTicks)
 	{
 		if(otf.getMode() == Mode.HIDDEN)
 			return;
@@ -50,7 +49,7 @@ public final class HackListHUD implements UpdateListener
 		int height = count == 0 ? 0
 			: count * lineHeight + Math.max(0, count - 1) * spacing;
 		
-		int baseY = isBottom ? context.getScaledWindowHeight() - height - 2 : 2;
+		int baseY = isBottom ? context.guiHeight() - height - 2 : 2;
 		// Avoid overlapping with Wurst Logo in top-left
 		boolean isLeft = (otf.getPosition() == Position.TOP_LEFT
 			|| otf.getPosition() == Position.BOTTOM_LEFT);
@@ -74,14 +73,13 @@ public final class HackListHUD implements UpdateListener
 		usePerHackColors = otf.useHackColors() && !rainbowUi;
 		
 		int totalHeight = height + posY;
-		if(otf.getMode() == Mode.COUNT
-			|| totalHeight > context.getScaledWindowHeight())
+		if(otf.getMode() == Mode.COUNT || totalHeight > context.guiHeight())
 			drawCounter(context);
 		else
 			drawHackList(context, partialTicks, lineHeight, spacing);
 	}
 	
-	private void drawCounter(DrawContext context)
+	private void drawCounter(GuiGraphics context)
 	{
 		long size = activeHax.stream().filter(e -> e.hack.isEnabled()).count();
 		String s = size + " hack" + (size != 1 ? "s" : "") + " active";
@@ -90,7 +88,7 @@ public final class HackListHUD implements UpdateListener
 			/* spacing */0);
 	}
 	
-	private void drawHackList(DrawContext context, float partialTicks,
+	private void drawHackList(GuiGraphics context, float partialTicks,
 		int lineHeight, int spacing)
 	{
 		if(otf.isAnimations())
@@ -150,22 +148,22 @@ public final class HackListHUD implements UpdateListener
 		}
 	}
 	
-	private void drawString(DrawContext context, String s, int lineHeight,
+	private void drawString(GuiGraphics context, String s, int lineHeight,
 		int spacing)
 	{
-		TextRenderer tr = WurstClient.MC.textRenderer;
+		Font tr = WurstClient.MC.font;
 		int posX;
 		int yDraw = posY + otf.getYOffset();
 		double scale = getScale() * otf.getFontSize();
 		// scaled string width
-		int stringWidth = (int)(tr.getWidth(s) * scale);
+		int stringWidth = (int)(tr.width(s) * scale);
 		boolean isLeft = (otf.getPosition() == Position.TOP_LEFT
 			|| otf.getPosition() == Position.BOTTOM_LEFT);
 		if(isLeft)
 			posX = 2 + otf.getXOffset();
 		else
 		{
-			int screenWidth = context.getScaledWindowWidth();
+			int screenWidth = context.guiWidth();
 			posX = screenWidth - stringWidth - 2 + otf.getXOffset();
 		}
 		int alpha = (int)(otf.getTransparency() * 255) << 24;
@@ -200,29 +198,29 @@ public final class HackListHUD implements UpdateListener
 			RenderUtils.drawScaledText(context, tr, s, shadowX, shadowY,
 				0x04000000 | alpha, false, scale);
 		}
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		RenderUtils.drawScaledText(context, tr, s, mainX, mainY,
 			(lineColor | alpha), false, scale);
 		
 		posY += lineHeight + spacing;
 	}
 	
-	private void drawString(DrawContext context, Hack hack, String s,
+	private void drawString(GuiGraphics context, Hack hack, String s,
 		int lineHeight, int spacing)
 	{
-		TextRenderer tr = WurstClient.MC.textRenderer;
+		Font tr = WurstClient.MC.font;
 		int posX;
 		int yDraw = posY + otf.getYOffset();
 		double scale = getScale() * otf.getFontSize();
 		// scaled string width
-		int stringWidth = (int)(tr.getWidth(s) * scale);
+		int stringWidth = (int)(tr.width(s) * scale);
 		boolean isLeft = (otf.getPosition() == Position.TOP_LEFT
 			|| otf.getPosition() == Position.BOTTOM_LEFT);
 		if(isLeft)
 			posX = 2 + otf.getXOffset();
 		else
 		{
-			int screenWidth = context.getScaledWindowWidth();
+			int screenWidth = context.guiWidth();
 			posX = screenWidth - stringWidth - 2 + otf.getXOffset();
 		}
 		int alpha = (int)(otf.getTransparency() * 255) << 24;
@@ -262,24 +260,24 @@ public final class HackListHUD implements UpdateListener
 			RenderUtils.drawScaledText(context, tr, s, shadowX, shadowY,
 				0x04000000 | alpha, false, scale);
 		}
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		RenderUtils.drawScaledText(context, tr, s, mainX, mainY,
 			(lineColor | alpha), false, scale);
 		
 		posY += lineHeight + spacing;
 	}
 	
-	private void drawWithOffset(DrawContext context, HackListEntry e,
+	private void drawWithOffset(GuiGraphics context, HackListEntry e,
 		float partialTicks, int lineHeight, int spacing)
 	{
-		TextRenderer tr = WurstClient.MC.textRenderer;
+		Font tr = WurstClient.MC.font;
 		String s = e.hack.getRenderName();
 		
 		float offset =
 			e.offset * partialTicks + e.prevOffset * (1 - partialTicks);
 		
 		double scale = getScale() * otf.getFontSize();
-		int stringWidth = (int)(tr.getWidth(s) * scale);
+		int stringWidth = (int)(tr.width(s) * scale);
 		
 		float posX;
 		boolean isLeft = (otf.getPosition() == Position.TOP_LEFT
@@ -288,7 +286,7 @@ public final class HackListHUD implements UpdateListener
 			posX = 2 - (int)(5 * offset * scale) + otf.getXOffset();
 		else
 		{
-			int screenWidth = context.getScaledWindowWidth();
+			int screenWidth = context.guiWidth();
 			posX = screenWidth - stringWidth - 2 + (int)(5 * offset * scale)
 				+ otf.getXOffset();
 		}
@@ -327,7 +325,7 @@ public final class HackListHUD implements UpdateListener
 			RenderUtils.drawScaledText(context, tr, s, shadowX2, shadowY2,
 				0x04000000 | alpha, false, scale);
 		}
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		RenderUtils.drawScaledText(context, tr, s, mainX2, mainY2,
 			(lineColor | alpha), false, scale);
 		
diff --git a/src/main/java/net/wurstclient/hud/IngameHUD.java b/src/main/java/net/wurstclient/hud/IngameHUD.java
index 6b914ca80..1f4aa6117 100644
--- a/src/main/java/net/wurstclient/hud/IngameHUD.java
+++ b/src/main/java/net/wurstclient/hud/IngameHUD.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.hud;
 
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.clickgui.screens.ClickGuiScreen;
@@ -20,7 +20,7 @@ public final class IngameHUD implements GUIRenderListener
 	private TabGui tabGui;
 	
 	@Override
-	public void onRenderGUI(DrawContext context, float partialTicks)
+	public void onRenderGUI(GuiGraphics context, float partialTicks)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
@@ -37,7 +37,7 @@ public final class IngameHUD implements GUIRenderListener
 		tabGui.render(context, partialTicks);
 		
 		// pinned windows
-		if(!(WurstClient.MC.currentScreen instanceof ClickGuiScreen))
+		if(!(WurstClient.MC.screen instanceof ClickGuiScreen))
 			clickGui.renderPinnedWindows(context, partialTicks);
 	}
 	
diff --git a/src/main/java/net/wurstclient/hud/TabGui.java b/src/main/java/net/wurstclient/hud/TabGui.java
index d14fd0f98..52997a0f9 100644
--- a/src/main/java/net/wurstclient/hud/TabGui.java
+++ b/src/main/java/net/wurstclient/hud/TabGui.java
@@ -12,10 +12,9 @@ import java.util.LinkedHashMap;
 
 import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.Category;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
@@ -29,7 +28,7 @@ import net.wurstclient.util.RenderUtils;
 public final class TabGui implements KeyPressListener
 {
 	private static final WurstClient WURST = WurstClient.INSTANCE;
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	private final ArrayList<Tab> tabs = new ArrayList<>();
 	private final TabGuiOtf tabGuiOtf =
@@ -67,7 +66,7 @@ public final class TabGui implements KeyPressListener
 		width = 64;
 		for(Tab tab : tabs)
 		{
-			int tabWidth = MC.textRenderer.getWidth(tab.name) + 10;
+			int tabWidth = MC.font.width(tab.name) + 10;
 			if(tabWidth > width)
 				width = tabWidth;
 		}
@@ -117,30 +116,30 @@ public final class TabGui implements KeyPressListener
 			}
 	}
 	
-	public void render(DrawContext context, float partialTicks)
+	public void render(GuiGraphics context, float partialTicks)
 	{
 		if(tabGuiOtf.isHidden())
 			return;
 		
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		matrixStack.pushMatrix();
 		matrixStack.translate(2, 23);
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		drawBox(context, 0, 0, width, height);
 		context.enableScissor(0, 0, width, height);
 		
 		int textY = 1;
 		int txtColor = WURST.getGui().getTxtColor();
-		TextRenderer tr = MC.textRenderer;
-		context.state.goUpLayer();
+		Font tr = MC.font;
+		context.guiRenderState.up();
 		for(int i = 0; i < tabs.size(); i++)
 		{
 			String tabName = tabs.get(i).name;
 			if(i == selected)
 				tabName = (tabOpened ? "<" : ">") + tabName;
 			
-			context.drawText(tr, tabName, 2, textY, txtColor, false);
+			context.drawString(tr, tabName, 2, textY, txtColor, false);
 			textY += 10;
 		}
 		
@@ -157,7 +156,7 @@ public final class TabGui implements KeyPressListener
 			context.enableScissor(0, 0, tab.width, tab.height);
 			
 			int tabTextY = 1;
-			context.state.goUpLayer();
+			context.guiRenderState.up();
 			for(int i = 0; i < tab.features.size(); i++)
 			{
 				Feature feature = tab.features.get(i);
@@ -169,7 +168,7 @@ public final class TabGui implements KeyPressListener
 				if(i == tab.selected)
 					fName = ">" + fName;
 				
-				context.drawText(tr, fName, 2, tabTextY, txtColor, false);
+				context.drawString(tr, fName, 2, tabTextY, txtColor, false);
 				tabTextY += 10;
 			}
 			
@@ -180,7 +179,7 @@ public final class TabGui implements KeyPressListener
 		matrixStack.popMatrix();
 	}
 	
-	private void drawBox(DrawContext context, int x1, int y1, int x2, int y2)
+	private void drawBox(GuiGraphics context, int x1, int y1, int x2, int y2)
 	{
 		ClickGui gui = WURST.getGui();
 		int bgColor =
@@ -209,7 +208,7 @@ public final class TabGui implements KeyPressListener
 			width = 64;
 			for(Feature feature : features)
 			{
-				int fWidth = MC.textRenderer.getWidth(feature.getName()) + 10;
+				int fWidth = MC.font.width(feature.getName()) + 10;
 				if(fWidth > width)
 					width = fWidth;
 			}
diff --git a/src/main/java/net/wurstclient/hud/WurstLogo.java b/src/main/java/net/wurstclient/hud/WurstLogo.java
index 049509ae1..eb0d83729 100644
--- a/src/main/java/net/wurstclient/hud/WurstLogo.java
+++ b/src/main/java/net/wurstclient/hud/WurstLogo.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.hud;
 
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
 import net.wurstclient.WurstClient;
 import net.wurstclient.other_features.WurstLogoOtf;
 import net.wurstclient.util.RenderUtils;
@@ -18,7 +18,7 @@ public final class WurstLogo
 {
 	private static final WurstClient WURST = WurstClient.INSTANCE;
 	
-	public void render(DrawContext context)
+	public void render(GuiGraphics context)
 	{
 		WurstLogoOtf otf = WURST.getOtfs().wurstLogoOtf;
 		if(!otf.isVisible())
@@ -26,11 +26,11 @@ public final class WurstLogo
 		
 		String version = getVersionString();
 		String brand = NiceWurstModule.getBrandLabel("Wurst 7 CevAPI");
-		TextRenderer tr = WurstClient.MC.textRenderer;
+		Font tr = WurstClient.MC.font;
 		
 		// Measure and layout
-		int brandWidth = tr.getWidth(brand);
-		int versionWidth = tr.getWidth(version);
+		int brandWidth = tr.width(brand);
+		int versionWidth = tr.width(version);
 		int leftPadding = 4;
 		int gap = 6;
 		int rightPadding = 8;
@@ -45,14 +45,14 @@ public final class WurstLogo
 			bgColor = otf.getBackgroundColor();
 		context.fill(0, 6, bgWidth, 17, bgColor);
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// brand and version strings
 		int textY = 8;
 		int brandX = leftPadding;
 		int versionX = brandX + brandWidth + gap;
-		context.drawText(tr, brand, brandX, textY, otf.getTextColor(), false);
-		context.drawText(tr, version, versionX, textY, otf.getTextColor(),
+		context.drawString(tr, brand, brandX, textY, otf.getTextColor(), false);
+		context.drawString(tr, version, versionX, textY, otf.getTextColor(),
 			false);
 	}
 	
diff --git a/src/main/java/net/wurstclient/keybinds/KeybindProcessor.java b/src/main/java/net/wurstclient/keybinds/KeybindProcessor.java
index f9ce49bf4..b9664c960 100644
--- a/src/main/java/net/wurstclient/keybinds/KeybindProcessor.java
+++ b/src/main/java/net/wurstclient/keybinds/KeybindProcessor.java
@@ -8,10 +8,9 @@
 package net.wurstclient.keybinds;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.util.InputUtil;
+import com.mojang.blaze3d.platform.InputConstants;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.screens.ClickGuiScreen;
 import net.wurstclient.command.CmdProcessor;
@@ -40,10 +39,11 @@ public final class KeybindProcessor implements KeyPressListener
 		if(event.getAction() != GLFW.GLFW_PRESS)
 			return;
 		
-		if(InputUtil.isKeyPressed(WurstClient.MC.getWindow(), GLFW.GLFW_KEY_F3))
+		if(InputConstants.isKeyDown(WurstClient.MC.getWindow(),
+			GLFW.GLFW_KEY_F3))
 			return;
 		
-		Screen screen = WurstClient.MC.currentScreen;
+		Screen screen = WurstClient.MC.screen;
 		if(screen != null && !(screen instanceof ClickGuiScreen))
 			return;
 			
@@ -97,9 +97,9 @@ public final class KeybindProcessor implements KeyPressListener
 	{
 		int keyCode = event.getKeyCode();
 		int scanCode = event.getScanCode();
-		return InputUtil
-			.fromKeyCode(new KeyInput(keyCode, scanCode, event.getModifiers()))
-			.getTranslationKey();
+		return InputConstants
+			.getKey(new KeyEvent(keyCode, scanCode, event.getModifiers()))
+			.getName();
 	}
 	
 	private void processCmds(String cmds)
diff --git a/src/main/java/net/wurstclient/keybinds/KeybindsFile.java b/src/main/java/net/wurstclient/keybinds/KeybindsFile.java
index 2c7fbf359..a8e048409 100644
--- a/src/main/java/net/wurstclient/keybinds/KeybindsFile.java
+++ b/src/main/java/net/wurstclient/keybinds/KeybindsFile.java
@@ -16,8 +16,7 @@ import java.util.Map.Entry;
 import java.util.Set;
 
 import com.google.gson.JsonObject;
-
-import net.minecraft.client.util.InputUtil;
+import com.mojang.blaze3d.platform.InputConstants;
 import net.wurstclient.util.json.JsonException;
 import net.wurstclient.util.json.JsonUtils;
 import net.wurstclient.util.json.WsonObject;
@@ -87,7 +86,7 @@ public final class KeybindsFile
 	{
 		try
 		{
-			InputUtil.fromTranslationKey(key);
+			InputConstants.getKey(key);
 			return true;
 			
 		}catch(IllegalArgumentException e)
diff --git a/src/main/java/net/wurstclient/locator/LocatorBarMixin.java b/src/main/java/net/wurstclient/locator/LocatorBarMixin.java
index cde57823d..817dcd309 100644
--- a/src/main/java/net/wurstclient/locator/LocatorBarMixin.java
+++ b/src/main/java/net/wurstclient/locator/LocatorBarMixin.java
@@ -12,7 +12,9 @@ import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
-
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.contextualbar.LocatorBarRenderer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.spongepowered.asm.mixin.Mixin;
@@ -20,11 +22,7 @@ import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.render.RenderTickCounter;
-import net.minecraft.client.gui.hud.bar.LocatorBar;
-
-@Mixin(value = LocatorBar.class)
+@Mixin(value = LocatorBarRenderer.class)
 public class LocatorBarMixin
 {
 	private static final Logger LOGGER =
@@ -35,9 +33,9 @@ public class LocatorBarMixin
 	// Inject after vanilla finishes rendering addons to snapshot entries for
 	// this frame
 	@Inject(
-		method = "renderAddons(Lnet/minecraft/client/gui/DrawContext;Lnet/minecraft/client/render/RenderTickCounter;)V",
+		method = "render(Lnet/minecraft/client/gui/GuiGraphics;Lnet/minecraft/client/DeltaTracker;)V",
 		at = @At("TAIL"))
-	private void onRenderAddons(DrawContext ctx, RenderTickCounter rtc,
+	private void onRenderAddons(GuiGraphics ctx, DeltaTracker rtc,
 		CallbackInfo ci)
 	{
 		// Log once to confirm mixin was executed in-game
@@ -251,10 +249,9 @@ public class LocatorBarMixin
 	
 	// Also hook the main bar render as a fallback point each frame
 	@Inject(
-		method = "renderBar(Lnet/minecraft/client/gui/DrawContext;Lnet/minecraft/client/render/RenderTickCounter;)V",
+		method = "renderBackground(Lnet/minecraft/client/gui/GuiGraphics;Lnet/minecraft/client/DeltaTracker;)V",
 		at = @At("TAIL"))
-	private void onRenderBar(DrawContext ctx, RenderTickCounter rtc,
-		CallbackInfo ci)
+	private void onRenderBar(GuiGraphics ctx, DeltaTracker rtc, CallbackInfo ci)
 	{
 		// Keep data store from going stale until we map exact fields
 		// LocatorDataStore may not be present in this build; guard usage
diff --git a/src/main/java/net/wurstclient/mixin/AbstractBlockStateMixin.java b/src/main/java/net/wurstclient/mixin/AbstractBlockStateMixin.java
index 74b8818cd..30eb83ab5 100644
--- a/src/main/java/net/wurstclient/mixin/AbstractBlockStateMixin.java
+++ b/src/main/java/net/wurstclient/mixin/AbstractBlockStateMixin.java
@@ -16,17 +16,17 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 import com.mojang.serialization.MapCodec;
 
 import it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap;
-import net.minecraft.block.AbstractBlock.AbstractBlockState;
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.ShapeContext;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.state.State;
-import net.minecraft.state.property.Property;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.shape.VoxelShape;
-import net.minecraft.util.shape.VoxelShapes;
-import net.minecraft.world.BlockView;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockBehaviour.BlockStateBase;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateHolder;
+import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.material.FluidState;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.GetAmbientOcclusionLightLevelListener.GetAmbientOcclusionLightLevelEvent;
@@ -34,8 +34,9 @@ import net.wurstclient.events.IsNormalCubeListener.IsNormalCubeEvent;
 import net.wurstclient.hack.HackList;
 import net.wurstclient.hacks.HandNoClipHack;
 
-@Mixin(AbstractBlockState.class)
-public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
+@Mixin(BlockStateBase.class)
+public abstract class AbstractBlockStateMixin
+	extends StateHolder<Block, BlockState>
 {
 	private AbstractBlockStateMixin(WurstClient wurst, Block owner,
 		Reference2ObjectArrayMap<Property<?>, Comparable<?>> propertyMap,
@@ -45,9 +46,9 @@ public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "isFullCube(Lnet/minecraft/world/BlockView;Lnet/minecraft/util/math/BlockPos;)Z",
+		method = "isCollisionShapeFullBlock(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;)Z",
 		cancellable = true)
-	private void onIsFullCube(BlockView world, BlockPos pos,
+	private void onIsFullCube(BlockGetter world, BlockPos pos,
 		CallbackInfoReturnable<Boolean> cir)
 	{
 		IsNormalCubeEvent event = new IsNormalCubeEvent();
@@ -57,9 +58,9 @@ public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "getAmbientOcclusionLightLevel(Lnet/minecraft/world/BlockView;Lnet/minecraft/util/math/BlockPos;)F",
+		method = "getShadeBrightness(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;)F",
 		cancellable = true)
-	private void onGetAmbientOcclusionLightLevel(BlockView blockView,
+	private void onGetAmbientOcclusionLightLevel(BlockGetter blockView,
 		BlockPos blockPos, CallbackInfoReturnable<Float> cir)
 	{
 		GetAmbientOcclusionLightLevelEvent event =
@@ -71,12 +72,12 @@ public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getOutlineShape(Lnet/minecraft/world/BlockView;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/ShapeContext;)Lnet/minecraft/util/shape/VoxelShape;",
+		method = "getShape(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/phys/shapes/CollisionContext;)Lnet/minecraft/world/phys/shapes/VoxelShape;",
 		cancellable = true)
-	private void onGetOutlineShape(BlockView view, BlockPos pos,
-		ShapeContext context, CallbackInfoReturnable<VoxelShape> cir)
+	private void onGetOutlineShape(BlockGetter view, BlockPos pos,
+		CollisionContext context, CallbackInfoReturnable<VoxelShape> cir)
 	{
-		if(context == ShapeContext.absent())
+		if(context == CollisionContext.empty())
 			return;
 		
 		HackList hax = WurstClient.INSTANCE.getHax();
@@ -87,14 +88,14 @@ public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
 		if(!handNoClipHack.isEnabled() || handNoClipHack.isBlockInList(pos))
 			return;
 		
-		cir.setReturnValue(VoxelShapes.empty());
+		cir.setReturnValue(Shapes.empty());
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getCollisionShape(Lnet/minecraft/world/BlockView;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/ShapeContext;)Lnet/minecraft/util/shape/VoxelShape;",
+		method = "getCollisionShape(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/phys/shapes/CollisionContext;)Lnet/minecraft/world/phys/shapes/VoxelShape;",
 		cancellable = true)
-	private void onGetCollisionShape(BlockView world, BlockPos pos,
-		ShapeContext context, CallbackInfoReturnable<VoxelShape> cir)
+	private void onGetCollisionShape(BlockGetter world, BlockPos pos,
+		CollisionContext context, CallbackInfoReturnable<VoxelShape> cir)
 	{
 		if(getFluidState().isEmpty())
 			return;
@@ -103,7 +104,7 @@ public abstract class AbstractBlockStateMixin extends State<Block, BlockState>
 		if(hax == null || !hax.jesusHack.shouldBeSolid())
 			return;
 		
-		cir.setReturnValue(VoxelShapes.fullCube());
+		cir.setReturnValue(Shapes.block());
 		cir.cancel();
 	}
 	
diff --git a/src/main/java/net/wurstclient/mixin/AbstractSignEditScreenMixin.java b/src/main/java/net/wurstclient/mixin/AbstractSignEditScreenMixin.java
index 2b578a3d9..790ebfb8c 100644
--- a/src/main/java/net/wurstclient/mixin/AbstractSignEditScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/AbstractSignEditScreenMixin.java
@@ -13,10 +13,9 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.ingame.AbstractSignEditScreen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.inventory.AbstractSignEditScreen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoSignHack;
 
@@ -27,7 +26,7 @@ public abstract class AbstractSignEditScreenMixin extends Screen
 	@Final
 	private String[] messages;
 	
-	private AbstractSignEditScreenMixin(WurstClient wurst, Text title)
+	private AbstractSignEditScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -44,17 +43,17 @@ public abstract class AbstractSignEditScreenMixin extends Screen
 		for(int i = 0; i < 4; i++)
 			messages[i] = autoSignText[i];
 		
-		finishEditing();
+		onDone();
 	}
 	
-	@Inject(at = @At("HEAD"), method = "finishEditing()V")
+	@Inject(at = @At("HEAD"), method = "onDone()V")
 	private void onFinishEditing(CallbackInfo ci)
 	{
 		WurstClient.INSTANCE.getHax().autoSignHack.setSignText(messages);
 	}
 	
 	@Shadow
-	private void finishEditing()
+	private void onDone()
 	{
 		
 	}
diff --git a/src/main/java/net/wurstclient/mixin/AllowedAddressResolverMixin.java b/src/main/java/net/wurstclient/mixin/AllowedAddressResolverMixin.java
index 7e721052e..6b3e90af7 100644
--- a/src/main/java/net/wurstclient/mixin/AllowedAddressResolverMixin.java
+++ b/src/main/java/net/wurstclient/mixin/AllowedAddressResolverMixin.java
@@ -15,24 +15,23 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.network.Address;
-import net.minecraft.client.network.AddressResolver;
-import net.minecraft.client.network.AllowedAddressResolver;
-import net.minecraft.client.network.RedirectResolver;
-import net.minecraft.client.network.ServerAddress;
+import net.minecraft.client.multiplayer.resolver.ResolvedServerAddress;
+import net.minecraft.client.multiplayer.resolver.ServerAddress;
+import net.minecraft.client.multiplayer.resolver.ServerAddressResolver;
+import net.minecraft.client.multiplayer.resolver.ServerNameResolver;
+import net.minecraft.client.multiplayer.resolver.ServerRedirectHandler;
 import net.wurstclient.WurstClient;
 
-@Mixin(AllowedAddressResolver.class)
+@Mixin(ServerNameResolver.class)
 public class AllowedAddressResolverMixin
 {
 	@Shadow
 	@Final
-	private AddressResolver addressResolver;
+	private ServerAddressResolver resolver;
 	
 	@Shadow
 	@Final
-	private RedirectResolver redirectResolver;
+	private ServerRedirectHandler redirectHandler;
 	
 	/**
 	 * This mixin allows users to connect to servers that have been shadowbanned
@@ -40,20 +39,21 @@ public class AllowedAddressResolverMixin
 	 * adult-oriented" for having pixelated guns.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "resolve(Lnet/minecraft/client/network/ServerAddress;)Ljava/util/Optional;",
+		method = "resolveAddress(Lnet/minecraft/client/multiplayer/resolver/ServerAddress;)Ljava/util/Optional;",
 		cancellable = true)
 	public void resolve(ServerAddress address,
-		CallbackInfoReturnable<Optional<Address>> cir)
+		CallbackInfoReturnable<Optional<ResolvedServerAddress>> cir)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		Optional<Address> optionalAddress = addressResolver.resolve(address);
+		Optional<ResolvedServerAddress> optionalAddress =
+			resolver.resolve(address);
 		Optional<ServerAddress> optionalRedirect =
-			redirectResolver.lookupRedirect(address);
+			redirectHandler.lookupRedirect(address);
 		
 		if(optionalRedirect.isPresent())
-			optionalAddress = addressResolver.resolve(optionalRedirect.get());
+			optionalAddress = resolver.resolve(optionalRedirect.get());
 		
 		cir.setReturnValue(optionalAddress);
 	}
diff --git a/src/main/java/net/wurstclient/mixin/AtmosphericFogModifierMixin.java b/src/main/java/net/wurstclient/mixin/AtmosphericFogModifierMixin.java
index 0aefa6c73..f18c2e7bb 100644
--- a/src/main/java/net/wurstclient/mixin/AtmosphericFogModifierMixin.java
+++ b/src/main/java/net/wurstclient/mixin/AtmosphericFogModifierMixin.java
@@ -11,28 +11,25 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.render.RenderTickCounter;
-import net.minecraft.client.render.fog.AtmosphericFogModifier;
-import net.minecraft.client.render.fog.FogData;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.renderer.fog.FogData;
+import net.minecraft.client.renderer.fog.environment.AtmosphericFogEnvironment;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.WurstClient;
 
-@Mixin(AtmosphericFogModifier.class)
+@Mixin(AtmosphericFogEnvironment.class)
 public class AtmosphericFogModifierMixin
 {
 	/**
 	 * Removes the foggy overlay in the Overworld (including rain fog), if
 	 * NoFog is enabled.
 	 */
-	@Inject(method = "applyStartEndModifier",
-		at = @At("TAIL"),
-		cancellable = true)
+	@Inject(method = "setupFog", at = @At("TAIL"), cancellable = true)
 	private void onApplyStartEndModifier(FogData data, Entity cameraEntity,
-		BlockPos cameraPos, ClientWorld world, float viewDistance,
-		RenderTickCounter tickCounter, CallbackInfo ci)
+		BlockPos cameraPos, ClientLevel world, float viewDistance,
+		DeltaTracker tickCounter, CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.getHax().noFogHack.isEnabled())
 			return;
diff --git a/src/main/java/net/wurstclient/mixin/BlockEntityRenderDispatcherMixin.java b/src/main/java/net/wurstclient/mixin/BlockEntityRenderDispatcherMixin.java
index 69bb15e6a..0d349d9ea 100644
--- a/src/main/java/net/wurstclient/mixin/BlockEntityRenderDispatcherMixin.java
+++ b/src/main/java/net/wurstclient/mixin/BlockEntityRenderDispatcherMixin.java
@@ -11,23 +11,22 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.render.block.entity.BlockEntityRenderManager;
-import net.minecraft.client.render.block.entity.state.BlockEntityRenderState;
-import net.minecraft.client.render.command.OrderedRenderCommandQueue;
-import net.minecraft.client.render.state.CameraRenderState;
-import net.minecraft.client.util.math.MatrixStack;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.renderer.SubmitNodeCollector;
+import net.minecraft.client.renderer.blockentity.BlockEntityRenderDispatcher;
+import net.minecraft.client.renderer.blockentity.state.BlockEntityRenderState;
+import net.minecraft.client.renderer.state.CameraRenderState;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.RenderBlockEntityListener.RenderBlockEntityEvent;
 
-@Mixin(BlockEntityRenderManager.class)
+@Mixin(BlockEntityRenderDispatcher.class)
 public class BlockEntityRenderDispatcherMixin
 {
 	@Inject(at = @At("HEAD"),
-		method = "render(Lnet/minecraft/client/render/block/entity/state/BlockEntityRenderState;Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/command/OrderedRenderCommandQueue;Lnet/minecraft/client/render/state/CameraRenderState;)V",
+		method = "submit(Lnet/minecraft/client/renderer/blockentity/state/BlockEntityRenderState;Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/SubmitNodeCollector;Lnet/minecraft/client/renderer/state/CameraRenderState;)V",
 		cancellable = true)
 	private <S extends BlockEntityRenderState> void onRenderRenderState(
-		S renderState, MatrixStack matrices, OrderedRenderCommandQueue queue,
+		S renderState, PoseStack matrices, SubmitNodeCollector queue,
 		CameraRenderState cameraRenderState, CallbackInfo ci)
 	{
 		RenderBlockEntityEvent event = new RenderBlockEntityEvent(renderState);
diff --git a/src/main/java/net/wurstclient/mixin/BlockMixin.java b/src/main/java/net/wurstclient/mixin/BlockMixin.java
index 6bfe9935e..8fc3adfd5 100644
--- a/src/main/java/net/wurstclient/mixin/BlockMixin.java
+++ b/src/main/java/net/wurstclient/mixin/BlockMixin.java
@@ -11,18 +11,15 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.Block;
-import net.minecraft.item.ItemConvertible;
+import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hack.HackList;
 
 @Mixin(Block.class)
-public abstract class BlockMixin implements ItemConvertible
+public abstract class BlockMixin implements ItemLike
 {
-	@Inject(at = @At("HEAD"),
-		method = "getVelocityMultiplier()F",
-		cancellable = true)
+	@Inject(at = @At("HEAD"), method = "getSpeedFactor()F", cancellable = true)
 	private void onGetVelocityMultiplier(CallbackInfoReturnable<Float> cir)
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
diff --git a/src/main/java/net/wurstclient/mixin/BlockModelRendererMixin.java b/src/main/java/net/wurstclient/mixin/BlockModelRendererMixin.java
index 6f4fabd3a..8b01a38a9 100644
--- a/src/main/java/net/wurstclient/mixin/BlockModelRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/BlockModelRendererMixin.java
@@ -14,13 +14,12 @@ import org.spongepowered.asm.mixin.injection.ModifyConstant;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.render.block.BlockModelRenderer;
-import net.minecraft.item.ItemConvertible;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.world.BlockRenderView;
+import net.minecraft.client.renderer.block.ModelBlockRenderer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.BlockAndTintGetter;
+import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ShouldDrawSideListener.ShouldDrawSideEvent;
@@ -28,8 +27,8 @@ import net.wurstclient.hacks.SurfaceXrayHack;
 import net.wurstclient.hacks.SurfaceXrayHack.SurfaceState;
 import net.wurstclient.hacks.XRayHack;
 
-@Mixin(BlockModelRenderer.class)
-public abstract class BlockModelRendererMixin implements ItemConvertible
+@Mixin(ModelBlockRenderer.class)
+public abstract class BlockModelRendererMixin implements ItemLike
 {
 	private static ThreadLocal<Float> currentOpacity =
 		ThreadLocal.withInitial(() -> 1F);
@@ -40,11 +39,11 @@ public abstract class BlockModelRendererMixin implements ItemConvertible
 	 * seeing a piston retract.
 	 */
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/block/Block;shouldDrawSide(Lnet/minecraft/block/BlockState;Lnet/minecraft/block/BlockState;Lnet/minecraft/util/math/Direction;)Z"),
-		method = "shouldDrawFace(Lnet/minecraft/world/BlockRenderView;Lnet/minecraft/block/BlockState;ZLnet/minecraft/util/math/Direction;Lnet/minecraft/util/math/BlockPos;)Z")
+		target = "Lnet/minecraft/world/level/block/Block;shouldRenderFace(Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/core/Direction;)Z"),
+		method = "shouldRenderFace(Lnet/minecraft/world/level/BlockAndTintGetter;Lnet/minecraft/world/level/block/state/BlockState;ZLnet/minecraft/core/Direction;Lnet/minecraft/core/BlockPos;)Z")
 	private static boolean onRenderSmoothOrFlat(BlockState state,
 		BlockState otherState, Direction side, Operation<Boolean> original,
-		BlockRenderView world, BlockState stateButFromTheOtherMethod,
+		BlockAndTintGetter world, BlockState stateButFromTheOtherMethod,
 		boolean cull, Direction sideButFromTheOtherMethod, BlockPos pos)
 	{
 		ShouldDrawSideEvent event = new ShouldDrawSideEvent(state, pos);
@@ -80,7 +79,7 @@ public abstract class BlockModelRendererMixin implements ItemConvertible
 	 * coloring and shading is done, if neither Sodium nor Indigo are running.
 	 */
 	@ModifyConstant(
-		method = "renderQuad(Lnet/minecraft/world/BlockRenderView;Lnet/minecraft/block/BlockState;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/client/render/VertexConsumer;Lnet/minecraft/client/util/math/MatrixStack$Entry;Lnet/minecraft/client/render/model/BakedQuad;Lnet/minecraft/client/render/block/BlockModelRenderer$LightmapCache;I)V",
+		method = "putQuadData(Lnet/minecraft/world/level/BlockAndTintGetter;Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/core/BlockPos;Lcom/mojang/blaze3d/vertex/VertexConsumer;Lcom/mojang/blaze3d/vertex/PoseStack$Pose;Lnet/minecraft/client/renderer/block/model/BakedQuad;Lnet/minecraft/client/renderer/block/ModelBlockRenderer$CommonRenderStorage;I)V",
 		constant = @Constant(floatValue = 1F))
 	private float modifyOpacity(float original)
 	{
diff --git a/src/main/java/net/wurstclient/mixin/CactusBlockMixin.java b/src/main/java/net/wurstclient/mixin/CactusBlockMixin.java
index 22de467ca..484a09977 100644
--- a/src/main/java/net/wurstclient/mixin/CactusBlockMixin.java
+++ b/src/main/java/net/wurstclient/mixin/CactusBlockMixin.java
@@ -11,14 +11,13 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.CactusBlock;
-import net.minecraft.block.ShapeContext;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.shape.VoxelShape;
-import net.minecraft.world.BlockView;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.CactusBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.CactusCollisionShapeListener.CactusCollisionShapeEvent;
@@ -26,16 +25,16 @@ import net.wurstclient.events.CactusCollisionShapeListener.CactusCollisionShapeE
 @Mixin(CactusBlock.class)
 public abstract class CactusBlockMixin extends Block
 {
-	private CactusBlockMixin(WurstClient wurst, Settings settings)
+	private CactusBlockMixin(WurstClient wurst, Properties settings)
 	{
 		super(settings);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getCollisionShape(Lnet/minecraft/block/BlockState;Lnet/minecraft/world/BlockView;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/ShapeContext;)Lnet/minecraft/util/shape/VoxelShape;",
+		method = "getCollisionShape(Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/phys/shapes/CollisionContext;)Lnet/minecraft/world/phys/shapes/VoxelShape;",
 		cancellable = true)
-	private void onGetCollisionShape(BlockState state, BlockView world,
-		BlockPos pos, ShapeContext context,
+	private void onGetCollisionShape(BlockState state, BlockGetter world,
+		BlockPos pos, CollisionContext context,
 		CallbackInfoReturnable<VoxelShape> cir)
 	{
 		CactusCollisionShapeEvent event = new CactusCollisionShapeEvent();
diff --git a/src/main/java/net/wurstclient/mixin/CameraMixin.java b/src/main/java/net/wurstclient/mixin/CameraMixin.java
index 7d0dd2edf..e6d928706 100644
--- a/src/main/java/net/wurstclient/mixin/CameraMixin.java
+++ b/src/main/java/net/wurstclient/mixin/CameraMixin.java
@@ -12,9 +12,8 @@ import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.ModifyVariable;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.enums.CameraSubmersionType;
-import net.minecraft.client.render.Camera;
+import net.minecraft.client.Camera;
+import net.minecraft.world.level.material.FogType;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.CameraDistanceHack;
 
@@ -22,7 +21,7 @@ import net.wurstclient.hacks.CameraDistanceHack;
 public abstract class CameraMixin
 {
 	@ModifyVariable(at = @At("HEAD"),
-		method = "clipToSpace(F)F",
+		method = "getMaxZoom(F)F",
 		argsOnly = true)
 	private float changeClipToSpaceDistance(float desiredCameraDistance)
 	{
@@ -34,7 +33,7 @@ public abstract class CameraMixin
 		return desiredCameraDistance;
 	}
 	
-	@Inject(at = @At("HEAD"), method = "clipToSpace(F)F", cancellable = true)
+	@Inject(at = @At("HEAD"), method = "getMaxZoom(F)F", cancellable = true)
 	private void onClipToSpace(float desiredCameraDistance,
 		CallbackInfoReturnable<Float> cir)
 	{
@@ -43,12 +42,11 @@ public abstract class CameraMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getSubmersionType()Lnet/minecraft/block/enums/CameraSubmersionType;",
+		method = "getFluidInCamera()Lnet/minecraft/world/level/material/FogType;",
 		cancellable = true)
-	private void onGetSubmersionType(
-		CallbackInfoReturnable<CameraSubmersionType> cir)
+	private void onGetSubmersionType(CallbackInfoReturnable<FogType> cir)
 	{
 		if(WurstClient.INSTANCE.getHax().noOverlayHack.isEnabled())
-			cir.setReturnValue(CameraSubmersionType.NONE);
+			cir.setReturnValue(FogType.NONE);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/ChatHudMixin.java b/src/main/java/net/wurstclient/mixin/ChatHudMixin.java
index 540e48759..6f895dcc8 100644
--- a/src/main/java/net/wurstclient/mixin/ChatHudMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ChatHudMixin.java
@@ -19,34 +19,33 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import com.llamalad7.mixinextras.sugar.Local;
 import com.llamalad7.mixinextras.sugar.ref.LocalRef;
-
-import net.minecraft.client.gui.hud.ChatHud;
-import net.minecraft.client.gui.hud.ChatHudLine;
-import net.minecraft.client.gui.hud.MessageIndicator;
-import net.minecraft.network.message.MessageSignatureData;
-import net.minecraft.text.Text;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.client.GuiMessageTag;
+import net.minecraft.client.gui.components.ChatComponent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MessageSignature;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ChatInputListener.ChatInputEvent;
 
-@Mixin(ChatHud.class)
+@Mixin(ChatComponent.class)
 public class ChatHudMixin
 {
 	@Shadow
 	@Final
-	private List<ChatHudLine.Visible> visibleMessages;
+	private List<GuiMessage.Line> trimmedMessages;
 	
 	@Inject(at = @At("HEAD"),
-		method = "addMessage(Lnet/minecraft/text/Text;Lnet/minecraft/network/message/MessageSignatureData;Lnet/minecraft/client/gui/hud/MessageIndicator;)V",
+		method = "addMessage(Lnet/minecraft/network/chat/Component;Lnet/minecraft/network/chat/MessageSignature;Lnet/minecraft/client/GuiMessageTag;)V",
 		cancellable = true)
-	private void onAddMessage(Text messageDontUse,
-		@Nullable MessageSignatureData signature,
-		@Nullable MessageIndicator indicatorDontUse, CallbackInfo ci,
-		@Local(argsOnly = true) LocalRef<Text> message,
-		@Local(argsOnly = true) LocalRef<MessageIndicator> indicator)
+	private void onAddMessage(Component messageDontUse,
+		@Nullable MessageSignature signature,
+		@Nullable GuiMessageTag indicatorDontUse, CallbackInfo ci,
+		@Local(argsOnly = true) LocalRef<Component> message,
+		@Local(argsOnly = true) LocalRef<GuiMessageTag> indicator)
 	{
 		ChatInputEvent event =
-			new ChatInputEvent(message.get(), visibleMessages);
+			new ChatInputEvent(message.get(), trimmedMessages);
 		
 		EventManager.fire(event);
 		if(event.isCancelled())
diff --git a/src/main/java/net/wurstclient/mixin/ChatInputSuggestorMixin.java b/src/main/java/net/wurstclient/mixin/ChatInputSuggestorMixin.java
index 0b3d95841..281716ad0 100644
--- a/src/main/java/net/wurstclient/mixin/ChatInputSuggestorMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ChatInputSuggestorMixin.java
@@ -17,22 +17,21 @@ import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import com.mojang.brigadier.suggestion.Suggestions;
-
-import net.minecraft.client.gui.screen.ChatInputSuggestor;
-import net.minecraft.client.gui.widget.TextFieldWidget;
+import net.minecraft.client.gui.components.CommandSuggestions;
+import net.minecraft.client.gui.components.EditBox;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoCompleteHack;
 
-@Mixin(ChatInputSuggestor.class)
+@Mixin(CommandSuggestions.class)
 public abstract class ChatInputSuggestorMixin
 {
 	@Shadow
 	@Final
-	private TextFieldWidget textField;
+	private EditBox input;
 	@Shadow
 	private CompletableFuture<Suggestions> pendingSuggestions;
 	
-	@Inject(at = @At("TAIL"), method = "refresh()V")
+	@Inject(at = @At("TAIL"), method = "updateCommandInfo()V")
 	private void onRefresh(CallbackInfo ci)
 	{
 		AutoCompleteHack autoComplete =
@@ -41,14 +40,14 @@ public abstract class ChatInputSuggestorMixin
 			return;
 		
 		String draftMessage =
-			textField.getText().substring(0, textField.getCursor());
+			input.getValue().substring(0, input.getCursorPosition());
 		autoComplete.onRefresh(draftMessage, (builder, suggestion) -> {
-			textField.setSuggestion(suggestion);
+			input.setSuggestion(suggestion);
 			pendingSuggestions = builder.buildFuture();
-			show(false);
+			showSuggestions(false);
 		});
 	}
 	
 	@Shadow
-	public abstract void show(boolean narrateFirstSuggestion);
+	public abstract void showSuggestions(boolean narrateFirstSuggestion);
 }
diff --git a/src/main/java/net/wurstclient/mixin/ChatScreenMixin.java b/src/main/java/net/wurstclient/mixin/ChatScreenMixin.java
index d7ef5acd0..3c25409ee 100644
--- a/src/main/java/net/wurstclient/mixin/ChatScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ChatScreenMixin.java
@@ -12,11 +12,10 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.ChatScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.ChatScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ChatOutputListener.ChatOutputEvent;
@@ -25,9 +24,9 @@ import net.wurstclient.events.ChatOutputListener.ChatOutputEvent;
 public abstract class ChatScreenMixin extends Screen
 {
 	@Shadow
-	protected TextFieldWidget chatField;
+	protected EditBox input;
 	
-	private ChatScreenMixin(WurstClient wurst, Text title)
+	private ChatScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -36,17 +35,17 @@ public abstract class ChatScreenMixin extends Screen
 	protected void onInit(CallbackInfo ci)
 	{
 		if(WurstClient.INSTANCE.getHax().infiniChatHack.isEnabled())
-			chatField.setMaxLength(Integer.MAX_VALUE);
+			input.setMaxLength(Integer.MAX_VALUE);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "sendMessage(Ljava/lang/String;Z)V",
+		method = "handleChatInput(Ljava/lang/String;Z)V",
 		cancellable = true)
 	public void onSendMessage(String message, boolean addToHistory,
 		CallbackInfo ci)
 	{
 		// Ignore empty messages just like vanilla
-		if((message = normalize(message)).isEmpty())
+		if((message = normalizeChatMessage(message)).isEmpty())
 			return;
 		
 		// Create and fire the chat output event
@@ -66,17 +65,17 @@ public abstract class ChatScreenMixin extends Screen
 		// Otherwise the up/down arrows won't work correctly
 		String newMessage = event.getMessage();
 		if(addToHistory)
-			client.inGameHud.getChatHud().addToMessageHistory(newMessage);
+			minecraft.gui.getChat().addRecentChat(newMessage);
 		
 		// If the event isn't cancelled, send the modified message
 		if(!cancelled)
 			if(newMessage.startsWith("/"))
-				client.player.networkHandler
-					.sendChatCommand(newMessage.substring(1));
+				minecraft.player.connection
+					.sendCommand(newMessage.substring(1));
 			else
-				client.player.networkHandler.sendChatMessage(newMessage);
+				minecraft.player.connection.sendChat(newMessage);
 	}
 	
 	@Shadow
-	public abstract String normalize(String chatText);
+	public abstract String normalizeChatMessage(String chatText);
 }
diff --git a/src/main/java/net/wurstclient/mixin/ChunkOcclusionGraphBuilderMixin.java b/src/main/java/net/wurstclient/mixin/ChunkOcclusionGraphBuilderMixin.java
index 192387602..ecffcab70 100644
--- a/src/main/java/net/wurstclient/mixin/ChunkOcclusionGraphBuilderMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ChunkOcclusionGraphBuilderMixin.java
@@ -11,17 +11,16 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.render.chunk.ChunkOcclusionDataBuilder;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.renderer.chunk.VisGraph;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.SetOpaqueCubeListener.SetOpaqueCubeEvent;
 
-@Mixin(ChunkOcclusionDataBuilder.class)
+@Mixin(VisGraph.class)
 public class ChunkOcclusionGraphBuilderMixin
 {
 	@Inject(at = @At("HEAD"),
-		method = "markClosed(Lnet/minecraft/util/math/BlockPos;)V",
+		method = "setOpaque(Lnet/minecraft/core/BlockPos;)V",
 		cancellable = true)
 	private void onMarkClosed(BlockPos pos, CallbackInfo ci)
 	{
diff --git a/src/main/java/net/wurstclient/mixin/ClientCommonNetworkHandlerMixin.java b/src/main/java/net/wurstclient/mixin/ClientCommonNetworkHandlerMixin.java
index f7340549d..3a908f1d4 100644
--- a/src/main/java/net/wurstclient/mixin/ClientCommonNetworkHandlerMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientCommonNetworkHandlerMixin.java
@@ -15,32 +15,31 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientCommonNetworkHandler;
-import net.minecraft.network.ClientConnection;
-import net.minecraft.network.listener.ClientCommonPacketListener;
-import net.minecraft.network.packet.Packet;
-import net.minecraft.network.packet.s2c.common.ResourcePackSendS2CPacket;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.PacketOutputListener.PacketOutputEvent;
 import net.cevapi.security.ResourcePackProtector;
 import net.cevapi.security.ResourcePackProtector.PolicyResult;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientCommonPacketListenerImpl;
+import net.minecraft.network.Connection;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientCommonPacketListener;
+import net.minecraft.network.protocol.common.ClientboundResourcePackPushPacket;
 
-@Mixin(ClientCommonNetworkHandler.class)
+@Mixin(ClientCommonPacketListenerImpl.class)
 public abstract class ClientCommonNetworkHandlerMixin
 	implements ClientCommonPacketListener
 {
 	@Shadow
-	protected MinecraftClient client;
+	protected Minecraft minecraft;
 	
 	@Shadow
-	protected ClientConnection connection;
+	protected Connection connection;
 	
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/network/ClientConnection;send(Lnet/minecraft/network/packet/Packet;)V"),
-		method = "sendPacket(Lnet/minecraft/network/packet/Packet;)V")
-	private void wrapSendPacket(ClientConnection connection, Packet<?> packet,
+		target = "Lnet/minecraft/network/Connection;send(Lnet/minecraft/network/protocol/Packet;)V"),
+		method = "send(Lnet/minecraft/network/protocol/Packet;)V")
+	private void wrapSendPacket(Connection connection, Packet<?> packet,
 		Operation<Void> original)
 	{
 		PacketOutputEvent event = new PacketOutputEvent(packet);
@@ -51,16 +50,16 @@ public abstract class ClientCommonNetworkHandlerMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "onResourcePackSend(Lnet/minecraft/network/packet/s2c/common/ResourcePackSendS2CPacket;)V",
+		method = "handleResourcePackPush(Lnet/minecraft/network/protocol/common/ClientboundResourcePackPushPacket;)V",
 		cancellable = true)
-	private void onResourcePackSend(ResourcePackSendS2CPacket packet,
+	private void onResourcePackSend(ClientboundResourcePackPushPacket packet,
 		CallbackInfo ci)
 	{
 		try
 		{
 			PolicyResult result = ResourcePackProtector.evaluate(packet);
-			MinecraftClient mc =
-				client != null ? client : MinecraftClient.getInstance();
+			Minecraft mc =
+				minecraft != null ? minecraft : Minecraft.getInstance();
 			boolean cancel =
 				ResourcePackProtector.applyDecision(result, connection, mc);
 			if(cancel)
diff --git a/src/main/java/net/wurstclient/mixin/ClientConnectionMixin.java b/src/main/java/net/wurstclient/mixin/ClientConnectionMixin.java
index a8cf0ab7b..4c681032e 100644
--- a/src/main/java/net/wurstclient/mixin/ClientConnectionMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientConnectionMixin.java
@@ -19,13 +19,13 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
-import net.minecraft.network.ClientConnection;
-import net.minecraft.network.packet.Packet;
+import net.minecraft.network.Connection;
+import net.minecraft.network.protocol.Packet;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ConnectionPacketOutputListener.ConnectionPacketOutputEvent;
 import net.wurstclient.events.PacketInputListener.PacketInputEvent;
 
-@Mixin(ClientConnection.class)
+@Mixin(Connection.class)
 public abstract class ClientConnectionMixin
 	extends SimpleChannelInboundHandler<Packet<?>>
 {
@@ -33,9 +33,9 @@ public abstract class ClientConnectionMixin
 		new ConcurrentLinkedQueue<>();
 	
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/network/ClientConnection;handlePacket(Lnet/minecraft/network/packet/Packet;Lnet/minecraft/network/listener/PacketListener;)V",
+		target = "Lnet/minecraft/network/Connection;genericsFtw(Lnet/minecraft/network/protocol/Packet;Lnet/minecraft/network/PacketListener;)V",
 		ordinal = 0),
-		method = "channelRead0(Lio/netty/channel/ChannelHandlerContext;Lnet/minecraft/network/packet/Packet;)V",
+		method = "channelRead0(Lio/netty/channel/ChannelHandlerContext;Lnet/minecraft/network/protocol/Packet;)V",
 		cancellable = true)
 	private void onChannelRead0(ChannelHandlerContext context, Packet<?> packet,
 		CallbackInfo ci)
@@ -50,7 +50,7 @@ public abstract class ClientConnectionMixin
 	// These mixins target the second "send" method. The one with two arguments.
 	
 	@ModifyVariable(at = @At("HEAD"),
-		method = "send(Lnet/minecraft/network/packet/Packet;Lio/netty/channel/ChannelFutureListener;)V")
+		method = "send(Lnet/minecraft/network/protocol/Packet;Lio/netty/channel/ChannelFutureListener;)V")
 	public Packet<?> modifyPacket(Packet<?> packet)
 	{
 		ConnectionPacketOutputEvent event =
@@ -61,7 +61,7 @@ public abstract class ClientConnectionMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "send(Lnet/minecraft/network/packet/Packet;Lio/netty/channel/ChannelFutureListener;)V",
+		method = "send(Lnet/minecraft/network/protocol/Packet;Lio/netty/channel/ChannelFutureListener;)V",
 		cancellable = true)
 	private void onSend(Packet<?> packet,
 		@Nullable ChannelFutureListener callback, CallbackInfo ci)
diff --git a/src/main/java/net/wurstclient/mixin/ClientPlayNetworkHandlerMixin.java b/src/main/java/net/wurstclient/mixin/ClientPlayNetworkHandlerMixin.java
index f6e34da3b..d99fb2537 100644
--- a/src/main/java/net/wurstclient/mixin/ClientPlayNetworkHandlerMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientPlayNetworkHandlerMixin.java
@@ -13,42 +13,40 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientCommonNetworkHandler;
-import net.minecraft.client.network.ClientConnectionState;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.client.toast.SystemToast;
-import net.minecraft.network.ClientConnection;
-import net.minecraft.network.listener.ClientPlayPacketListener;
-import net.minecraft.network.listener.TickablePacketListener;
-import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.ChunkData;
-import net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.ExplosionS2CPacket;
-import net.minecraft.network.packet.s2c.play.GameJoinS2CPacket;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.Text;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.components.toasts.SystemToast;
+import net.minecraft.client.multiplayer.ClientCommonPacketListenerImpl;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.client.multiplayer.CommonListenerCookie;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.network.Connection;
+import net.minecraft.network.TickablePacketListener;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.protocol.game.ClientGamePacketListener;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundExplodePacket;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
+import net.minecraft.network.protocol.game.ClientboundLoginPacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.ChatUtils;
 
-@Mixin(ClientPlayNetworkHandler.class)
+@Mixin(ClientPacketListener.class)
 public abstract class ClientPlayNetworkHandlerMixin
-	extends ClientCommonNetworkHandler
-	implements TickablePacketListener, ClientPlayPacketListener
+	extends ClientCommonPacketListenerImpl
+	implements TickablePacketListener, ClientGamePacketListener
 {
-	private ClientPlayNetworkHandlerMixin(WurstClient wurst,
-		MinecraftClient client, ClientConnection connection,
-		ClientConnectionState connectionState)
+	private ClientPlayNetworkHandlerMixin(WurstClient wurst, Minecraft client,
+		Connection connection, CommonListenerCookie connectionState)
 	{
 		super(client, connection, connectionState);
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "onGameJoin(Lnet/minecraft/network/packet/s2c/play/GameJoinS2CPacket;)V")
-	public void onOnGameJoin(GameJoinS2CPacket packet, CallbackInfo ci)
+		method = "handleLogin(Lnet/minecraft/network/protocol/game/ClientboundLoginPacket;)V")
+	public void onOnGameJoin(ClientboundLoginPacket packet, CallbackInfo ci)
 	{
 		WurstClient wurst = WurstClient.INSTANCE;
 		if(!wurst.isEnabled())
@@ -57,8 +55,8 @@ public abstract class ClientPlayNetworkHandlerMixin
 		// Remove Mojang's dishonest warning toast on safe servers
 		if(!packet.enforcesSecureChat())
 		{
-			client.getToastManager().toastQueue.removeIf(toast -> toast
-				.getType() == SystemToast.Type.UNSECURE_SERVER_WARNING);
+			minecraft.getToastManager().queued.removeIf(toast -> toast
+				.getToken() == SystemToast.SystemToastId.UNSECURE_SERVER_WARNING);
 			return;
 		}
 		
@@ -66,62 +64,64 @@ public abstract class ClientPlayNetworkHandlerMixin
 		if(!wurst.getOtfs().noChatReportsOtf.getUnsafeChatToast().isChecked())
 			return;
 		
-		MutableText title = Text.literal(ChatUtils.WURST_PREFIX
+		MutableComponent title = Component.literal(ChatUtils.WURST_PREFIX
 			+ wurst.translate("toast.wurst.nochatreports.unsafe_server.title"));
-		MutableText message = Text.literal(
+		MutableComponent message = Component.literal(
 			wurst.translate("toast.wurst.nochatreports.unsafe_server.message"));
 		
-		SystemToast systemToast = SystemToast.create(client,
-			SystemToast.Type.UNSECURE_SERVER_WARNING, title, message);
-		client.getToastManager().add(systemToast);
+		SystemToast systemToast = SystemToast.multiline(minecraft,
+			SystemToast.SystemToastId.UNSECURE_SERVER_WARNING, title, message);
+		minecraft.getToastManager().addToast(systemToast);
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "loadChunk(IILnet/minecraft/network/packet/s2c/play/ChunkData;)V")
-	private void onLoadChunk(int x, int z, ChunkData chunkData, CallbackInfo ci)
+		method = "updateLevelChunk(IILnet/minecraft/network/protocol/game/ClientboundLevelChunkPacketData;)V")
+	private void onLoadChunk(int x, int z,
+		ClientboundLevelChunkPacketData chunkData, CallbackInfo ci)
 	{
 		WurstClient.INSTANCE.getHax().newChunksHack.afterLoadChunk(x, z);
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "onBlockUpdate(Lnet/minecraft/network/packet/s2c/play/BlockUpdateS2CPacket;)V")
-	private void onOnBlockUpdate(BlockUpdateS2CPacket packet, CallbackInfo ci)
+		method = "handleBlockUpdate(Lnet/minecraft/network/protocol/game/ClientboundBlockUpdatePacket;)V")
+	private void onOnBlockUpdate(ClientboundBlockUpdatePacket packet,
+		CallbackInfo ci)
 	{
 		WurstClient.INSTANCE.getHax().newChunksHack
 			.afterUpdateBlock(packet.getPos());
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "onChunkDeltaUpdate(Lnet/minecraft/network/packet/s2c/play/ChunkDeltaUpdateS2CPacket;)V")
-	private void onOnChunkDeltaUpdate(ChunkDeltaUpdateS2CPacket packet,
-		CallbackInfo ci)
+		method = "handleChunkBlocksUpdate(Lnet/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket;)V")
+	private void onOnChunkDeltaUpdate(
+		ClientboundSectionBlocksUpdatePacket packet, CallbackInfo ci)
 	{
-		packet.visitUpdates(
+		packet.runUpdates(
 			(pos, state) -> WurstClient.INSTANCE.getHax().newChunksHack
 				.afterUpdateBlock(pos));
 	}
 	
 	@Inject(
-		method = "onExplosion(Lnet/minecraft/network/packet/s2c/play/ExplosionS2CPacket;)V",
+		method = "handleExplosion(Lnet/minecraft/network/protocol/game/ClientboundExplodePacket;)V",
 		at = @At(value = "INVOKE",
 			target = "Ljava/util/Optional;ifPresent(Ljava/util/function/Consumer;)V"),
 		cancellable = true)
-	private void wurst$handleExplosionKnockback(ExplosionS2CPacket packet,
+	private void wurst$handleExplosionKnockback(ClientboundExplodePacket packet,
 		CallbackInfo ci)
 	{
-		ClientPlayerEntity player = client.player;
+		LocalPlayer player = minecraft.player;
 		if(player == null)
 			return;
 		
-		Optional<Vec3d> knockback = packet.playerKnockback();
+		Optional<Vec3> knockback = packet.playerKnockback();
 		if(knockback.isEmpty())
 			return;
 		
-		Vec3d vec = knockback.get();
-		Vec3d adjusted = WurstClient.INSTANCE.getHax().antiBlastHack
+		Vec3 vec = knockback.get();
+		Vec3 adjusted = WurstClient.INSTANCE.getHax().antiBlastHack
 			.modifyKnockback(vec.x, vec.y, vec.z);
 		
-		player.addVelocity(adjusted.x, adjusted.y, adjusted.z);
+		player.push(adjusted.x, adjusted.y, adjusted.z);
 		ci.cancel();
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/ClientPlayerEntityMixin.java b/src/main/java/net/wurstclient/mixin/ClientPlayerEntityMixin.java
index 58acc298b..0457f2679 100644
--- a/src/main/java/net/wurstclient/mixin/ClientPlayerEntityMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientPlayerEntityMixin.java
@@ -19,20 +19,19 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
 import com.mojang.authlib.GameProfile;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.input.Input;
-import net.minecraft.client.network.AbstractClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.MovementType;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.player.AbstractClientPlayer;
+import net.minecraft.client.player.ClientInput;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.Holder;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.MoverType;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.AirStrafingSpeedListener.AirStrafingSpeedEvent;
@@ -47,24 +46,24 @@ import net.wurstclient.hack.HackList;
 import net.wurstclient.hacks.AntiDropHack;
 import net.wurstclient.mixinterface.IClientPlayerEntity;
 
-@Mixin(ClientPlayerEntity.class)
-public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
+@Mixin(LocalPlayer.class)
+public class ClientPlayerEntityMixin extends AbstractClientPlayer
 	implements IClientPlayerEntity
 {
 	@Shadow
 	@Final
-	protected MinecraftClient client;
+	protected Minecraft minecraft;
 	
 	private Screen tempCurrentScreen;
 	
-	public ClientPlayerEntityMixin(WurstClient wurst, ClientWorld world,
+	public ClientPlayerEntityMixin(WurstClient wurst, ClientLevel world,
 		GameProfile profile)
 	{
 		super(world, profile);
 	}
 	
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/network/AbstractClientPlayerEntity;tick()V",
+		target = "Lnet/minecraft/client/player/AbstractClientPlayer;tick()V",
 		ordinal = 0), method = "tick()V")
 	private void onTick(CallbackInfo ci)
 	{
@@ -74,16 +73,14 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	/**
 	 * This mixin makes AutoSprint's "Omnidirectional Sprint" setting work.
 	 */
-	@WrapOperation(
-		at = @At(value = "INVOKE",
-			target = "Lnet/minecraft/client/input/Input;hasForwardMovement()Z",
-			ordinal = 0),
-		method = "tickMovement()V")
-	private boolean wrapHasForwardMovement(Input input,
+	@WrapOperation(at = @At(value = "INVOKE",
+		target = "Lnet/minecraft/client/player/ClientInput;hasForwardImpulse()Z",
+		ordinal = 0), method = "aiStep()V")
+	private boolean wrapHasForwardMovement(ClientInput input,
 		Operation<Boolean> original)
 	{
 		if(WurstClient.INSTANCE.getHax().autoSprintHack.shouldOmniSprint())
-			return input.getMovementInput().length() > 1e-5F;
+			return input.getMoveVector().length() > 1e-5F;
 		
 		return original.call(input);
 	}
@@ -92,10 +89,12 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * Allows NoSlowdown to intercept the isUsingItem() call in
 	 * tickMovement().
 	 */
-	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/network/ClientPlayerEntity;isUsingItem()Z",
-		ordinal = 0), method = "tickMovement()V")
-	private boolean wrapTickMovementItemUse(ClientPlayerEntity instance,
+	@WrapOperation(
+		at = @At(value = "INVOKE",
+			target = "Lnet/minecraft/client/player/LocalPlayer;isUsingItem()Z",
+			ordinal = 0),
+		method = "aiStep()V")
+	private boolean wrapTickMovementItemUse(LocalPlayer instance,
 		Operation<Boolean> original)
 	{
 		if(WurstClient.INSTANCE.getHax().noSlowdownHack.isEnabled())
@@ -104,21 +103,21 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 		return original.call(instance);
 	}
 	
-	@Inject(at = @At("HEAD"), method = "sendMovementPackets()V")
+	@Inject(at = @At("HEAD"), method = "sendPosition()V")
 	private void onSendMovementPacketsHEAD(CallbackInfo ci)
 	{
 		EventManager.fire(PreMotionEvent.INSTANCE);
 	}
 	
-	@Inject(at = @At("TAIL"), method = "sendMovementPackets()V")
+	@Inject(at = @At("TAIL"), method = "sendPosition()V")
 	private void onSendMovementPacketsTAIL(CallbackInfo ci)
 	{
 		EventManager.fire(PostMotionEvent.INSTANCE);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "move(Lnet/minecraft/entity/MovementType;Lnet/minecraft/util/math/Vec3d;)V")
-	private void onMove(MovementType type, Vec3d offset, CallbackInfo ci)
+		method = "move(Lnet/minecraft/world/entity/MoverType;Lnet/minecraft/world/phys/Vec3;)V")
+	private void onMove(MoverType type, Vec3 offset, CallbackInfo ci)
 	{
 		EventManager.fire(PlayerMoveEvent.INSTANCE);
 	}
@@ -137,16 +136,16 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * to null to prevent the updateNausea() method from closing it.
 	 */
 	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/MinecraftClient;currentScreen:Lnet/minecraft/client/gui/screen/Screen;",
+		target = "Lnet/minecraft/client/Minecraft;screen:Lnet/minecraft/client/gui/screens/Screen;",
 		opcode = Opcodes.GETFIELD,
-		ordinal = 0), method = "tickNausea(Z)V")
+		ordinal = 0), method = "handlePortalTransitionEffect(Z)V")
 	private void beforeTickNausea(boolean fromPortalEffect, CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.getHax().portalGuiHack.isEnabled())
 			return;
 		
-		tempCurrentScreen = client.currentScreen;
-		client.currentScreen = null;
+		tempCurrentScreen = minecraft.screen;
+		minecraft.screen = null;
 	}
 	
 	/**
@@ -154,15 +153,15 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * method is done looking at it.
 	 */
 	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/network/ClientPlayerEntity;nauseaIntensity:F",
+		target = "Lnet/minecraft/client/player/LocalPlayer;portalEffectIntensity:F",
 		opcode = Opcodes.GETFIELD,
-		ordinal = 1), method = "tickNausea(Z)V")
+		ordinal = 1), method = "handlePortalTransitionEffect(Z)V")
 	private void afterTickNausea(boolean fromPortalEffect, CallbackInfo ci)
 	{
 		if(tempCurrentScreen == null)
 			return;
 		
-		client.currentScreen = tempCurrentScreen;
+		minecraft.screen = tempCurrentScreen;
 		tempCurrentScreen = null;
 	}
 	
@@ -170,16 +169,16 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * This mixin allows AutoSprint to enable sprinting even when the player is
 	 * too hungry.
 	 */
-	@Inject(at = @At("HEAD"), method = "canSprint()Z", cancellable = true)
+	@Inject(at = @At("HEAD"),
+		method = "hasEnoughFoodToSprint()Z",
+		cancellable = true)
 	private void onCanSprint(CallbackInfoReturnable<Boolean> cir)
 	{
 		if(WurstClient.INSTANCE.getHax().autoSprintHack.shouldSprintHungry())
 			cir.setReturnValue(true);
 	}
 	
-	@Inject(at = @At("HEAD"),
-		method = "dropSelectedItem(Z)Z",
-		cancellable = true)
+	@Inject(at = @At("HEAD"), method = "drop(Z)Z", cancellable = true)
 	private void onDropSelectedItem(boolean entireStack,
 		CallbackInfoReturnable<Boolean> cir)
 	{
@@ -190,7 +189,7 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 		if(!antiDrop.isEnabled())
 			return;
 		
-		ItemStack stack = getMainHandStack();
+		ItemStack stack = getMainHandItem();
 		if(!antiDrop.shouldBlock(stack))
 			return;
 		
@@ -202,27 +201,26 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * Overridden to allow for the speed to be modified by hacks.
 	 */
 	@Override
-	protected float getOffGroundSpeed()
+	protected float getFlyingSpeed()
 	{
 		AirStrafingSpeedEvent event =
-			new AirStrafingSpeedEvent(super.getOffGroundSpeed());
+			new AirStrafingSpeedEvent(super.getFlyingSpeed());
 		EventManager.fire(event);
 		return event.getSpeed();
 	}
 	
 	@Override
-	public void setVelocityClient(Vec3d vec)
+	public void lerpMotion(Vec3 vec)
 	{
 		KnockbackEvent event = new KnockbackEvent(vec.x, vec.y, vec.z);
 		EventManager.fire(event);
-		super.setVelocityClient(
-			new Vec3d(event.getX(), event.getY(), event.getZ()));
+		super.lerpMotion(new Vec3(event.getX(), event.getY(), event.getZ()));
 	}
 	
 	@Override
-	public boolean isTouchingWater()
+	public boolean isInWater()
 	{
-		boolean inWater = super.isTouchingWater();
+		boolean inWater = super.isInWater();
 		IsPlayerInWaterEvent event = new IsPlayerInWaterEvent(inWater);
 		EventManager.fire(event);
 		
@@ -249,24 +247,23 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	@Override
 	public boolean isTouchingWaterBypass()
 	{
-		return super.isTouchingWater();
+		return super.isInWater();
 	}
 	
 	@Override
-	protected float getJumpVelocity()
+	protected float getJumpPower()
 	{
-		return super.getJumpVelocity()
-			+ WurstClient.INSTANCE.getHax().highJumpHack
-				.getAdditionalJumpMotion();
+		return super.getJumpPower() + WurstClient.INSTANCE.getHax().highJumpHack
+			.getAdditionalJumpMotion();
 	}
 	
 	/**
 	 * This is the part that makes SafeWalk work.
 	 */
 	@Override
-	protected boolean clipAtLedge()
+	protected boolean isStayingOnGroundSurface()
 	{
-		return super.clipAtLedge()
+		return super.isStayingOnGroundSurface()
 			|| WurstClient.INSTANCE.getHax().safeWalkHack.isEnabled();
 	}
 	
@@ -275,9 +272,9 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	 * near a ledge.
 	 */
 	@Override
-	protected Vec3d adjustMovementForSneaking(Vec3d movement, MovementType type)
+	protected Vec3 maybeBackOffFromEdge(Vec3 movement, MoverType type)
 	{
-		Vec3d result = super.adjustMovementForSneaking(movement, type);
+		Vec3 result = super.maybeBackOffFromEdge(movement, type);
 		
 		if(movement != null)
 			WurstClient.INSTANCE.getHax().safeWalkHack
@@ -287,63 +284,60 @@ public class ClientPlayerEntityMixin extends AbstractClientPlayerEntity
 	}
 	
 	@Override
-	public boolean hasStatusEffect(RegistryEntry<StatusEffect> effect)
+	public boolean hasEffect(Holder<MobEffect> effect)
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
 		
-		if(effect == StatusEffects.NIGHT_VISION
+		if(effect == MobEffects.NIGHT_VISION
 			&& hax.fullbrightHack.isNightVisionActive())
 			return true;
 		
-		if(effect == StatusEffects.LEVITATION
-			&& hax.noLevitationHack.isEnabled())
+		if(effect == MobEffects.LEVITATION && hax.noLevitationHack.isEnabled())
 			return false;
 		
-		if(effect == StatusEffects.BLINDNESS && hax.antiBlindHack.isEnabled())
+		if(effect == MobEffects.BLINDNESS && hax.antiBlindHack.isEnabled())
 			return false;
 		
-		if(effect == StatusEffects.DARKNESS && hax.antiBlindHack.isEnabled())
+		if(effect == MobEffects.DARKNESS && hax.antiBlindHack.isEnabled())
 			return false;
 		
-		return super.hasStatusEffect(effect);
+		return super.hasEffect(effect);
 	}
 	
 	@Override
-	public StatusEffectInstance getStatusEffect(
-		RegistryEntry<StatusEffect> effect)
+	public MobEffectInstance getEffect(Holder<MobEffect> effect)
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
 		
-		if(effect == StatusEffects.LEVITATION
-			&& hax.noLevitationHack.isEnabled())
+		if(effect == MobEffects.LEVITATION && hax.noLevitationHack.isEnabled())
 			return null;
 		
-		return super.getStatusEffect(effect);
+		return super.getEffect(effect);
 	}
 	
 	@Override
-	public float getStepHeight()
+	public float maxUpStep()
 	{
 		return WurstClient.INSTANCE.getHax().stepHack
-			.adjustStepHeight(super.getStepHeight());
+			.adjustStepHeight(super.maxUpStep());
 	}
 	
 	@Override
-	public double getBlockInteractionRange()
+	public double blockInteractionRange()
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
 		if(hax == null || !hax.reachHack.isEnabled())
-			return super.getBlockInteractionRange();
+			return super.blockInteractionRange();
 		
 		return hax.reachHack.getReachDistance();
 	}
 	
 	@Override
-	public double getEntityInteractionRange()
+	public double entityInteractionRange()
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
 		if(hax == null || !hax.reachHack.isEnabled())
-			return super.getEntityInteractionRange();
+			return super.entityInteractionRange();
 		
 		return hax.reachHack.getReachDistance();
 	}
diff --git a/src/main/java/net/wurstclient/mixin/ClientPlayerInteractionManagerMixin.java b/src/main/java/net/wurstclient/mixin/ClientPlayerInteractionManagerMixin.java
index 086a53004..e577ca4d0 100644
--- a/src/main/java/net/wurstclient/mixin/ClientPlayerInteractionManagerMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientPlayerInteractionManagerMixin.java
@@ -14,27 +14,26 @@ import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.client.network.SequencedPacketCreator;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.item.BlockItem;
-import net.minecraft.item.ItemStack;
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket.Action;
-import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.client.multiplayer.prediction.PredictiveAction;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket.Action;
+import net.minecraft.network.protocol.game.ServerboundUseItemOnPacket;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.BlockBreakingProgressListener.BlockBreakingProgressEvent;
@@ -43,20 +42,21 @@ import net.wurstclient.events.StopUsingItemListener.StopUsingItemEvent;
 import net.wurstclient.hacks.AntiDropHack;
 import net.wurstclient.mixinterface.IClientPlayerInteractionManager;
 
-@Mixin(ClientPlayerInteractionManager.class)
+@Mixin(MultiPlayerGameMode.class)
 public abstract class ClientPlayerInteractionManagerMixin
 	implements IClientPlayerInteractionManager
 {
 	@Shadow
 	@Final
-	private MinecraftClient client;
+	private Minecraft minecraft;
 	
 	private boolean antiDropBypassingPlacement;
 	
-	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/network/ClientPlayerEntity;getId()I",
-		ordinal = 0),
-		method = "updateBlockBreakingProgress(Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/util/math/Direction;)Z")
+	@Inject(
+		at = @At(value = "INVOKE",
+			target = "Lnet/minecraft/client/player/LocalPlayer;getId()I",
+			ordinal = 0),
+		method = "continueDestroyBlock(Lnet/minecraft/core/BlockPos;Lnet/minecraft/core/Direction;)Z")
 	private void onPlayerDamageBlock(BlockPos pos, Direction direction,
 		CallbackInfoReturnable<Boolean> cir)
 	{
@@ -64,19 +64,19 @@ public abstract class ClientPlayerInteractionManagerMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "stopUsingItem(Lnet/minecraft/entity/player/PlayerEntity;)V")
-	private void onStopUsingItem(PlayerEntity player, CallbackInfo ci)
+		method = "releaseUsingItem(Lnet/minecraft/world/entity/player/Player;)V")
+	private void onStopUsingItem(Player player, CallbackInfo ci)
 	{
 		EventManager.fire(StopUsingItemEvent.INSTANCE);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "clickSlot(IIILnet/minecraft/screen/slot/SlotActionType;Lnet/minecraft/entity/player/PlayerEntity;)V",
+		method = "handleInventoryMouseClick(IIILnet/minecraft/world/inventory/ClickType;Lnet/minecraft/world/entity/player/Player;)V",
 		cancellable = true)
 	private void onClickSlotHEAD(int syncId, int slotId, int button,
-		SlotActionType actionType, PlayerEntity player, CallbackInfo ci)
+		ClickType actionType, Player player, CallbackInfo ci)
 	{
-		if(actionType != SlotActionType.THROW)
+		if(actionType != ClickType.THROW)
 			return;
 		
 		if(!WurstClient.INSTANCE.isEnabled())
@@ -88,28 +88,28 @@ public abstract class ClientPlayerInteractionManagerMixin
 		
 		ItemStack stack = ItemStack.EMPTY;
 		
-		if(slotId == -999 && player.currentScreenHandler != null
-			&& player.currentScreenHandler.syncId == syncId)
+		if(slotId == -999 && player.containerMenu != null
+			&& player.containerMenu.containerId == syncId)
 		{
-			stack = player.currentScreenHandler.getCursorStack();
+			stack = player.containerMenu.getCarried();
 			
 		}else if(slotId >= 0)
 		{
-			if(player.currentScreenHandler != null
-				&& player.currentScreenHandler.syncId == syncId
-				&& slotId < player.currentScreenHandler.slots.size())
+			if(player.containerMenu != null
+				&& player.containerMenu.containerId == syncId
+				&& slotId < player.containerMenu.slots.size())
 			{
-				Slot slot = player.currentScreenHandler.getSlot(slotId);
+				Slot slot = player.containerMenu.getSlot(slotId);
 				if(slot != null)
-					stack = slot.getStack();
+					stack = slot.getItem();
 				
-			}else if(player.playerScreenHandler != null
-				&& player.playerScreenHandler.syncId == syncId
-				&& slotId < player.playerScreenHandler.slots.size())
+			}else if(player.inventoryMenu != null
+				&& player.inventoryMenu.containerId == syncId
+				&& slotId < player.inventoryMenu.slots.size())
 			{
-				Slot slot = player.playerScreenHandler.getSlot(slotId);
+				Slot slot = player.inventoryMenu.getSlot(slotId);
 				if(slot != null)
-					stack = slot.getStack();
+					stack = slot.getItem();
 			}
 		}
 		
@@ -120,11 +120,10 @@ public abstract class ClientPlayerInteractionManagerMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "attackEntity(Lnet/minecraft/entity/player/PlayerEntity;Lnet/minecraft/entity/Entity;)V")
-	private void onAttackEntity(PlayerEntity player, Entity target,
-		CallbackInfo ci)
+		method = "attack(Lnet/minecraft/world/entity/player/Player;Lnet/minecraft/world/entity/Entity;)V")
+	private void onAttackEntity(Player player, Entity target, CallbackInfo ci)
 	{
-		if(player != client.player)
+		if(player != minecraft.player)
 			return;
 		
 		EventManager.fire(new PlayerAttacksEntityEvent(target));
@@ -133,62 +132,67 @@ public abstract class ClientPlayerInteractionManagerMixin
 	@Override
 	public void windowClick_PICKUP(int slot)
 	{
-		clickSlot(0, slot, 0, SlotActionType.PICKUP, client.player);
+		handleInventoryMouseClick(0, slot, 0, ClickType.PICKUP,
+			minecraft.player);
 	}
 	
 	@Override
 	public void windowClick_QUICK_MOVE(int slot)
 	{
-		clickSlot(0, slot, 0, SlotActionType.QUICK_MOVE, client.player);
+		handleInventoryMouseClick(0, slot, 0, ClickType.QUICK_MOVE,
+			minecraft.player);
 	}
 	
 	@Override
 	public void windowClick_THROW(int slot)
 	{
-		clickSlot(0, slot, 1, SlotActionType.THROW, client.player);
+		handleInventoryMouseClick(0, slot, 1, ClickType.THROW,
+			minecraft.player);
 	}
 	
 	@Override
 	public void windowClick_SWAP(int from, int to)
 	{
-		clickSlot(0, from, to, SlotActionType.SWAP, client.player);
+		handleInventoryMouseClick(0, from, to, ClickType.SWAP,
+			minecraft.player);
 	}
 	
 	@Override
 	public void rightClickItem()
 	{
-		interactItem(client.player, Hand.MAIN_HAND);
+		useItem(minecraft.player, InteractionHand.MAIN_HAND);
 	}
 	
 	@Override
-	public void rightClickBlock(BlockPos pos, Direction side, Vec3d hitVec)
+	public void rightClickBlock(BlockPos pos, Direction side, Vec3 hitVec)
 	{
 		BlockHitResult hitResult = new BlockHitResult(hitVec, side, pos, false);
-		Hand hand = Hand.MAIN_HAND;
-		interactBlock(client.player, hand, hitResult);
-		interactItem(client.player, hand);
+		InteractionHand hand = InteractionHand.MAIN_HAND;
+		useItemOn(minecraft.player, hand, hitResult);
+		useItem(minecraft.player, hand);
 	}
 	
 	@Override
 	public void sendPlayerActionC2SPacket(Action action, BlockPos blockPos,
 		Direction direction)
 	{
-		sendSequencedPacket(client.world,
-			i -> new PlayerActionC2SPacket(action, blockPos, direction, i));
+		startPrediction(minecraft.level,
+			i -> new ServerboundPlayerActionPacket(action, blockPos, direction,
+				i));
 	}
 	
 	@Override
-	public void sendPlayerInteractBlockPacket(Hand hand,
+	public void sendPlayerInteractBlockPacket(InteractionHand hand,
 		BlockHitResult blockHitResult)
 	{
-		sendSequencedPacket(client.world,
-			i -> new PlayerInteractBlockC2SPacket(hand, blockHitResult, i));
+		startPrediction(minecraft.level,
+			i -> new ServerboundUseItemOnPacket(hand, blockHitResult, i));
 	}
 	
-	@Inject(method = "interactBlock", at = @At(value = "HEAD"))
-	private void wurst$allowBlockPlacementBypass(ClientPlayerEntity player,
-		Hand hand, BlockHitResult hitResult,
-		CallbackInfoReturnable<ActionResult> cir)
+	@Inject(method = "useItemOn", at = @At(value = "HEAD"))
+	private void wurst$allowBlockPlacementBypass(LocalPlayer player,
+		InteractionHand hand, BlockHitResult hitResult,
+		CallbackInfoReturnable<InteractionResult> cir)
 	{
 		if(player == null || !WurstClient.INSTANCE.isEnabled())
 			return;
@@ -197,7 +201,7 @@ public abstract class ClientPlayerInteractionManagerMixin
 		if(antiDrop == null || !antiDrop.isEnabled())
 			return;
 		
-		ItemStack stack = player.getStackInHand(hand);
+		ItemStack stack = player.getItemInHand(hand);
 		if(stack == null || stack.isEmpty()
 			|| !(stack.getItem() instanceof BlockItem))
 			return;
@@ -208,10 +212,10 @@ public abstract class ClientPlayerInteractionManagerMixin
 		antiDropBypassingPlacement = true;
 	}
 	
-	@Inject(method = "interactBlock", at = @At(value = "RETURN"))
-	private void wurst$resetBlockPlacementBypass(ClientPlayerEntity player,
-		Hand hand, BlockHitResult hitResult,
-		CallbackInfoReturnable<ActionResult> cir)
+	@Inject(method = "useItemOn", at = @At(value = "RETURN"))
+	private void wurst$resetBlockPlacementBypass(LocalPlayer player,
+		InteractionHand hand, BlockHitResult hitResult,
+		CallbackInfoReturnable<InteractionResult> cir)
 	{
 		AntiDropHack antiDrop = WurstClient.INSTANCE.getHax().antiDropHack;
 		if(antiDrop == null)
@@ -228,20 +232,21 @@ public abstract class ClientPlayerInteractionManagerMixin
 	}
 	
 	@Shadow
-	private void sendSequencedPacket(ClientWorld world,
-		SequencedPacketCreator packetCreator)
+	private void startPrediction(ClientLevel world,
+		PredictiveAction packetCreator)
 	{
 		
 	}
 	
 	@Shadow
-	public abstract ActionResult interactBlock(ClientPlayerEntity player,
-		Hand hand, BlockHitResult hitResult);
+	public abstract InteractionResult useItemOn(LocalPlayer player,
+		InteractionHand hand, BlockHitResult hitResult);
 	
 	@Shadow
-	public abstract ActionResult interactItem(PlayerEntity player, Hand hand);
+	public abstract InteractionResult useItem(Player player,
+		InteractionHand hand);
 	
 	@Shadow
-	public abstract void clickSlot(int syncId, int slotId, int button,
-		SlotActionType actionType, PlayerEntity player);
+	public abstract void handleInventoryMouseClick(int syncId, int slotId,
+		int button, ClickType actionType, Player player);
 }
diff --git a/src/main/java/net/wurstclient/mixin/ClientWorldMixin.java b/src/main/java/net/wurstclient/mixin/ClientWorldMixin.java
index 0603195f5..18f9a6669 100644
--- a/src/main/java/net/wurstclient/mixin/ClientWorldMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ClientWorldMixin.java
@@ -13,27 +13,26 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.item.Items;
-import net.minecraft.world.GameMode;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.wurstclient.WurstClient;
 
-@Mixin(ClientWorld.class)
+@Mixin(ClientLevel.class)
 public class ClientWorldMixin
 {
 	@Shadow
 	@Final
-	private MinecraftClient client;
+	private Minecraft minecraft;
 	
 	/**
 	 * This is the part that makes BarrierESP work.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "getBlockParticle()Lnet/minecraft/block/Block;",
+		method = "getMarkerParticleTarget()Lnet/minecraft/world/level/block/Block;",
 		cancellable = true)
 	private void onGetBlockParticle(CallbackInfoReturnable<Block> cir)
 	{
@@ -42,8 +41,8 @@ public class ClientWorldMixin
 			
 		// Pause BarrierESP when holding a light in Creative Mode, since it
 		// would otherwise prevent the player from seeing light blocks.
-		if(client.interactionManager.getCurrentGameMode() == GameMode.CREATIVE
-			&& client.player.getMainHandStack().getItem() == Items.LIGHT)
+		if(minecraft.gameMode.getPlayerMode() == GameType.CREATIVE
+			&& minecraft.player.getMainHandItem().getItem() == Items.LIGHT)
 			return;
 		
 		cir.setReturnValue(Blocks.BARRIER);
diff --git a/src/main/java/net/wurstclient/mixin/ControlsListWidgetMixin.java b/src/main/java/net/wurstclient/mixin/ControlsListWidgetMixin.java
index 40032f94a..5bd2c9224 100644
--- a/src/main/java/net/wurstclient/mixin/ControlsListWidgetMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ControlsListWidgetMixin.java
@@ -12,20 +12,19 @@ import org.spongepowered.asm.mixin.injection.At;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.screen.option.ControlsListWidget;
-import net.minecraft.client.gui.widget.ElementListWidget;
-import net.minecraft.client.gui.widget.EntryListWidget;
-import net.minecraft.text.Text;
-import net.minecraft.text.TranslatableTextContent;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.components.AbstractSelectionList;
+import net.minecraft.client.gui.components.ContainerObjectSelectionList;
+import net.minecraft.client.gui.screens.options.controls.KeyBindsList;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.contents.TranslatableContents;
 import net.wurstclient.WurstClient;
 
-@Mixin(ControlsListWidget.class)
+@Mixin(KeyBindsList.class)
 public abstract class ControlsListWidgetMixin
-	extends ElementListWidget<ControlsListWidget.Entry>
+	extends ContainerObjectSelectionList<KeyBindsList.Entry>
 {
-	public ControlsListWidgetMixin(WurstClient wurst, MinecraftClient client,
+	public ControlsListWidgetMixin(WurstClient wurst, Minecraft client,
 		int width, int height, int y, int itemHeight)
 	{
 		super(client, width, height, y, itemHeight);
@@ -35,18 +34,18 @@ public abstract class ControlsListWidgetMixin
 	 * Prevents Wurst's zoom keybind from being added to the controls list.
 	 */
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/gui/screen/option/ControlsListWidget;addEntry(Lnet/minecraft/client/gui/widget/EntryListWidget$Entry;)I",
+		target = "Lnet/minecraft/client/gui/screens/options/controls/KeyBindsList;addEntry(Lnet/minecraft/client/gui/components/AbstractSelectionList$Entry;)I",
 		ordinal = 1),
-		method = "<init>(Lnet/minecraft/client/gui/screen/option/KeybindsScreen;Lnet/minecraft/client/MinecraftClient;)V")
-	private int dontAddZoomEntry(ControlsListWidget instance,
-		EntryListWidget.Entry<?> entry, Operation<Integer> original)
+		method = "<init>(Lnet/minecraft/client/gui/screens/options/controls/KeyBindsScreen;Lnet/minecraft/client/Minecraft;)V")
+	private int dontAddZoomEntry(KeyBindsList instance,
+		AbstractSelectionList.Entry<?> entry, Operation<Integer> original)
 	{
-		if(!(entry instanceof ControlsListWidget.KeyBindingEntry kbEntry))
+		if(!(entry instanceof KeyBindsList.KeyEntry kbEntry))
 			return original.call(instance, entry);
 		
-		Text name = kbEntry.bindingName;
-		if(name == null || !(name
-			.getContent() instanceof TranslatableTextContent trContent))
+		Component name = kbEntry.name;
+		if(name == null
+			|| !(name.getContents() instanceof TranslatableContents trContent))
 			return original.call(instance, entry);
 		
 		if(!"key.wurst.zoom".equals(trContent.getKey()))
diff --git a/src/main/java/net/wurstclient/mixin/CreativeInventoryScreenMixin.java b/src/main/java/net/wurstclient/mixin/CreativeInventoryScreenMixin.java
index 44365917f..6a0e64c34 100644
--- a/src/main/java/net/wurstclient/mixin/CreativeInventoryScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/CreativeInventoryScreenMixin.java
@@ -11,30 +11,28 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;
-import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen.CreativeScreenHandler;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.CreativeModeInventoryScreen;
+import net.minecraft.client.gui.screens.inventory.CreativeModeInventoryScreen.ItemPickerMenu;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.entity.player.Player;
 import net.wurstclient.WurstClient;
 
-@Mixin(CreativeInventoryScreen.class)
+@Mixin(CreativeModeInventoryScreen.class)
 public abstract class CreativeInventoryScreenMixin
-	extends HandledScreen<CreativeInventoryScreen.CreativeScreenHandler>
+	extends AbstractContainerScreen<CreativeModeInventoryScreen.ItemPickerMenu>
 {
 	private CreativeInventoryScreenMixin(WurstClient wurst,
-		CreativeScreenHandler screenHandler, PlayerInventory inventory,
-		Text title)
+		ItemPickerMenu screenHandler, Inventory inventory, Component title)
 	{
 		super(screenHandler, inventory, title);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "shouldShowOperatorTab(Lnet/minecraft/entity/player/PlayerEntity;)Z",
+		method = "hasPermissions(Lnet/minecraft/world/entity/player/Player;)Z",
 		cancellable = true)
-	private void onShouldShowOperatorTab(PlayerEntity player,
+	private void onShouldShowOperatorTab(Player player,
 		CallbackInfoReturnable<Boolean> cir)
 	{
 		if(WurstClient.INSTANCE.isEnabled())
diff --git a/src/main/java/net/wurstclient/mixin/DeathScreenMixin.java b/src/main/java/net/wurstclient/mixin/DeathScreenMixin.java
index 9f7387726..ca527d860 100644
--- a/src/main/java/net/wurstclient/mixin/DeathScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/DeathScreenMixin.java
@@ -11,11 +11,10 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.DeathScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.DeathScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.DeathListener.DeathEvent;
@@ -24,7 +23,7 @@ import net.wurstclient.hacks.AutoRespawnHack;
 @Mixin(DeathScreen.class)
 public abstract class DeathScreenMixin extends Screen
 {
-	private DeathScreenMixin(WurstClient wurst, Text title)
+	private DeathScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -47,10 +46,10 @@ public abstract class DeathScreenMixin extends Screen
 		int backButtonX = width / 2 - 100;
 		int backButtonY = height / 4;
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("AutoRespawn: OFF"), b -> {
+		addRenderableWidget(
+			Button.builder(Component.literal("AutoRespawn: OFF"), b -> {
 				autoRespawn.setEnabled(true);
 				autoRespawn.onDeath();
-			}).dimensions(backButtonX, backButtonY + 48, 200, 20).build());
+			}).bounds(backButtonX, backButtonY + 48, 200, 20).build());
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/DimensionOrBossFogModifierMixin.java b/src/main/java/net/wurstclient/mixin/DimensionOrBossFogModifierMixin.java
index 41fd594a0..be79daff5 100644
--- a/src/main/java/net/wurstclient/mixin/DimensionOrBossFogModifierMixin.java
+++ b/src/main/java/net/wurstclient/mixin/DimensionOrBossFogModifierMixin.java
@@ -11,28 +11,25 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.render.RenderTickCounter;
-import net.minecraft.client.render.fog.DimensionOrBossFogModifier;
-import net.minecraft.client.render.fog.FogData;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.renderer.fog.FogData;
+import net.minecraft.client.renderer.fog.environment.DimensionOrBossFogEnvironment;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.WurstClient;
 
-@Mixin(DimensionOrBossFogModifier.class)
+@Mixin(DimensionOrBossFogEnvironment.class)
 public class DimensionOrBossFogModifierMixin
 {
 	/**
 	 * Removes the thick fog in the Nether and during the Ender Dragon fight,
 	 * if NoFog is enabled.
 	 */
-	@Inject(method = "applyStartEndModifier",
-		at = @At("TAIL"),
-		cancellable = true)
+	@Inject(method = "setupFog", at = @At("TAIL"), cancellable = true)
 	private void onApplyStartEndModifier(FogData data, Entity cameraEntity,
-		BlockPos cameraPos, ClientWorld world, float viewDistance,
-		RenderTickCounter tickCounter, CallbackInfo ci)
+		BlockPos cameraPos, ClientLevel world, float viewDistance,
+		DeltaTracker tickCounter, CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.getHax().noFogHack.isEnabled())
 			return;
diff --git a/src/main/java/net/wurstclient/mixin/DirectConnectScreenMixin.java b/src/main/java/net/wurstclient/mixin/DirectConnectScreenMixin.java
index 270ecebb7..e82f70d23 100644
--- a/src/main/java/net/wurstclient/mixin/DirectConnectScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/DirectConnectScreenMixin.java
@@ -13,29 +13,28 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.multiplayer.DirectConnectScreen;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.DirectJoinServerScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.LastServerRememberer;
 
-@Mixin(DirectConnectScreen.class)
+@Mixin(DirectJoinServerScreen.class)
 public class DirectConnectScreenMixin extends Screen
 {
 	@Shadow
 	@Final
-	private ServerInfo serverEntry;
+	private ServerData serverData;
 	
-	private DirectConnectScreenMixin(WurstClient wurst, Text title)
+	private DirectConnectScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
 	
-	@Inject(at = @At("TAIL"), method = "saveAndClose()V")
+	@Inject(at = @At("TAIL"), method = "onSelect()V")
 	private void onSaveAndClose(CallbackInfo ci)
 	{
-		LastServerRememberer.setLastServer(serverEntry);
+		LastServerRememberer.setLastServer(serverData);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/DisconnectedScreenMixin.java b/src/main/java/net/wurstclient/mixin/DisconnectedScreenMixin.java
index a6e927b29..356fa709d 100644
--- a/src/main/java/net/wurstclient/mixin/DisconnectedScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/DisconnectedScreenMixin.java
@@ -15,13 +15,12 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.DisconnectedScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.DirectionalLayoutWidget;
-import net.minecraft.network.DisconnectionInfo;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.layouts.LinearLayout;
+import net.minecraft.client.gui.screens.DisconnectedScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.DisconnectionDetails;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoReconnectHack;
 import net.wurstclient.nochatreports.ForcedChatReportsScreen;
@@ -32,19 +31,19 @@ import net.wurstclient.util.LastServerRememberer;
 public class DisconnectedScreenMixin extends Screen
 {
 	private int autoReconnectTimer;
-	private ButtonWidget autoReconnectButton;
+	private Button autoReconnectButton;
 	
 	@Shadow
 	@Final
-	private DisconnectionInfo info;
+	private DisconnectionDetails details;
 	@Shadow
 	@Final
 	private Screen parent;
 	@Shadow
 	@Final
-	private DirectionalLayoutWidget grid;
+	private LinearLayout layout;
 	
-	private DisconnectedScreenMixin(WurstClient wurst, Text title)
+	private DisconnectedScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -55,18 +54,18 @@ public class DisconnectedScreenMixin extends Screen
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		Text reason = info.reason();
+		Component reason = details.reason();
 		System.out.println("Disconnected: " + reason);
 		
 		if(ForcedChatReportsScreen.isCausedByNoChatReports(reason))
 		{
-			client.setScreen(new ForcedChatReportsScreen(parent));
+			minecraft.setScreen(new ForcedChatReportsScreen(parent));
 			return;
 		}
 		
 		if(NcrModRequiredScreen.isCausedByLackOfNCR(reason))
 		{
-			client.setScreen(new NcrModRequiredScreen(parent));
+			minecraft.setScreen(new NcrModRequiredScreen(parent));
 			return;
 		}
 		
@@ -75,31 +74,31 @@ public class DisconnectedScreenMixin extends Screen
 	
 	private void addReconnectButtons()
 	{
-		ButtonWidget reconnectButton = grid.add(ButtonWidget
-			.builder(Text.literal("Reconnect"),
+		Button reconnectButton = layout.addChild(Button
+			.builder(Component.literal("Reconnect"),
 				b -> LastServerRememberer.reconnect(parent))
 			.width(200).build());
 		
-		autoReconnectButton = grid.add(ButtonWidget
-			.builder(Text.literal("AutoReconnect"), b -> pressAutoReconnect())
-			.width(200).build());
+		autoReconnectButton =
+			layout.addChild(Button.builder(Component.literal("AutoReconnect"),
+				b -> pressAutoReconnect()).width(200).build());
 		
 		// Show player location (click to copy to clipboard)
 		final String posString;
-		if(client.player != null)
+		if(minecraft.player != null)
 		{
-			var ppos = client.player.getBlockPos();
+			var ppos = minecraft.player.blockPosition();
 			posString = ppos.getX() + ", " + ppos.getY() + ", " + ppos.getZ();
 		}else
 			posString = "Unknown";
-		ButtonWidget copyLocButton = grid.add(ButtonWidget
-			.builder(Text.literal("Copy location: " + posString), b -> {
-				client.keyboard.setClipboard(posString);
+		Button copyLocButton = layout.addChild(Button
+			.builder(Component.literal("Copy location: " + posString), b -> {
+				minecraft.keyboardHandler.setClipboard(posString);
 			}).width(200).build());
 		
-		grid.refreshPositions();
+		layout.arrangeElements();
 		Stream.of(reconnectButton, autoReconnectButton, copyLocButton)
-			.forEach(this::addDrawableChild);
+			.forEach(this::addRenderableWidget);
 		
 		AutoReconnectHack autoReconnect =
 			WurstClient.INSTANCE.getHax().autoReconnectHack;
@@ -130,11 +129,11 @@ public class DisconnectedScreenMixin extends Screen
 		
 		if(!autoReconnect.isEnabled())
 		{
-			autoReconnectButton.setMessage(Text.literal("AutoReconnect"));
+			autoReconnectButton.setMessage(Component.literal("AutoReconnect"));
 			return;
 		}
 		
-		autoReconnectButton.setMessage(Text.literal("AutoReconnect ("
+		autoReconnectButton.setMessage(Component.literal("AutoReconnect ("
 			+ (int)Math.ceil(autoReconnectTimer / 20.0) + ")"));
 		
 		if(autoReconnectTimer > 0)
diff --git a/src/main/java/net/wurstclient/mixin/DownloaderMixin.java b/src/main/java/net/wurstclient/mixin/DownloaderMixin.java
index 939290eb9..936b6a7f2 100644
--- a/src/main/java/net/wurstclient/mixin/DownloaderMixin.java
+++ b/src/main/java/net/wurstclient/mixin/DownloaderMixin.java
@@ -17,18 +17,17 @@ import org.spongepowered.asm.mixin.injection.At;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.session.Session;
-import net.minecraft.util.Downloader;
-import net.minecraft.util.Uuids;
+import net.minecraft.client.User;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.server.packs.DownloadQueue;
 import net.wurstclient.WurstClient;
 
-@Mixin(Downloader.class)
+@Mixin(DownloadQueue.class)
 public abstract class DownloaderMixin implements AutoCloseable
 {
 	@Shadow
 	@Final
-	private Path directory;
+	private Path cacheDir;
 	
 	/**
 	 * Patches a fingerprinting vulnerability by creating a separate cache
@@ -51,16 +50,16 @@ public abstract class DownloaderMixin implements AutoCloseable
 		
 		// If the path has already been modified by another mod (likely trying
 		// to patch the same exploit), don't modify it further.
-		if(result == null || !result.getParent().equals(directory))
+		if(result == null || !result.getParent().equals(cacheDir))
 			return result;
 			
 		// "getUuidOrNull" seems to be an outdated Yarn name, as Minecraft
 		// 1.21.10 treats this like a non-null method. Just in case, we manually
 		// fallback to the offline UUID if it ever does return null.
-		Session session = WurstClient.MC.getSession();
-		UUID uuid = session.getUuidOrNull();
+		User session = WurstClient.MC.getUser();
+		UUID uuid = session.getProfileId();
 		if(uuid == null)
-			uuid = Uuids.getOfflinePlayerUuid(session.getUsername());
+			uuid = UUIDUtil.createOfflinePlayerUUID(session.getName());
 		
 		return result.getParent().resolve(uuid.toString())
 			.resolve(result.getFileName());
diff --git a/src/main/java/net/wurstclient/mixin/EntityMixin.java b/src/main/java/net/wurstclient/mixin/EntityMixin.java
index a08573b55..fc1b6ecb0 100644
--- a/src/main/java/net/wurstclient/mixin/EntityMixin.java
+++ b/src/main/java/net/wurstclient/mixin/EntityMixin.java
@@ -15,14 +15,13 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 
 import com.llamalad7.mixinextras.injector.v2.WrapWithCondition;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.server.command.CommandOutput;
-import net.minecraft.util.Nameable;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.entity.EntityLike;
+import net.minecraft.commands.CommandSource;
+import net.minecraft.world.Nameable;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.entity.EntityAccess;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.VelocityFromEntityCollisionListener.VelocityFromEntityCollisionEvent;
@@ -30,7 +29,8 @@ import net.wurstclient.events.VelocityFromFluidListener.VelocityFromFluidEvent;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
 @Mixin(Entity.class)
-public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
+public abstract class EntityMixin
+	implements Nameable, EntityAccess, CommandSource
 {
 	/**
 	 * This mixin makes the VelocityFromFluidEvent work, which is used by
@@ -38,12 +38,12 @@ public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
 	 * when using Sinytra Connector.
 	 */
 	@WrapWithCondition(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/entity/Entity;setVelocity(Lnet/minecraft/util/math/Vec3d;)V",
+		target = "Lnet/minecraft/world/entity/Entity;setDeltaMovement(Lnet/minecraft/world/phys/Vec3;)V",
 		opcode = Opcodes.INVOKEVIRTUAL,
 		ordinal = 0),
-		method = "updateMovementInFluid(Lnet/minecraft/registry/tag/TagKey;D)Z",
+		method = "updateFluidHeightAndDoFluidPushing(Lnet/minecraft/tags/TagKey;D)Z",
 		require = 0)
-	private boolean shouldSetVelocity(Entity instance, Vec3d velocity)
+	private boolean shouldSetVelocity(Entity instance, Vec3 velocity)
 	{
 		VelocityFromFluidEvent event = new VelocityFromFluidEvent(instance);
 		EventManager.fire(event);
@@ -51,7 +51,7 @@ public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "Lnet/minecraft/entity/Entity;pushAwayFrom(Lnet/minecraft/entity/Entity;)V",
+		method = "push(Lnet/minecraft/world/entity/Entity;)V",
 		cancellable = true)
 	private void onPushAwayFrom(Entity entity, CallbackInfo ci)
 	{
@@ -67,9 +67,9 @@ public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
 	 * Makes invisible entities render as ghosts if TrueSight is enabled.
 	 */
 	@Inject(at = @At("RETURN"),
-		method = "Lnet/minecraft/entity/Entity;isInvisibleTo(Lnet/minecraft/entity/player/PlayerEntity;)Z",
+		method = "isInvisibleTo(Lnet/minecraft/world/entity/player/Player;)Z",
 		cancellable = true)
-	private void onIsInvisibleTo(PlayerEntity player,
+	private void onIsInvisibleTo(Player player,
 		CallbackInfoReturnable<Boolean> cir)
 	{
 		// Return early if the entity is not invisible
@@ -81,7 +81,9 @@ public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
 			cir.setReturnValue(false);
 	}
 	
-	@Inject(at = @At("RETURN"), method = "isGlowing", cancellable = true)
+	@Inject(at = @At("RETURN"),
+		method = "isCurrentlyGlowing",
+		cancellable = true)
 	private void onIsGlowing(CallbackInfoReturnable<Boolean> cir)
 	{
 		if(cir.getReturnValueZ())
@@ -95,9 +97,7 @@ public abstract class EntityMixin implements Nameable, EntityLike, CommandOutput
 			cir.setReturnValue(true);
 	}
 	
-	@Inject(at = @At("RETURN"),
-		method = "getTeamColorValue",
-		cancellable = true)
+	@Inject(at = @At("RETURN"), method = "getTeamColor", cancellable = true)
 	private void onGetTeamColorValue(CallbackInfoReturnable<Integer> cir)
 	{
 		if(!((Object)this instanceof LivingEntity living))
diff --git a/src/main/java/net/wurstclient/mixin/EntityRendererMixin.java b/src/main/java/net/wurstclient/mixin/EntityRendererMixin.java
index 2bb1f6d78..3c629a988 100644
--- a/src/main/java/net/wurstclient/mixin/EntityRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/EntityRendererMixin.java
@@ -16,12 +16,11 @@ import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
 import com.llamalad7.mixinextras.sugar.Share;
 import com.llamalad7.mixinextras.sugar.ref.LocalDoubleRef;
-
-import net.minecraft.client.render.entity.EntityRenderManager;
-import net.minecraft.client.render.entity.EntityRenderer;
-import net.minecraft.client.render.entity.state.EntityRenderState;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
+import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
+import net.minecraft.client.renderer.entity.EntityRenderer;
+import net.minecraft.client.renderer.entity.state.EntityRenderState;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.HealthTagsHack;
 
@@ -32,10 +31,11 @@ public abstract class EntityRendererMixin<T extends Entity, S extends EntityRend
 	 * Disables the nametag distance limit if configured in NameTags.
 	 */
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/render/entity/EntityRenderManager;getSquaredDistanceToCamera(Lnet/minecraft/entity/Entity;)D"),
-		method = "updateRenderState(Lnet/minecraft/entity/Entity;Lnet/minecraft/client/render/entity/state/EntityRenderState;F)V")
-	private double fakeSquaredDistanceToCamera(EntityRenderManager dispatcher,
-		Entity entity, Operation<Double> original,
+		target = "Lnet/minecraft/client/renderer/entity/EntityRenderDispatcher;distanceToSqr(Lnet/minecraft/world/entity/Entity;)D"),
+		method = "extractRenderState(Lnet/minecraft/world/entity/Entity;Lnet/minecraft/client/renderer/entity/state/EntityRenderState;F)V")
+	private double fakeSquaredDistanceToCamera(
+		EntityRenderDispatcher dispatcher, Entity entity,
+		Operation<Double> original,
 		@Share("actualDistanceSq") LocalDoubleRef actualDistanceSq)
 	{
 		actualDistanceSq.set(original.call(dispatcher, entity));
@@ -51,12 +51,12 @@ public abstract class EntityRendererMixin<T extends Entity, S extends EntityRend
 	 * might rely on it.
 	 */
 	@Inject(at = @At("TAIL"),
-		method = "updateRenderState(Lnet/minecraft/entity/Entity;Lnet/minecraft/client/render/entity/state/EntityRenderState;F)V")
+		method = "extractRenderState(Lnet/minecraft/world/entity/Entity;Lnet/minecraft/client/renderer/entity/state/EntityRenderState;F)V")
 	private void restoreSquaredDistanceToCamera(T entity, S state,
 		float tickDelta, CallbackInfo ci,
 		@Share("actualDistanceSq") LocalDoubleRef actualDistanceSq)
 	{
-		state.squaredDistanceToCamera = actualDistanceSq.get();
+		state.distanceToCameraSq = actualDistanceSq.get();
 	}
 	
 	/**
@@ -66,11 +66,11 @@ public abstract class EntityRendererMixin<T extends Entity, S extends EntityRend
 	 * HealthTags is disabled.
 	 */
 	@Inject(at = @At("TAIL"),
-		method = "updateRenderState(Lnet/minecraft/entity/Entity;Lnet/minecraft/client/render/entity/state/EntityRenderState;F)V")
+		method = "extractRenderState(Lnet/minecraft/world/entity/Entity;Lnet/minecraft/client/renderer/entity/state/EntityRenderState;F)V")
 	private void addHealthToDisplayName(T entity, S state, float tickProgress,
 		CallbackInfo ci)
 	{
-		if(state.displayName == null)
+		if(state.nameTag == null)
 			return;
 		if(!(entity instanceof LivingEntity le))
 			return;
@@ -80,6 +80,6 @@ public abstract class EntityRendererMixin<T extends Entity, S extends EntityRend
 		if(!healthTags.isEnabled())
 			return;
 		
-		state.displayName = healthTags.addHealth(le, state.displayName.copy());
+		state.nameTag = healthTags.addHealth(le, state.nameTag.copy());
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/FluidRendererMixin.java b/src/main/java/net/wurstclient/mixin/FluidRendererMixin.java
index 163a9109d..0bc3ce5cb 100644
--- a/src/main/java/net/wurstclient/mixin/FluidRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/FluidRendererMixin.java
@@ -15,14 +15,13 @@ import org.spongepowered.asm.mixin.injection.ModifyConstant;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.render.block.FluidRenderer;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.world.BlockRenderView;
+import com.mojang.blaze3d.vertex.VertexConsumer;
+import net.minecraft.client.renderer.block.LiquidBlockRenderer;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.BlockAndTintGetter;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ShouldDrawSideListener.ShouldDrawSideEvent;
@@ -30,7 +29,7 @@ import net.wurstclient.hacks.SurfaceXrayHack;
 import net.wurstclient.hacks.SurfaceXrayHack.SurfaceState;
 import net.wurstclient.hacks.XRayHack;
 
-@Mixin(FluidRenderer.class)
+@Mixin(LiquidBlockRenderer.class)
 public class FluidRendererMixin
 {
 	@Unique
@@ -41,11 +40,11 @@ public class FluidRendererMixin
 	 * Hides and shows fluids when using X-Ray without Sodium installed.
 	 */
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/render/block/FluidRenderer;shouldSkipRendering(Lnet/minecraft/util/math/Direction;FLnet/minecraft/block/BlockState;)Z"),
-		method = "render(Lnet/minecraft/world/BlockRenderView;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/client/render/VertexConsumer;Lnet/minecraft/block/BlockState;Lnet/minecraft/fluid/FluidState;)V")
+		target = "Lnet/minecraft/client/renderer/block/LiquidBlockRenderer;isFaceOccludedByNeighbor(Lnet/minecraft/core/Direction;FLnet/minecraft/world/level/block/state/BlockState;)Z"),
+		method = "tesselate(Lnet/minecraft/world/level/BlockAndTintGetter;Lnet/minecraft/core/BlockPos;Lcom/mojang/blaze3d/vertex/VertexConsumer;Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/world/level/material/FluidState;)V")
 	private boolean modifyShouldSkipRendering(Direction side, float height,
 		BlockState neighborState, Operation<Boolean> original,
-		BlockRenderView world, BlockPos pos, VertexConsumer vertexConsumer,
+		BlockAndTintGetter world, BlockPos pos, VertexConsumer vertexConsumer,
 		BlockState blockState, FluidState fluidState)
 	{
 		ShouldDrawSideEvent event = new ShouldDrawSideEvent(blockState, pos);
@@ -80,7 +79,7 @@ public class FluidRendererMixin
 	 * Modifies opacity of fluids when using X-Ray without Sodium installed.
 	 */
 	@ModifyConstant(
-		method = "vertex(Lnet/minecraft/client/render/VertexConsumer;FFFFFFFFI)V",
+		method = "vertex(Lcom/mojang/blaze3d/vertex/VertexConsumer;FFFFFFFFI)V",
 		constant = @Constant(floatValue = 1F, ordinal = 0))
 	private float modifyOpacity(float original)
 	{
diff --git a/src/main/java/net/wurstclient/mixin/FogRendererMixin.java b/src/main/java/net/wurstclient/mixin/FogRendererMixin.java
index 7cad8eece..023c954f6 100644
--- a/src/main/java/net/wurstclient/mixin/FogRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/FogRendererMixin.java
@@ -15,8 +15,7 @@ import org.spongepowered.asm.mixin.injection.At;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.render.fog.FogRenderer;
+import net.minecraft.client.renderer.fog.FogRenderer;
 import net.wurstclient.WurstClient;
 
 @Mixin(FogRenderer.class)
@@ -27,9 +26,9 @@ public class FogRendererMixin
 	 * NoFog is enabled.
 	 */
 	@WrapOperation(
-		method = "applyFog(Lnet/minecraft/client/render/Camera;IZLnet/minecraft/client/render/RenderTickCounter;FLnet/minecraft/client/world/ClientWorld;)Lorg/joml/Vector4f;",
+		method = "setupFog(Lnet/minecraft/client/Camera;IZLnet/minecraft/client/DeltaTracker;FLnet/minecraft/client/multiplayer/ClientLevel;)Lorg/joml/Vector4f;",
 		at = @At(value = "INVOKE",
-			target = "Lnet/minecraft/client/render/fog/FogRenderer;applyFog(Ljava/nio/ByteBuffer;ILorg/joml/Vector4f;FFFFFF)V"))
+			target = "Lnet/minecraft/client/renderer/fog/FogRenderer;updateBuffer(Ljava/nio/ByteBuffer;ILorg/joml/Vector4f;FFFFFF)V"))
 	private void wrapApplyFog(FogRenderer instance, ByteBuffer buffer,
 		int bufPos, Vector4f fogColor, float environmentalStart,
 		float environmentalEnd, float renderDistanceStart,
diff --git a/src/main/java/net/wurstclient/mixin/GameMenuScreenMixin.java b/src/main/java/net/wurstclient/mixin/GameMenuScreenMixin.java
index f28b88dd7..8851249fd 100644
--- a/src/main/java/net/wurstclient/mixin/GameMenuScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/GameMenuScreenMixin.java
@@ -17,30 +17,30 @@ import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.GameMenuScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.resource.language.I18n;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.PauseScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.resources.language.I18n;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.wurstclient.WurstClient;
 import net.wurstclient.options.WurstOptionsScreen;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
-@Mixin(GameMenuScreen.class)
+@Mixin(PauseScreen.class)
 public abstract class GameMenuScreenMixin extends Screen
 {
 	@Unique
-	private ButtonWidget wurstOptionsButton;
+	private Button wurstOptionsButton;
 	
-	private GameMenuScreenMixin(WurstClient wurst, Text title)
+	private GameMenuScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
 	
-	@Inject(at = @At("TAIL"), method = "initWidgets()V")
+	@Inject(at = @At("TAIL"), method = "createPauseMenu()V")
 	private void onInitWidgets(CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
@@ -50,8 +50,8 @@ public abstract class GameMenuScreenMixin extends Screen
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "render(Lnet/minecraft/client/gui/DrawContext;IIF)V")
-	private void onRender(DrawContext context, int mouseX, int mouseY,
+		method = "render(Lnet/minecraft/client/gui/GuiGraphics;IIF)V")
+	private void onRender(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks, CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.isEnabled() || wurstOptionsButton == null)
@@ -61,7 +61,7 @@ public abstract class GameMenuScreenMixin extends Screen
 	@Unique
 	private void addWurstOptionsButton()
 	{
-		List<ClickableWidget> buttons = Screens.getButtons(this);
+		List<AbstractWidget> buttons = Screens.getButtons(this);
 		
 		// Fallback position
 		int buttonX = width / 2 - 102;
@@ -69,7 +69,7 @@ public abstract class GameMenuScreenMixin extends Screen
 		int buttonWidth = 204;
 		int buttonHeight = 20;
 		
-		for(ClickableWidget button : buttons)
+		for(AbstractWidget button : buttons)
 		{
 			// If feedback button exists, use its position
 			if(isTrKey(button, "menu.sendFeedback")
@@ -94,17 +94,16 @@ public abstract class GameMenuScreenMixin extends Screen
 		// Create Wurst Options button with full label instead of padded spaces
 		String label =
 			NiceWurstModule.getOptionsLabel("Wurst 7 CevAPI Options");
-		MutableText buttonText = Text.literal(label);
-		wurstOptionsButton = ButtonWidget
-			.builder(buttonText, b -> openWurstOptions())
-			.dimensions(buttonX, buttonY, buttonWidth, buttonHeight).build();
+		MutableComponent buttonText = Component.literal(label);
+		wurstOptionsButton = Button.builder(buttonText, b -> openWurstOptions())
+			.bounds(buttonX, buttonY, buttonWidth, buttonHeight).build();
 		buttons.add(wurstOptionsButton);
 	}
 	
 	@Unique
 	private void hideFeedbackReportAndServerLinksButtons()
 	{
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 			if(isTrKey(button, "menu.sendFeedback")
 				|| isTrKey(button, "menu.reportBugs")
 				|| isTrKey(button, "menu.feedback")
@@ -116,8 +115,8 @@ public abstract class GameMenuScreenMixin extends Screen
 	private void ensureSpaceAvailable(int x, int y, int width, int height)
 	{
 		// Check if there are any buttons in the way
-		ArrayList<ClickableWidget> buttonsInTheWay = new ArrayList<>();
-		for(ClickableWidget button : Screens.getButtons(this))
+		ArrayList<AbstractWidget> buttonsInTheWay = new ArrayList<>();
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
 			if(button.getRight() < x || button.getX() > x + width
 				|| button.getBottom() < y || button.getY() > y + height)
@@ -135,20 +134,20 @@ public abstract class GameMenuScreenMixin extends Screen
 		
 		// If yes, clear space below and move the buttons there
 		ensureSpaceAvailable(x, y + 24, width, height);
-		for(ClickableWidget button : buttonsInTheWay)
+		for(AbstractWidget button : buttonsInTheWay)
 			button.setY(button.getY() + 24);
 	}
 	
 	@Unique
 	private void openWurstOptions()
 	{
-		client.setScreen(new WurstOptionsScreen(this));
+		minecraft.setScreen(new WurstOptionsScreen(this));
 	}
 	
 	@Unique
-	private boolean isTrKey(ClickableWidget button, String key)
+	private boolean isTrKey(AbstractWidget button, String key)
 	{
 		String message = button.getMessage().getString();
-		return message != null && message.equals(I18n.translate(key));
+		return message != null && message.equals(I18n.get(key));
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/GameRendererMixin.java b/src/main/java/net/wurstclient/mixin/GameRendererMixin.java
index 988658297..1b892513b 100644
--- a/src/main/java/net/wurstclient/mixin/GameRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/GameRendererMixin.java
@@ -16,12 +16,11 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 import com.llamalad7.mixinextras.injector.ModifyReturnValue;
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.render.GameRenderer;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.hit.HitResult;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.renderer.GameRenderer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.CameraTransformViewBobbingListener.CameraTransformViewBobbingEvent;
@@ -31,10 +30,10 @@ import net.wurstclient.hacks.FullbrightHack;
 public abstract class GameRendererMixin implements AutoCloseable
 {
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/render/GameRenderer;bobView(Lnet/minecraft/client/util/math/MatrixStack;F)V",
+		target = "Lnet/minecraft/client/renderer/GameRenderer;bobView(Lcom/mojang/blaze3d/vertex/PoseStack;F)V",
 		ordinal = 0),
-		method = "renderWorld(Lnet/minecraft/client/render/RenderTickCounter;)V")
-	private void onBobView(GameRenderer instance, MatrixStack matrices,
+		method = "renderLevel(Lnet/minecraft/client/DeltaTracker;)V")
+	private void onBobView(GameRenderer instance, PoseStack matrices,
 		float tickDelta, Operation<Void> original)
 	{
 		CameraTransformViewBobbingEvent event =
@@ -46,7 +45,7 @@ public abstract class GameRendererMixin implements AutoCloseable
 	}
 	
 	@ModifyReturnValue(at = @At("RETURN"),
-		method = "getFov(Lnet/minecraft/client/render/Camera;FZ)F")
+		method = "getFov(Lnet/minecraft/client/Camera;FZ)F")
 	private float onGetFov(float original)
 	{
 		return WurstClient.INSTANCE.getOtfs().zoomOtf
@@ -57,9 +56,9 @@ public abstract class GameRendererMixin implements AutoCloseable
 	 * This is the part that makes Liquids work.
 	 */
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/entity/Entity;raycast(DFZ)Lnet/minecraft/util/hit/HitResult;",
+		target = "Lnet/minecraft/world/entity/Entity;pick(DFZ)Lnet/minecraft/world/phys/HitResult;",
 		ordinal = 0),
-		method = "findCrosshairTarget(Lnet/minecraft/entity/Entity;DDF)Lnet/minecraft/util/hit/HitResult;")
+		method = "pick(Lnet/minecraft/world/entity/Entity;DDF)Lnet/minecraft/world/phys/HitResult;")
 	private HitResult liquidsRaycast(Entity instance, double maxDistance,
 		float tickDelta, boolean includeFluids, Operation<HitResult> original)
 	{
@@ -72,9 +71,9 @@ public abstract class GameRendererMixin implements AutoCloseable
 	
 	@WrapOperation(
 		at = @At(value = "INVOKE",
-			target = "Lnet/minecraft/util/math/MathHelper;lerp(FFF)F",
+			target = "Lnet/minecraft/util/Mth;lerp(FFF)F",
 			ordinal = 0),
-		method = "renderWorld(Lnet/minecraft/client/render/RenderTickCounter;)V")
+		method = "renderLevel(Lnet/minecraft/client/DeltaTracker;)V")
 	private float onRenderWorldNauseaLerp(float delta, float start, float end,
 		Operation<Float> original)
 	{
@@ -85,7 +84,7 @@ public abstract class GameRendererMixin implements AutoCloseable
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getNightVisionStrength(Lnet/minecraft/entity/LivingEntity;F)F",
+		method = "getNightVisionScale(Lnet/minecraft/world/entity/LivingEntity;F)F",
 		cancellable = true)
 	private static void onGetNightVisionStrength(LivingEntity entity,
 		float tickDelta, CallbackInfoReturnable<Float> cir)
@@ -98,9 +97,9 @@ public abstract class GameRendererMixin implements AutoCloseable
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "tiltViewWhenHurt(Lnet/minecraft/client/util/math/MatrixStack;F)V",
+		method = "bobHurt(Lcom/mojang/blaze3d/vertex/PoseStack;F)V",
 		cancellable = true)
-	private void onTiltViewWhenHurt(MatrixStack matrices, float tickDelta,
+	private void onTiltViewWhenHurt(PoseStack matrices, float tickDelta,
 		CallbackInfo ci)
 	{
 		if(WurstClient.INSTANCE.getHax().noHurtcamHack.isEnabled())
diff --git a/src/main/java/net/wurstclient/mixin/GenericContainerScreenMixin.java b/src/main/java/net/wurstclient/mixin/GenericContainerScreenMixin.java
index 2e92c3189..988a59bf6 100644
--- a/src/main/java/net/wurstclient/mixin/GenericContainerScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/GenericContainerScreenMixin.java
@@ -14,21 +14,28 @@ import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.ingame.GenericContainerScreen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.screen.GenericContainerScreenHandler;
-import net.minecraft.screen.ScreenHandlerContext;
-import net.minecraft.text.Text;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.state.property.Properties;
-
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.ContainerScreen;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.ChestMenu;
+import net.minecraft.world.inventory.ContainerLevelAccess;
+import net.minecraft.world.level.block.BarrelBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.DecoratedPotBlock;
+import net.minecraft.world.level.block.EnderChestBlock;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.ChestType;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.WurstClient;
 import net.wurstclient.chestsearch.ChestConfig;
 import net.wurstclient.chestsearch.ChestRecorder;
@@ -36,23 +43,13 @@ import net.wurstclient.clickgui.screens.ChestSearchScreen;
 import net.wurstclient.hacks.AutoStealHack;
 import net.wurstclient.hacks.QuickShulkerHack;
 
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.ChestBlock;
-import net.minecraft.block.EnderChestBlock;
-import net.minecraft.block.ShulkerBoxBlock;
-import net.minecraft.block.BarrelBlock;
-import net.minecraft.block.DecoratedPotBlock;
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.block.enums.ChestType;
-
-@Mixin(GenericContainerScreen.class)
+@Mixin(ContainerScreen.class)
 public abstract class GenericContainerScreenMixin
-	extends HandledScreen<GenericContainerScreenHandler>
+	extends AbstractContainerScreen<ChestMenu>
 {
 	@Shadow
 	@Final
-	private int rows;
+	private int containerRows;
 	
 	@Unique
 	private final AutoStealHack autoSteal =
@@ -84,9 +81,8 @@ public abstract class GenericContainerScreenMixin
 	@Unique
 	private long lastRecordUntilMs = 0L;
 	
-	public GenericContainerScreenMixin(WurstClient wurst,
-		GenericContainerScreenHandler container,
-		PlayerInventory playerInventory, Text name)
+	public GenericContainerScreenMixin(WurstClient wurst, ChestMenu container,
+		Inventory playerInventory, Component name)
 	{
 		super(container, playerInventory, name);
 	}
@@ -99,17 +95,18 @@ public abstract class GenericContainerScreenMixin
 			return;
 		if(autoSteal.areButtonsVisible())
 		{
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Steal"),
-					b -> autoSteal.steal(this, rows))
-				.dimensions(x + backgroundWidth - 108, y + 4, 50, 12).build());
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Store"),
-					b -> autoSteal.store(this, rows))
-				.dimensions(x + backgroundWidth - 56, y + 4, 50, 12).build());
+			addRenderableWidget(Button
+				.builder(Component.literal("Steal"),
+					b -> autoSteal.steal(this, containerRows))
+				.bounds(leftPos + imageWidth - 108, topPos + 4, 50, 12)
+				.build());
+			addRenderableWidget(Button
+				.builder(Component.literal("Store"),
+					b -> autoSteal.store(this, containerRows))
+				.bounds(leftPos + imageWidth - 56, topPos + 4, 50, 12).build());
 		}
 		if(autoSteal.isEnabled())
-			autoSteal.steal(this, rows);
+			autoSteal.steal(this, containerRows);
 		
 		QuickShulkerHack quickShulker =
 			WurstClient.INSTANCE.getHax().quickShulkerHack;
@@ -120,12 +117,12 @@ public abstract class GenericContainerScreenMixin
 			// visually outside the chest/inventory GUI. Use the same
 			// positioning/size as the inventory screen button so it
 			// appears outside the form consistently.
-			ButtonWidget quickButton = ButtonWidget
-				.builder(Text.literal("QuickShulker"),
+			Button quickButton = Button
+				.builder(Component.literal("QuickShulker"),
 					b -> quickShulker.triggerFromGui())
-				.dimensions(x + backgroundWidth - 90, y - 20, 80, 16).build();
+				.bounds(leftPos + imageWidth - 90, topPos - 20, 80, 16).build();
 			quickButton.active = !quickShulker.isBusy();
-			addDrawableChild(quickButton);
+			addRenderableWidget(quickButton);
 		}
 		
 		// Add a manual scan button to help on plugin-protected servers when
@@ -143,9 +140,9 @@ public abstract class GenericContainerScreenMixin
 			}catch(Throwable ignored)
 			{}
 			if(showScan)
-				addDrawableChild(ButtonWidget
-					.builder(Text.literal("Scan"), b -> startManualScan())
-					.dimensions(x + 6, y + 4, 50, 12).build());
+				addRenderableWidget(Button
+					.builder(Component.literal("Scan"), b -> startManualScan())
+					.bounds(leftPos + 6, topPos + 4, 50, 12).build());
 		}catch(Throwable ignored)
 		{}
 		
@@ -166,16 +163,16 @@ public abstract class GenericContainerScreenMixin
 			try
 			{
 				if(WurstClient.MC != null
-					&& WurstClient.MC.getCurrentServerEntry() != null)
-					serverIp = WurstClient.MC.getCurrentServerEntry().address;
+					&& WurstClient.MC.getCurrentServer() != null)
+					serverIp = WurstClient.MC.getCurrentServer().ip;
 			}catch(Throwable ignored)
 			{}
 			String dimension = null;
 			try
 			{
-				if(WurstClient.MC != null && WurstClient.MC.world != null)
-					dimension = WurstClient.MC.world.getRegistryKey().getValue()
-						.toString();
+				if(WurstClient.MC != null && WurstClient.MC.level != null)
+					dimension =
+						WurstClient.MC.level.dimension().location().toString();
 			}catch(Throwable ignored)
 			{}
 			
@@ -185,11 +182,11 @@ public abstract class GenericContainerScreenMixin
 			try
 			{
 				java.lang.reflect.Method gb =
-					this.handler.getClass().getMethod("getBlockEntity");
-				Object be = gb.invoke(this.handler);
+					this.menu.getClass().getMethod("getBlockEntity");
+				Object be = gb.invoke(this.menu);
 				if(be instanceof BlockEntity)
 				{
-					resolvedPos = ((BlockEntity)be).getPos();
+					resolvedPos = ((BlockEntity)be).getBlockPos();
 					if(resolvedPos != null)
 					{
 						// debug removed
@@ -205,7 +202,7 @@ public abstract class GenericContainerScreenMixin
 				// crosshair fallback
 				try
 				{
-					HitResult hr = WurstClient.MC.crosshairTarget;
+					HitResult hr = WurstClient.MC.hitResult;
 					if(hr instanceof BlockHitResult bhr)
 					{
 						BlockPos bp = bhr.getBlockPos();
@@ -228,25 +225,25 @@ public abstract class GenericContainerScreenMixin
 					try
 					{
 						java.lang.reflect.Method m =
-							this.handler.getClass().getMethod("getContext");
-						ctxObj = m.invoke(this.handler);
+							this.menu.getClass().getMethod("getContext");
+						ctxObj = m.invoke(this.menu);
 					}catch(Throwable ignored)
 					{}
 					if(ctxObj == null)
 					{
 						try
 						{
-							java.lang.reflect.Field f = this.handler.getClass()
+							java.lang.reflect.Field f = this.menu.getClass()
 								.getDeclaredField("context");
 							f.setAccessible(true);
-							ctxObj = f.get(this.handler);
+							ctxObj = f.get(this.menu);
 						}catch(Throwable ignored)
 						{}
 					}
-					if(ctxObj instanceof ScreenHandlerContext ctx)
+					if(ctxObj instanceof ContainerLevelAccess ctx)
 					{
 						BlockPos[] holder = new BlockPos[1];
-						ctx.run((world, pos) -> holder[0] = pos);
+						ctx.execute((world, pos) -> holder[0] = pos);
 						if(holder[0] != null)
 						{
 							resolvedPos = holder[0];
@@ -262,8 +259,8 @@ public abstract class GenericContainerScreenMixin
 			{
 				try
 				{
-					Object inv = this.handler.getClass()
-						.getMethod("getInventory").invoke(this.handler);
+					Object inv = this.menu.getClass().getMethod("getInventory")
+						.invoke(this.menu);
 					if(inv != null)
 					{
 						try
@@ -322,32 +319,32 @@ public abstract class GenericContainerScreenMixin
 				try
 				{
 					if(WurstClient.MC != null && WurstClient.MC.player != null
-						&& WurstClient.MC.world != null)
+						&& WurstClient.MC.level != null)
 					{
 						var player = WurstClient.MC.player;
-						net.minecraft.util.math.Vec3d eye =
-							player.getCameraPosVec(1.0f);
-						net.minecraft.util.math.Vec3d look =
-							player.getRotationVec(1.0f).normalize();
-						BlockPos pcenter = player.getBlockPos();
+						net.minecraft.world.phys.Vec3 eye =
+							player.getEyePosition(1.0f);
+						net.minecraft.world.phys.Vec3 look =
+							player.getViewVector(1.0f).normalize();
+						BlockPos pcenter = player.blockPosition();
 						BlockPos best = null;
 						double bestScore = -1e9;
 						for(int dx = -2; dx <= 2; dx++)
 							for(int dy = -1; dy <= 2; dy++)
 								for(int dz = -2; dz <= 2; dz++)
 								{
-									BlockPos c = pcenter.add(dx, dy, dz);
+									BlockPos c = pcenter.offset(dx, dy, dz);
 									BlockState s =
-										WurstClient.MC.world.getBlockState(c);
+										WurstClient.MC.level.getBlockState(c);
 									if(!(s.getBlock() instanceof ChestBlock))
 										continue;
-									net.minecraft.util.math.Vec3d center =
-										new net.minecraft.util.math.Vec3d(
+									net.minecraft.world.phys.Vec3 center =
+										new net.minecraft.world.phys.Vec3(
 											c.getX() + 0.5, c.getY() + 0.5,
 											c.getZ() + 0.5);
-									double dist = center.squaredDistanceTo(eye);
-									double align = look.dotProduct(
-										center.subtract(eye).normalize());
+									double dist = center.distanceToSqr(eye);
+									double align = look
+										.dot(center.subtract(eye).normalize());
 									double score = 2.0 - dist * 0.01
 										+ Math.max(0, align) * 0.5;
 									if(score > bestScore)
@@ -402,7 +399,7 @@ public abstract class GenericContainerScreenMixin
 				}catch(Throwable ignored)
 				{}
 			}
-			final int chestSlots = Math.max(0, rows * 9);
+			final int chestSlots = Math.max(0, containerRows * 9);
 			// prepare slot order in outer scope so fallback branches can reuse
 			java.util.List<Integer> chestSlotIndices =
 				new java.util.ArrayList<>();
@@ -415,16 +412,17 @@ public abstract class GenericContainerScreenMixin
 					// Prefer reading from handler.slots (client-side view)
 					try
 					{
-						java.util.List<net.minecraft.item.ItemStack> all =
+						java.util.List<net.minecraft.world.item.ItemStack> all =
 							new java.util.ArrayList<>();
-						for(int i = 0; i < this.handler.slots.size(); i++)
+						for(int i = 0; i < this.menu.slots.size(); i++)
 						{
 							try
 							{
-								all.add(this.handler.slots.get(i).getStack());
+								all.add(this.menu.slots.get(i).getItem());
 							}catch(Throwable ignored)
 							{
-								all.add(net.minecraft.item.ItemStack.EMPTY);
+								all.add(
+									net.minecraft.world.item.ItemStack.EMPTY);
 							}
 						}
 						// determine candidate slots that belong to chest (not
@@ -460,11 +458,11 @@ public abstract class GenericContainerScreenMixin
 							}
 						}catch(Throwable ignored)
 						{}
-						for(int i = 0; i < this.handler.slots.size(); i++)
+						for(int i = 0; i < this.menu.slots.size(); i++)
 						{
 							try
 							{
-								Object slot = this.handler.slots.get(i);
+								Object slot = this.menu.slots.get(i);
 								Class<?> sc = slot.getClass();
 								Object inv = null;
 								// strategy 1: field named "inventory"
@@ -525,7 +523,7 @@ public abstract class GenericContainerScreenMixin
 								{}
 								// as a safety, if index is within last 36 slots
 								// (typical player inv range), mark as player
-								int totalSlots = this.handler.slots.size();
+								int totalSlots = this.menu.slots.size();
 								if(!isPlayerInv && totalSlots >= 36
 									&& i >= totalSlots - 36)
 									isPlayerInv = true;
@@ -578,47 +576,49 @@ public abstract class GenericContainerScreenMixin
 						// otherwise fallback to old heuristic
 						if(bestStartIdx >= 0 && bestLen > 0)
 						{
-							int window =
-								Math.min(bestLen, Math.max(0, rows * 9));
+							int window = Math.min(bestLen,
+								Math.max(0, containerRows * 9));
 							chestSlotIndices.clear();
 							for(int ii = 0; ii < window && bestStartIdx
-								+ ii < this.handler.slots.size(); ii++)
+								+ ii < this.menu.slots.size(); ii++)
 								chestSlotIndices.add(bestStartIdx + ii);
 							System.out.println(
 								"[ChestRecorder] detected chest region start="
 									+ bestStartIdx + " len=" + window);
 						}else
 						{
-							int window = Math.min(Math.max(0, rows * 9),
-								this.handler.slots.size());
+							int window =
+								Math.min(Math.max(0, containerRows * 9),
+									this.menu.slots.size());
 							System.out.println(
 								"[ChestRecorder] fallback chest region start="
 									+ 0 + " len=" + window);
 							chestSlotIndices.clear();
 							for(int ii = 0; ii < window
-								&& ii < this.handler.slots.size(); ii++)
+								&& ii < this.menu.slots.size(); ii++)
 								chestSlotIndices.add(ii);
 						}
 						java.util.List<Integer> slotOrder =
 							new java.util.ArrayList<>(chestSlotIndices);
 						if(slotOrder.isEmpty())
 						{
-							int fallbackWindow = Math.min(Math.max(0, rows * 9),
-								this.handler.slots.size());
+							int fallbackWindow =
+								Math.min(Math.max(0, containerRows * 9),
+									this.menu.slots.size());
 							for(int ii = 0; ii < fallbackWindow; ii++)
 								slotOrder.add(ii);
 						}
 						this.chestSlotOrder =
 							new java.util.ArrayList<>(slotOrder);
-						java.util.List<net.minecraft.item.ItemStack> region =
+						java.util.List<net.minecraft.world.item.ItemStack> region =
 							new java.util.ArrayList<>(slotOrder.size());
 						int nonEmpty = 0;
 						for(int idx : slotOrder)
 						{
-							net.minecraft.item.ItemStack s =
-								(idx >= 0 && idx < this.handler.slots.size())
-									? this.handler.slots.get(idx).getStack()
-									: net.minecraft.item.ItemStack.EMPTY;
+							net.minecraft.world.item.ItemStack s =
+								(idx >= 0 && idx < this.menu.slots.size())
+									? this.menu.slots.get(idx).getItem()
+									: net.minecraft.world.item.ItemStack.EMPTY;
 							region.add(s);
 							if(s != null && !s.isEmpty())
 								nonEmpty++;
@@ -643,8 +643,8 @@ public abstract class GenericContainerScreenMixin
 										GenericContainerScreenMixin.this.clickedZ;
 									try
 									{
-										var hr = WurstClient.MC.crosshairTarget;
-										if(hr instanceof net.minecraft.util.hit.BlockHitResult bhr)
+										var hr = WurstClient.MC.hitResult;
+										if(hr instanceof net.minecraft.world.phys.BlockHitResult bhr)
 										{
 											var bpos = bhr.getBlockPos();
 											if(bpos != null)
@@ -661,9 +661,8 @@ public abstract class GenericContainerScreenMixin
 										wurst$currentBounds());
 									// debug removed
 									chestRecorder.onChestOpened(fServerIp,
-										fDimension, px, py, pz, handler,
-										slotCount, slotOrder,
-										wurst$currentBounds());
+										fDimension, px, py, pz, menu, slotCount,
+										slotOrder, wurst$currentBounds());
 								}
 							}catch(Throwable ignored)
 							{}
@@ -675,15 +674,15 @@ public abstract class GenericContainerScreenMixin
 					}
 					// fallback to block entity read
 					BlockPos bp = new BlockPos(fx, fy, fz);
-					if(WurstClient.MC != null && WurstClient.MC.world != null)
+					if(WurstClient.MC != null && WurstClient.MC.level != null)
 					{
 						BlockEntity be =
-							WurstClient.MC.world.getBlockEntity(bp);
+							WurstClient.MC.level.getBlockEntity(bp);
 						if(be != null)
 						{
 							try
 							{
-								java.util.List<net.minecraft.item.ItemStack> stacks =
+								java.util.List<net.minecraft.world.item.ItemStack> stacks =
 									new java.util.ArrayList<>();
 								java.util.List<Integer> slotOrderEntity =
 									new java.util.ArrayList<>();
@@ -691,17 +690,16 @@ public abstract class GenericContainerScreenMixin
 								{
 									try
 									{
-										stacks
-											.add(
-												(net.minecraft.item.ItemStack)be
-													.getClass()
-													.getMethod("getStack",
-														int.class)
-													.invoke(be, i));
+										stacks.add(
+											(net.minecraft.world.item.ItemStack)be
+												.getClass()
+												.getMethod("getStack",
+													int.class)
+												.invoke(be, i));
 									}catch(Throwable ignored)
 									{
 										stacks.add(
-											net.minecraft.item.ItemStack.EMPTY);
+											net.minecraft.world.item.ItemStack.EMPTY);
 									}
 									slotOrderEntity.add(i);
 								}
@@ -722,9 +720,8 @@ public abstract class GenericContainerScreenMixin
 											GenericContainerScreenMixin.this.clickedZ;
 										try
 										{
-											var hr =
-												WurstClient.MC.crosshairTarget;
-											if(hr instanceof net.minecraft.util.hit.BlockHitResult bhr)
+											var hr = WurstClient.MC.hitResult;
+											if(hr instanceof net.minecraft.world.phys.BlockHitResult bhr)
 											{
 												var bpos = bhr.getBlockPos();
 												if(bpos != null)
@@ -753,7 +750,7 @@ public abstract class GenericContainerScreenMixin
 								if(chestSlotIndices.isEmpty())
 								{
 									for(int ii = 0; ii < Math.min(chestSlots,
-										this.handler.slots.size()); ii++)
+										this.menu.slots.size()); ii++)
 										chestSlotIndices.add(ii);
 								}
 								this.chestSlotOrder =
@@ -771,7 +768,7 @@ public abstract class GenericContainerScreenMixin
 											GenericContainerScreenMixin.this.clickedX,
 											GenericContainerScreenMixin.this.clickedY,
 											GenericContainerScreenMixin.this.clickedZ,
-											handler, chestSlotIndices.size(),
+											menu, chestSlotIndices.size(),
 											chestSlotIndices,
 											wurst$currentBounds());
 								}catch(Throwable ignored)
@@ -794,7 +791,7 @@ public abstract class GenericContainerScreenMixin
 				if(chestSlotIndices.isEmpty())
 				{
 					for(int ii = 0; ii < Math.min(chestSlots,
-						this.handler.slots.size()); ii++)
+						this.menu.slots.size()); ii++)
 						chestSlotIndices.add(ii);
 				}
 				java.util.List<Integer> slotOrder =
@@ -808,7 +805,7 @@ public abstract class GenericContainerScreenMixin
 						chestRecorder.onChestOpened(fServerIp, fDimension,
 							GenericContainerScreenMixin.this.clickedX,
 							GenericContainerScreenMixin.this.clickedY,
-							GenericContainerScreenMixin.this.clickedZ, handler,
+							GenericContainerScreenMixin.this.clickedZ, menu,
 							slotOrder.size(), slotOrder, wurst$currentBounds());
 				}catch(Throwable ignored)
 				{}
@@ -824,11 +821,11 @@ public abstract class GenericContainerScreenMixin
 				{
 					try
 					{
-						java.util.List<net.minecraft.item.ItemStack> all =
+						java.util.List<net.minecraft.world.item.ItemStack> all =
 							new java.util.ArrayList<>();
-						for(int i = 0; i < handler.slots.size(); i++)
+						for(int i = 0; i < menu.slots.size(); i++)
 						{
-							all.add(handler.slots.get(i).getStack());
+							all.add(menu.slots.get(i).getItem());
 						}
 						int total = all.size();
 						java.util.List<Integer> slotOrder =
@@ -836,19 +833,19 @@ public abstract class GenericContainerScreenMixin
 								GenericContainerScreenMixin.this.chestSlotOrder);
 						if(slotOrder.isEmpty())
 						{
-							int fallbackWindow =
-								Math.min(chestSlots, Math.min(total, rows * 9));
+							int fallbackWindow = Math.min(chestSlots,
+								Math.min(total, containerRows * 9));
 							for(int i = 0; i < fallbackWindow; i++)
 								slotOrder.add(i);
 						}
-						java.util.List<net.minecraft.item.ItemStack> region =
+						java.util.List<net.minecraft.world.item.ItemStack> region =
 							new java.util.ArrayList<>(slotOrder.size());
 						int nonEmpty = 0;
 						for(int idx : slotOrder)
 						{
-							net.minecraft.item.ItemStack stack =
+							net.minecraft.world.item.ItemStack stack =
 								(idx >= 0 && idx < total) ? all.get(idx)
-									: net.minecraft.item.ItemStack.EMPTY;
+									: net.minecraft.world.item.ItemStack.EMPTY;
 							region.add(stack);
 							if(stack != null && !stack.isEmpty())
 								nonEmpty++;
@@ -875,8 +872,8 @@ public abstract class GenericContainerScreenMixin
 										GenericContainerScreenMixin.this.clickedZ;
 									try
 									{
-										var hr = WurstClient.MC.crosshairTarget;
-										if(hr instanceof net.minecraft.util.hit.BlockHitResult bhr)
+										var hr = WurstClient.MC.hitResult;
+										if(hr instanceof net.minecraft.world.phys.BlockHitResult bhr)
 										{
 											var bpos = bhr.getBlockPos();
 											if(bpos != null)
@@ -925,40 +922,40 @@ public abstract class GenericContainerScreenMixin
 		try
 		{
 			final String serverIp = (WurstClient.MC != null
-				&& WurstClient.MC.getCurrentServerEntry() != null)
-					? WurstClient.MC.getCurrentServerEntry().address : null;
+				&& WurstClient.MC.getCurrentServer() != null)
+					? WurstClient.MC.getCurrentServer().ip : null;
 			final String dimension =
-				(WurstClient.MC != null && WurstClient.MC.world != null)
-					? WurstClient.MC.world.getRegistryKey().getValue()
-						.toString()
+				(WurstClient.MC != null && WurstClient.MC.level != null)
+					? WurstClient.MC.level.dimension().location().toString()
 					: null;
 			
 			java.util.List<Integer> slotOrder =
 				new java.util.ArrayList<>(this.chestSlotOrder);
 			if(slotOrder.isEmpty())
 			{
-				int limit =
-					Math.min(Math.max(0, rows * 9), this.handler.slots.size());
+				int limit = Math.min(Math.max(0, containerRows * 9),
+					this.menu.slots.size());
 				for(int i = 0; i < limit; i++)
 					slotOrder.add(i);
 			}
-			java.util.List<net.minecraft.item.ItemStack> region =
+			java.util.List<net.minecraft.world.item.ItemStack> region =
 				new java.util.ArrayList<>();
 			for(int idx : slotOrder)
 			{
-				net.minecraft.item.ItemStack s =
-					(idx >= 0 && idx < this.handler.slots.size())
-						? this.handler.slots.get(idx).getStack()
-						: net.minecraft.item.ItemStack.EMPTY;
-				region.add(s == null ? net.minecraft.item.ItemStack.EMPTY : s);
+				net.minecraft.world.item.ItemStack s =
+					(idx >= 0 && idx < this.menu.slots.size())
+						? this.menu.slots.get(idx).getItem()
+						: net.minecraft.world.item.ItemStack.EMPTY;
+				region.add(
+					s == null ? net.minecraft.world.item.ItemStack.EMPTY : s);
 			}
 			// choose primary position: prefer crosshair block the player was
 			// pointing at
 			int px = chestX, py = chestY, pz = chestZ;
 			try
 			{
-				var hr = WurstClient.MC.crosshairTarget;
-				if(hr instanceof net.minecraft.util.hit.BlockHitResult bhr)
+				var hr = WurstClient.MC.hitResult;
+				if(hr instanceof net.minecraft.world.phys.BlockHitResult bhr)
 				{
 					var bpos = bhr.getBlockPos();
 					if(bpos != null)
@@ -972,7 +969,7 @@ public abstract class GenericContainerScreenMixin
 			{}
 			
 			boolean any = false;
-			for(net.minecraft.item.ItemStack s : region)
+			for(net.minecraft.world.item.ItemStack s : region)
 				if(s != null && !s.isEmpty())
 				{
 					any = true;
@@ -987,16 +984,16 @@ public abstract class GenericContainerScreenMixin
 			Runnable doRecord = () -> {
 				try
 				{
-					java.util.List<net.minecraft.item.ItemStack> reg =
+					java.util.List<net.minecraft.world.item.ItemStack> reg =
 						new java.util.ArrayList<>();
 					for(int idx2 : fSlotOrder)
 					{
-						net.minecraft.item.ItemStack s2 =
-							(idx2 >= 0 && idx2 < this.handler.slots.size())
-								? this.handler.slots.get(idx2).getStack()
-								: net.minecraft.item.ItemStack.EMPTY;
-						reg.add(s2 == null ? net.minecraft.item.ItemStack.EMPTY
-							: s2);
+						net.minecraft.world.item.ItemStack s2 =
+							(idx2 >= 0 && idx2 < this.menu.slots.size())
+								? this.menu.slots.get(idx2).getItem()
+								: net.minecraft.world.item.ItemStack.EMPTY;
+						reg.add(s2 == null
+							? net.minecraft.world.item.ItemStack.EMPTY : s2);
 					}
 					chestRecorder.recordFromStacksWithSlotOrder(fServer, fDim,
 						fpx, fpy, fpz, reg, fSlotOrder, fBounds);
@@ -1034,14 +1031,13 @@ public abstract class GenericContainerScreenMixin
 			System.currentTimeMillis() + Math.max(500, durationMs);
 		System.out.println(
 			"[ChestRecorder] Manual scan started. Hover/click through chest slots.");
-		final int chestSlots = Math.max(0, rows * 9);
+		final int chestSlots = Math.max(0, containerRows * 9);
 		final String serverIp = (WurstClient.MC != null
-			&& WurstClient.MC.getCurrentServerEntry() != null)
-				? WurstClient.MC.getCurrentServerEntry().address : null;
+			&& WurstClient.MC.getCurrentServer() != null)
+				? WurstClient.MC.getCurrentServer().ip : null;
 		final String dimension =
-			(WurstClient.MC != null && WurstClient.MC.world != null)
-				? WurstClient.MC.world.getRegistryKey().getValue().toString()
-				: null;
+			(WurstClient.MC != null && WurstClient.MC.level != null)
+				? WurstClient.MC.level.dimension().location().toString() : null;
 		// choose chest position determined on open; fallback to crosshair, then
 		// player
 		BlockPos chosenPos = null;
@@ -1051,7 +1047,7 @@ public abstract class GenericContainerScreenMixin
 		{
 			try
 			{
-				HitResult hr = WurstClient.MC.crosshairTarget;
+				HitResult hr = WurstClient.MC.hitResult;
 				if(hr instanceof BlockHitResult bhr)
 				{
 					BlockPos bp = bhr.getBlockPos();
@@ -1062,7 +1058,7 @@ public abstract class GenericContainerScreenMixin
 			{}
 			if(chosenPos == null && WurstClient.MC != null
 				&& WurstClient.MC.player != null)
-				chosenPos = WurstClient.MC.player.getBlockPos();
+				chosenPos = WurstClient.MC.player.blockPosition();
 		}
 		final BlockPos bp =
 			chosenPos != null ? chosenPos : new BlockPos(0, 0, 0);
@@ -1075,7 +1071,7 @@ public abstract class GenericContainerScreenMixin
 				try
 				{
 					if(WurstClient.MC == null
-						|| WurstClient.MC.currentScreen != GenericContainerScreenMixin.this
+						|| WurstClient.MC.screen != GenericContainerScreenMixin.this
 						|| !manualScanActive
 						|| System.currentTimeMillis() > manualScanUntil)
 					{
@@ -1085,11 +1081,11 @@ public abstract class GenericContainerScreenMixin
 							.println("[ChestRecorder] Manual scan finished.");
 						return;
 					}
-					java.util.List<net.minecraft.item.ItemStack> all =
+					java.util.List<net.minecraft.world.item.ItemStack> all =
 						new java.util.ArrayList<>();
-					for(int i = 0; i < handler.slots.size(); i++)
+					for(int i = 0; i < menu.slots.size(); i++)
 					{
-						all.add(handler.slots.get(i).getStack());
+						all.add(menu.slots.get(i).getItem());
 					}
 					int total = all.size();
 					int window = Math.min(chestSlots, total);
@@ -1100,7 +1096,8 @@ public abstract class GenericContainerScreenMixin
 						int count = 0;
 						for(int i = 0; i < window; i++)
 						{
-							net.minecraft.item.ItemStack s = all.get(start + i);
+							net.minecraft.world.item.ItemStack s =
+								all.get(start + i);
 							if(s != null && !s.isEmpty())
 								count++;
 						}
@@ -1110,7 +1107,7 @@ public abstract class GenericContainerScreenMixin
 							bestStart = start;
 						}
 					}
-					java.util.List<net.minecraft.item.ItemStack> region =
+					java.util.List<net.minecraft.world.item.ItemStack> region =
 						new java.util.ArrayList<>(window);
 					java.util.List<Integer> slotOrder =
 						new java.util.ArrayList<>(window);
@@ -1137,7 +1134,7 @@ public abstract class GenericContainerScreenMixin
 	
 	// Replace hard override with a safe inject at TAIL to render overlay
 	@Inject(method = "render", at = @At("TAIL"))
-	private void wurst$renderOverlay(DrawContext context, int mouseX,
+	private void wurst$renderOverlay(GuiGraphics context, int mouseX,
 		int mouseY, float delta, CallbackInfo ci)
 	{
 		long now = System.currentTimeMillis();
@@ -1145,15 +1142,15 @@ public abstract class GenericContainerScreenMixin
 		{
 			int textX = this.width / 2 - 120;
 			int textY = this.height - 18; // near bottom
-			context.drawText(this.textRenderer, Text.literal(lastRecordMessage),
+			context.drawString(this.font, Component.literal(lastRecordMessage),
 				textX, textY, 0xFFFFFF00, false);
 		}else if(manualScanActive && !manualScanQuiet)
 		{
 			String hint = "Scanning... hover/click slots to reveal items";
 			int textX = this.width / 2 - 120;
 			int textY = this.height - 18;
-			context.drawText(this.textRenderer, Text.literal(hint), textX,
-				textY, 0xFFFFFF00, false);
+			context.drawString(this.font, Component.literal(hint), textX, textY,
+				0xFFFFFF00, false);
 		}
 	}
 	
@@ -1170,7 +1167,7 @@ public abstract class GenericContainerScreenMixin
 	{
 		try
 		{
-			if(this.chestRecorder == null || this.handler == null)
+			if(this.chestRecorder == null || this.menu == null)
 				return;
 			// Only finalize snapshot automatically if automatic mode is on
 			try
@@ -1188,21 +1185,21 @@ public abstract class GenericContainerScreenMixin
 			{
 				if(net.wurstclient.WurstClient.MC != null
 					&& net.wurstclient.WurstClient.MC
-						.getCurrentServerEntry() != null)
-					serverIp = net.wurstclient.WurstClient.MC
-						.getCurrentServerEntry().address;
+						.getCurrentServer() != null)
+					serverIp =
+						net.wurstclient.WurstClient.MC.getCurrentServer().ip;
 			}catch(Throwable ignored)
 			{}
 			try
 			{
 				if(net.wurstclient.WurstClient.MC != null
-					&& net.wurstclient.WurstClient.MC.world != null)
-					dimension = net.wurstclient.WurstClient.MC.world
-						.getRegistryKey().getValue().toString();
+					&& net.wurstclient.WurstClient.MC.level != null)
+					dimension = net.wurstclient.WurstClient.MC.level.dimension()
+						.location().toString();
 			}catch(Throwable ignored)
 			{}
-			int chestSlots = Math.max(0, this.rows * 9);
-			int total = this.handler.slots.size();
+			int chestSlots = Math.max(0, this.containerRows * 9);
+			int total = this.menu.slots.size();
 			java.util.List<Integer> slotOrder =
 				new java.util.ArrayList<>(this.chestSlotOrder);
 			if(slotOrder.isEmpty())
@@ -1211,14 +1208,14 @@ public abstract class GenericContainerScreenMixin
 				for(int i = 0; i < fallbackWindow; i++)
 					slotOrder.add(i);
 			}
-			java.util.List<net.minecraft.item.ItemStack> region =
+			java.util.List<net.minecraft.world.item.ItemStack> region =
 				new java.util.ArrayList<>(slotOrder.size());
 			boolean any = false;
 			for(int idx : slotOrder)
 			{
 				var st = (idx >= 0 && idx < total)
-					? this.handler.slots.get(idx).getStack()
-					: net.minecraft.item.ItemStack.EMPTY;
+					? this.menu.slots.get(idx).getItem()
+					: net.minecraft.world.item.ItemStack.EMPTY;
 				region.add(st);
 				if(st != null && !st.isEmpty())
 					any = true;
@@ -1237,14 +1234,14 @@ public abstract class GenericContainerScreenMixin
 	private BlockPos wurst$normalizeContainerPos(BlockPos pos)
 	{
 		if(pos == null || WurstClient.MC == null
-			|| WurstClient.MC.world == null)
+			|| WurstClient.MC.level == null)
 			return pos;
 		BlockPos current = pos;
-		BlockState state = WurstClient.MC.world.getBlockState(current);
+		BlockState state = WurstClient.MC.level.getBlockState(current);
 		if(!wurst$isTrackableContainer(state))
 		{
-			BlockPos below = current.down();
-			BlockState belowState = WurstClient.MC.world.getBlockState(below);
+			BlockPos below = current.below();
+			BlockState belowState = WurstClient.MC.level.getBlockState(below);
 			if(wurst$isTrackableContainer(belowState))
 			{
 				current = below;
@@ -1266,7 +1263,7 @@ public abstract class GenericContainerScreenMixin
 			{
 				for(Direction d : Direction.values())
 				{
-					if(d.asString().equalsIgnoreCase(fName))
+					if(d.getSerializedName().equalsIgnoreCase(fName))
 					{
 						facingDir = d;
 						break;
@@ -1277,14 +1274,14 @@ public abstract class GenericContainerScreenMixin
 			{
 				try
 				{
-					facingDir = state.get(ChestBlock.FACING);
+					facingDir = state.getValue(ChestBlock.FACING);
 				}catch(Throwable ignored)
 				{}
 			}
 		}catch(Throwable ignored)
 		{}
 		if(facingDir != null)
-			this.chestFacing = facingDir.asString();
+			this.chestFacing = facingDir.getSerializedName();
 		
 		// If chest block, try to find its connected pair
 		if(state.getBlock() instanceof ChestBlock)
@@ -1301,12 +1298,13 @@ public abstract class GenericContainerScreenMixin
 						try
 						{
 							String of = wurst$getFacingName(
-								WurstClient.MC.world.getBlockState(other));
+								WurstClient.MC.level.getBlockState(other));
 							if(of != null)
 							{
 								for(Direction d : Direction.values())
 								{
-									if(d.asString().equalsIgnoreCase(of))
+									if(d.getSerializedName()
+										.equalsIgnoreCase(of))
 									{
 										facingDir = d;
 										break;
@@ -1363,13 +1361,13 @@ public abstract class GenericContainerScreenMixin
 					try
 					{
 						BlockEntity beL =
-							WurstClient.MC.world.getBlockEntity(minPos);
-						if(beL instanceof net.minecraft.block.entity.LockableContainerBlockEntity)
+							WurstClient.MC.level.getBlockEntity(minPos);
+						if(beL instanceof net.minecraft.world.level.block.entity.BaseContainerBlockEntity)
 						{
-							var inv = (net.minecraft.inventory.Inventory)beL;
-							for(int i = 0; i < inv.size(); i++)
-								if(inv.getStack(i) != null
-									&& !inv.getStack(i).isEmpty())
+							var inv = (net.minecraft.world.Container)beL;
+							for(int i = 0; i < inv.getContainerSize(); i++)
+								if(inv.getItem(i) != null
+									&& !inv.getItem(i).isEmpty())
 								{
 									leftHasItems = true;
 									break;
@@ -1380,13 +1378,13 @@ public abstract class GenericContainerScreenMixin
 					try
 					{
 						BlockEntity beR =
-							WurstClient.MC.world.getBlockEntity(maxPos);
-						if(beR instanceof net.minecraft.block.entity.LockableContainerBlockEntity)
+							WurstClient.MC.level.getBlockEntity(maxPos);
+						if(beR instanceof net.minecraft.world.level.block.entity.BaseContainerBlockEntity)
 						{
-							var inv = (net.minecraft.inventory.Inventory)beR;
-							for(int i = 0; i < inv.size(); i++)
-								if(inv.getStack(i) != null
-									&& !inv.getStack(i).isEmpty())
+							var inv = (net.minecraft.world.Container)beR;
+							for(int i = 0; i < inv.getContainerSize(); i++)
+								if(inv.getItem(i) != null
+									&& !inv.getItem(i).isEmpty())
 								{
 									rightHasItems = true;
 									break;
@@ -1482,22 +1480,22 @@ public abstract class GenericContainerScreenMixin
 		try
 		{
 			if(WurstClient.MC == null || WurstClient.MC.player == null
-				|| WurstClient.MC.world == null)
+				|| WurstClient.MC.level == null)
 				return null;
 			var player = WurstClient.MC.player;
-			net.minecraft.util.math.Vec3d eye = player.getCameraPosVec(1.0f);
-			net.minecraft.util.math.Vec3d look = player.getRotationVec(1.0f);
+			net.minecraft.world.phys.Vec3 eye = player.getEyePosition(1.0f);
+			net.minecraft.world.phys.Vec3 look = player.getViewVector(1.0f);
 			double reach = 5.0;
-			net.minecraft.util.math.Vec3d end =
+			net.minecraft.world.phys.Vec3 end =
 				eye.add(look.x * reach, look.y * reach, look.z * reach);
 			int steps = 40;
 			for(int i = 0; i <= steps; i++)
 			{
 				double t = (double)i / (double)steps;
-				net.minecraft.util.math.Vec3d p =
-					eye.multiply(1.0 - t).add(end.multiply(t));
-				BlockPos bp = BlockPos.ofFloored(p);
-				BlockState s = WurstClient.MC.world.getBlockState(bp);
+				net.minecraft.world.phys.Vec3 p =
+					eye.scale(1.0 - t).add(end.scale(t));
+				BlockPos bp = BlockPos.containing(p);
+				BlockState s = WurstClient.MC.level.getBlockState(bp);
 				if(s.getBlock() instanceof ChestBlock)
 					return bp;
 			}
@@ -1513,15 +1511,17 @@ public abstract class GenericContainerScreenMixin
 			return null;
 		try
 		{
-			if(state.contains(Properties.HORIZONTAL_FACING))
-				return state.get(Properties.HORIZONTAL_FACING).asString();
-			if(state.contains(Properties.FACING))
-				return state.get(Properties.FACING).asString();
+			if(state.hasProperty(BlockStateProperties.HORIZONTAL_FACING))
+				return state.getValue(BlockStateProperties.HORIZONTAL_FACING)
+					.getSerializedName();
+			if(state.hasProperty(BlockStateProperties.FACING))
+				return state.getValue(BlockStateProperties.FACING)
+					.getSerializedName();
 			try
 			{
-				Direction d = state.get(ChestBlock.FACING);
+				Direction d = state.getValue(ChestBlock.FACING);
 				if(d != null)
-					return d.asString();
+					return d.getSerializedName();
 			}catch(Throwable ignored)
 			{}
 		}catch(Throwable ignored)
@@ -1533,16 +1533,16 @@ public abstract class GenericContainerScreenMixin
 	private BlockPos wurst$findConnectedChest(BlockPos current,
 		BlockState state, Direction facing)
 	{
-		if(WurstClient.MC == null || WurstClient.MC.world == null)
+		if(WurstClient.MC == null || WurstClient.MC.level == null)
 			return null;
 		try
 		{
 			for(Direction d : new Direction[]{Direction.NORTH, Direction.SOUTH,
 				Direction.WEST, Direction.EAST})
 			{
-				BlockPos candidate = current.offset(d);
+				BlockPos candidate = current.relative(d);
 				BlockState other =
-					WurstClient.MC.world.getBlockState(candidate);
+					WurstClient.MC.level.getBlockState(candidate);
 				if(!(other.getBlock() instanceof ChestBlock))
 					continue;
 				try
@@ -1550,13 +1550,13 @@ public abstract class GenericContainerScreenMixin
 					Direction of = null;
 					try
 					{
-						of = other.get(ChestBlock.FACING);
+						of = other.getValue(ChestBlock.FACING);
 					}catch(Throwable ignored)
 					{}
 					ChestType ot = null;
 					try
 					{
-						ot = other.get(ChestBlock.CHEST_TYPE);
+						ot = other.getValue(ChestBlock.TYPE);
 					}catch(Throwable ignored)
 					{}
 					if(ot != ChestType.SINGLE)
@@ -1574,7 +1574,7 @@ public abstract class GenericContainerScreenMixin
 	
 	@Unique
 	private void wurst$recordForBounds(String serverIp, String dimension, int x,
-		int y, int z, java.util.List<net.minecraft.item.ItemStack> stacks,
+		int y, int z, java.util.List<net.minecraft.world.item.ItemStack> stacks,
 		java.util.List<Integer> slotOrder, ChestRecorder.Bounds bounds)
 	{
 		try
diff --git a/src/main/java/net/wurstclient/mixin/GrindstoneScreenMixin.java b/src/main/java/net/wurstclient/mixin/GrindstoneScreenMixin.java
index 37abdde7a..01347288b 100644
--- a/src/main/java/net/wurstclient/mixin/GrindstoneScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/GrindstoneScreenMixin.java
@@ -9,26 +9,25 @@ package net.wurstclient.mixin;
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
-
-import net.minecraft.client.gui.screen.ingame.GrindstoneScreen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.screen.GrindstoneScreenHandler;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.GrindstoneScreen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.GrindstoneMenu;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoDisenchantHack;
 
 @Mixin(GrindstoneScreen.class)
 public abstract class GrindstoneScreenMixin
-	extends HandledScreen<GrindstoneScreenHandler>
+	extends AbstractContainerScreen<GrindstoneMenu>
 {
 	@Unique
 	private final AutoDisenchantHack autoDisenchant =
 		WurstClient.INSTANCE.getHax().autoDisenchantHack;
 	
-	private GrindstoneScreenMixin(WurstClient wurst,
-		GrindstoneScreenHandler handler, PlayerInventory inventory, Text title)
+	private GrindstoneScreenMixin(WurstClient wurst, GrindstoneMenu handler,
+		Inventory inventory, Component title)
 	{
 		super(handler, inventory, title);
 	}
@@ -41,10 +40,10 @@ public abstract class GrindstoneScreenMixin
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("AutoDisenchant"),
+		addRenderableWidget(Button
+			.builder(Component.literal("AutoDisenchant"),
 				b -> autoDisenchant.start((GrindstoneScreen)(Object)this))
-			.dimensions(x + backgroundWidth - 110, y + 4, 106, 12).build());
+			.bounds(leftPos + imageWidth - 110, topPos + 4, 106, 12).build());
 		
 		if(autoDisenchant.isEnabled())
 			autoDisenchant.start((GrindstoneScreen)(Object)this);
diff --git a/src/main/java/net/wurstclient/mixin/HandledScreenAccessor.java b/src/main/java/net/wurstclient/mixin/HandledScreenAccessor.java
index a9ba59e1d..ec9b092c8 100644
--- a/src/main/java/net/wurstclient/mixin/HandledScreenAccessor.java
+++ b/src/main/java/net/wurstclient/mixin/HandledScreenAccessor.java
@@ -7,23 +7,22 @@
  */
 package net.wurstclient.mixin;
 
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-
-@Mixin(HandledScreen.class)
+@Mixin(AbstractContainerScreen.class)
 public interface HandledScreenAccessor
 {
-	@Accessor("x")
+	@Accessor("leftPos")
 	int getX();
 	
-	@Accessor("y")
+	@Accessor("topPos")
 	int getY();
 	
-	@Accessor("backgroundWidth")
+	@Accessor("imageWidth")
 	int getBackgroundWidth();
 	
-	@Accessor("backgroundHeight")
+	@Accessor("imageHeight")
 	int getBackgroundHeight();
 }
diff --git a/src/main/java/net/wurstclient/mixin/HandledScreenMixin.java b/src/main/java/net/wurstclient/mixin/HandledScreenMixin.java
index d6fc90161..456972ca7 100644
--- a/src/main/java/net/wurstclient/mixin/HandledScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/HandledScreenMixin.java
@@ -13,30 +13,29 @@ import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.item.ItemStack;
-import net.minecraft.screen.slot.Slot;
-import net.minecraft.screen.slot.SlotActionType;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.world.inventory.ClickType;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AntiDropHack;
 import net.wurstclient.hacks.EnchantmentHandlerHack;
 
-@Mixin(HandledScreen.class)
+@Mixin(AbstractContainerScreen.class)
 public abstract class HandledScreenMixin
 {
 	@Shadow
-	public abstract net.minecraft.screen.ScreenHandler getScreenHandler();
+	public abstract net.minecraft.world.inventory.AbstractContainerMenu getMenu();
 	
 	@Inject(at = @At("HEAD"),
-		method = "onMouseClick(Lnet/minecraft/screen/slot/Slot;IILnet/minecraft/screen/slot/SlotActionType;)V",
+		method = "slotClicked(Lnet/minecraft/world/inventory/Slot;IILnet/minecraft/world/inventory/ClickType;)V",
 		cancellable = true)
 	private void onMouseClick(Slot slot, int slotId, int button,
-		SlotActionType actionType, CallbackInfo ci)
+		ClickType actionType, CallbackInfo ci)
 	{
-		if(actionType != SlotActionType.THROW && slotId != -999)
+		if(actionType != ClickType.THROW && slotId != -999)
 			return;
 		
 		if(!WurstClient.INSTANCE.isEnabled())
@@ -49,19 +48,19 @@ public abstract class HandledScreenMixin
 		ItemStack stack = ItemStack.EMPTY;
 		
 		if(slotId == -999)
-			stack = getScreenHandler().getCursorStack();
+			stack = getMenu().getCarried();
 		else if(slot != null)
-			stack = slot.getStack();
+			stack = slot.getItem();
 		
 		if(antiDrop.shouldBlock(stack))
 			ci.cancel();
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "mouseClicked(Lnet/minecraft/client/gui/Click;Z)Z",
+		method = "mouseClicked(Lnet/minecraft/client/input/MouseButtonEvent;Z)Z",
 		cancellable = true)
-	private void wurst$handleMouseClick(Click context, boolean doubleClick,
-		CallbackInfoReturnable<Boolean> cir)
+	private void wurst$handleMouseClick(MouseButtonEvent context,
+		boolean doubleClick, CallbackInfoReturnable<Boolean> cir)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
@@ -69,8 +68,9 @@ public abstract class HandledScreenMixin
 		EnchantmentHandlerHack enchantHack =
 			WurstClient.INSTANCE.getHax().enchantmentHandlerHack;
 		if(enchantHack != null && enchantHack.isEnabled()
-			&& enchantHack.handleMouseClick((HandledScreen<?>)(Object)this,
-				context.x(), context.y(), context.button()))
+			&& enchantHack.handleMouseClick(
+				(AbstractContainerScreen<?>)(Object)this, context.x(),
+				context.y(), context.button()))
 		{
 			cir.setReturnValue(true);
 			cir.cancel();
@@ -88,8 +88,9 @@ public abstract class HandledScreenMixin
 		EnchantmentHandlerHack enchantHack =
 			WurstClient.INSTANCE.getHax().enchantmentHandlerHack;
 		if(enchantHack != null && enchantHack.isEnabled()
-			&& enchantHack.handleMouseScroll((HandledScreen<?>)(Object)this,
-				mouseX, mouseY, verticalAmount))
+			&& enchantHack.handleMouseScroll(
+				(AbstractContainerScreen<?>)(Object)this, mouseX, mouseY,
+				verticalAmount))
 		{
 			cir.setReturnValue(true);
 			cir.cancel();
@@ -97,8 +98,8 @@ public abstract class HandledScreenMixin
 	}
 	
 	@Inject(at = @At("TAIL"),
-		method = "render(Lnet/minecraft/client/gui/DrawContext;IIF)V")
-	private void wurst$renderOverlay(DrawContext context, int mouseX,
+		method = "render(Lnet/minecraft/client/gui/GuiGraphics;IIF)V")
+	private void wurst$renderOverlay(GuiGraphics context, int mouseX,
 		int mouseY, float delta, CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
@@ -108,7 +109,7 @@ public abstract class HandledScreenMixin
 			WurstClient.INSTANCE.getHax().enchantmentHandlerHack;
 		
 		if(enchantHack != null && enchantHack.isEnabled())
-			enchantHack.renderOnHandledScreen((HandledScreen<?>)(Object)this,
-				context, delta);
+			enchantHack.renderOnHandledScreen(
+				(AbstractContainerScreen<?>)(Object)this, context, delta);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/HeldItemRendererMixin.java b/src/main/java/net/wurstclient/mixin/HeldItemRendererMixin.java
index cd3660261..2fac7e6c8 100644
--- a/src/main/java/net/wurstclient/mixin/HeldItemRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/HeldItemRendererMixin.java
@@ -11,17 +11,16 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.network.AbstractClientPlayerEntity;
-import net.minecraft.client.render.command.OrderedRenderCommandQueue;
-import net.minecraft.client.render.item.HeldItemRenderer;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.Items;
-import net.minecraft.util.Hand;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.player.AbstractClientPlayer;
+import net.minecraft.client.renderer.ItemInHandRenderer;
+import net.minecraft.client.renderer.SubmitNodeCollector;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.wurstclient.WurstClient;
 
-@Mixin(HeldItemRenderer.class)
+@Mixin(ItemInHandRenderer.class)
 public abstract class HeldItemRendererMixin
 {
 	/**
@@ -29,14 +28,14 @@ public abstract class HeldItemRendererMixin
 	 * switch.
 	 */
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/render/item/HeldItemRenderer;applyEquipOffset(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/util/Arm;F)V",
+		target = "Lnet/minecraft/client/renderer/ItemInHandRenderer;applyItemArmTransform(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/world/entity/HumanoidArm;F)V",
 		ordinal = 3),
-		method = "renderFirstPersonItem(Lnet/minecraft/client/network/AbstractClientPlayerEntity;FFLnet/minecraft/util/Hand;FLnet/minecraft/item/ItemStack;FLnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/command/OrderedRenderCommandQueue;I)V")
-	private void onApplyEquipOffsetBlocking(AbstractClientPlayerEntity player,
-		float tickProgress, float pitch, Hand hand, float swingProgress,
-		ItemStack item, float equipProgress, MatrixStack matrices,
-		OrderedRenderCommandQueue entityRenderCommandQueue, int light,
-		CallbackInfo ci)
+		method = "renderArmWithItem(Lnet/minecraft/client/player/AbstractClientPlayer;FFLnet/minecraft/world/InteractionHand;FLnet/minecraft/world/item/ItemStack;FLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/SubmitNodeCollector;I)V")
+	private void onApplyEquipOffsetBlocking(AbstractClientPlayer player,
+		float tickProgress, float pitch, InteractionHand hand,
+		float swingProgress, ItemStack item, float equipProgress,
+		PoseStack matrices, SubmitNodeCollector entityRenderCommandQueue,
+		int light, CallbackInfo ci)
 	{
 		// lower shield when blocking
 		if(item.getItem() == Items.SHIELD)
@@ -49,15 +48,14 @@ public abstract class HeldItemRendererMixin
 	 * renderFirstPersonItem(), right after `else if(player.isUsingRiptide())`.
 	 */
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/render/item/HeldItemRenderer;swingArm(FFLnet/minecraft/client/util/math/MatrixStack;ILnet/minecraft/util/Arm;)V",
+		target = "Lnet/minecraft/client/renderer/ItemInHandRenderer;swingArm(FFLcom/mojang/blaze3d/vertex/PoseStack;ILnet/minecraft/world/entity/HumanoidArm;)V",
 		ordinal = 2),
-		method = "renderFirstPersonItem(Lnet/minecraft/client/network/AbstractClientPlayerEntity;FFLnet/minecraft/util/Hand;FLnet/minecraft/item/ItemStack;FLnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/command/OrderedRenderCommandQueue;I)V")
-	private void onApplySwingOffsetNotBlocking(
-		AbstractClientPlayerEntity player, float tickProgress, float pitch,
-		Hand hand, float swingProgress, ItemStack item, float equipProgress,
-		MatrixStack matrices,
-		OrderedRenderCommandQueue entityRenderCommandQueue, int light,
-		CallbackInfo ci)
+		method = "renderArmWithItem(Lnet/minecraft/client/player/AbstractClientPlayer;FFLnet/minecraft/world/InteractionHand;FLnet/minecraft/world/item/ItemStack;FLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/SubmitNodeCollector;I)V")
+	private void onApplySwingOffsetNotBlocking(AbstractClientPlayer player,
+		float tickProgress, float pitch, InteractionHand hand,
+		float swingProgress, ItemStack item, float equipProgress,
+		PoseStack matrices, SubmitNodeCollector entityRenderCommandQueue,
+		int light, CallbackInfo ci)
 	{
 		// lower shield when not blocking
 		if(item.getItem() == Items.SHIELD)
diff --git a/src/main/java/net/wurstclient/mixin/InGameHudLocatorProbeMixin.java b/src/main/java/net/wurstclient/mixin/InGameHudLocatorProbeMixin.java
index 63f8fad37..10e962bf6 100644
--- a/src/main/java/net/wurstclient/mixin/InGameHudLocatorProbeMixin.java
+++ b/src/main/java/net/wurstclient/mixin/InGameHudLocatorProbeMixin.java
@@ -12,7 +12,10 @@ import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
-
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.gui.Gui;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.contextualbar.LocatorBarRenderer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.spongepowered.asm.mixin.Mixin;
@@ -20,12 +23,7 @@ import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.hud.InGameHud;
-import net.minecraft.client.gui.hud.bar.LocatorBar;
-import net.minecraft.client.render.RenderTickCounter;
-
-@Mixin(InGameHud.class)
+@Mixin(Gui.class)
 public class InGameHudLocatorProbeMixin
 {
 	private static final Logger LOGGER =
@@ -33,9 +31,9 @@ public class InGameHudLocatorProbeMixin
 	private static long lastProbeLogMs = 0L;
 	
 	@Inject(
-		method = "renderPlayerList(Lnet/minecraft/client/gui/DrawContext;Lnet/minecraft/client/render/RenderTickCounter;)V",
+		method = "renderTabList(Lnet/minecraft/client/gui/GuiGraphics;Lnet/minecraft/client/DeltaTracker;)V",
 		at = @At("HEAD"))
-	private void onAnyHudRender(DrawContext ctx, RenderTickCounter rtc,
+	private void onAnyHudRender(GuiGraphics ctx, DeltaTracker rtc,
 		CallbackInfo ci)
 	{
 		long now = System.currentTimeMillis();
@@ -61,7 +59,7 @@ public class InGameHudLocatorProbeMixin
 						int count = 0;
 						for(Object val : map.values())
 						{
-							if(val instanceof LocatorBar)
+							if(val instanceof LocatorBarRenderer)
 							{
 								count++;
 								reflectLocatorBar(val);
diff --git a/src/main/java/net/wurstclient/mixin/InGameOverlayRendererMixin.java b/src/main/java/net/wurstclient/mixin/InGameOverlayRendererMixin.java
index 60ed879e5..5f101e4b0 100644
--- a/src/main/java/net/wurstclient/mixin/InGameOverlayRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/InGameOverlayRendererMixin.java
@@ -13,18 +13,17 @@ import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.hud.InGameOverlayRenderer;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.client.renderer.ScreenEffectRenderer;
 import net.wurstclient.WurstClient;
 
-@Mixin(InGameOverlayRenderer.class)
+@Mixin(ScreenEffectRenderer.class)
 public class InGameOverlayRendererMixin
 {
 	@ModifyConstant(
-		method = "renderFireOverlay(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider;Lnet/minecraft/client/texture/Sprite;)V",
+		method = "renderFire(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;Lnet/minecraft/client/renderer/texture/TextureAtlasSprite;)V",
 		constant = @Constant(floatValue = -0.3F))
 	private static float getFireOffset(float original)
 	{
@@ -33,10 +32,10 @@ public class InGameOverlayRendererMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "renderUnderwaterOverlay(Lnet/minecraft/client/MinecraftClient;Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider;)V",
+		method = "renderWater(Lnet/minecraft/client/Minecraft;Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;)V",
 		cancellable = true)
-	private static void onRenderUnderwaterOverlay(MinecraftClient client,
-		MatrixStack matrices, VertexConsumerProvider vertexConsumerProvider,
+	private static void onRenderUnderwaterOverlay(Minecraft client,
+		PoseStack matrices, MultiBufferSource vertexConsumerProvider,
 		CallbackInfo ci)
 	{
 		if(WurstClient.INSTANCE.getHax().noOverlayHack.isEnabled())
diff --git a/src/main/java/net/wurstclient/mixin/IngameHudMixin.java b/src/main/java/net/wurstclient/mixin/IngameHudMixin.java
index bd8191539..a73bcaa34 100644
--- a/src/main/java/net/wurstclient/mixin/IngameHudMixin.java
+++ b/src/main/java/net/wurstclient/mixin/IngameHudMixin.java
@@ -11,39 +11,38 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.hud.InGameHud;
-import net.minecraft.client.render.RenderTickCounter;
-import net.minecraft.entity.Entity;
-import net.minecraft.util.Identifier;
 import net.cevapi.security.ResourcePackProtector;
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.gui.Gui;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.GUIRenderListener.GUIRenderEvent;
 import net.wurstclient.hack.HackList;
 
-@Mixin(InGameHud.class)
+@Mixin(Gui.class)
 public class IngameHudMixin
 {
 	// runs after renderScoreboardSidebar()
 	// and before playerListHud.setVisible()
 	@Inject(at = @At("HEAD"),
-		method = "renderPlayerList(Lnet/minecraft/client/gui/DrawContext;Lnet/minecraft/client/render/RenderTickCounter;)V")
-	private void onRenderPlayerList(DrawContext context,
-		RenderTickCounter tickCounter, CallbackInfo ci)
+		method = "renderTabList(Lnet/minecraft/client/gui/GuiGraphics;Lnet/minecraft/client/DeltaTracker;)V")
+	private void onRenderPlayerList(GuiGraphics context,
+		DeltaTracker tickCounter, CallbackInfo ci)
 	{
-		if(WurstClient.MC.debugHudEntryList.isF3Enabled())
+		if(WurstClient.MC.debugEntries.isF3Visible())
 			return;
 		
-		float tickDelta = tickCounter.getTickProgress(true);
+		float tickDelta = tickCounter.getGameTimeDeltaPartialTick(true);
 		EventManager.fire(new GUIRenderEvent(context, tickDelta));
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "renderOverlay(Lnet/minecraft/client/gui/DrawContext;Lnet/minecraft/util/Identifier;F)V",
+		method = "renderTextureOverlay(Lnet/minecraft/client/gui/GuiGraphics;Lnet/minecraft/resources/ResourceLocation;F)V",
 		cancellable = true)
-	private void onRenderOverlay(DrawContext context, Identifier texture,
+	private void onRenderOverlay(GuiGraphics context, ResourceLocation texture,
 		float opacity, CallbackInfo ci)
 	{
 		if(texture == null)
@@ -61,10 +60,8 @@ public class IngameHudMixin
 			ci.cancel();
 	}
 	
-	@Inject(at = @At("HEAD"),
-		method = "renderVignetteOverlay",
-		cancellable = true)
-	private void onRenderVignetteOverlay(DrawContext context, Entity entity,
+	@Inject(at = @At("HEAD"), method = "renderVignette", cancellable = true)
+	private void onRenderVignetteOverlay(GuiGraphics context, Entity entity,
 		CallbackInfo ci)
 	{
 		HackList hax = WurstClient.INSTANCE.getHax();
diff --git a/src/main/java/net/wurstclient/mixin/InventoryScreenMixin.java b/src/main/java/net/wurstclient/mixin/InventoryScreenMixin.java
index ce9901b05..d11f170f1 100644
--- a/src/main/java/net/wurstclient/mixin/InventoryScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/InventoryScreenMixin.java
@@ -11,22 +11,21 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.screen.PlayerScreenHandler;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.InventoryMenu;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.QuickShulkerHack;
 
 @Mixin(InventoryScreen.class)
 public abstract class InventoryScreenMixin
-	extends HandledScreen<PlayerScreenHandler>
+	extends AbstractContainerScreen<InventoryMenu>
 {
-	private InventoryScreenMixin(WurstClient wurst, PlayerScreenHandler handler,
-		PlayerInventory inventory, Text title)
+	private InventoryScreenMixin(WurstClient wurst, InventoryMenu handler,
+		Inventory inventory, Component title)
 	{
 		super(handler, inventory, title);
 	}
@@ -45,11 +44,11 @@ public abstract class InventoryScreenMixin
 			
 		// place the button above the inventory border so it doesn't overlap
 		// the container background
-		ButtonWidget button = ButtonWidget
-			.builder(Text.literal("QuickShulker"),
+		Button button = Button
+			.builder(Component.literal("QuickShulker"),
 				b -> quickShulker.triggerFromGui())
-			.dimensions(x + backgroundWidth - 90, y - 20, 80, 16).build();
+			.bounds(leftPos + imageWidth - 90, topPos - 20, 80, 16).build();
 		button.active = !quickShulker.isBusy();
-		addDrawableChild(button);
+		addRenderableWidget(button);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/KeyBindingMixin.java b/src/main/java/net/wurstclient/mixin/KeyBindingMixin.java
index 4ee5b095c..5040ca109 100644
--- a/src/main/java/net/wurstclient/mixin/KeyBindingMixin.java
+++ b/src/main/java/net/wurstclient/mixin/KeyBindingMixin.java
@@ -11,21 +11,20 @@ import org.lwjgl.glfw.GLFW;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.Unique;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.input.MouseInput;
-import net.minecraft.client.option.KeyBinding;
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.client.util.Window;
+import com.mojang.blaze3d.platform.InputConstants;
+import com.mojang.blaze3d.platform.Window;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonInfo;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IKeyBinding;
 
-@Mixin(KeyBinding.class)
+@Mixin(KeyMapping.class)
 public abstract class KeyBindingMixin implements IKeyBinding
 {
 	@Shadow
-	private InputUtil.Key boundKey;
+	private InputConstants.Key key;
 	
 	@Override
 	@Unique
@@ -33,12 +32,12 @@ public abstract class KeyBindingMixin implements IKeyBinding
 	public void wurst_resetPressedState()
 	{
 		Window window = WurstClient.MC.getWindow();
-		int code = boundKey.getCode();
+		int code = key.getValue();
 		
-		if(boundKey.getCategory() == InputUtil.Type.MOUSE)
-			setPressed(GLFW.glfwGetMouseButton(window.getHandle(), code) == 1);
+		if(key.getType() == InputConstants.Type.MOUSE)
+			setDown(GLFW.glfwGetMouseButton(window.handle(), code) == 1);
 		else
-			setPressed(InputUtil.isKeyPressed(window, code));
+			setDown(InputConstants.isKeyDown(window, code));
 	}
 	
 	@Override
@@ -46,35 +45,33 @@ public abstract class KeyBindingMixin implements IKeyBinding
 	@Deprecated // use IKeyBinding.simulatePress() instead
 	public void wurst_simulatePress(boolean pressed)
 	{
-		MinecraftClient mc = WurstClient.MC;
+		Minecraft mc = WurstClient.MC;
 		Window window = mc.getWindow();
 		int action = pressed ? 1 : 0;
 		
-		switch(boundKey.getCategory())
+		switch(key.getType())
 		{
 			case KEYSYM:
-			mc.keyboard.onKey(window.getHandle(), action,
-				new KeyInput(boundKey.getCode(), 0, 0));
+			mc.keyboardHandler.keyPress(window.handle(), action,
+				new KeyEvent(key.getValue(), 0, 0));
 			break;
 			
 			case SCANCODE:
-			mc.keyboard.onKey(window.getHandle(), action,
-				new KeyInput(GLFW.GLFW_KEY_UNKNOWN, boundKey.getCode(), 0));
+			mc.keyboardHandler.keyPress(window.handle(), action,
+				new KeyEvent(GLFW.GLFW_KEY_UNKNOWN, key.getValue(), 0));
 			break;
 			
 			case MOUSE:
-			mc.mouse.onMouseButton(window.getHandle(),
-				new MouseInput(boundKey.getCode(), 0), action);
+			mc.mouseHandler.onButton(window.handle(),
+				new MouseButtonInfo(key.getValue(), 0), action);
 			break;
 			
 			default:
-			System.out
-				.println("Unknown keybinding type: " + boundKey.getCategory());
+			System.out.println("Unknown keybinding type: " + key.getType());
 			break;
 		}
 	}
 	
-	@Override
 	@Shadow
-	public abstract void setPressed(boolean pressed);
+	public abstract void setDown(boolean pressed);
 }
diff --git a/src/main/java/net/wurstclient/mixin/KeyboardMixin.java b/src/main/java/net/wurstclient/mixin/KeyboardMixin.java
index 8553d972d..0ab29a7c1 100644
--- a/src/main/java/net/wurstclient/mixin/KeyboardMixin.java
+++ b/src/main/java/net/wurstclient/mixin/KeyboardMixin.java
@@ -11,18 +11,17 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.Keyboard;
-import net.minecraft.client.input.KeyInput;
+import net.minecraft.client.KeyboardHandler;
+import net.minecraft.client.input.KeyEvent;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.KeyPressListener.KeyPressEvent;
 
-@Mixin(Keyboard.class)
+@Mixin(KeyboardHandler.class)
 public class KeyboardMixin
 {
 	@Inject(at = @At("HEAD"),
-		method = "onKey(JILnet/minecraft/client/input/KeyInput;)V")
-	private void onOnKey(long windowHandle, int action, KeyInput arg,
+		method = "keyPress(JILnet/minecraft/client/input/KeyEvent;)V")
+	private void onOnKey(long windowHandle, int action, KeyEvent arg,
 		CallbackInfo ci)
 	{
 		EventManager.fire(new KeyPressEvent(arg.key(), arg.scancode(), action,
diff --git a/src/main/java/net/wurstclient/mixin/LabelCommandRendererMixin.java b/src/main/java/net/wurstclient/mixin/LabelCommandRendererMixin.java
index 76430de49..125738db8 100644
--- a/src/main/java/net/wurstclient/mixin/LabelCommandRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/LabelCommandRendererMixin.java
@@ -19,34 +19,34 @@ import org.spongepowered.asm.mixin.injection.ModifyVariable;
 import com.llamalad7.mixinextras.injector.ModifyReceiver;
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.render.command.LabelCommandRenderer;
-import net.minecraft.client.render.command.OrderedRenderCommandQueueImpl;
-import net.minecraft.client.render.state.CameraRenderState;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.text.Text;
-import net.minecraft.util.math.Vec3d;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.renderer.SubmitNodeStorage;
+import net.minecraft.client.renderer.feature.NameTagFeatureRenderer;
+import net.minecraft.client.renderer.state.CameraRenderState;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.NameTagsHack;
 
-@Mixin(LabelCommandRenderer.Commands.class)
+@Mixin(NameTagFeatureRenderer.Storage.class)
 public class LabelCommandRendererMixin
 {
 	@Shadow
 	@Final
-	List<OrderedRenderCommandQueueImpl.LabelCommand> seethroughLabels;
+	List<SubmitNodeStorage.NameTagSubmit> nameTagSubmitsSeethrough;
 	
 	@Shadow
 	@Final
-	List<OrderedRenderCommandQueueImpl.LabelCommand> normalLabels;
+	List<SubmitNodeStorage.NameTagSubmit> nameTagSubmitsNormal;
 	
 	@WrapOperation(
 		at = @At(value = "INVOKE",
-			target = "Lnet/minecraft/client/util/math/MatrixStack;scale(FFF)V"),
-		method = "add(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/util/math/Vec3d;ILnet/minecraft/text/Text;ZIDLnet/minecraft/client/render/state/CameraRenderState;)V")
-	private void wrapLabelScale(MatrixStack matrices, float x, float y, float z,
-		Operation<Void> original, MatrixStack matrices2, @Nullable Vec3d vec3d,
-		int i, Text text, boolean bl, int j, double d, CameraRenderState state)
+			target = "Lcom/mojang/blaze3d/vertex/PoseStack;scale(FFF)V"),
+		method = "add(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/world/phys/Vec3;ILnet/minecraft/network/chat/Component;ZIDLnet/minecraft/client/renderer/state/CameraRenderState;)V")
+	private void wrapLabelScale(PoseStack matrices, float x, float y, float z,
+		Operation<Void> original, PoseStack matrices2, @Nullable Vec3 vec3d,
+		int i, Component text, boolean bl, int j, double d,
+		CameraRenderState state)
 	{
 		NameTagsHack nameTags = WurstClient.INSTANCE.getHax().nameTagsHack;
 		if(!nameTags.isEnabled())
@@ -68,7 +68,7 @@ public class LabelCommandRendererMixin
 	 * is enabled.
 	 */
 	@ModifyVariable(at = @At("HEAD"),
-		method = "add(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/util/math/Vec3d;ILnet/minecraft/text/Text;ZIDLnet/minecraft/client/render/state/CameraRenderState;)V",
+		method = "add(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/world/phys/Vec3;ILnet/minecraft/network/chat/Component;ZIDLnet/minecraft/client/renderer/state/CameraRenderState;)V",
 		argsOnly = true)
 	private boolean forceNotSneaking(boolean notSneaking)
 	{
@@ -85,16 +85,15 @@ public class LabelCommandRendererMixin
 		at = @At(value = "INVOKE",
 			target = "Ljava/util/List;add(Ljava/lang/Object;)Z",
 			ordinal = 0),
-		method = "add(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/util/math/Vec3d;ILnet/minecraft/text/Text;ZIDLnet/minecraft/client/render/state/CameraRenderState;)V")
-	private List<OrderedRenderCommandQueueImpl.LabelCommand> swapFirstList(
-		List<OrderedRenderCommandQueueImpl.LabelCommand> originalList,
-		Object labelCommand)
+		method = "add(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/world/phys/Vec3;ILnet/minecraft/network/chat/Component;ZIDLnet/minecraft/client/renderer/state/CameraRenderState;)V")
+	private List<SubmitNodeStorage.NameTagSubmit> swapFirstList(
+		List<SubmitNodeStorage.NameTagSubmit> originalList, Object labelCommand)
 	{
 		NameTagsHack nameTags = WurstClient.INSTANCE.getHax().nameTagsHack;
 		
 		if(nameTags.isEnabled() && nameTags.isSeeThrough())
-			if(originalList == normalLabels)
-				return seethroughLabels;
+			if(originalList == nameTagSubmitsNormal)
+				return nameTagSubmitsSeethrough;
 			
 		return originalList;
 	}
@@ -108,16 +107,15 @@ public class LabelCommandRendererMixin
 		at = @At(value = "INVOKE",
 			target = "Ljava/util/List;add(Ljava/lang/Object;)Z",
 			ordinal = 1),
-		method = "add(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/util/math/Vec3d;ILnet/minecraft/text/Text;ZIDLnet/minecraft/client/render/state/CameraRenderState;)V")
-	private List<OrderedRenderCommandQueueImpl.LabelCommand> swapSecondList(
-		List<OrderedRenderCommandQueueImpl.LabelCommand> originalList,
-		Object labelCommand)
+		method = "add(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/world/phys/Vec3;ILnet/minecraft/network/chat/Component;ZIDLnet/minecraft/client/renderer/state/CameraRenderState;)V")
+	private List<SubmitNodeStorage.NameTagSubmit> swapSecondList(
+		List<SubmitNodeStorage.NameTagSubmit> originalList, Object labelCommand)
 	{
 		NameTagsHack nameTags = WurstClient.INSTANCE.getHax().nameTagsHack;
 		
 		if(nameTags.isEnabled() && nameTags.isSeeThrough())
-			if(originalList == seethroughLabels)
-				return normalLabels;
+			if(originalList == nameTagSubmitsSeethrough)
+				return nameTagSubmitsNormal;
 			
 		return originalList;
 	}
diff --git a/src/main/java/net/wurstclient/mixin/LanguageManagerMixin.java b/src/main/java/net/wurstclient/mixin/LanguageManagerMixin.java
index 58614212a..ec3330127 100644
--- a/src/main/java/net/wurstclient/mixin/LanguageManagerMixin.java
+++ b/src/main/java/net/wurstclient/mixin/LanguageManagerMixin.java
@@ -11,22 +11,21 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.resource.language.LanguageManager;
-import net.minecraft.resource.ResourceManager;
-import net.minecraft.resource.SynchronousResourceReloader;
+import net.minecraft.client.resources.language.LanguageManager;
+import net.minecraft.server.packs.resources.ResourceManager;
+import net.minecraft.server.packs.resources.ResourceManagerReloadListener;
 import net.wurstclient.WurstClient;
 
 @Mixin(LanguageManager.class)
 public abstract class LanguageManagerMixin
-	implements SynchronousResourceReloader
+	implements ResourceManagerReloadListener
 {
 	@Inject(at = @At("HEAD"),
-		method = "reload(Lnet/minecraft/resource/ResourceManager;)V")
+		method = "onResourceManagerReload(Lnet/minecraft/server/packs/resources/ResourceManager;)V")
 	private void onReload(ResourceManager manager, CallbackInfo ci)
 	{
 		// Using a mixin for this because WurstClient.initialize() runs too
 		// early to call ResourceManager.registerReloader()
-		WurstClient.INSTANCE.getTranslator().reload(manager);
+		WurstClient.INSTANCE.getTranslator().onResourceManagerReload(manager);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/LivingEntityMixin.java b/src/main/java/net/wurstclient/mixin/LivingEntityMixin.java
index 630f64cf2..5a92debb1 100644
--- a/src/main/java/net/wurstclient/mixin/LivingEntityMixin.java
+++ b/src/main/java/net/wurstclient/mixin/LivingEntityMixin.java
@@ -11,11 +11,10 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffects;
-import net.minecraft.registry.entry.RegistryEntry;
+import net.minecraft.core.Holder;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.WurstClient;
 
 @Mixin(LivingEntity.class)
@@ -25,13 +24,12 @@ public class LivingEntityMixin
 	 * Stops the other darkness effect in caves when AntiBlind is enabled.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "getEffectFadeFactor(Lnet/minecraft/registry/entry/RegistryEntry;F)F",
+		method = "getEffectBlendFactor(Lnet/minecraft/core/Holder;F)F",
 		cancellable = true)
-	private void onGetEffectFadeFactor(
-		RegistryEntry<StatusEffect> registryEntry, float delta,
-		CallbackInfoReturnable<Float> cir)
+	private void onGetEffectFadeFactor(Holder<MobEffect> registryEntry,
+		float delta, CallbackInfoReturnable<Float> cir)
 	{
-		if(registryEntry != StatusEffects.DARKNESS)
+		if(registryEntry != MobEffects.DARKNESS)
 			return;
 		
 		if(WurstClient.INSTANCE.getHax().antiBlindHack.isEnabled())
diff --git a/src/main/java/net/wurstclient/mixin/LivingEntityRendererMixin.java b/src/main/java/net/wurstclient/mixin/LivingEntityRendererMixin.java
index 34638b976..a0d273416 100644
--- a/src/main/java/net/wurstclient/mixin/LivingEntityRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/LivingEntityRendererMixin.java
@@ -11,9 +11,8 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.render.entity.LivingEntityRenderer;
-import net.minecraft.entity.LivingEntity;
+import net.minecraft.client.renderer.entity.LivingEntityRenderer;
+import net.minecraft.world.entity.LivingEntity;
 import net.wurstclient.WurstClient;
 
 @Mixin(LivingEntityRenderer.class)
@@ -23,9 +22,9 @@ public abstract class LivingEntityRendererMixin
 	 * Forces the nametag to be rendered if configured in NameTags.
 	 */
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/MinecraftClient;getInstance()Lnet/minecraft/client/MinecraftClient;",
+		target = "Lnet/minecraft/client/Minecraft;getInstance()Lnet/minecraft/client/Minecraft;",
 		ordinal = 0),
-		method = "hasLabel(Lnet/minecraft/entity/LivingEntity;D)Z",
+		method = "shouldShowName(Lnet/minecraft/world/entity/LivingEntity;D)Z",
 		cancellable = true)
 	private void shouldForceLabel(LivingEntity entity, double distanceSq,
 		CallbackInfoReturnable<Boolean> cir)
diff --git a/src/main/java/net/wurstclient/mixin/MerchantScreenMixin.java b/src/main/java/net/wurstclient/mixin/MerchantScreenMixin.java
index 4e9262197..2400fda4c 100644
--- a/src/main/java/net/wurstclient/mixin/MerchantScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/MerchantScreenMixin.java
@@ -11,23 +11,21 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.MerchantScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.screen.MerchantScreenHandler;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.MerchantScreen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.MerchantMenu;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoTraderHack;
 
-import net.minecraft.entity.player.PlayerInventory;
-
 @Mixin(MerchantScreen.class)
 public abstract class MerchantScreenMixin
-	extends HandledScreen<MerchantScreenHandler>
+	extends AbstractContainerScreen<MerchantMenu>
 {
-	private MerchantScreenMixin(WurstClient wurst,
-		MerchantScreenHandler handler, PlayerInventory inventory, Text title)
+	private MerchantScreenMixin(WurstClient wurst, MerchantMenu handler,
+		Inventory inventory, Component title)
 	{
 		super(handler, inventory, title);
 	}
@@ -43,10 +41,10 @@ public abstract class MerchantScreenMixin
 		if(autoTrader == null)
 			return;
 		
-		ButtonWidget button = ButtonWidget
-			.builder(Text.literal("AutoTrader"),
+		Button button = Button
+			.builder(Component.literal("AutoTrader"),
 				b -> autoTrader.triggerFromGui())
-			.dimensions(x + backgroundWidth - 90, y - 20, 80, 16).build();
-		addDrawableChild(button);
+			.bounds(leftPos + imageWidth - 90, topPos - 20, 80, 16).build();
+		addRenderableWidget(button);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/MinecraftClientMixin.java b/src/main/java/net/wurstclient/mixin/MinecraftClientMixin.java
index 2220fc518..8bdaa74a3 100644
--- a/src/main/java/net/wurstclient/mixin/MinecraftClientMixin.java
+++ b/src/main/java/net/wurstclient/mixin/MinecraftClientMixin.java
@@ -22,17 +22,16 @@ import com.llamalad7.mixinextras.sugar.Local;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.minecraft.UserApiService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.RunArgs;
-import net.minecraft.client.WindowEventHandler;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.ClientPlayerInteractionManager;
-import net.minecraft.client.session.ProfileKeys;
-import net.minecraft.client.session.Session;
-import net.minecraft.util.hit.EntityHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.thread.ReentrantThreadExecutor;
+import com.mojang.blaze3d.platform.WindowEventHandler;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.User;
+import net.minecraft.client.main.GameConfig;
+import net.minecraft.client.multiplayer.MultiPlayerGameMode;
+import net.minecraft.client.multiplayer.ProfileKeyPairManager;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.util.thread.ReentrantBlockableEventLoop;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.HandleBlockBreakingListener.HandleBlockBreakingEvent;
@@ -43,24 +42,24 @@ import net.wurstclient.mixinterface.IClientPlayerEntity;
 import net.wurstclient.mixinterface.IClientPlayerInteractionManager;
 import net.wurstclient.mixinterface.IMinecraftClient;
 
-@Mixin(MinecraftClient.class)
+@Mixin(Minecraft.class)
 public abstract class MinecraftClientMixin
-	extends ReentrantThreadExecutor<Runnable>
+	extends ReentrantBlockableEventLoop<Runnable>
 	implements WindowEventHandler, IMinecraftClient
 {
 	@Shadow
 	@Final
-	public File runDirectory;
+	public File gameDirectory;
 	@Shadow
-	public ClientPlayerInteractionManager interactionManager;
+	public MultiPlayerGameMode gameMode;
 	@Shadow
-	public ClientPlayerEntity player;
+	public LocalPlayer player;
 	
 	@Unique
 	private YggdrasilAuthenticationService wurstAuthenticationService;
 	
-	private Session wurstSession;
-	private ProfileKeys wurstProfileKeys;
+	private User wurstSession;
+	private ProfileKeyPairManager wurstProfileKeys;
 	
 	private MinecraftClientMixin(WurstClient wurst, String name)
 	{
@@ -68,21 +67,21 @@ public abstract class MinecraftClientMixin
 	}
 	
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/util/ApiServices;create(Lcom/mojang/authlib/yggdrasil/YggdrasilAuthenticationService;Ljava/io/File;)Lnet/minecraft/util/ApiServices;",
+		target = "Lnet/minecraft/server/Services;create(Lcom/mojang/authlib/yggdrasil/YggdrasilAuthenticationService;Ljava/io/File;)Lnet/minecraft/server/Services;",
 		shift = At.Shift.AFTER), method = "<init>")
-	private void captureAuthenticationService(RunArgs args, CallbackInfo ci,
+	private void captureAuthenticationService(GameConfig args, CallbackInfo ci,
 		@Local YggdrasilAuthenticationService yggdrasilAuthenticationService)
 	{
 		wurstAuthenticationService = yggdrasilAuthenticationService;
 	}
 	
 	/**
-	 * Runs just before {@link MinecraftClient#handleInputEvents()}, bypassing
+	 * Runs just before {@link Minecraft#handleKeybinds()}, bypassing
 	 * the <code>overlay == null && currentScreen == null</code> check in
-	 * {@link MinecraftClient#tick()}.
+	 * {@link Minecraft#tick()}.
 	 */
 	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/MinecraftClient;overlay:Lnet/minecraft/client/gui/screen/Overlay;",
+		target = "Lnet/minecraft/client/Minecraft;overlay:Lnet/minecraft/client/gui/screens/Overlay;",
 		ordinal = 0), method = "tick()V")
 	private void onHandleInputEvents(CallbackInfo ci)
 	{
@@ -94,8 +93,8 @@ public abstract class MinecraftClientMixin
 	}
 	
 	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/MinecraftClient;crosshairTarget:Lnet/minecraft/util/hit/HitResult;",
-		ordinal = 0), method = "doAttack()Z", cancellable = true)
+		target = "Lnet/minecraft/client/Minecraft;hitResult:Lnet/minecraft/world/phys/HitResult;",
+		ordinal = 0), method = "startAttack()Z", cancellable = true)
 	private void onDoAttack(CallbackInfoReturnable<Boolean> cir)
 	{
 		LeftClickEvent event = new LeftClickEvent();
@@ -107,9 +106,9 @@ public abstract class MinecraftClientMixin
 	
 	@Inject(
 		at = @At(value = "FIELD",
-			target = "Lnet/minecraft/client/MinecraftClient;itemUseCooldown:I",
+			target = "Lnet/minecraft/client/Minecraft;rightClickDelay:I",
 			ordinal = 0),
-		method = "doItemUse()V",
+		method = "startUseItem()V",
 		cancellable = true)
 	private void onDoItemUse(CallbackInfo ci)
 	{
@@ -120,13 +119,13 @@ public abstract class MinecraftClientMixin
 			ci.cancel();
 	}
 	
-	@Inject(at = @At("HEAD"), method = "doItemPick()V")
+	@Inject(at = @At("HEAD"), method = "pickBlock()V")
 	private void onDoItemPick(CallbackInfo ci)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		HitResult hitResult = WurstClient.MC.crosshairTarget;
+		HitResult hitResult = WurstClient.MC.hitResult;
 		if(!(hitResult instanceof EntityHitResult eHitResult))
 			return;
 		
@@ -137,9 +136,7 @@ public abstract class MinecraftClientMixin
 	 * Allows hacks to cancel vanilla block breaking and replace it with their
 	 * own. Useful for Nuker-like hacks.
 	 */
-	@Inject(at = @At("HEAD"),
-		method = "handleBlockBreaking(Z)V",
-		cancellable = true)
+	@Inject(at = @At("HEAD"), method = "continueAttack(Z)V", cancellable = true)
 	private void onHandleBlockBreaking(boolean breaking, CallbackInfo ci)
 	{
 		HandleBlockBreakingEvent event = new HandleBlockBreakingEvent();
@@ -150,9 +147,9 @@ public abstract class MinecraftClientMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getSession()Lnet/minecraft/client/session/Session;",
+		method = "getUser()Lnet/minecraft/client/User;",
 		cancellable = true)
-	private void onGetSession(CallbackInfoReturnable<Session> cir)
+	private void onGetSession(CallbackInfoReturnable<User> cir)
 	{
 		if(wurstSession != null)
 			cir.setReturnValue(wurstSession);
@@ -167,18 +164,19 @@ public abstract class MinecraftClientMixin
 			return;
 		
 		GameProfile oldProfile = cir.getReturnValue();
-		GameProfile newProfile = new GameProfile(wurstSession.getUuidOrNull(),
-			wurstSession.getUsername(), oldProfile.properties());
+		GameProfile newProfile = new GameProfile(wurstSession.getProfileId(),
+			wurstSession.getName(), oldProfile.properties());
 		cir.setReturnValue(newProfile);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "getProfileKeys()Lnet/minecraft/client/session/ProfileKeys;",
+		method = "getProfileKeyPairManager()Lnet/minecraft/client/multiplayer/ProfileKeyPairManager;",
 		cancellable = true)
-	private void onGetProfileKeys(CallbackInfoReturnable<ProfileKeys> cir)
+	private void onGetProfileKeys(
+		CallbackInfoReturnable<ProfileKeyPairManager> cir)
 	{
 		if(WurstClient.INSTANCE.getOtfs().noChatReportsOtf.isActive())
-			cir.setReturnValue(ProfileKeys.MISSING);
+			cir.setReturnValue(ProfileKeyPairManager.EMPTY_KEY_MANAGER);
 		
 		if(wurstProfileKeys == null)
 			return;
@@ -186,9 +184,7 @@ public abstract class MinecraftClientMixin
 		cir.setReturnValue(wurstProfileKeys);
 	}
 	
-	@Inject(at = @At("HEAD"),
-		method = "isTelemetryEnabledByApi()Z",
-		cancellable = true)
+	@Inject(at = @At("HEAD"), method = "allowsTelemetry()Z", cancellable = true)
 	private void onIsTelemetryEnabledByApi(CallbackInfoReturnable<Boolean> cir)
 	{
 		cir.setReturnValue(
@@ -196,7 +192,7 @@ public abstract class MinecraftClientMixin
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "isOptionalTelemetryEnabledByApi()Z",
+		method = "extraTelemetryAvailable()Z",
 		cancellable = true)
 	private void onIsOptionalTelemetryEnabledByApi(
 		CallbackInfoReturnable<Boolean> cir)
@@ -214,17 +210,17 @@ public abstract class MinecraftClientMixin
 	@Override
 	public IClientPlayerInteractionManager getInteractionManager()
 	{
-		return (IClientPlayerInteractionManager)interactionManager;
+		return (IClientPlayerInteractionManager)gameMode;
 	}
 	
 	@Override
-	public Session getWurstSession()
+	public User getWurstSession()
 	{
 		return wurstSession;
 	}
 	
 	@Override
-	public void setWurstSession(Session session)
+	public void setWurstSession(User session)
 	{
 		wurstSession = session;
 		if(session == null)
@@ -238,7 +234,7 @@ public abstract class MinecraftClientMixin
 			|| accessToken.equals("0") || accessToken.equals("null");
 		UserApiService userApiService = isOffline ? UserApiService.OFFLINE
 			: wurstAuthenticationService.createUserApiService(accessToken);
-		wurstProfileKeys =
-			ProfileKeys.create(userApiService, session, runDirectory.toPath());
+		wurstProfileKeys = ProfileKeyPairManager.create(userApiService, session,
+			gameDirectory.toPath());
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/MobEntityRendererMixin.java b/src/main/java/net/wurstclient/mixin/MobEntityRendererMixin.java
index feb1067c5..e1b8179df 100644
--- a/src/main/java/net/wurstclient/mixin/MobEntityRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/MobEntityRendererMixin.java
@@ -12,11 +12,10 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.render.entity.MobEntityRenderer;
+import net.minecraft.client.renderer.entity.MobRenderer;
 import net.wurstclient.WurstClient;
 
-@Mixin(MobEntityRenderer.class)
+@Mixin(MobRenderer.class)
 public abstract class MobEntityRendererMixin
 {
 	/**
@@ -24,10 +23,10 @@ public abstract class MobEntityRendererMixin
 	 * NameTags.
 	 */
 	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/render/entity/EntityRenderManager;targetedEntity:Lnet/minecraft/entity/Entity;",
+		target = "Lnet/minecraft/client/renderer/entity/EntityRenderDispatcher;crosshairPickEntity:Lnet/minecraft/world/entity/Entity;",
 		opcode = Opcodes.GETFIELD,
 		ordinal = 0),
-		method = "hasLabel(Lnet/minecraft/entity/mob/MobEntity;D)Z",
+		method = "shouldShowName(Lnet/minecraft/world/entity/Mob;D)Z",
 		cancellable = true)
 	private void onHasLabel(CallbackInfoReturnable<Boolean> cir)
 	{
diff --git a/src/main/java/net/wurstclient/mixin/MouseMixin.java b/src/main/java/net/wurstclient/mixin/MouseMixin.java
index 650125d65..51199553e 100644
--- a/src/main/java/net/wurstclient/mixin/MouseMixin.java
+++ b/src/main/java/net/wurstclient/mixin/MouseMixin.java
@@ -14,43 +14,42 @@ import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import com.llamalad7.mixinextras.injector.v2.WrapWithCondition;
-
-import net.minecraft.client.Mouse;
-import net.minecraft.entity.player.PlayerInventory;
+import net.minecraft.client.MouseHandler;
+import net.minecraft.world.entity.player.Inventory;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.MouseScrollListener.MouseScrollEvent;
 import net.wurstclient.events.MouseUpdateListener.MouseUpdateEvent;
 
-@Mixin(Mouse.class)
+@Mixin(MouseHandler.class)
 public class MouseMixin
 {
 	@Shadow
-	private double cursorDeltaX;
+	private double accumulatedDX;
 	@Shadow
-	private double cursorDeltaY;
+	private double accumulatedDY;
 	
-	@Inject(at = @At("RETURN"), method = "onMouseScroll(JDD)V")
+	@Inject(at = @At("RETURN"), method = "onScroll(JDD)V")
 	private void onOnMouseScroll(long window, double horizontal,
 		double vertical, CallbackInfo ci)
 	{
 		EventManager.fire(new MouseScrollEvent(vertical));
 	}
 	
-	@Inject(at = @At("HEAD"), method = "tick()V")
+	@Inject(at = @At("HEAD"), method = "handleAccumulatedMovement()V")
 	private void onTick(CallbackInfo ci)
 	{
 		MouseUpdateEvent event =
-			new MouseUpdateEvent(cursorDeltaX, cursorDeltaY);
+			new MouseUpdateEvent(accumulatedDX, accumulatedDY);
 		EventManager.fire(event);
-		cursorDeltaX = event.getDeltaX();
-		cursorDeltaY = event.getDeltaY();
+		accumulatedDX = event.getDeltaX();
+		accumulatedDY = event.getDeltaY();
 	}
 	
 	@WrapWithCondition(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/entity/player/PlayerInventory;setSelectedSlot(I)V"),
-		method = "onMouseScroll(JDD)V")
-	private boolean wrapOnMouseScroll(PlayerInventory inventory, int slot)
+		target = "Lnet/minecraft/world/entity/player/Inventory;setSelectedSlot(I)V"),
+		method = "onScroll(JDD)V")
+	private boolean wrapOnMouseScroll(Inventory inventory, int slot)
 	{
 		return !WurstClient.INSTANCE.getOtfs().zoomOtf
 			.shouldPreventHotbarScrolling();
diff --git a/src/main/java/net/wurstclient/mixin/MultiplayerScreenMixin.java b/src/main/java/net/wurstclient/mixin/MultiplayerScreenMixin.java
index 9caa3bb4d..437ef11ff 100644
--- a/src/main/java/net/wurstclient/mixin/MultiplayerScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/MultiplayerScreenMixin.java
@@ -14,32 +14,31 @@ import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import com.llamalad7.mixinextras.sugar.Local;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.DirectionalLayoutWidget;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.text.Text;
 import net.wurstclient.WurstClient;
 import net.wurstclient.serverfinder.CleanUpScreen;
 import net.wurstclient.serverfinder.ServerFinderScreen;
 import net.wurstclient.util.LastServerRememberer;
 import net.cevapi.config.AntiFingerprintConfigScreen;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.layouts.LinearLayout;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.multiplayer.JoinMultiplayerScreen;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
-@Mixin(MultiplayerScreen.class)
+@Mixin(JoinMultiplayerScreen.class)
 public class MultiplayerScreenMixin extends Screen
 {
-	private ButtonWidget lastServerButton;
+	private Button lastServerButton;
 	@Unique
-	private ButtonWidget antiFingerprintButton;
+	private Button antiFingerprintButton;
 	@Unique
-	private ButtonWidget cornerServerFinderButton;
+	private Button cornerServerFinderButton;
 	@Unique
-	private ButtonWidget cornerCleanUpButton;
+	private Button cornerCleanUpButton;
 	
-	private MultiplayerScreenMixin(WurstClient wurst, Text title)
+	private MultiplayerScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -54,44 +53,44 @@ public class MultiplayerScreenMixin extends Screen
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		MultiplayerScreen mpScreen = (MultiplayerScreen)(Object)this;
+		JoinMultiplayerScreen mpScreen = (JoinMultiplayerScreen)(Object)this;
 		
 		// Add Last Server button early for better tab navigation
-		lastServerButton = ButtonWidget
-			.builder(Text.of("Last Server"),
+		lastServerButton = Button
+			.builder(Component.nullToEmpty("Last Server"),
 				b -> LastServerRememberer.joinLastServer(mpScreen))
 			.width(100).build();
-		addDrawableChild(lastServerButton);
+		addRenderableWidget(lastServerButton);
 	}
 	
 	@Inject(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/gui/screen/multiplayer/MultiplayerScreen;refreshWidgetPositions()V",
+		target = "Lnet/minecraft/client/gui/screens/multiplayer/JoinMultiplayerScreen;repositionElements()V",
 		ordinal = 0), method = "init()V")
 	private void afterVanillaButtons(CallbackInfo ci,
-		@Local(ordinal = 1) DirectionalLayoutWidget footerTopRow,
-		@Local(ordinal = 2) DirectionalLayoutWidget footerBottomRow)
+		@Local(ordinal = 1) LinearLayout footerTopRow,
+		@Local(ordinal = 2) LinearLayout footerBottomRow)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		MultiplayerScreen mpScreen = (MultiplayerScreen)(Object)this;
+		JoinMultiplayerScreen mpScreen = (JoinMultiplayerScreen)(Object)this;
 		
-		ButtonWidget serverFinderButton = ButtonWidget
-			.builder(Text.of("Server Finder"),
-				b -> client.setScreen(new ServerFinderScreen(mpScreen)))
+		Button serverFinderButton = Button
+			.builder(Component.nullToEmpty("Server Finder"),
+				b -> minecraft.setScreen(new ServerFinderScreen(mpScreen)))
 			.width(100).build();
-		addDrawableChild(serverFinderButton);
-		footerTopRow.add(serverFinderButton);
+		addRenderableWidget(serverFinderButton);
+		footerTopRow.addChild(serverFinderButton);
 		
-		ButtonWidget cleanUpButton = ButtonWidget
-			.builder(Text.of("Clean Up"),
-				b -> client.setScreen(new CleanUpScreen(mpScreen)))
+		Button cleanUpButton = Button
+			.builder(Component.nullToEmpty("Clean Up"),
+				b -> minecraft.setScreen(new CleanUpScreen(mpScreen)))
 			.width(100).build();
-		addDrawableChild(cleanUpButton);
-		footerBottomRow.add(cleanUpButton);
+		addRenderableWidget(cleanUpButton);
+		footerBottomRow.addChild(cleanUpButton);
 	}
 	
-	@Inject(at = @At("TAIL"), method = "refreshWidgetPositions()V")
+	@Inject(at = @At("TAIL"), method = "repositionElements()V")
 	private void onRefreshWidgetPositions(CallbackInfo ci)
 	{
 		updateLastServerButton();
@@ -106,12 +105,12 @@ public class MultiplayerScreenMixin extends Screen
 				antiFingerprintButton = null;
 			}else
 			{
-				antiFingerprintButton = ButtonWidget
-					.builder(Text.literal("Anti-Fingerprint"),
-						b -> client.setScreen(new AntiFingerprintConfigScreen(
-							(MultiplayerScreen)(Object)this)))
-					.dimensions(0, 0, 100, 20).build();
-				addDrawableChild(antiFingerprintButton);
+				antiFingerprintButton = Button.builder(
+					Component.literal("Anti-Fingerprint"),
+					b -> minecraft.setScreen(new AntiFingerprintConfigScreen(
+						(JoinMultiplayerScreen)(Object)this)))
+					.bounds(0, 0, 100, 20).build();
+				addRenderableWidget(antiFingerprintButton);
 			}
 		}
 		
@@ -125,12 +124,12 @@ public class MultiplayerScreenMixin extends Screen
 		
 		if(cornerServerFinderButton == null)
 		{
-			cornerServerFinderButton = ButtonWidget
-				.builder(Text.literal("Server Finder"),
-					b -> client.setScreen(new ServerFinderScreen(
-						(MultiplayerScreen)(Object)this)))
-				.dimensions(0, 0, 100, 20).build();
-			addDrawableChild(cornerServerFinderButton);
+			cornerServerFinderButton = Button
+				.builder(Component.literal("Server Finder"),
+					b -> minecraft.setScreen(new ServerFinderScreen(
+						(JoinMultiplayerScreen)(Object)this)))
+				.bounds(0, 0, 100, 20).build();
+			addRenderableWidget(cornerServerFinderButton);
 		}
 		cornerServerFinderButton.setX(width / 2 + 154 + 4);
 		cornerServerFinderButton.setY(height - 54);
@@ -138,12 +137,13 @@ public class MultiplayerScreenMixin extends Screen
 		
 		if(cornerCleanUpButton == null)
 		{
-			cornerCleanUpButton = ButtonWidget
-				.builder(Text.literal("Clean Up"),
-					b -> client.setScreen(
-						new CleanUpScreen((MultiplayerScreen)(Object)this)))
-				.dimensions(0, 0, 100, 20).build();
-			addDrawableChild(cornerCleanUpButton);
+			cornerCleanUpButton =
+				Button
+					.builder(Component.literal("Clean Up"),
+						b -> minecraft.setScreen(new CleanUpScreen(
+							(JoinMultiplayerScreen)(Object)this)))
+					.bounds(0, 0, 100, 20).build();
+			addRenderableWidget(cornerCleanUpButton);
 		}
 		cornerCleanUpButton.setX(width / 2 + 154 + 4);
 		cornerCleanUpButton.setY(height - 30);
@@ -151,8 +151,8 @@ public class MultiplayerScreenMixin extends Screen
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "connect(Lnet/minecraft/client/network/ServerInfo;)V")
-	private void onConnect(ServerInfo entry, CallbackInfo ci)
+		method = "join(Lnet/minecraft/client/multiplayer/ServerData;)V")
+	private void onConnect(ServerData entry, CallbackInfo ci)
 	{
 		LastServerRememberer.setLastServer(entry);
 		updateLastServerButton();
diff --git a/src/main/java/net/wurstclient/mixin/PackScreenMixin.java b/src/main/java/net/wurstclient/mixin/PackScreenMixin.java
index c4c8a83d5..be05e96f2 100644
--- a/src/main/java/net/wurstclient/mixin/PackScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/PackScreenMixin.java
@@ -11,16 +11,15 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.pack.PackScreen;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.packs.PackSelectionScreen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 
-@Mixin(PackScreen.class)
+@Mixin(PackSelectionScreen.class)
 public class PackScreenMixin extends Screen
 {
-	private PackScreenMixin(WurstClient wurst, Text title)
+	private PackScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -29,7 +28,7 @@ public class PackScreenMixin extends Screen
 	 * Scans for problematic resource packs (currently just VanillaTweaks
 	 * Twinkling Stars) whenever the resource pack screen is closed.
 	 */
-	@Inject(at = @At("HEAD"), method = "close()V")
+	@Inject(at = @At("HEAD"), method = "onClose()V")
 	public void onClose(CallbackInfo ci)
 	{
 		WurstClient.INSTANCE.getProblematicPackDetector().start();
diff --git a/src/main/java/net/wurstclient/mixin/PlayerSkinProviderMixin.java b/src/main/java/net/wurstclient/mixin/PlayerSkinProviderMixin.java
index e24a3dbbb..e9cc579af 100644
--- a/src/main/java/net/wurstclient/mixin/PlayerSkinProviderMixin.java
+++ b/src/main/java/net/wurstclient/mixin/PlayerSkinProviderMixin.java
@@ -22,14 +22,13 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 
 import com.mojang.authlib.minecraft.MinecraftProfileTexture;
 import com.mojang.authlib.minecraft.MinecraftProfileTextures;
-
-import net.minecraft.client.texture.PlayerSkinProvider;
-import net.minecraft.entity.player.SkinTextures;
-import net.minecraft.util.Uuids;
+import net.minecraft.client.resources.SkinManager;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.world.entity.player.PlayerSkin;
 import net.wurstclient.util.json.JsonUtils;
 import net.wurstclient.util.json.WsonObject;
 
-@Mixin(PlayerSkinProvider.class)
+@Mixin(SkinManager.class)
 public abstract class PlayerSkinProviderMixin
 {
 	@Unique
@@ -39,10 +38,10 @@ public abstract class PlayerSkinProviderMixin
 	private MinecraftProfileTexture currentCape;
 	
 	@Inject(at = @At("HEAD"),
-		method = "fetchSkinTextures(Ljava/util/UUID;Lcom/mojang/authlib/minecraft/MinecraftProfileTextures;)Ljava/util/concurrent/CompletableFuture;")
+		method = "registerTextures(Ljava/util/UUID;Lcom/mojang/authlib/minecraft/MinecraftProfileTextures;)Ljava/util/concurrent/CompletableFuture;")
 	private void onFetchSkinTextures(UUID uuid,
 		MinecraftProfileTextures textures,
-		CallbackInfoReturnable<CompletableFuture<SkinTextures>> cir)
+		CallbackInfoReturnable<CompletableFuture<PlayerSkin>> cir)
 	{
 		String uuidString = uuid.toString();
 		
@@ -69,7 +68,7 @@ public abstract class PlayerSkinProviderMixin
 	}
 	
 	@ModifyVariable(at = @At("STORE"),
-		method = "fetchSkinTextures(Ljava/util/UUID;Lcom/mojang/authlib/minecraft/MinecraftProfileTextures;)Ljava/util/concurrent/CompletableFuture;",
+		method = "registerTextures(Ljava/util/UUID;Lcom/mojang/authlib/minecraft/MinecraftProfileTextures;)Ljava/util/concurrent/CompletableFuture;",
 		ordinal = 1,
 		name = "minecraftProfileTexture2")
 	private MinecraftProfileTexture modifyCapeTexture(
@@ -112,7 +111,8 @@ public abstract class PlayerSkinProviderMixin
 				}
 				
 				// convert name to offline UUID
-				String offlineUUID = "" + Uuids.getOfflinePlayerUuid(name);
+				String offlineUUID =
+					"" + UUIDUtil.createOfflinePlayerUUID(name);
 				capes.put(offlineUUID, capeURL);
 			}
 			
diff --git a/src/main/java/net/wurstclient/mixin/PowderSnowBlockMixin.java b/src/main/java/net/wurstclient/mixin/PowderSnowBlockMixin.java
index aa5be867c..01d1cb60e 100644
--- a/src/main/java/net/wurstclient/mixin/PowderSnowBlockMixin.java
+++ b/src/main/java/net/wurstclient/mixin/PowderSnowBlockMixin.java
@@ -11,24 +11,22 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.FluidDrainable;
-import net.minecraft.block.PowderSnowBlock;
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BucketPickup;
+import net.minecraft.world.level.block.PowderSnowBlock;
 import net.wurstclient.WurstClient;
 
 @Mixin(PowderSnowBlock.class)
-public abstract class PowderSnowBlockMixin extends Block
-	implements FluidDrainable
+public abstract class PowderSnowBlockMixin extends Block implements BucketPickup
 {
-	private PowderSnowBlockMixin(WurstClient wurst, Settings settings)
+	private PowderSnowBlockMixin(WurstClient wurst, Properties settings)
 	{
 		super(settings);
 	}
 	
 	@Inject(at = @At("HEAD"),
-		method = "canWalkOnPowderSnow(Lnet/minecraft/entity/Entity;)Z",
+		method = "canEntityWalkOnPowderSnow(Lnet/minecraft/world/entity/Entity;)Z",
 		cancellable = true)
 	private static void onCanWalkOnPowderSnow(Entity entity,
 		CallbackInfoReturnable<Boolean> cir)
diff --git a/src/main/java/net/wurstclient/mixin/RenderLayersMixin.java b/src/main/java/net/wurstclient/mixin/RenderLayersMixin.java
index 22c0c2edf..9a97a6491 100644
--- a/src/main/java/net/wurstclient/mixin/RenderLayersMixin.java
+++ b/src/main/java/net/wurstclient/mixin/RenderLayersMixin.java
@@ -11,59 +11,58 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.render.BlockRenderLayer;
-import net.minecraft.client.render.RenderLayers;
-import net.minecraft.fluid.FluidState;
+import net.minecraft.client.renderer.ItemBlockRenderTypes;
+import net.minecraft.client.renderer.chunk.ChunkSectionLayer;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.SurfaceXrayHack;
 
-@Mixin(RenderLayers.class)
+@Mixin(ItemBlockRenderTypes.class)
 public abstract class RenderLayersMixin
 {
 	/**
 	 * Puts all blocks on the translucent layer if Opacity X-Ray is enabled.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "getBlockLayer(Lnet/minecraft/block/BlockState;)Lnet/minecraft/client/render/BlockRenderLayer;",
+		method = "getChunkRenderType(Lnet/minecraft/world/level/block/state/BlockState;)Lnet/minecraft/client/renderer/chunk/ChunkSectionLayer;",
 		cancellable = true)
 	private static void onGetBlockLayer(BlockState state,
-		CallbackInfoReturnable<BlockRenderLayer> cir)
+		CallbackInfoReturnable<ChunkSectionLayer> cir)
 	{
 		SurfaceXrayHack surface = WurstClient.INSTANCE.getHax().surfaceXrayHack;
 		if(surface.isEnabled() && surface.isTarget(state))
 		{
-			cir.setReturnValue(BlockRenderLayer.TRANSLUCENT);
+			cir.setReturnValue(ChunkSectionLayer.TRANSLUCENT);
 			return;
 		}
 		
 		if(!WurstClient.INSTANCE.getHax().xRayHack.isOpacityMode())
 			return;
 		
-		cir.setReturnValue(BlockRenderLayer.TRANSLUCENT);
+		cir.setReturnValue(ChunkSectionLayer.TRANSLUCENT);
 	}
 	
 	/**
 	 * Puts all fluids on the translucent layer if Opacity X-Ray is enabled.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "getFluidLayer(Lnet/minecraft/fluid/FluidState;)Lnet/minecraft/client/render/BlockRenderLayer;",
+		method = "getRenderLayer(Lnet/minecraft/world/level/material/FluidState;)Lnet/minecraft/client/renderer/chunk/ChunkSectionLayer;",
 		cancellable = true)
 	private static void onGetFluidLayer(FluidState state,
-		CallbackInfoReturnable<BlockRenderLayer> cir)
+		CallbackInfoReturnable<ChunkSectionLayer> cir)
 	{
 		SurfaceXrayHack surface = WurstClient.INSTANCE.getHax().surfaceXrayHack;
 		if(surface.isEnabled()
-			&& surface.isTarget(state.getBlockState().getBlock()))
+			&& surface.isTarget(state.createLegacyBlock().getBlock()))
 		{
-			cir.setReturnValue(BlockRenderLayer.TRANSLUCENT);
+			cir.setReturnValue(ChunkSectionLayer.TRANSLUCENT);
 			return;
 		}
 		
 		if(!WurstClient.INSTANCE.getHax().xRayHack.isOpacityMode())
 			return;
 		
-		cir.setReturnValue(BlockRenderLayer.TRANSLUCENT);
+		cir.setReturnValue(ChunkSectionLayer.TRANSLUCENT);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/RenderTickCounterDynamicMixin.java b/src/main/java/net/wurstclient/mixin/RenderTickCounterDynamicMixin.java
index 50cb00d85..79f4d2bc3 100644
--- a/src/main/java/net/wurstclient/mixin/RenderTickCounterDynamicMixin.java
+++ b/src/main/java/net/wurstclient/mixin/RenderTickCounterDynamicMixin.java
@@ -13,24 +13,24 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.render.RenderTickCounter;
+import net.minecraft.client.DeltaTracker;
 import net.wurstclient.WurstClient;
 
-@Mixin(RenderTickCounter.Dynamic.class)
+@Mixin(DeltaTracker.Timer.class)
 public abstract class RenderTickCounterDynamicMixin
 {
 	@Shadow
-	public float dynamicDeltaTicks;
+	public float deltaTicks;
 	
-	@Inject(at = @At(value = "FIELD",
-		target = "Lnet/minecraft/client/render/RenderTickCounter$Dynamic;lastTimeMillis:J",
-		opcode = Opcodes.PUTFIELD,
-		ordinal = 0), method = "beginRenderTick(J)I")
+	@Inject(
+		at = @At(value = "FIELD",
+			target = "Lnet/minecraft/client/DeltaTracker$Timer;lastMs:J",
+			opcode = Opcodes.PUTFIELD,
+			ordinal = 0),
+		method = "advanceGameTime(J)I")
 	public void onBeginRenderTick(long timeMillis,
 		CallbackInfoReturnable<Integer> cir)
 	{
-		dynamicDeltaTicks *=
-			WurstClient.INSTANCE.getHax().timerHack.getTimerSpeed();
+		deltaTicks *= WurstClient.INSTANCE.getHax().timerHack.getTimerSpeed();
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/ScreenMixin.java b/src/main/java/net/wurstclient/mixin/ScreenMixin.java
index e2e4648e4..1b0d09a68 100644
--- a/src/main/java/net/wurstclient/mixin/ScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ScreenMixin.java
@@ -11,21 +11,20 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.client.gui.AbstractParentElement;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.components.events.AbstractContainerEventHandler;
+import net.minecraft.client.gui.screens.Screen;
 import net.wurstclient.WurstClient;
 
 @Mixin(Screen.class)
-public abstract class ScreenMixin extends AbstractParentElement
-	implements Drawable
+public abstract class ScreenMixin extends AbstractContainerEventHandler
+	implements Renderable
 {
 	@Inject(at = @At("HEAD"),
-		method = "renderInGameBackground(Lnet/minecraft/client/gui/DrawContext;)V",
+		method = "renderTransparentBackground(Lnet/minecraft/client/gui/GuiGraphics;)V",
 		cancellable = true)
-	public void onRenderInGameBackground(DrawContext context, CallbackInfo ci)
+	public void onRenderInGameBackground(GuiGraphics context, CallbackInfo ci)
 	{
 		if(WurstClient.INSTANCE.getHax().noBackgroundHack
 			.shouldCancelBackground((Screen)(Object)this))
diff --git a/src/main/java/net/wurstclient/mixin/ShulkerBoxScreenMixin.java b/src/main/java/net/wurstclient/mixin/ShulkerBoxScreenMixin.java
index 37f9c4b49..f274ace50 100644
--- a/src/main/java/net/wurstclient/mixin/ShulkerBoxScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/ShulkerBoxScreenMixin.java
@@ -9,20 +9,19 @@ package net.wurstclient.mixin;
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
-
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.ShulkerBoxScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.screen.ShulkerBoxScreenHandler;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.ShulkerBoxScreen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.ShulkerBoxMenu;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.AutoStealHack;
 import net.wurstclient.hacks.QuickShulkerHack;
 
 @Mixin(ShulkerBoxScreen.class)
 public abstract class ShulkerBoxScreenMixin
-	extends HandledScreen<ShulkerBoxScreenHandler>
+	extends AbstractContainerScreen<ShulkerBoxMenu>
 {
 	@Unique
 	private final AutoStealHack autoSteal =
@@ -31,8 +30,8 @@ public abstract class ShulkerBoxScreenMixin
 	private final QuickShulkerHack quickShulker =
 		WurstClient.INSTANCE.getHax().quickShulkerHack;
 	
-	private ShulkerBoxScreenMixin(WurstClient wurst,
-		ShulkerBoxScreenHandler handler, PlayerInventory inventory, Text title)
+	private ShulkerBoxScreenMixin(WurstClient wurst, ShulkerBoxMenu handler,
+		Inventory inventory, Component title)
 	{
 		super(handler, inventory, title);
 	}
@@ -47,13 +46,16 @@ public abstract class ShulkerBoxScreenMixin
 		
 		if(autoSteal.areButtonsVisible())
 		{
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Steal"), b -> autoSteal.steal(this, 3))
-				.dimensions(x + backgroundWidth - 108, y + 4, 50, 12).build());
+			addRenderableWidget(Button
+				.builder(Component.literal("Steal"),
+					b -> autoSteal.steal(this, 3))
+				.bounds(leftPos + imageWidth - 108, topPos + 4, 50, 12)
+				.build());
 			
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Store"), b -> autoSteal.store(this, 3))
-				.dimensions(x + backgroundWidth - 56, y + 4, 50, 12).build());
+			addRenderableWidget(Button
+				.builder(Component.literal("Store"),
+					b -> autoSteal.store(this, 3))
+				.bounds(leftPos + imageWidth - 56, topPos + 4, 50, 12).build());
 		}
 		
 		if(autoSteal.isEnabled())
@@ -65,12 +67,12 @@ public abstract class ShulkerBoxScreenMixin
 			// place the QuickShulker button outside the shulker UI so it
 			// doesn't overlap the container background, matching the
 			// inventory screen placement
-			ButtonWidget quickButton = ButtonWidget
-				.builder(Text.literal("QuickShulker"),
+			Button quickButton = Button
+				.builder(Component.literal("QuickShulker"),
 					b -> quickShulker.triggerFromGui())
-				.dimensions(x + backgroundWidth - 90, y - 20, 80, 16).build();
+				.bounds(leftPos + imageWidth - 90, topPos - 20, 80, 16).build();
 			quickButton.active = !quickShulker.isBusy();
-			addDrawableChild(quickButton);
+			addRenderableWidget(quickButton);
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/SimpleOptionMixin.java b/src/main/java/net/wurstclient/mixin/SimpleOptionMixin.java
index 72e40dcf6..687b5280c 100644
--- a/src/main/java/net/wurstclient/mixin/SimpleOptionMixin.java
+++ b/src/main/java/net/wurstclient/mixin/SimpleOptionMixin.java
@@ -13,12 +13,11 @@ import java.util.function.Consumer;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.option.SimpleOption;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.OptionInstance;
 import net.wurstclient.mixinterface.ISimpleOption;
 
-@Mixin(SimpleOption.class)
+@Mixin(OptionInstance.class)
 public class SimpleOptionMixin<T> implements ISimpleOption<T>
 {
 	@Shadow
@@ -26,12 +25,12 @@ public class SimpleOptionMixin<T> implements ISimpleOption<T>
 	
 	@Shadow
 	@Final
-	private Consumer<T> changeCallback;
+	private Consumer<T> onValueUpdate;
 	
 	@Override
 	public void forceSetValue(T newValue)
 	{
-		if(!MinecraftClient.getInstance().isRunning())
+		if(!Minecraft.getInstance().isRunning())
 		{
 			value = newValue;
 			return;
@@ -40,7 +39,7 @@ public class SimpleOptionMixin<T> implements ISimpleOption<T>
 		if(!Objects.equals(value, newValue))
 		{
 			value = newValue;
-			changeCallback.accept(value);
+			onValueUpdate.accept(value);
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/StatsScreenMixin.java b/src/main/java/net/wurstclient/mixin/StatsScreenMixin.java
index b0c433d25..1480a58e2 100644
--- a/src/main/java/net/wurstclient/mixin/StatsScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/StatsScreenMixin.java
@@ -13,25 +13,24 @@ import org.spongepowered.asm.mixin.injection.At;
 
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
-
-import net.minecraft.client.gui.screen.StatsScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.DirectionalLayoutWidget;
-import net.minecraft.client.gui.widget.ThreePartsLayoutWidget;
-import net.minecraft.client.gui.widget.Widget;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.layouts.HeaderAndFooterLayout;
+import net.minecraft.client.gui.layouts.LayoutElement;
+import net.minecraft.client.gui.layouts.LinearLayout;
+import net.minecraft.client.gui.screens.achievement.StatsScreen;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 
 @Mixin(StatsScreen.class)
 public class StatsScreenMixin
 {
 	@WrapOperation(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/gui/widget/ThreePartsLayoutWidget;addFooter(Lnet/minecraft/client/gui/widget/Widget;)Lnet/minecraft/client/gui/widget/Widget;",
+		target = "Lnet/minecraft/client/gui/layouts/HeaderAndFooterLayout;addToFooter(Lnet/minecraft/client/gui/layouts/LayoutElement;)Lnet/minecraft/client/gui/layouts/LayoutElement;",
 		ordinal = 0), method = "init()V")
-	private <T extends Widget> T onAddFooter(ThreePartsLayoutWidget layout,
-		T doneWidget, Operation<T> original)
+	private <T extends LayoutElement> T onAddFooter(
+		HeaderAndFooterLayout layout, T doneWidget, Operation<T> original)
 	{
-		if(!(doneWidget instanceof ButtonWidget doneButton))
+		if(!(doneWidget instanceof Button doneButton))
 			throw new IllegalStateException(
 				"The done button in the statistics screen somehow isn't a button");
 		
@@ -40,16 +39,15 @@ public class StatsScreenMixin
 		
 		doneButton.setWidth(150);
 		
-		DirectionalLayoutWidget subLayout =
-			DirectionalLayoutWidget.horizontal().spacing(5);
-		subLayout.add(ButtonWidget.builder(getButtonText(), this::toggleWurst)
+		LinearLayout subLayout = LinearLayout.horizontal().spacing(5);
+		subLayout.addChild(Button.builder(getButtonText(), this::toggleWurst)
 			.width(150).build());
-		subLayout.add(doneButton);
+		subLayout.addChild(doneButton);
 		return original.call(layout, subLayout);
 	}
 	
 	@Unique
-	private void toggleWurst(ButtonWidget button)
+	private void toggleWurst(Button button)
 	{
 		WurstClient wurst = WurstClient.INSTANCE;
 		wurst.setEnabled(!wurst.isEnabled());
@@ -57,10 +55,10 @@ public class StatsScreenMixin
 	}
 	
 	@Unique
-	private Text getButtonText()
+	private Component getButtonText()
 	{
 		WurstClient wurst = WurstClient.INSTANCE;
 		String text = (wurst.isEnabled() ? "Disable" : "Enable") + " Wurst";
-		return Text.literal(text);
+		return Component.literal(text);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/StatusEffectInstanceMixin.java b/src/main/java/net/wurstclient/mixin/StatusEffectInstanceMixin.java
index 7eee31a95..826c979d2 100644
--- a/src/main/java/net/wurstclient/mixin/StatusEffectInstanceMixin.java
+++ b/src/main/java/net/wurstclient/mixin/StatusEffectInstanceMixin.java
@@ -11,15 +11,16 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-import net.minecraft.entity.effect.StatusEffectInstance;
+import net.minecraft.world.effect.MobEffectInstance;
 import net.wurstclient.WurstClient;
 
-@Mixin(StatusEffectInstance.class)
+@Mixin(MobEffectInstance.class)
 public abstract class StatusEffectInstanceMixin
-	implements Comparable<StatusEffectInstance>
+	implements Comparable<MobEffectInstance>
 {
-	@Inject(at = @At("HEAD"), method = "updateDuration()V", cancellable = true)
+	@Inject(at = @At("HEAD"),
+		method = "tickDownDuration()V",
+		cancellable = true)
 	private void onUpdateDuration(CallbackInfo ci)
 	{
 		if(WurstClient.INSTANCE.getHax().potionSaverHack.isFrozen())
diff --git a/src/main/java/net/wurstclient/mixin/TelemetryManagerMixin.java b/src/main/java/net/wurstclient/mixin/TelemetryManagerMixin.java
index d02e7de40..b888ed28a 100644
--- a/src/main/java/net/wurstclient/mixin/TelemetryManagerMixin.java
+++ b/src/main/java/net/wurstclient/mixin/TelemetryManagerMixin.java
@@ -11,23 +11,22 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.client.session.telemetry.TelemetryManager;
-import net.minecraft.client.session.telemetry.TelemetrySender;
+import net.minecraft.client.telemetry.ClientTelemetryManager;
+import net.minecraft.client.telemetry.TelemetryEventSender;
 import net.wurstclient.WurstClient;
 
-@Mixin(TelemetryManager.class)
+@Mixin(ClientTelemetryManager.class)
 public class TelemetryManagerMixin
 {
 	@Inject(at = @At("HEAD"),
-		method = "getSender()Lnet/minecraft/client/session/telemetry/TelemetrySender;",
+		method = "getOutsideSessionSender()Lnet/minecraft/client/telemetry/TelemetryEventSender;",
 		cancellable = true)
-	private void onGetSender(CallbackInfoReturnable<TelemetrySender> cir)
+	private void onGetSender(CallbackInfoReturnable<TelemetryEventSender> cir)
 	{
 		if(!WurstClient.INSTANCE.getOtfs().noTelemetryOtf.isEnabled())
 			return;
 		
 		// Return a dummy that can't actually send anything. :)
-		cir.setReturnValue(TelemetrySender.NOOP);
+		cir.setReturnValue(TelemetryEventSender.DISABLED);
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/TextRendererMixin.java b/src/main/java/net/wurstclient/mixin/TextRendererMixin.java
index 34688f276..237b0c935 100644
--- a/src/main/java/net/wurstclient/mixin/TextRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/TextRendererMixin.java
@@ -10,32 +10,31 @@ package net.wurstclient.mixin;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.ModifyVariable;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.font.TextRenderer.TextLayerType;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.Font.DisplayMode;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
-@Mixin(TextRenderer.class)
+@Mixin(Font.class)
 public abstract class TextRendererMixin
 {
 	@ModifyVariable(
-		method = "draw(Ljava/lang/String;FFIZLorg/joml/Matrix4f;Lnet/minecraft/client/render/VertexConsumerProvider;Lnet/minecraft/client/font/TextRenderer$TextLayerType;II)V",
+		method = "drawInBatch(Ljava/lang/String;FFIZLorg/joml/Matrix4f;Lnet/minecraft/client/renderer/MultiBufferSource;Lnet/minecraft/client/gui/Font$DisplayMode;II)V",
 		at = @At("HEAD"),
 		argsOnly = true,
 		ordinal = 0)
-	private TextLayerType nicewurst$enforceDepthOnStringLabels(
-		TextLayerType originalLayer)
+	private DisplayMode nicewurst$enforceDepthOnStringLabels(
+		DisplayMode originalLayer)
 	{
 		return NiceWurstModule.enforceTextLayer(originalLayer);
 	}
 	
 	@ModifyVariable(
-		method = "draw(Lnet/minecraft/text/Text;FFIZLorg/joml/Matrix4f;Lnet/minecraft/client/render/VertexConsumerProvider;Lnet/minecraft/client/font/TextRenderer$TextLayerType;II)V",
+		method = "drawInBatch(Lnet/minecraft/network/chat/Component;FFIZLorg/joml/Matrix4f;Lnet/minecraft/client/renderer/MultiBufferSource;Lnet/minecraft/client/gui/Font$DisplayMode;II)V",
 		at = @At("HEAD"),
 		argsOnly = true,
 		ordinal = 0)
-	private TextLayerType nicewurst$enforceDepthOnComponentLabels(
-		TextLayerType originalLayer)
+	private DisplayMode nicewurst$enforceDepthOnComponentLabels(
+		DisplayMode originalLayer)
 	{
 		return NiceWurstModule.enforceTextLayer(originalLayer);
 	}
diff --git a/src/main/java/net/wurstclient/mixin/TextVisitFactoryMixin.java b/src/main/java/net/wurstclient/mixin/TextVisitFactoryMixin.java
index 3ee3282d2..1b44e7bf5 100644
--- a/src/main/java/net/wurstclient/mixin/TextVisitFactoryMixin.java
+++ b/src/main/java/net/wurstclient/mixin/TextVisitFactoryMixin.java
@@ -10,17 +10,16 @@ package net.wurstclient.mixin;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.ModifyArg;
-
-import net.minecraft.text.TextVisitFactory;
+import net.minecraft.util.StringDecomposer;
 import net.wurstclient.WurstClient;
 
-@Mixin(TextVisitFactory.class)
+@Mixin(StringDecomposer.class)
 public abstract class TextVisitFactoryMixin
 {
 	@ModifyArg(at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/text/TextVisitFactory;visitFormatted(Ljava/lang/String;ILnet/minecraft/text/Style;Lnet/minecraft/text/Style;Lnet/minecraft/text/CharacterVisitor;)Z",
+		target = "Lnet/minecraft/util/StringDecomposer;iterateFormatted(Ljava/lang/String;ILnet/minecraft/network/chat/Style;Lnet/minecraft/network/chat/Style;Lnet/minecraft/util/FormattedCharSink;)Z",
 		ordinal = 0),
-		method = "visitFormatted(Ljava/lang/String;ILnet/minecraft/text/Style;Lnet/minecraft/text/CharacterVisitor;)Z",
+		method = "iterateFormatted(Ljava/lang/String;ILnet/minecraft/network/chat/Style;Lnet/minecraft/util/FormattedCharSink;)Z",
 		index = 0)
 	private static String adjustText(String text)
 	{
diff --git a/src/main/java/net/wurstclient/mixin/TitleScreenMixin.java b/src/main/java/net/wurstclient/mixin/TitleScreenMixin.java
index 4a27652fe..22525bc9b 100644
--- a/src/main/java/net/wurstclient/mixin/TitleScreenMixin.java
+++ b/src/main/java/net/wurstclient/mixin/TitleScreenMixin.java
@@ -14,12 +14,12 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.TitleScreen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.resource.language.I18n;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.TitleScreen;
+import net.minecraft.client.resources.language.I18n;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.altmanager.screens.AltManagerScreen;
 import net.wurstclient.nicewurst.NiceWurstModule;
@@ -27,10 +27,10 @@ import net.wurstclient.nicewurst.NiceWurstModule;
 @Mixin(TitleScreen.class)
 public abstract class TitleScreenMixin extends Screen
 {
-	private ClickableWidget realmsButton = null;
-	private ButtonWidget altsButton;
+	private AbstractWidget realmsButton = null;
+	private Button altsButton;
 	
-	private TitleScreenMixin(WurstClient wurst, Text title)
+	private TitleScreenMixin(WurstClient wurst, Component title)
 	{
 		super(title);
 	}
@@ -39,17 +39,16 @@ public abstract class TitleScreenMixin extends Screen
 	 * Adds the AltManager button to the title screen. This mixin must not
 	 * run in demo mode, as the Realms button doesn't exist there.
 	 */
-	@Inject(at = @At("RETURN"), method = "addNormalWidgets(II)I")
+	@Inject(at = @At("RETURN"), method = "createNormalMenuOptions(II)I")
 	private void onAddNormalWidgets(int y, int spacingY,
 		CallbackInfoReturnable<Integer> cir)
 	{
 		if(!WurstClient.INSTANCE.isEnabled())
 			return;
 		
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
-			if(!button.getMessage().getString()
-				.equals(I18n.translate("menu.online")))
+			if(!button.getMessage().getString().equals(I18n.get("menu.online")))
 				continue;
 			
 			realmsButton = button;
@@ -65,12 +64,11 @@ public abstract class TitleScreenMixin extends Screen
 			realmsButton.setWidth(98);
 			
 			// add AltManager button
-			addDrawableChild(altsButton = ButtonWidget
-				.builder(Text.literal("Alt Manager"),
-					b -> client.setScreen(new AltManagerScreen(this,
+			addRenderableWidget(altsButton = Button
+				.builder(Component.literal("Alt Manager"),
+					b -> minecraft.setScreen(new AltManagerScreen(this,
 						WurstClient.INSTANCE.getAltManager())))
-				.dimensions(width / 2 + 2, realmsButton.getY(), 98, 20)
-				.build());
+				.bounds(width / 2 + 2, realmsButton.getY(), 98, 20).build());
 		}else
 			altsButton = null;
 	}
@@ -91,9 +89,10 @@ public abstract class TitleScreenMixin extends Screen
 	 * account is parental-control'd or banned from online play.
 	 */
 	@Inject(at = @At("HEAD"),
-		method = "getMultiplayerDisabledText()Lnet/minecraft/text/Text;",
+		method = "getMultiplayerDisabledReason()Lnet/minecraft/network/chat/Component;",
 		cancellable = true)
-	private void onGetMultiplayerDisabledText(CallbackInfoReturnable<Text> cir)
+	private void onGetMultiplayerDisabledText(
+		CallbackInfoReturnable<Component> cir)
 	{
 		cir.setReturnValue(null);
 	}
diff --git a/src/main/java/net/wurstclient/mixin/TrialSpawnerDataAccessor.java b/src/main/java/net/wurstclient/mixin/TrialSpawnerDataAccessor.java
index 88661790a..18e60b21e 100644
--- a/src/main/java/net/wurstclient/mixin/TrialSpawnerDataAccessor.java
+++ b/src/main/java/net/wurstclient/mixin/TrialSpawnerDataAccessor.java
@@ -9,24 +9,22 @@ package net.wurstclient.mixin;
 
 import java.util.Set;
 import java.util.UUID;
-
+import net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerStateData;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-import net.minecraft.block.spawner.TrialSpawnerData;
-
-@Mixin(TrialSpawnerData.class)
+@Mixin(TrialSpawnerStateData.class)
 public interface TrialSpawnerDataAccessor
 {
-	@Accessor("cooldownEnd")
+	@Accessor("cooldownEndsAt")
 	long getCooldownEnd();
 	
 	@Accessor("nextMobSpawnsAt")
 	long getNextMobSpawnsAt();
 	
-	@Accessor("totalSpawnedMobs")
+	@Accessor("totalMobsSpawned")
 	int getTotalSpawnedMobs();
 	
-	@Accessor("spawnedMobsAlive")
+	@Accessor("currentMobs")
 	Set<UUID> getSpawnedMobsAlive();
 }
diff --git a/src/main/java/net/wurstclient/mixin/WorldMixin.java b/src/main/java/net/wurstclient/mixin/WorldMixin.java
index 1ce1ca295..d494c2fcb 100644
--- a/src/main/java/net/wurstclient/mixin/WorldMixin.java
+++ b/src/main/java/net/wurstclient/mixin/WorldMixin.java
@@ -11,18 +11,15 @@ import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.world.World;
-import net.minecraft.world.WorldAccess;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hacks.NoWeatherHack;
 
-@Mixin(World.class)
-public abstract class WorldMixin implements WorldAccess, AutoCloseable
+@Mixin(Level.class)
+public abstract class WorldMixin implements LevelAccessor, AutoCloseable
 {
-	@Inject(at = @At("HEAD"),
-		method = "getRainGradient(F)F",
-		cancellable = true)
+	@Inject(at = @At("HEAD"), method = "getRainLevel(F)F", cancellable = true)
 	private void onGetRainGradient(float delta,
 		CallbackInfoReturnable<Float> cir)
 	{
@@ -31,14 +28,14 @@ public abstract class WorldMixin implements WorldAccess, AutoCloseable
 	}
 	
 	@Override
-	public float getSkyAngle(float tickDelta)
+	public float getTimeOfDay(float tickDelta)
 	{
 		NoWeatherHack noWeather = WurstClient.INSTANCE.getHax().noWeatherHack;
 		
 		long timeOfDay = noWeather.isTimeChanged() ? noWeather.getChangedTime()
-			: getLevelProperties().getTimeOfDay();
+			: getLevelData().getDayTime();
 		
-		return getDimension().getSkyAngle(timeOfDay);
+		return dimensionType().timeOfDay(timeOfDay);
 	}
 	
 	@Override
@@ -49,6 +46,6 @@ public abstract class WorldMixin implements WorldAccess, AutoCloseable
 		if(noWeather.isMoonPhaseChanged())
 			return noWeather.getChangedMoonPhase();
 		
-		return getDimension().getMoonPhase(getLunarTime());
+		return dimensionType().moonPhase(dayTime());
 	}
 }
diff --git a/src/main/java/net/wurstclient/mixin/WorldRendererMixin.java b/src/main/java/net/wurstclient/mixin/WorldRendererMixin.java
index c4e574189..03b846cb9 100644
--- a/src/main/java/net/wurstclient/mixin/WorldRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/WorldRendererMixin.java
@@ -16,21 +16,20 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 
 import com.mojang.blaze3d.buffers.GpuBufferSlice;
-
-import net.minecraft.client.render.Camera;
-import net.minecraft.client.render.RenderTickCounter;
-import net.minecraft.client.render.WorldRenderer;
-import net.minecraft.client.util.ObjectAllocator;
-import net.minecraft.client.util.math.MatrixStack;
+import com.mojang.blaze3d.resource.GraphicsResourceAllocator;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.Camera;
+import net.minecraft.client.DeltaTracker;
+import net.minecraft.client.renderer.LevelRenderer;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.RenderListener.RenderEvent;
 
-@Mixin(WorldRenderer.class)
+@Mixin(LevelRenderer.class)
 public class WorldRendererMixin
 {
 	@Inject(at = @At("HEAD"),
-		method = "hasBlindnessOrDarkness(Lnet/minecraft/client/render/Camera;)Z",
+		method = "doesMobEffectBlockSky(Lnet/minecraft/client/Camera;)Z",
 		cancellable = true)
 	private void onHasBlindnessOrDarkness(Camera camera,
 		CallbackInfoReturnable<Boolean> ci)
@@ -40,16 +39,16 @@ public class WorldRendererMixin
 	}
 	
 	@Inject(at = @At("RETURN"),
-		method = "render(Lnet/minecraft/client/util/ObjectAllocator;Lnet/minecraft/client/render/RenderTickCounter;ZLnet/minecraft/client/render/Camera;Lorg/joml/Matrix4f;Lorg/joml/Matrix4f;Lorg/joml/Matrix4f;Lcom/mojang/blaze3d/buffers/GpuBufferSlice;Lorg/joml/Vector4f;Z)V")
-	private void onRender(ObjectAllocator allocator,
-		RenderTickCounter tickCounter, boolean renderBlockOutline,
-		Camera camera, Matrix4f positionMatrix, Matrix4f projectionMatrix,
-		Matrix4f matrix4f2, GpuBufferSlice gpuBufferSlice, Vector4f vector4f,
-		boolean bl, CallbackInfo ci)
+		method = "renderLevel(Lcom/mojang/blaze3d/resource/GraphicsResourceAllocator;Lnet/minecraft/client/DeltaTracker;ZLnet/minecraft/client/Camera;Lorg/joml/Matrix4f;Lorg/joml/Matrix4f;Lorg/joml/Matrix4f;Lcom/mojang/blaze3d/buffers/GpuBufferSlice;Lorg/joml/Vector4f;Z)V")
+	private void onRender(GraphicsResourceAllocator allocator,
+		DeltaTracker tickCounter, boolean renderBlockOutline, Camera camera,
+		Matrix4f positionMatrix, Matrix4f projectionMatrix, Matrix4f matrix4f2,
+		GpuBufferSlice gpuBufferSlice, Vector4f vector4f, boolean bl,
+		CallbackInfo ci)
 	{
-		MatrixStack matrixStack = new MatrixStack();
-		matrixStack.multiplyPositionMatrix(positionMatrix);
-		float tickProgress = tickCounter.getTickProgress(false);
+		PoseStack matrixStack = new PoseStack();
+		matrixStack.mulPose(positionMatrix);
+		float tickProgress = tickCounter.getGameTimeDeltaPartialTick(false);
 		RenderEvent event = new RenderEvent(matrixStack, tickProgress);
 		EventManager.fire(event);
 	}
diff --git a/src/main/java/net/wurstclient/mixin/indigo/BlockRenderInfoMixin.java b/src/main/java/net/wurstclient/mixin/indigo/BlockRenderInfoMixin.java
index 19e66e3bc..382518d01 100644
--- a/src/main/java/net/wurstclient/mixin/indigo/BlockRenderInfoMixin.java
+++ b/src/main/java/net/wurstclient/mixin/indigo/BlockRenderInfoMixin.java
@@ -13,10 +13,9 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ShouldDrawSideListener.ShouldDrawSideEvent;
 
diff --git a/src/main/java/net/wurstclient/mixin/sodium/AbstractBlockRenderContextMixin.java b/src/main/java/net/wurstclient/mixin/sodium/AbstractBlockRenderContextMixin.java
index e89df43de..80394b68b 100644
--- a/src/main/java/net/wurstclient/mixin/sodium/AbstractBlockRenderContextMixin.java
+++ b/src/main/java/net/wurstclient/mixin/sodium/AbstractBlockRenderContextMixin.java
@@ -14,10 +14,9 @@ import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ShouldDrawSideListener.ShouldDrawSideEvent;
 
diff --git a/src/main/java/net/wurstclient/mixin/sodium/DefaultFluidRendererMixin.java b/src/main/java/net/wurstclient/mixin/sodium/DefaultFluidRendererMixin.java
index f1c8b1520..be6dcd99b 100644
--- a/src/main/java/net/wurstclient/mixin/sodium/DefaultFluidRendererMixin.java
+++ b/src/main/java/net/wurstclient/mixin/sodium/DefaultFluidRendererMixin.java
@@ -15,12 +15,11 @@ import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
 
 import com.llamalad7.mixinextras.injector.ModifyExpressionValue;
 import com.llamalad7.mixinextras.sugar.Local;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.fluid.FluidState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.world.BlockRenderView;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.level.BlockAndTintGetter;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.FluidState;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.ShouldDrawSideListener.ShouldDrawSideEvent;
@@ -46,8 +45,8 @@ public class DefaultFluidRendererMixin
 		cancellable = true,
 		remap = false,
 		require = 0)
-	private void onIsFullBlockFluidOccluded(BlockRenderView world, BlockPos pos,
-		Direction dir, BlockState state, FluidState fluid,
+	private void onIsFullBlockFluidOccluded(BlockAndTintGetter world,
+		BlockPos pos, Direction dir, BlockState state, FluidState fluid,
 		CallbackInfoReturnable<Boolean> cir)
 	{
 		ShouldDrawSideEvent event = new ShouldDrawSideEvent(state, pos);
@@ -80,7 +79,7 @@ public class DefaultFluidRendererMixin
 		
 		XRayHack xray = WurstClient.INSTANCE.getHax().xRayHack;
 		if(!xray.isOpacityMode()
-			|| xray.isVisible(fluid.getBlockState().getBlock(), pos))
+			|| xray.isVisible(fluid.createLegacyBlock().getBlock(), pos))
 			return original;
 		
 		return original & xray.getOpacityColorMask();
diff --git a/src/main/java/net/wurstclient/mixinterface/IClientPlayerInteractionManager.java b/src/main/java/net/wurstclient/mixinterface/IClientPlayerInteractionManager.java
index a58744cec..68758492b 100644
--- a/src/main/java/net/wurstclient/mixinterface/IClientPlayerInteractionManager.java
+++ b/src/main/java/net/wurstclient/mixinterface/IClientPlayerInteractionManager.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.mixinterface;
 
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 
 public interface IClientPlayerInteractionManager
 {
@@ -26,11 +26,12 @@ public interface IClientPlayerInteractionManager
 	
 	public void rightClickItem();
 	
-	public void rightClickBlock(BlockPos pos, Direction side, Vec3d hitVec);
+	public void rightClickBlock(BlockPos pos, Direction side, Vec3 hitVec);
 	
-	public void sendPlayerActionC2SPacket(PlayerActionC2SPacket.Action action,
-		BlockPos blockPos, Direction direction);
+	public void sendPlayerActionC2SPacket(
+		ServerboundPlayerActionPacket.Action action, BlockPos blockPos,
+		Direction direction);
 	
-	public void sendPlayerInteractBlockPacket(Hand hand,
+	public void sendPlayerInteractBlockPacket(InteractionHand hand,
 		BlockHitResult blockHitResult);
 }
diff --git a/src/main/java/net/wurstclient/mixinterface/IKeyBinding.java b/src/main/java/net/wurstclient/mixinterface/IKeyBinding.java
index cf47475e8..aa45bae11 100644
--- a/src/main/java/net/wurstclient/mixinterface/IKeyBinding.java
+++ b/src/main/java/net/wurstclient/mixinterface/IKeyBinding.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.mixinterface;
 
-import net.minecraft.client.option.KeyBinding;
+import net.minecraft.client.KeyMapping;
 
 public interface IKeyBinding
 {
@@ -32,19 +32,19 @@ public interface IKeyBinding
 	
 	public default void setPressed(boolean pressed)
 	{
-		asVanilla().setPressed(pressed);
+		asVanilla().setDown(pressed);
 	}
 	
-	public default KeyBinding asVanilla()
+	public default KeyMapping asVanilla()
 	{
-		return (KeyBinding)this;
+		return (KeyMapping)this;
 	}
 	
 	/**
 	 * Returns the given KeyBinding object as an IKeyBinding, allowing you to
 	 * access the resetPressedState() method.
 	 */
-	public static IKeyBinding get(KeyBinding kb)
+	public static IKeyBinding get(KeyMapping kb)
 	{
 		return (IKeyBinding)kb;
 	}
diff --git a/src/main/java/net/wurstclient/mixinterface/IMinecraftClient.java b/src/main/java/net/wurstclient/mixinterface/IMinecraftClient.java
index 67246fca7..339641d00 100644
--- a/src/main/java/net/wurstclient/mixinterface/IMinecraftClient.java
+++ b/src/main/java/net/wurstclient/mixinterface/IMinecraftClient.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.mixinterface;
 
-import net.minecraft.client.session.Session;
+import net.minecraft.client.User;
 
 public interface IMinecraftClient
 {
@@ -15,7 +15,7 @@ public interface IMinecraftClient
 	
 	public IClientPlayerEntity getPlayer();
 	
-	public Session getWurstSession();
+	public User getWurstSession();
 	
-	public void setWurstSession(Session session);
+	public void setWurstSession(User session);
 }
diff --git a/src/main/java/net/wurstclient/mixinterface/ISimpleOption.java b/src/main/java/net/wurstclient/mixinterface/ISimpleOption.java
index 994b0d543..c413677e9 100644
--- a/src/main/java/net/wurstclient/mixinterface/ISimpleOption.java
+++ b/src/main/java/net/wurstclient/mixinterface/ISimpleOption.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.mixinterface;
 
-import net.minecraft.client.option.SimpleOption;
+import net.minecraft.client.OptionInstance;
 
 public interface ISimpleOption<T>
 {
@@ -22,7 +22,7 @@ public interface ISimpleOption<T>
 	 * to access the forceSetValue() method.
 	 */
 	@SuppressWarnings("unchecked")
-	public static <T> ISimpleOption<T> get(SimpleOption<T> option)
+	public static <T> ISimpleOption<T> get(OptionInstance<T> option)
 	{
 		return (ISimpleOption<T>)(Object)option;
 	}
diff --git a/src/main/java/net/wurstclient/navigator/NavigatorFeatureScreen.java b/src/main/java/net/wurstclient/navigator/NavigatorFeatureScreen.java
index 8ce4ad3bf..3bc7356b2 100644
--- a/src/main/java/net/wurstclient/navigator/NavigatorFeatureScreen.java
+++ b/src/main/java/net/wurstclient/navigator/NavigatorFeatureScreen.java
@@ -19,17 +19,16 @@ import org.joml.Matrix3x2fStack;
 import org.lwjgl.glfw.GLFW;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.input.MouseInput;
-import net.minecraft.client.sound.PositionedSoundInstance;
-import net.minecraft.sound.SoundEvents;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.client.input.MouseButtonInfo;
+import net.minecraft.client.resources.sounds.SimpleSoundInstance;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.util.CommonColors;
+import net.minecraft.util.Mth;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
@@ -50,7 +49,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	private Feature feature;
 	private NavigatorMainScreen parent;
 	private ButtonData activeButton;
-	private ButtonWidget primaryButton;
+	private Button primaryButton;
 	private String text;
 	private ArrayList<ButtonData> buttonDatas = new ArrayList<>();
 	
@@ -89,8 +88,9 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 		boolean hasPrimaryAction = !primaryAction.isEmpty();
 		if(hasPrimaryAction)
 		{
-			primaryButton =
-				ButtonWidget.builder(Text.literal(primaryAction), b -> {
+			primaryButton = Button.builder(
+				net.minecraft.network.chat.Component.literal(primaryAction),
+				b -> {
 					TooManyHaxHack tooManyHax =
 						WurstClient.INSTANCE.getHax().tooManyHaxHack;
 					if(tooManyHax.isEnabled() && tooManyHax.isBlocked(feature))
@@ -103,11 +103,12 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 					feature.doPrimaryAction();
 					
 					primaryButton
-						.setMessage(Text.literal(feature.getPrimaryAction()));
+						.setMessage(net.minecraft.network.chat.Component
+							.literal(feature.getPrimaryAction()));
 					WurstClient.INSTANCE.getNavigator()
 						.addPreference(feature.getName());
-				}).dimensions(width / 2 - 151, height - 65, 302, 18).build();
-			addDrawableChild(primaryButton);
+				}).bounds(width / 2 - 151, height - 65, 302, 18).build();
+			addRenderableWidget(primaryButton);
 		}
 		
 		// type
@@ -138,7 +139,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 			text += "\n\nSettings:";
 			window.validate();
 			
-			int fontHeight = client.textRenderer.fontHeight;
+			int fontHeight = minecraft.font.lineHeight;
 			if(fontHeight <= 0)
 				fontHeight = 9;
 			
@@ -231,7 +232,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 					public void press()
 					{
 						// remove keybind
-						client.setScreen(new NavigatorRemoveKeybindScreen(
+						minecraft.setScreen(new NavigatorRemoveKeybindScreen(
 							existingKeybinds, NavigatorFeatureScreen.this));
 					}
 				});
@@ -245,7 +246,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onKeyPress(KeyInput context)
+	protected void onKeyPress(KeyEvent context)
 	{
 		int keyCode = context.key();
 		
@@ -255,7 +256,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onMouseClick(Click context)
+	protected void onMouseClick(MouseButtonEvent context)
 	{
 		double x = context.x();
 		double y = context.y();
@@ -282,8 +283,8 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 		// buttons
 		if(activeButton != null)
 		{
-			client.getSoundManager().play(
-				PositionedSoundInstance.master(SoundEvents.UI_BUTTON_CLICK, 1));
+			minecraft.getSoundManager().play(
+				SimpleSoundInstance.forUI(SoundEvents.UI_BUTTON_CLICK, 1));
 			activeButton.press();
 			WurstClient.INSTANCE.getNavigator()
 				.addPreference(feature.getName());
@@ -299,7 +300,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	private void goBack()
 	{
 		parent.setExpanding(false);
-		client.setScreen(parent);
+		minecraft.setScreen(parent);
 	}
 	
 	@Override
@@ -319,20 +320,21 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	protected void onUpdate()
 	{
 		if(primaryButton != null)
-			primaryButton.setMessage(Text.literal(feature.getPrimaryAction()));
+			primaryButton.setMessage(net.minecraft.network.chat.Component
+				.literal(feature.getPrimaryAction()));
 	}
 	
 	@Override
-	protected void onRender(DrawContext context, int mouseX, int mouseY,
+	protected void onRender(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		ClickGui gui = WurstClient.INSTANCE.getGui();
 		int txtColor = gui.getTxtColor();
 		
 		// title bar
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			feature.getName(), middleX, 32, txtColor);
+		context.drawCenteredString(minecraft.font, feature.getName(), middleX,
+			32, txtColor);
 		
 		// background
 		int bgx1 = middleX - 154;
@@ -345,9 +347,9 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 		int windowY1 = bgy1 + scroll + windowComponentY;
 		int windowY2 = windowY1 + window.getInnerHeight();
 		
-		context.fill(bgx1, bgy1, bgx2, MathHelper.clamp(windowY1, bgy1, bgy3),
+		context.fill(bgx1, bgy1, bgx2, Mth.clamp(windowY1, bgy1, bgy3),
 			getBackgroundColor());
-		context.fill(bgx1, MathHelper.clamp(windowY2, bgy1, bgy3), bgx2, bgy2,
+		context.fill(bgx1, Mth.clamp(windowY2, bgy1, bgy3), bgx2, bgy2,
 			getBackgroundColor());
 		RenderUtils.drawBoxShadow2D(context, bgx1, bgy1, bgx2, bgy2);
 		
@@ -448,27 +450,27 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 				RenderUtils.toIntColor(rgb, alpha));
 			
 			// text
-			context.state.goUpLayer();
-			context.drawCenteredTextWithShadow(client.textRenderer,
-				buttonData.buttonText, (x1 + x2) / 2,
-				y1 + (buttonData.height - 10) / 2 + 1, buttonData.isLocked()
-					? WurstColors.VERY_LIGHT_GRAY : buttonData.textColor);
+			context.guiRenderState.up();
+			context.drawCenteredString(minecraft.font, buttonData.buttonText,
+				(x1 + x2) / 2, y1 + (buttonData.height - 10) / 2 + 1,
+				buttonData.isLocked() ? WurstColors.VERY_LIGHT_GRAY
+					: buttonData.textColor);
 		}
 		
 		// text
 		int textY = bgy1 + scroll + 2;
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		for(String line : text.split("\n"))
 		{
-			context.drawText(client.textRenderer, line, bgx1 + 2, textY,
-				txtColor, false);
-			textY += client.textRenderer.fontHeight;
+			context.drawString(minecraft.font, line, bgx1 + 2, textY, txtColor,
+				false);
+			textY += minecraft.font.lineHeight;
 		}
 		
 		context.disableScissor();
 		
 		// buttons below scissor box
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
 			// positions
 			int x1 = button.getX();
@@ -490,10 +492,10 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 			
 			// text
 			String buttonText = button.getMessage().getString();
-			context.state.goUpLayer();
-			context.drawText(client.textRenderer, buttonText,
-				(x1 + x2 - client.textRenderer.getWidth(buttonText)) / 2,
-				y1 + 5, txtColor, false);
+			context.guiRenderState.up();
+			context.drawString(minecraft.font, buttonText,
+				(x1 + x2 - minecraft.font.width(buttonText)) / 2, y1 + 5,
+				txtColor, false);
 		}
 		
 		// popups & tooltip
@@ -502,11 +504,11 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
 		window.close();
-		WurstClient.INSTANCE.getGui().handleMouseClick(new Click(
-			Double.MIN_VALUE, Double.MIN_VALUE, new MouseInput(0, 0)));
+		WurstClient.INSTANCE.getGui().handleMouseClick(new MouseButtonEvent(
+			Double.MIN_VALUE, Double.MIN_VALUE, new MouseButtonInfo(0, 0)));
 	}
 	
 	public Feature getFeature()
@@ -533,7 +535,7 @@ public final class NavigatorFeatureScreen extends NavigatorScreen
 	{
 		public String buttonText;
 		public Color color;
-		public int textColor = Colors.WHITE;
+		public int textColor = CommonColors.WHITE;
 		
 		public ButtonData(int x, int y, int width, int height,
 			String buttonText, int color)
diff --git a/src/main/java/net/wurstclient/navigator/NavigatorMainScreen.java b/src/main/java/net/wurstclient/navigator/NavigatorMainScreen.java
index 4c1a2a671..d80888de1 100644
--- a/src/main/java/net/wurstclient/navigator/NavigatorMainScreen.java
+++ b/src/main/java/net/wurstclient/navigator/NavigatorMainScreen.java
@@ -11,14 +11,13 @@ import java.awt.Rectangle;
 import java.util.ArrayList;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
@@ -31,7 +30,7 @@ public final class NavigatorMainScreen extends NavigatorScreen
 {
 	private static final ArrayList<Feature> navigatorDisplayList =
 		new ArrayList<>();
-	private TextFieldWidget searchBar;
+	private EditBox searchBar;
 	private String lastSearchText = "";
 	private String tooltip;
 	private int hoveredFeature = -1;
@@ -65,13 +64,13 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		ClickGui gui = WurstClient.INSTANCE.getGui();
 		int txtColor = gui.getTxtColor();
 		
-		TextRenderer tr = WurstClient.MC.textRenderer;
-		searchBar = new TextFieldWidget(tr, 0, 32, 200, 20, Text.literal(""));
-		searchBar.setEditableColor(txtColor);
-		searchBar.setDrawsBackground(false);
+		Font tr = WurstClient.MC.font;
+		searchBar = new EditBox(tr, 0, 32, 200, 20, Component.literal(""));
+		searchBar.setTextColor(txtColor);
+		searchBar.setBordered(false);
 		searchBar.setMaxLength(128);
 		
-		addSelectableChild(searchBar);
+		addWidget(searchBar);
 		setFocused(searchBar);
 		searchBar.setFocused(true);
 		
@@ -80,17 +79,17 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		// if we have an initial search text, populate the search bar
 		if(!initialSearchText.isEmpty())
 		{
-			searchBar.setText(initialSearchText);
+			searchBar.setValue(initialSearchText);
 			lastSearchText = ""; // force update on next tick
 		}
 		setContentHeight(navigatorDisplayList.size() / 3 * 20);
 	}
 	
 	@Override
-	protected void onKeyPress(KeyInput context)
+	protected void onKeyPress(KeyEvent context)
 	{
 		int keyCode = context.key();
-		boolean hasShiftDown = context.hasShift();
+		boolean hasShiftDown = context.hasShiftDown();
 		
 		if(keyCode == GLFW.GLFW_KEY_ENTER)
 			leftClick(selectedFeature);
@@ -121,10 +120,10 @@ public final class NavigatorMainScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onMouseClick(Click context)
+	protected void onMouseClick(MouseButtonEvent context)
 	{
 		int button = context.button();
-		boolean hasShiftDown = context.hasShift();
+		boolean hasShiftDown = context.hasShiftDown();
 		
 		if(clickTimer != -1)
 			return;
@@ -192,7 +191,7 @@ public final class NavigatorMainScreen extends NavigatorScreen
 	@Override
 	protected void onUpdate()
 	{
-		String newText = searchBar.getText();
+		String newText = searchBar.getValue();
 		if(clickTimer == -1 && !newText.equals(lastSearchText))
 		{
 			Navigator navigator = WurstClient.INSTANCE.getNavigator();
@@ -229,7 +228,7 @@ public final class NavigatorMainScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onRender(DrawContext context, int mouseX, int mouseY,
+	protected void onRender(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		ClickGui gui = WurstClient.INSTANCE.getGui();
@@ -241,8 +240,8 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		// search bar
 		if(!clickTimerRunning)
 		{
-			context.drawTextWithShadow(WurstClient.MC.textRenderer, "Search: ",
-				middleX - 150, 32, txtColor);
+			context.drawString(WurstClient.MC.font, "Search: ", middleX - 150,
+				32, txtColor);
 			searchBar.render(context, mouseX, mouseY, partialTicks);
 		}
 		
@@ -273,21 +272,21 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		// tooltip
 		if(tooltip != null)
 		{
-			context.state.goUpLayer();
+			context.guiRenderState.up();
 			
 			String[] lines = tooltip.split("\n");
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			int tw = 0;
-			int th = lines.length * tr.fontHeight;
+			int th = lines.length * tr.lineHeight;
 			for(String line : lines)
 			{
-				int lw = tr.getWidth(line);
+				int lw = tr.width(line);
 				if(lw > tw)
 					tw = lw;
 			}
-			int sw = client.currentScreen.width;
-			int sh = client.currentScreen.height;
+			int sw = minecraft.screen.width;
+			int sh = minecraft.screen.height;
 			
 			int xt1 = mouseX + tw + 11 <= sw ? mouseX + 8 : mouseX - tw - 8;
 			int xt2 = xt1 + tw + 3;
@@ -304,14 +303,14 @@ public final class NavigatorMainScreen extends NavigatorScreen
 			RenderUtils.drawBorder2D(context, xt1, yt1, xt2, yt2, acColor);
 			
 			// text
-			context.state.goUpLayer();
+			context.guiRenderState.up();
 			for(int i = 0; i < lines.length; i++)
-				context.drawText(tr, lines[i], xt1 + 2,
-					yt1 + 2 + i * tr.fontHeight, txtColor, false);
+				context.drawString(tr, lines[i], xt1 + 2,
+					yt1 + 2 + i * tr.lineHeight, txtColor, false);
 		}
 	}
 	
-	private void renderFeature(DrawContext context, int mouseX, int mouseY,
+	private void renderFeature(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks, int i, int x, int y)
 	{
 		ClickGui gui = WurstClient.INSTANCE.getGui();
@@ -386,7 +385,7 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		if(hovering)
 			hoveringArrow = mouseX >= bx1;
 		
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		
 		// arrow
 		ClickGuiIcons.drawMinimizeArrow(context, bx1 + 2, area.y + 2.5F,
@@ -395,12 +394,12 @@ public final class NavigatorMainScreen extends NavigatorScreen
 		// text
 		if(!clickTimerRunning)
 		{
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			String buttonText = feature.getName();
 			int bx = area.x + 4;
 			int by = area.y + 4;
 			int txtColor = gui.getTxtColor();
-			context.drawText(tr, buttonText, bx, by, txtColor, false);
+			context.drawString(tr, buttonText, bx, by, txtColor, false);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/navigator/NavigatorNewKeybindScreen.java b/src/main/java/net/wurstclient/navigator/NavigatorNewKeybindScreen.java
index 26318f989..55b63bf26 100644
--- a/src/main/java/net/wurstclient/navigator/NavigatorNewKeybindScreen.java
+++ b/src/main/java/net/wurstclient/navigator/NavigatorNewKeybindScreen.java
@@ -7,20 +7,20 @@
  */
 package net.wurstclient.navigator;
 
+import com.mojang.blaze3d.platform.InputConstants;
 import java.util.Set;
 import java.util.function.Supplier;
 
 import org.lwjgl.glfw.GLFW;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.keybinds.PossibleKeybind;
@@ -33,7 +33,7 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 	private PossibleKeybind selectedCommand;
 	private String selectedKey = "key.keyboard.unknown";
 	private String text = "";
-	private ButtonWidget okButton;
+	private Button okButton;
 	private boolean choosingKey;
 	
 	public NavigatorNewKeybindScreen(Set<PossibleKeybind> possibleKeybinds,
@@ -47,8 +47,8 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 	protected void onResize()
 	{
 		// OK button
-		okButton = new ButtonWidget(width / 2 - 151, height - 65, 149, 18,
-			Text.literal("OK"), b -> {
+		okButton = new Button(width / 2 - 151, height - 65, 149, 18,
+			Component.literal("OK"), b -> {
 				if(choosingKey)
 				{
 					String newCommands = selectedCommand.getCommand();
@@ -63,7 +63,7 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 					
 					WurstClient.INSTANCE.getNavigator()
 						.addPreference(parent.getFeature().getName());
-					client.setScreen(parent);
+					minecraft.setScreen(parent);
 				}else
 				{
 					choosingKey = true;
@@ -72,44 +72,44 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 			}, Supplier::get)
 		{
 			@Override
-			public boolean keyPressed(KeyInput context)
+			public boolean keyPressed(KeyEvent context)
 			{
 				// empty method so that pressing Enter won't trigger this button
 				return false;
 			}
 		};
 		okButton.active = selectedCommand != null;
-		addDrawableChild(okButton);
+		addRenderableWidget(okButton);
 		
 		// cancel button
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"),
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
 				b -> WurstClient.MC.setScreen(parent))
-			.dimensions(width / 2 + 2, height - 65, 149, 18).build());
+			.bounds(width / 2 + 2, height - 65, 149, 18).build());
 	}
 	
 	@Override
-	protected void onKeyPress(KeyInput context)
+	protected void onKeyPress(KeyEvent context)
 	{
 		if(choosingKey)
 		{
-			selectedKey = InputUtil.fromKeyCode(context).getTranslationKey();
+			selectedKey = InputConstants.getKey(context).getName();
 			okButton.active = !selectedKey.equals("key.keyboard.unknown");
 			
 		}else if(context.key() == GLFW.GLFW_KEY_ESCAPE
 			|| context.key() == GLFW.GLFW_KEY_BACKSPACE)
-			client.setScreen(parent);
+			minecraft.setScreen(parent);
 	}
 	
 	@Override
-	protected void onMouseClick(Click context)
+	protected void onMouseClick(MouseButtonEvent context)
 	{
 		int button = context.button();
 		
 		// back button
 		if(button == GLFW.GLFW_MOUSE_BUTTON_4)
 		{
-			client.setScreen(parent);
+			minecraft.setScreen(parent);
 			return;
 		}
 		
@@ -155,16 +155,15 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onRender(DrawContext context, int mouseX, int mouseY,
+	protected void onRender(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		ClickGui gui = WurstClient.INSTANCE.getGui();
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		int txtColor = gui.getTxtColor();
 		
 		// title bar
-		context.drawCenteredTextWithShadow(tr, "New Keybind", middleX, 32,
-			txtColor);
+		context.drawCenteredString(tr, "New Keybind", middleX, 32, txtColor);
 		
 		// background
 		int bgx1 = middleX - 154;
@@ -210,27 +209,27 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 				drawBox(context, x1, y1, x2, y2, buttonColor);
 				
 				// text
-				context.state.goUpLayer();
-				context.drawTextWithShadow(tr, pkb.getDescription(), x1 + 1,
-					y1 + 1, txtColor);
-				context.drawTextWithShadow(tr, pkb.getCommand(), x1 + 1,
-					y1 + 1 + tr.fontHeight, txtColor);
+				context.guiRenderState.up();
+				context.drawString(tr, pkb.getDescription(), x1 + 1, y1 + 1,
+					txtColor);
+				context.drawString(tr, pkb.getCommand(), x1 + 1,
+					y1 + 1 + tr.lineHeight, txtColor);
 			}
 		}
 		
 		// text
 		int textY = bgy1 + scroll + 2;
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		for(String line : text.split("\n"))
 		{
-			context.drawTextWithShadow(tr, line, bgx1 + 2, textY, txtColor);
-			textY += tr.fontHeight;
+			context.drawString(tr, line, bgx1 + 2, textY, txtColor);
+			textY += tr.lineHeight;
 		}
 		
 		context.disableScissor();
 		
 		// buttons below scissor box
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
 			// positions
 			int x1 = button.getX();
@@ -252,10 +251,9 @@ public class NavigatorNewKeybindScreen extends NavigatorScreen
 			drawBox(context, x1, y1, x2, y2, buttonColor);
 			
 			// text
-			context.state.goUpLayer();
-			context.drawCenteredTextWithShadow(tr,
-				button.getMessage().getString(), (x1 + x2) / 2, y1 + 5,
-				txtColor);
+			context.guiRenderState.up();
+			context.drawCenteredString(tr, button.getMessage().getString(),
+				(x1 + x2) / 2, y1 + 5, txtColor);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/navigator/NavigatorRemoveKeybindScreen.java b/src/main/java/net/wurstclient/navigator/NavigatorRemoveKeybindScreen.java
index 2c2f5805d..28f7cbc07 100644
--- a/src/main/java/net/wurstclient/navigator/NavigatorRemoveKeybindScreen.java
+++ b/src/main/java/net/wurstclient/navigator/NavigatorRemoveKeybindScreen.java
@@ -15,13 +15,13 @@ import java.util.TreeMap;
 import org.lwjgl.glfw.GLFW;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.keybinds.PossibleKeybind;
@@ -33,7 +33,7 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 	private String hoveredKey = "";
 	private String selectedKey = "";
 	private String text = "Select the keybind you want to remove.";
-	private ButtonWidget removeButton;
+	private Button removeButton;
 	
 	public NavigatorRemoveKeybindScreen(
 		TreeMap<String, PossibleKeybind> existingKeybinds,
@@ -47,14 +47,15 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 	protected void onResize()
 	{
 		removeButton =
-			ButtonWidget.builder(Text.literal("Remove"), b -> remove())
-				.dimensions(width / 2 - 151, height - 65, 149, 18).build();
+			Button.builder(Component.literal("Remove"), b -> remove())
+				.bounds(width / 2 - 151, height - 65, 149, 18).build();
 		removeButton.active = !selectedKey.isEmpty();
-		addDrawableChild(removeButton);
+		addRenderableWidget(removeButton);
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(parent))
-			.dimensions(width / 2 + 2, height - 65, 149, 18).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(parent))
+			.bounds(width / 2 + 2, height - 65, 149, 18).build());
 	}
 	
 	private void remove()
@@ -87,19 +88,19 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 		WurstClient.INSTANCE.getNavigator()
 			.addPreference(parent.getFeature().getName());
 		
-		client.setScreen(parent);
+		minecraft.setScreen(parent);
 	}
 	
 	@Override
-	protected void onKeyPress(KeyInput context)
+	protected void onKeyPress(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ESCAPE
 			|| context.key() == GLFW.GLFW_KEY_BACKSPACE)
-			client.setScreen(parent);
+			minecraft.setScreen(parent);
 	}
 	
 	@Override
-	protected void onMouseClick(Click context)
+	protected void onMouseClick(MouseButtonEvent context)
 	{
 		int button = context.button();
 		
@@ -125,16 +126,15 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 	}
 	
 	@Override
-	protected void onRender(DrawContext context, int mouseX, int mouseY,
+	protected void onRender(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		ClickGui gui = WurstClient.INSTANCE.getGui();
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		int txtColor = gui.getTxtColor();
 		
 		// title bar
-		context.drawCenteredTextWithShadow(tr, "Remove Keybind", middleX, 32,
-			txtColor);
+		context.drawCenteredString(tr, "Remove Keybind", middleX, 32, txtColor);
 		
 		// background
 		int bgx1 = middleX - 154;
@@ -179,26 +179,26 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 			drawBox(context, x1, y1, x2, y2, buttonColor);
 			
 			// text
-			context.state.goUpLayer();
-			context.drawTextWithShadow(tr, key.replace("key.keyboard.", "")
-				+ ": " + keybind.getDescription(), x1 + 1, y1 + 1, txtColor);
-			context.drawTextWithShadow(tr, keybind.getCommand(), x1 + 1,
-				y1 + 1 + tr.fontHeight, txtColor);
+			context.guiRenderState.up();
+			context.drawString(tr, key.replace("key.keyboard.", "") + ": "
+				+ keybind.getDescription(), x1 + 1, y1 + 1, txtColor);
+			context.drawString(tr, keybind.getCommand(), x1 + 1,
+				y1 + 1 + tr.lineHeight, txtColor);
 		}
 		
 		// text
 		int textY = bgy1 + scroll + 2;
-		context.state.goUpLayer();
+		context.guiRenderState.up();
 		for(String line : text.split("\n"))
 		{
-			context.drawTextWithShadow(tr, line, bgx1 + 2, textY, txtColor);
-			textY += tr.fontHeight;
+			context.drawString(tr, line, bgx1 + 2, textY, txtColor);
+			textY += tr.lineHeight;
 		}
 		
 		context.disableScissor();
 		
 		// buttons below scissor box
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
 			// positions
 			int x1 = button.getX();
@@ -221,9 +221,9 @@ public class NavigatorRemoveKeybindScreen extends NavigatorScreen
 			
 			// text
 			String buttonText = button.getMessage().getString();
-			context.state.goUpLayer();
-			context.drawCenteredTextWithShadow(tr, buttonText, (x1 + x2) / 2,
-				y1 + 5, txtColor);
+			context.guiRenderState.up();
+			context.drawCenteredString(tr, buttonText, (x1 + x2) / 2, y1 + 5,
+				txtColor);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/navigator/NavigatorScreen.java b/src/main/java/net/wurstclient/navigator/NavigatorScreen.java
index 714ce0adf..0496ca967 100644
--- a/src/main/java/net/wurstclient/navigator/NavigatorScreen.java
+++ b/src/main/java/net/wurstclient/navigator/NavigatorScreen.java
@@ -8,12 +8,11 @@
 package net.wurstclient.navigator;
 
 import java.awt.Rectangle;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.ClickGui;
 import net.wurstclient.util.RenderUtils;
@@ -32,7 +31,7 @@ public abstract class NavigatorScreen extends Screen
 	
 	public NavigatorScreen()
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 	}
 	
 	@Override
@@ -43,14 +42,15 @@ public abstract class NavigatorScreen extends Screen
 	}
 	
 	@Override
-	public final boolean keyPressed(KeyInput context)
+	public final boolean keyPressed(KeyEvent context)
 	{
 		onKeyPress(context);
 		return super.keyPressed(context);
 	}
 	
 	@Override
-	public final boolean mouseClicked(Click context, boolean doubleClick)
+	public final boolean mouseClicked(MouseButtonEvent context,
+		boolean doubleClick)
 	{
 		// scrollbar
 		if(new Rectangle(width / 2 + 170, 60, 12, height - 103)
@@ -64,7 +64,7 @@ public abstract class NavigatorScreen extends Screen
 	}
 	
 	@Override
-	public final boolean mouseDragged(Click context, double double_3,
+	public final boolean mouseDragged(MouseButtonEvent context, double double_3,
 		double double_4)
 	{
 		// scrollbar
@@ -95,7 +95,7 @@ public abstract class NavigatorScreen extends Screen
 	}
 	
 	@Override
-	public final boolean mouseReleased(Click context)
+	public final boolean mouseReleased(MouseButtonEvent context)
 	{
 		// scrollbar
 		scrolling = false;
@@ -143,7 +143,7 @@ public abstract class NavigatorScreen extends Screen
 	}
 	
 	@Override
-	public final void render(DrawContext context, int mouseX, int mouseY,
+	public final void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		// background
@@ -182,23 +182,23 @@ public abstract class NavigatorScreen extends Screen
 	}
 	
 	@Override
-	public void renderBackground(DrawContext context, int mouseX, int mouseY,
+	public void renderBackground(GuiGraphics context, int mouseX, int mouseY,
 		float deltaTicks)
 	{
 		// Don't blur
 	}
 	
 	@Override
-	public final boolean shouldPause()
+	public final boolean isPauseScreen()
 	{
 		return false;
 	}
 	
 	protected abstract void onResize();
 	
-	protected abstract void onKeyPress(KeyInput context);
+	protected abstract void onKeyPress(KeyEvent context);
 	
-	protected abstract void onMouseClick(Click context);
+	protected abstract void onMouseClick(MouseButtonEvent context);
 	
 	protected abstract void onMouseDrag(double mouseX, double mouseY,
 		int button, double double_3, double double_4);
@@ -207,12 +207,12 @@ public abstract class NavigatorScreen extends Screen
 	
 	protected abstract void onUpdate();
 	
-	protected abstract void onRender(DrawContext context, int mouseX,
+	protected abstract void onRender(GuiGraphics context, int mouseX,
 		int mouseY, float partialTicks);
 	
 	protected final int getStringHeight(String s)
 	{
-		int fontHeight = client.textRenderer.fontHeight;
+		int fontHeight = minecraft.font.lineHeight;
 		int height = fontHeight;
 		
 		for(int i = 0; i < s.length(); i++)
@@ -233,7 +233,7 @@ public abstract class NavigatorScreen extends Screen
 			scroll = maxScroll;
 	}
 	
-	protected final void drawDownShadow(DrawContext context, int x1, int y1,
+	protected final void drawDownShadow(GuiGraphics context, int x1, int y1,
 		int x2, int y2)
 	{
 		float[] acColor = WurstClient.INSTANCE.getGui().getAcColor();
@@ -249,7 +249,7 @@ public abstract class NavigatorScreen extends Screen
 		context.fillGradient(x1, y1, x2, y2, shadowColor1, shadowColor2);
 	}
 	
-	protected final void drawBox(DrawContext context, int x1, int y1, int x2,
+	protected final void drawBox(GuiGraphics context, int x1, int y1, int x2,
 		int y2, int color)
 	{
 		context.fill(x1, y1, x2, y2, color);
@@ -263,7 +263,7 @@ public abstract class NavigatorScreen extends Screen
 		return RenderUtils.toIntColor(gui.getBgColor(), gui.getOpacity());
 	}
 	
-	protected final void drawBackgroundBox(DrawContext context, int x1, int y1,
+	protected final void drawBackgroundBox(GuiGraphics context, int x1, int y1,
 		int x2, int y2)
 	{
 		drawBox(context, x1, y1, x2, y2, getBackgroundColor());
diff --git a/src/main/java/net/wurstclient/nicewurst/NiceWurstModule.java b/src/main/java/net/wurstclient/nicewurst/NiceWurstModule.java
index 1208fc6e8..7c309ac25 100644
--- a/src/main/java/net/wurstclient/nicewurst/NiceWurstModule.java
+++ b/src/main/java/net/wurstclient/nicewurst/NiceWurstModule.java
@@ -17,16 +17,15 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
-
-import net.minecraft.client.font.TextRenderer.TextLayerType;
-import net.minecraft.client.render.Camera;
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.RaycastContext;
+import net.minecraft.client.Camera;
+import net.minecraft.client.gui.Font.DisplayMode;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.Category;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
@@ -168,8 +167,8 @@ public final class NiceWurstModule
 		return originalDepthTest;
 	}
 	
-	public static RenderLayer.MultiPhase enforceDepthTest(
-		RenderLayer.MultiPhase originalLayer)
+	public static RenderType.CompositeRenderType enforceDepthTest(
+		RenderType.CompositeRenderType originalLayer)
 	{
 		if(!isActive() || originalLayer == null)
 			return originalLayer;
@@ -206,29 +205,29 @@ public final class NiceWurstModule
 		return true;
 	}
 	
-	public static boolean shouldRenderTarget(Vec3d target)
+	public static boolean shouldRenderTarget(Vec3 target)
 	{
 		if(!isActive() || target == null)
 			return true;
 		
-		if(WurstClient.MC.world == null || WurstClient.MC.player == null)
+		if(WurstClient.MC.level == null || WurstClient.MC.player == null)
 			return true;
 		
-		Camera camera = WurstClient.MC.gameRenderer.getCamera();
+		Camera camera = WurstClient.MC.gameRenderer.getMainCamera();
 		if(camera == null)
 			return true;
 		
-		Vec3d from = camera.getPos();
+		Vec3 from = camera.getPosition();
 		if(from == null)
 			return true;
 		
-		if(from.squaredDistanceTo(target) < 1e-6)
+		if(from.distanceToSqr(target) < 1e-6)
 			return true;
 		
-		RaycastContext context =
-			new RaycastContext(from, target, RaycastContext.ShapeType.COLLIDER,
-				RaycastContext.FluidHandling.NONE, WurstClient.MC.player);
-		HitResult hit = WurstClient.MC.world.raycast(context);
+		ClipContext context =
+			new ClipContext(from, target, ClipContext.Block.COLLIDER,
+				ClipContext.Fluid.NONE, WurstClient.MC.player);
+		HitResult hit = WurstClient.MC.level.clip(context);
 		if(hit == null || hit.getType() == HitResult.Type.MISS)
 			return true;
 		
@@ -236,12 +235,12 @@ public final class NiceWurstModule
 			return true;
 		
 		BlockPos hitPos = ((BlockHitResult)hit).getBlockPos();
-		BlockPos targetPos = BlockPos.ofFloored(target);
+		BlockPos targetPos = BlockPos.containing(target);
 		if(hitPos.equals(targetPos))
 			return true;
 		
-		double targetDistSq = from.squaredDistanceTo(target);
-		double hitDistSq = hit.getPos().squaredDistanceTo(from);
+		double targetDistSq = from.distanceToSqr(target);
+		double hitDistSq = hit.getLocation().distanceToSqr(from);
 		return hitDistSq >= targetDistSq - 1e-3;
 	}
 	
@@ -252,22 +251,22 @@ public final class NiceWurstModule
 		if(entity == null)
 			return color;
 		
-		Vec3d target = entity.getBoundingBox().getCenter();
+		Vec3 target = entity.getBoundingBox().getCenter();
 		return shouldRenderTarget(target) ? color : null;
 	}
 	
-	public static TextLayerType enforceTextLayer(TextLayerType originalLayer)
+	public static DisplayMode enforceTextLayer(DisplayMode originalLayer)
 	{
 		if(originalLayer == null || !isActive())
 			return originalLayer;
 		
-		if(originalLayer != TextLayerType.SEE_THROUGH)
+		if(originalLayer != DisplayMode.SEE_THROUGH)
 			return originalLayer;
 		
 		for(StackTraceElement element : Thread.currentThread().getStackTrace())
 		{
 			if(TEXT_DEPTH_TEST_CALLERS.contains(element.getClassName()))
-				return TextLayerType.NORMAL;
+				return DisplayMode.NORMAL;
 		}
 		
 		return originalLayer;
diff --git a/src/main/java/net/wurstclient/nochatreports/ForcedChatReportsScreen.java b/src/main/java/net/wurstclient/nochatreports/ForcedChatReportsScreen.java
index 63577469d..a117858b2 100644
--- a/src/main/java/net/wurstclient/nochatreports/ForcedChatReportsScreen.java
+++ b/src/main/java/net/wurstclient/nochatreports/ForcedChatReportsScreen.java
@@ -10,16 +10,15 @@ package net.wurstclient.nochatreports;
 import java.util.Arrays;
 import java.util.List;
 import java.util.function.Supplier;
-
-import net.minecraft.client.font.MultilineText;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.text.PlainTextContent.Literal;
-import net.minecraft.text.Text;
-import net.minecraft.text.TranslatableTextContent;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.MultiLineLabel;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.contents.PlainTextContents.LiteralContents;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.other_features.NoChatReportsOtf;
 import net.wurstclient.util.ChatUtils;
@@ -39,21 +38,21 @@ public final class ForcedChatReportsScreen extends Screen
 			"Secure profile expired.", "Secure profile invalid.");
 	
 	private final Screen prevScreen;
-	private final Text reason;
-	private MultilineText reasonFormatted = MultilineText.EMPTY;
+	private final Component reason;
+	private MultiLineLabel reasonFormatted = MultiLineLabel.EMPTY;
 	private int reasonHeight;
 	
-	private ButtonWidget signatureButton;
+	private Button signatureButton;
 	private final Supplier<String> sigButtonMsg;
 	
 	public ForcedChatReportsScreen(Screen prevScreen)
 	{
-		super(Text.literal(ChatUtils.WURST_PREFIX)
-			.append(Text.literal(WurstClient.INSTANCE
+		super(Component.literal(ChatUtils.WURST_PREFIX)
+			.append(Component.literal(WurstClient.INSTANCE
 				.translate("gui.wurst.nochatreports.unsafe_server.title"))));
 		this.prevScreen = prevScreen;
 		
-		reason = Text.literal(WurstClient.INSTANCE
+		reason = Component.literal(WurstClient.INSTANCE
 			.translate("gui.wurst.nochatreports.unsafe_server.message"));
 		
 		NoChatReportsOtf ncr = WurstClient.INSTANCE.getOtfs().noChatReportsOtf;
@@ -71,52 +70,52 @@ public final class ForcedChatReportsScreen extends Screen
 	@Override
 	protected void init()
 	{
-		reasonFormatted =
-			MultilineText.create(textRenderer, reason, width - 50);
-		reasonHeight = reasonFormatted.getLineCount() * textRenderer.fontHeight;
+		reasonFormatted = MultiLineLabel.create(font, reason, width - 50);
+		reasonHeight = reasonFormatted.getLineCount() * font.lineHeight;
 		
 		int buttonX = width / 2 - 100;
 		int belowReasonY =
-			(height - 78) / 2 + reasonHeight / 2 + textRenderer.fontHeight * 2;
+			(height - 78) / 2 + reasonHeight / 2 + font.lineHeight * 2;
 		int signaturesY = Math.min(belowReasonY, height - 68);
 		int reconnectY = signaturesY + 24;
 		int backButtonY = reconnectY + 24;
 		
-		addDrawableChild(signatureButton = ButtonWidget
-			.builder(Text.literal(sigButtonMsg.get()), b -> toggleSignatures())
-			.dimensions(buttonX, signaturesY, 200, 20).build());
+		addRenderableWidget(signatureButton = Button
+			.builder(Component.literal(sigButtonMsg.get()),
+				b -> toggleSignatures())
+			.bounds(buttonX, signaturesY, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Reconnect"),
+		addRenderableWidget(Button
+			.builder(Component.literal("Reconnect"),
 				b -> LastServerRememberer.reconnect(prevScreen))
-			.dimensions(buttonX, reconnectY, 200, 20).build());
+			.bounds(buttonX, reconnectY, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.translatable("gui.toMenu"),
-				b -> client.setScreen(prevScreen))
-			.dimensions(buttonX, backButtonY, 200, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.translatable("gui.toMenu"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(buttonX, backButtonY, 200, 20).build());
 	}
 	
 	private void toggleSignatures()
 	{
 		WurstClient.INSTANCE.getOtfs().noChatReportsOtf.doPrimaryAction();
-		signatureButton.setMessage(Text.literal(sigButtonMsg.get()));
+		signatureButton.setMessage(Component.literal(sigButtonMsg.get()));
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int centerX = width / 2;
 		int reasonY = (height - 68) / 2 - reasonHeight / 2;
-		int titleY = reasonY - textRenderer.fontHeight * 2;
+		int titleY = reasonY - font.lineHeight * 2;
 		
-		context.drawCenteredTextWithShadow(textRenderer, title, centerX, titleY,
-			Colors.LIGHT_GRAY);
-		reasonFormatted.draw(context, MultilineText.Alignment.CENTER, centerX,
+		context.drawCenteredString(font, title, centerX, titleY,
+			CommonColors.LIGHT_GRAY);
+		reasonFormatted.render(context, MultiLineLabel.Align.CENTER, centerX,
 			reasonY, 9, true, -1);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
@@ -126,17 +125,17 @@ public final class ForcedChatReportsScreen extends Screen
 		return false;
 	}
 	
-	public static boolean isCausedByNoChatReports(Text disconnectReason)
+	public static boolean isCausedByNoChatReports(Component disconnectReason)
 	{
 		if(!WurstClient.INSTANCE.getOtfs().noChatReportsOtf.isActive())
 			return false;
 		
-		if(disconnectReason.getContent() instanceof TranslatableTextContent tr
+		if(disconnectReason.getContents() instanceof TranslatableContents tr
 			&& TRANSLATABLE_DISCONNECT_REASONS.contains(tr.getKey()))
 			return true;
 		
-		if(disconnectReason.getContent() instanceof Literal lt
-			&& LITERAL_DISCONNECT_REASONS.contains(lt.string()))
+		if(disconnectReason.getContents() instanceof LiteralContents lt
+			&& LITERAL_DISCONNECT_REASONS.contains(lt.text()))
 			return true;
 		
 		return false;
diff --git a/src/main/java/net/wurstclient/nochatreports/NcrModRequiredScreen.java b/src/main/java/net/wurstclient/nochatreports/NcrModRequiredScreen.java
index bb61ab7db..6cedfe2eb 100644
--- a/src/main/java/net/wurstclient/nochatreports/NcrModRequiredScreen.java
+++ b/src/main/java/net/wurstclient/nochatreports/NcrModRequiredScreen.java
@@ -10,15 +10,14 @@ package net.wurstclient.nochatreports;
 import java.util.Arrays;
 import java.util.List;
 import java.util.function.Supplier;
-
-import net.minecraft.client.font.MultilineText;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.StringHelper;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.MultiLineLabel;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
+import net.minecraft.util.StringUtil;
 import net.wurstclient.WurstClient;
 import net.wurstclient.other_feature.OtfList;
 import net.wurstclient.util.ChatUtils;
@@ -32,23 +31,23 @@ public final class NcrModRequiredScreen extends Screen
 		"You do not have No Chat Reports, and this server is configured to require it on client!");
 	
 	private final Screen prevScreen;
-	private final Text reason;
-	private MultilineText reasonFormatted = MultilineText.EMPTY;
+	private final Component reason;
+	private MultiLineLabel reasonFormatted = MultiLineLabel.EMPTY;
 	private int reasonHeight;
 	
-	private ButtonWidget signatureButton;
+	private Button signatureButton;
 	private final Supplier<String> sigButtonMsg;
 	
-	private ButtonWidget vsButton;
+	private Button vsButton;
 	private final Supplier<String> vsButtonMsg;
 	
 	public NcrModRequiredScreen(Screen prevScreen)
 	{
-		super(Text.literal(ChatUtils.WURST_PREFIX + WurstClient.INSTANCE
+		super(Component.literal(ChatUtils.WURST_PREFIX + WurstClient.INSTANCE
 			.translate("gui.wurst.nochatreports.ncr_mod_server.title")));
 		this.prevScreen = prevScreen;
 		
-		reason = Text.literal(WurstClient.INSTANCE
+		reason = Component.literal(WurstClient.INSTANCE
 			.translate("gui.wurst.nochatreports.ncr_mod_server.message"));
 		
 		OtfList otfs = WurstClient.INSTANCE.getOtfs();
@@ -76,62 +75,63 @@ public final class NcrModRequiredScreen extends Screen
 	@Override
 	protected void init()
 	{
-		reasonFormatted =
-			MultilineText.create(textRenderer, reason, width - 50);
-		reasonHeight = reasonFormatted.getLineCount() * textRenderer.fontHeight;
+		reasonFormatted = MultiLineLabel.create(font, reason, width - 50);
+		reasonHeight = reasonFormatted.getLineCount() * font.lineHeight;
 		
 		int buttonX = width / 2 - 100;
 		int belowReasonY =
-			(height - 78) / 2 + reasonHeight / 2 + textRenderer.fontHeight * 2;
+			(height - 78) / 2 + reasonHeight / 2 + font.lineHeight * 2;
 		int signaturesY = Math.min(belowReasonY, height - 68);
 		int reconnectY = signaturesY + 24;
 		int backButtonY = reconnectY + 24;
 		
-		addDrawableChild(signatureButton = ButtonWidget
-			.builder(Text.literal(sigButtonMsg.get()), b -> toggleSignatures())
-			.dimensions(buttonX - 48, signaturesY, 148, 20).build());
+		addRenderableWidget(signatureButton = Button
+			.builder(Component.literal(sigButtonMsg.get()),
+				b -> toggleSignatures())
+			.bounds(buttonX - 48, signaturesY, 148, 20).build());
 		
-		addDrawableChild(vsButton = ButtonWidget
-			.builder(Text.literal(vsButtonMsg.get()), b -> toggleVanillaSpoof())
-			.dimensions(buttonX + 102, signaturesY, 148, 20).build());
+		addRenderableWidget(vsButton = Button
+			.builder(Component.literal(vsButtonMsg.get()),
+				b -> toggleVanillaSpoof())
+			.bounds(buttonX + 102, signaturesY, 148, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Reconnect"),
+		addRenderableWidget(Button
+			.builder(Component.literal("Reconnect"),
 				b -> LastServerRememberer.reconnect(prevScreen))
-			.dimensions(buttonX, reconnectY, 200, 20).build());
+			.bounds(buttonX, reconnectY, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.translatable("gui.toMenu"),
-				b -> client.setScreen(prevScreen))
-			.dimensions(buttonX, backButtonY, 200, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.translatable("gui.toMenu"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(buttonX, backButtonY, 200, 20).build());
 	}
 	
 	private void toggleSignatures()
 	{
 		WurstClient.INSTANCE.getOtfs().noChatReportsOtf.doPrimaryAction();
-		signatureButton.setMessage(Text.literal(sigButtonMsg.get()));
+		signatureButton.setMessage(Component.literal(sigButtonMsg.get()));
 	}
 	
 	private void toggleVanillaSpoof()
 	{
 		WurstClient.INSTANCE.getOtfs().vanillaSpoofOtf.doPrimaryAction();
-		vsButton.setMessage(Text.literal(vsButtonMsg.get()));
+		vsButton.setMessage(Component.literal(vsButtonMsg.get()));
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		int centerX = width / 2;
 		int reasonY = (height - 68) / 2 - reasonHeight / 2;
-		int titleY = reasonY - textRenderer.fontHeight * 2;
+		int titleY = reasonY - font.lineHeight * 2;
 		
-		context.drawCenteredTextWithShadow(textRenderer, title, centerX, titleY,
-			Colors.LIGHT_GRAY);
-		reasonFormatted.draw(context, MultilineText.Alignment.CENTER, centerX,
+		context.drawCenteredString(font, title, centerX, titleY,
+			CommonColors.LIGHT_GRAY);
+		reasonFormatted.render(context, MultiLineLabel.Align.CENTER, centerX,
 			reasonY, 9, true, -1);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
@@ -141,7 +141,7 @@ public final class NcrModRequiredScreen extends Screen
 		return false;
 	}
 	
-	public static boolean isCausedByLackOfNCR(Text disconnectReason)
+	public static boolean isCausedByLackOfNCR(Component disconnectReason)
 	{
 		OtfList otfs = WurstClient.INSTANCE.getOtfs();
 		if(otfs.noChatReportsOtf.isActive()
@@ -152,7 +152,7 @@ public final class NcrModRequiredScreen extends Screen
 		if(text == null)
 			return false;
 		
-		text = StringHelper.stripTextFormat(text);
+		text = StringUtil.stripColor(text);
 		return DISCONNECT_REASONS.contains(text);
 	}
 }
diff --git a/src/main/java/net/wurstclient/options/EnterProfileNameScreen.java b/src/main/java/net/wurstclient/options/EnterProfileNameScreen.java
index e30ed01f9..123f85c0d 100644
--- a/src/main/java/net/wurstclient/options/EnterProfileNameScreen.java
+++ b/src/main/java/net/wurstclient/options/EnterProfileNameScreen.java
@@ -8,30 +8,28 @@
 package net.wurstclient.options;
 
 import java.util.function.Consumer;
-
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import org.lwjgl.glfw.GLFW;
 
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-
 public final class EnterProfileNameScreen extends Screen
 {
 	private final Screen prevScreen;
 	private final Consumer<String> callback;
 	
-	private TextFieldWidget valueField;
-	private ButtonWidget doneButton;
+	private EditBox valueField;
+	private Button doneButton;
 	
 	public EnterProfileNameScreen(Screen prevScreen, Consumer<String> callback)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.callback = callback;
 	}
@@ -43,32 +41,32 @@ public final class EnterProfileNameScreen extends Screen
 		int y1 = 60;
 		int y2 = height / 3 * 2;
 		
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		
-		valueField = new TextFieldWidget(tr, x1, y1, 200, 20, Text.literal(""));
-		valueField.setText("");
-		valueField.setSelectionStart(0);
+		valueField = new EditBox(tr, x1, y1, 200, 20, Component.literal(""));
+		valueField.setValue("");
+		valueField.setCursorPosition(0);
 		
-		addSelectableChild(valueField);
+		addWidget(valueField);
 		setFocused(valueField);
 		valueField.setFocused(true);
 		
-		doneButton = ButtonWidget.builder(Text.literal("Done"), b -> done())
-			.dimensions(x1, y2, 200, 20).build();
-		addDrawableChild(doneButton);
+		doneButton = Button.builder(Component.literal("Done"), b -> done())
+			.bounds(x1, y2, 200, 20).build();
+		addRenderableWidget(doneButton);
 	}
 	
 	private void done()
 	{
-		String value = valueField.getText();
+		String value = valueField.getValue();
 		if(!value.isEmpty())
 			callback.accept(value);
 		
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -77,7 +75,7 @@ public final class EnterProfileNameScreen extends Screen
 			break;
 			
 			case GLFW.GLFW_KEY_ESCAPE:
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			break;
 		}
 		
@@ -85,20 +83,20 @@ public final class EnterProfileNameScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			"Name your new profile", width / 2, 20, Colors.WHITE);
+		context.drawCenteredString(minecraft.font, "Name your new profile",
+			width / 2, 20, CommonColors.WHITE);
 		
 		valueField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public boolean shouldPause()
+	public boolean isPauseScreen()
 	{
 		return false;
 	}
diff --git a/src/main/java/net/wurstclient/options/KeybindEditorScreen.java b/src/main/java/net/wurstclient/options/KeybindEditorScreen.java
index 9b06794d0..e02eaf438 100644
--- a/src/main/java/net/wurstclient/options/KeybindEditorScreen.java
+++ b/src/main/java/net/wurstclient/options/KeybindEditorScreen.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.options;
 
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.WurstColors;
 
@@ -27,11 +27,11 @@ public final class KeybindEditorScreen extends Screen
 	private final String oldKey;
 	private final String oldCommands;
 	
-	private TextFieldWidget commandField;
+	private EditBox commandField;
 	
 	public KeybindEditorScreen(Screen prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		
 		key = "NONE";
@@ -41,7 +41,7 @@ public final class KeybindEditorScreen extends Screen
 	
 	public KeybindEditorScreen(Screen prevScreen, String defaultCommands)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		this.key = "NONE";
 		this.oldKey = null;
@@ -50,7 +50,7 @@ public final class KeybindEditorScreen extends Screen
 	
 	public KeybindEditorScreen(Screen prevScreen, String key, String commands)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 		
 		this.key = key;
@@ -61,27 +61,29 @@ public final class KeybindEditorScreen extends Screen
 	@Override
 	public void init()
 	{
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Change Key"),
-				b -> client.setScreen(new PressAKeyScreen(this)))
-			.dimensions(width / 2 - 100, 60, 200, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Change Key"),
+				b -> minecraft.setScreen(new PressAKeyScreen(this)))
+			.bounds(width / 2 - 100, 60, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Save"), b -> save())
-			.dimensions(width / 2 - 100, height / 4 + 72, 200, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Save"), b -> save())
+				.bounds(width / 2 - 100, height / 4 + 72, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height / 4 + 96, 200, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height / 4 + 96, 200, 20).build());
 		
-		commandField = new TextFieldWidget(textRenderer, width / 2 - 100, 100,
-			200, 20, Text.literal(""));
+		commandField = new EditBox(font, width / 2 - 100, 100, 200, 20,
+			Component.literal(""));
 		commandField.setMaxLength(65536);
-		addSelectableChild(commandField);
+		addWidget(commandField);
 		setFocused(commandField);
 		commandField.setFocused(true);
 		
 		if(oldCommands != null)
-			commandField.setText(oldCommands);
+			commandField.setValue(oldCommands);
 	}
 	
 	private void save()
@@ -89,41 +91,40 @@ public final class KeybindEditorScreen extends Screen
 		if(oldKey != null)
 			WurstClient.INSTANCE.getKeybinds().remove(oldKey);
 		
-		WurstClient.INSTANCE.getKeybinds().add(key, commandField.getText());
-		client.setScreen(prevScreen);
+		WurstClient.INSTANCE.getKeybinds().add(key, commandField.getValue());
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		commandField.mouseClicked(context, doubleClick);
 		return super.mouseClicked(context, doubleClick);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(textRenderer,
+		context.drawCenteredString(font,
 			(oldKey != null ? "Edit" : "Add") + " Keybind", width / 2, 20,
-			Colors.WHITE);
+			CommonColors.WHITE);
 		
-		context.drawTextWithShadow(textRenderer,
-			"Key: " + key.replace("key.keyboard.", ""), width / 2 - 100, 47,
-			WurstColors.VERY_LIGHT_GRAY);
-		context.drawTextWithShadow(textRenderer, "Commands (separated by ';')",
-			width / 2 - 100, 87, WurstColors.VERY_LIGHT_GRAY);
+		context.drawString(font, "Key: " + key.replace("key.keyboard.", ""),
+			width / 2 - 100, 47, WurstColors.VERY_LIGHT_GRAY);
+		context.drawString(font, "Commands (separated by ';')", width / 2 - 100,
+			87, WurstColors.VERY_LIGHT_GRAY);
 		
 		commandField.render(context, mouseX, mouseY, partialTicks);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/options/KeybindManagerScreen.java b/src/main/java/net/wurstclient/options/KeybindManagerScreen.java
index 897adf887..a48ba5409 100644
--- a/src/main/java/net/wurstclient/options/KeybindManagerScreen.java
+++ b/src/main/java/net/wurstclient/options/KeybindManagerScreen.java
@@ -10,18 +10,17 @@ package net.wurstclient.options;
 import java.util.Objects;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.ConfirmScreen;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.ObjectSelectionList;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.ConfirmScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.keybinds.Keybind;
 import net.wurstclient.keybinds.KeybindList;
@@ -32,54 +31,56 @@ public final class KeybindManagerScreen extends Screen
 	private final Screen prevScreen;
 	
 	private ListGui listGui;
-	private ButtonWidget addButton;
-	private ButtonWidget editButton;
-	private ButtonWidget removeButton;
-	private ButtonWidget backButton;
+	private Button addButton;
+	private Button editButton;
+	private Button removeButton;
+	private Button backButton;
 	
 	public KeybindManagerScreen(Screen prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 	}
 	
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this);
-		addSelectableChild(listGui);
+		listGui = new ListGui(minecraft, this);
+		addWidget(listGui);
 		
-		addDrawableChild(addButton = ButtonWidget
-			.builder(Text.literal("Add"),
-				b -> client.setScreen(new KeybindEditorScreen(this)))
-			.dimensions(width / 2 - 102, height - 52, 100, 20).build());
+		addRenderableWidget(addButton = Button
+			.builder(Component.literal("Add"),
+				b -> minecraft.setScreen(new KeybindEditorScreen(this)))
+			.bounds(width / 2 - 102, height - 52, 100, 20).build());
 		
-		addDrawableChild(
-			editButton = ButtonWidget.builder(Text.literal("Edit"), b -> edit())
-				.dimensions(width / 2 + 2, height - 52, 100, 20).build());
+		addRenderableWidget(
+			editButton = Button.builder(Component.literal("Edit"), b -> edit())
+				.bounds(width / 2 + 2, height - 52, 100, 20).build());
 		
-		addDrawableChild(removeButton =
-			ButtonWidget.builder(Text.literal("Remove"), b -> remove())
-				.dimensions(width / 2 - 102, height - 28, 100, 20).build());
+		addRenderableWidget(removeButton =
+			Button.builder(Component.literal("Remove"), b -> remove())
+				.bounds(width / 2 - 102, height - 28, 100, 20).build());
 		
-		addDrawableChild(backButton = ButtonWidget
-			.builder(Text.literal("Back"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 + 2, height - 28, 100, 20).build());
+		addRenderableWidget(backButton = Button
+			.builder(Component.literal("Back"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 + 2, height - 28, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget.builder(Text.literal("Reset Keybinds"),
-			b -> client.setScreen(new ConfirmScreen(confirmed -> {
+		addRenderableWidget(Button.builder(Component.literal("Reset Keybinds"),
+			b -> minecraft.setScreen(new ConfirmScreen(confirmed -> {
 				if(confirmed)
 					WurstClient.INSTANCE.getKeybinds()
 						.setKeybinds(KeybindList.DEFAULT_KEYBINDS);
-				client.setScreen(this);
-			}, Text.literal("Are you sure you want to reset your keybinds?"),
-				Text.literal("This cannot be undone!"))))
-			.dimensions(8, 8, 100, 20).build());
-		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Profiles..."),
-				b -> client.setScreen(new KeybindProfilesScreen(this)))
-			.dimensions(width - 108, 8, 100, 20).build());
+				minecraft.setScreen(this);
+			}, Component
+				.literal("Are you sure you want to reset your keybinds?"),
+				Component.literal("This cannot be undone!"))))
+			.bounds(8, 8, 100, 20).build());
+		
+		addRenderableWidget(Button
+			.builder(Component.literal("Profiles..."),
+				b -> minecraft.setScreen(new KeybindProfilesScreen(this)))
+			.bounds(width - 108, 8, 100, 20).build());
 	}
 	
 	private void edit()
@@ -88,7 +89,7 @@ public final class KeybindManagerScreen extends Screen
 		if(keybind == null)
 			return;
 		
-		client.setScreen(new KeybindEditorScreen(this, keybind.getKey(),
+		minecraft.setScreen(new KeybindEditorScreen(this, keybind.getKey(),
 			keybind.getCommands()));
 	}
 	
@@ -99,11 +100,11 @@ public final class KeybindManagerScreen extends Screen
 			return;
 		
 		WurstClient.INSTANCE.getKeybinds().remove(keybind.getKey());
-		client.setScreen(this);
+		minecraft.setScreen(this);
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		switch(context.key())
 		{
@@ -132,25 +133,25 @@ public final class KeybindManagerScreen extends Screen
 	@Override
 	public void tick()
 	{
-		boolean selected = listGui.getSelectedOrNull() != null;
+		boolean selected = listGui.getSelected() != null;
 		editButton.active = selected;
 		removeButton.active = selected;
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(textRenderer, "Keybind Manager",
-			width / 2, 8, Colors.WHITE);
+		context.drawCenteredString(font, "Keybind Manager", width / 2, 8,
+			CommonColors.WHITE);
 		
 		int count = WurstClient.INSTANCE.getKeybinds().getAllKeybinds().size();
-		context.drawCenteredTextWithShadow(textRenderer, "Keybinds: " + count,
-			width / 2, 20, Colors.WHITE);
+		context.drawCenteredString(font, "Keybinds: " + count, width / 2, 20,
+			CommonColors.WHITE);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
@@ -161,7 +162,7 @@ public final class KeybindManagerScreen extends Screen
 	}
 	
 	private final class Entry
-		extends AlwaysSelectedEntryListWidget.Entry<KeybindManagerScreen.Entry>
+		extends ObjectSelectionList.Entry<KeybindManagerScreen.Entry>
 	{
 		private final Keybind keybind;
 		
@@ -171,35 +172,36 @@ public final class KeybindManagerScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			return Text.translatable("narrator.select", "Keybind " + keybind);
+			return Component.translatable("narrator.select",
+				"Keybind " + keybind);
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			String keyText =
 				"Key: " + keybind.getKey().replace("key.keyboard.", "");
-			context.drawText(tr, keyText, x + 3, y + 3,
+			context.drawString(tr, keyText, x + 3, y + 3,
 				WurstColors.VERY_LIGHT_GRAY, false);
 			
 			String cmdText = "Commands: " + keybind.getCommands();
-			context.drawText(tr, cmdText, x + 3, y + 15, Colors.LIGHT_GRAY,
-				false);
+			context.drawString(tr, cmdText, x + 3, y + 15,
+				CommonColors.LIGHT_GRAY, false);
 		}
 	}
 	
 	private final class ListGui
-		extends AlwaysSelectedEntryListWidget<KeybindManagerScreen.Entry>
+		extends ObjectSelectionList<KeybindManagerScreen.Entry>
 	{
-		public ListGui(MinecraftClient mc, KeybindManagerScreen screen)
+		public ListGui(Minecraft mc, KeybindManagerScreen screen)
 		{
 			super(mc, screen.width, screen.height - 96, 36, 30);
 			
@@ -209,7 +211,7 @@ public final class KeybindManagerScreen extends Screen
 		
 		public Keybind getSelectedKeybind()
 		{
-			KeybindManagerScreen.Entry selected = getSelectedOrNull();
+			KeybindManagerScreen.Entry selected = getSelected();
 			return selected != null ? selected.keybind : null;
 		}
 	}
diff --git a/src/main/java/net/wurstclient/options/KeybindProfilesScreen.java b/src/main/java/net/wurstclient/options/KeybindProfilesScreen.java
index 74e1d8521..5080261f4 100644
--- a/src/main/java/net/wurstclient/options/KeybindProfilesScreen.java
+++ b/src/main/java/net/wurstclient/options/KeybindProfilesScreen.java
@@ -14,18 +14,17 @@ import java.util.List;
 import java.util.Objects;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.AlwaysSelectedEntryListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.ObjectSelectionList;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.util.WurstColors;
 import net.wurstclient.util.json.JsonException;
@@ -35,43 +34,44 @@ public final class KeybindProfilesScreen extends Screen
 	private final Screen prevScreen;
 	
 	private ListGui listGui;
-	private ButtonWidget loadButton;
+	private Button loadButton;
 	
 	public KeybindProfilesScreen(Screen prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 	}
 	
 	@Override
 	public void init()
 	{
-		listGui = new ListGui(client, this,
+		listGui = new ListGui(minecraft, this,
 			WurstClient.INSTANCE.getKeybinds().listProfiles());
-		addSelectableChild(listGui);
+		addWidget(listGui);
 		
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Open Folder"), b -> openFolder())
-				.dimensions(8, 8, 100, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Open Folder"), b -> openFolder())
+				.bounds(8, 8, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("New Profile"),
-				b -> client.setScreen(
+		addRenderableWidget(Button
+			.builder(Component.literal("New Profile"),
+				b -> minecraft.setScreen(
 					new EnterProfileNameScreen(this, this::newProfile)))
-			.dimensions(width / 2 - 154, height - 48, 100, 20).build());
+			.bounds(width / 2 - 154, height - 48, 100, 20).build());
 		
-		loadButton = addDrawableChild(
-			ButtonWidget.builder(Text.literal("Load"), b -> loadSelected())
-				.dimensions(width / 2 - 50, height - 48, 100, 20).build());
+		loadButton = addRenderableWidget(
+			Button.builder(Component.literal("Load"), b -> loadSelected())
+				.bounds(width / 2 - 50, height - 48, 100, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Cancel"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 + 54, height - 48, 100, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Cancel"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 + 54, height - 48, 100, 20).build());
 	}
 	
 	private void openFolder()
 	{
-		Util.getOperatingSystem().open(
+		Util.getPlatform().openFile(
 			WurstClient.INSTANCE.getKeybinds().getProfilesFolder().toFile());
 	}
 	
@@ -95,7 +95,7 @@ public final class KeybindProfilesScreen extends Screen
 		Path path = listGui.getSelectedPath();
 		if(path == null)
 		{
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			return;
 		}
 		
@@ -103,7 +103,7 @@ public final class KeybindProfilesScreen extends Screen
 		{
 			String fileName = "" + path.getFileName();
 			WurstClient.INSTANCE.getKeybinds().loadProfile(fileName);
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 			
 		}catch(IOException | JsonException e)
 		{
@@ -113,12 +113,12 @@ public final class KeybindProfilesScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ENTER)
 			loadSelected();
 		else if(context.key() == GLFW.GLFW_KEY_ESCAPE)
-			client.setScreen(prevScreen);
+			minecraft.setScreen(prevScreen);
 		
 		return super.keyPressed(context);
 	}
@@ -126,24 +126,25 @@ public final class KeybindProfilesScreen extends Screen
 	@Override
 	public void tick()
 	{
-		loadButton.active = listGui.getSelectedOrNull() != null;
+		loadButton.active = listGui.getSelected() != null;
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		listGui.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(client.textRenderer,
-			"Keybind Profiles", width / 2, 12, Colors.WHITE);
+		context.drawCenteredString(minecraft.font, "Keybind Profiles",
+			width / 2, 12, CommonColors.WHITE);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
-		if(loadButton.isSelected() && !loadButton.active)
-			context.drawTooltip(textRenderer,
-				Arrays.asList(Text.literal("You must first select a file.")),
+		if(loadButton.isHoveredOrFocused() && !loadButton.active)
+			context.setComponentTooltipForNextFrame(font,
+				Arrays
+					.asList(Component.literal("You must first select a file.")),
 				mouseX, mouseY);
 	}
 	
@@ -154,7 +155,7 @@ public final class KeybindProfilesScreen extends Screen
 	}
 	
 	private final class Entry
-		extends AlwaysSelectedEntryListWidget.Entry<KeybindProfilesScreen.Entry>
+		extends ObjectSelectionList.Entry<KeybindProfilesScreen.Entry>
 	{
 		private final Path path;
 		
@@ -164,35 +165,36 @@ public final class KeybindProfilesScreen extends Screen
 		}
 		
 		@Override
-		public Text getNarration()
+		public Component getNarration()
 		{
-			return Text.translatable("narrator.select",
+			return Component.translatable("narrator.select",
 				"Profile " + path.getFileName());
 		}
 		
 		@Override
-		public void render(DrawContext context, int mouseX, int mouseY,
+		public void renderContent(GuiGraphics context, int mouseX, int mouseY,
 			boolean hovered, float tickDelta)
 		{
 			int x = getContentX();
 			int y = getContentY();
 			
-			TextRenderer tr = client.textRenderer;
+			Font tr = minecraft.font;
 			
 			String fileName = "" + path.getFileName();
-			context.drawTextWithShadow(tr, fileName, x + 28, y,
+			context.drawString(tr, fileName, x + 28, y,
 				WurstColors.VERY_LIGHT_GRAY);
 			
-			String relPath = "" + client.runDirectory.toPath().relativize(path);
-			context.drawTextWithShadow(tr, relPath, x + 28, y + 9,
-				Colors.LIGHT_GRAY);
+			String relPath =
+				"" + minecraft.gameDirectory.toPath().relativize(path);
+			context.drawString(tr, relPath, x + 28, y + 9,
+				CommonColors.LIGHT_GRAY);
 		}
 	}
 	
 	private final class ListGui
-		extends AlwaysSelectedEntryListWidget<KeybindProfilesScreen.Entry>
+		extends ObjectSelectionList<KeybindProfilesScreen.Entry>
 	{
-		public ListGui(MinecraftClient mc, KeybindProfilesScreen screen,
+		public ListGui(Minecraft mc, KeybindProfilesScreen screen,
 			List<Path> list)
 		{
 			super(mc, screen.width, screen.height - 96, 36, 20);
@@ -203,7 +205,7 @@ public final class KeybindProfilesScreen extends Screen
 		
 		public Path getSelectedPath()
 		{
-			KeybindProfilesScreen.Entry selected = getSelectedOrNull();
+			KeybindProfilesScreen.Entry selected = getSelected();
 			return selected != null ? selected.path : null;
 		}
 	}
diff --git a/src/main/java/net/wurstclient/options/PressAKeyScreen.java b/src/main/java/net/wurstclient/options/PressAKeyScreen.java
index f9a79b837..7ebf281a3 100644
--- a/src/main/java/net/wurstclient/options/PressAKeyScreen.java
+++ b/src/main/java/net/wurstclient/options/PressAKeyScreen.java
@@ -7,23 +7,22 @@
  */
 package net.wurstclient.options;
 
+import com.mojang.blaze3d.platform.InputConstants;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import org.lwjgl.glfw.GLFW;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-
 public class PressAKeyScreen extends Screen
 {
 	private PressAKeyCallback prevScreen;
 	
 	public PressAKeyScreen(PressAKeyCallback prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		
 		if(!(prevScreen instanceof Screen))
 			throw new IllegalArgumentException("prevScreen is not a screen");
@@ -32,18 +31,18 @@ public class PressAKeyScreen extends Screen
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() != GLFW.GLFW_KEY_ESCAPE)
 			prevScreen.setKey(getKeyName(context));
 		
-		client.setScreen((Screen)prevScreen);
+		minecraft.setScreen((Screen)prevScreen);
 		return super.keyPressed(context);
 	}
 	
-	private String getKeyName(KeyInput context)
+	private String getKeyName(KeyEvent context)
 	{
-		return InputUtil.fromKeyCode(context).getTranslationKey();
+		return InputConstants.getKey(context).getName();
 	}
 	
 	@Override
@@ -53,13 +52,13 @@ public class PressAKeyScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(textRenderer, "Press a key",
-			width / 2, height / 4 + 48, Colors.WHITE);
+		context.drawCenteredString(font, "Press a key", width / 2,
+			height / 4 + 48, CommonColors.WHITE);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 }
diff --git a/src/main/java/net/wurstclient/options/WurstOptionsScreen.java b/src/main/java/net/wurstclient/options/WurstOptionsScreen.java
index 2c08ec587..9171667ec 100644
--- a/src/main/java/net/wurstclient/options/WurstOptionsScreen.java
+++ b/src/main/java/net/wurstclient/options/WurstOptionsScreen.java
@@ -12,17 +12,17 @@ import java.util.List;
 import java.util.function.Supplier;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.AbstractInput;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Util;
-import net.minecraft.util.Util.OperatingSystem;
+import net.minecraft.Util;
+import net.minecraft.Util.OS;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.input.InputWithModifiers;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.analytics.PlausibleAnalytics;
 import net.wurstclient.commands.FriendsCmd;
@@ -39,17 +39,17 @@ public class WurstOptionsScreen extends Screen
 	
 	public WurstOptionsScreen(Screen prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 	}
 	
 	@Override
 	public void init()
 	{
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Back"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height / 4 + 168 - 16, 200, 20)
-			.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Back"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height / 4 + 168 - 16, 200, 20).build());
 		
 		addSettingButtons();
 		addManagerButtons();
@@ -109,7 +109,7 @@ public class WurstOptionsScreen extends Screen
 		{
 			new WurstOptionsButton(-154, 144, () -> "Anti-Fingerprint",
 				"Open the Anti-Fingerprint controls for resource-pack handling.",
-				b -> client.setScreen(
+				b -> minecraft.setScreen(
 					new net.cevapi.config.AntiFingerprintConfigScreen(this)));
 		}
 	}
@@ -120,7 +120,7 @@ public class WurstOptionsScreen extends Screen
 		new WurstOptionsButton(-50, 24 + row++ * 24, () -> "Keybinds",
 			"Keybinds allow you to toggle any hack or command by simply"
 				+ " pressing a button.",
-			b -> client.setScreen(new KeybindManagerScreen(this)));
+			b -> minecraft.setScreen(new KeybindManagerScreen(this)));
 		
 		if(NiceWurstModule.showXrayBlocksManager())
 		{
@@ -133,7 +133,7 @@ public class WurstOptionsScreen extends Screen
 		new WurstOptionsButton(-50, 24 + row++ * 24, () -> "Zoom",
 			"The Zoom Manager allows you to change the zoom key and how far it"
 				+ " will zoom in.",
-			b -> client.setScreen(new ZoomManagerScreen(this)));
+			b -> minecraft.setScreen(new ZoomManagerScreen(this)));
 		
 		new WurstOptionsButton(-50, 24 + row++ * 24, () -> "Waypoints",
 			"Manage your waypoints.",
@@ -142,7 +142,7 @@ public class WurstOptionsScreen extends Screen
 	
 	private void addLinkButtons()
 	{
-		OperatingSystem os = Util.getOperatingSystem();
+		OS os = Util.getPlatform();
 		String primaryLabel =
 			NiceWurstModule.isActive() ? "NiceWurst Github" : "CevAPI Github";
 		String primaryTooltip = NiceWurstModule.isActive()
@@ -153,67 +153,67 @@ public class WurstOptionsScreen extends Screen
 				: "https://github.com/cev-api/Wurst7-CevAPI";
 		
 		new WurstOptionsButton(54, 24, () -> primaryLabel, primaryTooltip,
-			b -> os.open(primaryUrl));
+			b -> os.openUri(primaryUrl));
 		
 		new WurstOptionsButton(54, 48, () -> "Wurst Website",
 			"nlWurstClient.net",
-			b -> os.open("https://www.wurstclient.net/options-website/"));
+			b -> os.openUri("https://www.wurstclient.net/options-website/"));
 		
 		new WurstOptionsButton(54, 72, () -> "Wurst Wiki", "nlWurst.Wiki",
-			b -> os.open("https://www.wurstclient.net/options-wiki/"));
+			b -> os.openUri("https://www.wurstclient.net/options-wiki/"));
 		
 		new WurstOptionsButton(54, 96, () -> "WurstForum", "nlWurstForum.net",
-			b -> os.open("https://www.wurstclient.net/options-forum/"));
+			b -> os.openUri("https://www.wurstclient.net/options-forum/"));
 		
 		new WurstOptionsButton(54, 120, () -> "Twitter", "@Wurst_Imperium",
-			b -> os.open("https://www.wurstclient.net/options-twitter/"));
+			b -> os.openUri("https://www.wurstclient.net/options-twitter/"));
 		
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		renderTitles(context);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		renderButtonTooltip(context, mouseX, mouseY);
 	}
 	
-	private void renderTitles(DrawContext context)
+	private void renderTitles(GuiGraphics context)
 	{
-		TextRenderer tr = client.textRenderer;
+		Font tr = minecraft.font;
 		int middleX = width / 2;
 		int y1 = 40;
 		int y2 = height / 4 + 24 - 28;
 		
 		String title =
 			NiceWurstModule.isActive() ? "NiceWurst Options" : "Wurst Options";
-		context.drawCenteredTextWithShadow(tr, title, middleX, y1,
-			Colors.WHITE);
+		context.drawCenteredString(tr, title, middleX, y1, CommonColors.WHITE);
 		
-		context.drawCenteredTextWithShadow(tr, "Settings", middleX - 104, y2,
+		context.drawCenteredString(tr, "Settings", middleX - 104, y2,
 			WurstColors.VERY_LIGHT_GRAY);
-		context.drawCenteredTextWithShadow(tr, "Managers", middleX, y2,
+		context.drawCenteredString(tr, "Managers", middleX, y2,
 			WurstColors.VERY_LIGHT_GRAY);
-		context.drawCenteredTextWithShadow(tr, "Links", middleX + 104, y2,
+		context.drawCenteredString(tr, "Links", middleX + 104, y2,
 			WurstColors.VERY_LIGHT_GRAY);
 	}
 	
-	private void renderButtonTooltip(DrawContext context, int mouseX,
+	private void renderButtonTooltip(GuiGraphics context, int mouseX,
 		int mouseY)
 	{
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
-			if(!button.isSelected() || !(button instanceof WurstOptionsButton))
+			if(!button.isHoveredOrFocused()
+				|| !(button instanceof WurstOptionsButton))
 				continue;
 			
 			WurstOptionsButton woButton = (WurstOptionsButton)button;
@@ -221,24 +221,25 @@ public class WurstOptionsScreen extends Screen
 			if(woButton.tooltip.isEmpty())
 				continue;
 			
-			context.drawTooltip(textRenderer, woButton.tooltip, mouseX, mouseY);
+			context.setComponentTooltipForNextFrame(font, woButton.tooltip,
+				mouseX, mouseY);
 			break;
 		}
 	}
 	
-	private final class WurstOptionsButton extends ButtonWidget
+	private final class WurstOptionsButton extends Button
 	{
 		private final Supplier<String> messageSupplier;
-		private final List<Text> tooltip;
+		private final List<Component> tooltip;
 		
 		public WurstOptionsButton(int xOffset, int yOffset,
 			Supplier<String> messageSupplier, String tooltip,
-			PressAction pressAction)
+			OnPress pressAction)
 		{
 			super(WurstOptionsScreen.this.width / 2 + xOffset,
 				WurstOptionsScreen.this.height / 4 - 16 + yOffset, 100, 20,
-				Text.literal(messageSupplier.get()), pressAction,
-				ButtonWidget.DEFAULT_NARRATION_SUPPLIER);
+				Component.literal(messageSupplier.get()), pressAction,
+				Button.DEFAULT_NARRATION);
 			
 			this.messageSupplier = messageSupplier;
 			
@@ -248,21 +249,21 @@ public class WurstOptionsScreen extends Screen
 			{
 				String[] lines = ChatUtils.wrapText(tooltip, 200).split("\n");
 				
-				Text[] lines2 = new Text[lines.length];
+				Component[] lines2 = new Component[lines.length];
 				for(int i = 0; i < lines.length; i++)
-					lines2[i] = Text.literal(lines[i]);
+					lines2[i] = Component.literal(lines[i]);
 				
 				this.tooltip = Arrays.asList(lines2);
 			}
 			
-			addDrawableChild(this);
+			addRenderableWidget(this);
 		}
 		
 		@Override
-		public void onPress(AbstractInput context)
+		public void onPress(InputWithModifiers context)
 		{
 			super.onPress(context);
-			setMessage(Text.literal(messageSupplier.get()));
+			setMessage(Component.literal(messageSupplier.get()));
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/options/ZoomManagerScreen.java b/src/main/java/net/wurstclient/options/ZoomManagerScreen.java
index 4788e2ad0..3effe3108 100644
--- a/src/main/java/net/wurstclient/options/ZoomManagerScreen.java
+++ b/src/main/java/net/wurstclient/options/ZoomManagerScreen.java
@@ -7,12 +7,12 @@
  */
 package net.wurstclient.options;
 
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.WurstClient;
 import net.wurstclient.other_features.ZoomOtf;
 import net.wurstclient.settings.CheckboxSetting;
@@ -22,11 +22,11 @@ import net.wurstclient.util.WurstColors;
 public class ZoomManagerScreen extends Screen implements PressAKeyCallback
 {
 	private Screen prevScreen;
-	private ButtonWidget scrollButton;
+	private Button scrollButton;
 	
 	public ZoomManagerScreen(Screen par1GuiScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		prevScreen = par1GuiScreen;
 	}
 	
@@ -38,39 +38,38 @@ public class ZoomManagerScreen extends Screen implements PressAKeyCallback
 		SliderSetting level = zoom.getLevelSetting();
 		CheckboxSetting scroll = zoom.getScrollSetting();
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Back"), b -> client.setScreen(prevScreen))
-			.dimensions(width / 2 - 100, height / 4 + 144 - 16, 200, 20)
-			.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Back"),
+				b -> minecraft.setScreen(prevScreen))
+			.bounds(width / 2 - 100, height / 4 + 144 - 16, 200, 20).build());
 		
-		addDrawableChild(ButtonWidget
+		addRenderableWidget(Button
 			.builder(
-				Text.literal("Zoom Key: ")
+				Component.literal("Zoom Key: ")
 					.append(zoom.getTranslatedKeybindName()),
-				b -> client.setScreen(new PressAKeyScreen(this)))
-			.dimensions(width / 2 - 79, height / 4 + 24 - 16, 158, 20).build());
+				b -> minecraft.setScreen(new PressAKeyScreen(this)))
+			.bounds(width / 2 - 79, height / 4 + 24 - 16, 158, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("More"), b -> level.increaseValue())
-			.dimensions(width / 2 - 79, height / 4 + 72 - 16, 50, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("More"), b -> level.increaseValue())
+			.bounds(width / 2 - 79, height / 4 + 72 - 16, 50, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Less"), b -> level.decreaseValue())
-			.dimensions(width / 2 - 25, height / 4 + 72 - 16, 50, 20).build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Less"), b -> level.decreaseValue())
+			.bounds(width / 2 - 25, height / 4 + 72 - 16, 50, 20).build());
 		
-		addDrawableChild(ButtonWidget
-			.builder(Text.literal("Default"),
+		addRenderableWidget(Button
+			.builder(Component.literal("Default"),
 				b -> level.setValue(level.getDefaultValue()))
-			.dimensions(width / 2 + 29, height / 4 + 72 - 16, 50, 20).build());
+			.bounds(width / 2 + 29, height / 4 + 72 - 16, 50, 20).build());
 		
-		addDrawableChild(
-			scrollButton = ButtonWidget
+		addRenderableWidget(scrollButton =
+			Button
 				.builder(
-					Text.literal(
+					Component.literal(
 						"Use Mouse Wheel: " + onOrOff(scroll.isChecked())),
 					b -> toggleScroll())
-				.dimensions(width / 2 - 79, height / 4 + 96 - 16, 158, 20)
-				.build());
+				.bounds(width / 2 - 79, height / 4 + 96 - 16, 158, 20).build());
 	}
 	
 	private void toggleScroll()
@@ -79,8 +78,8 @@ public class ZoomManagerScreen extends Screen implements PressAKeyCallback
 		CheckboxSetting scroll = zoom.getScrollSetting();
 		
 		scroll.setChecked(!scroll.isChecked());
-		scrollButton.setMessage(
-			Text.literal("Use Mouse Wheel: " + onOrOff(scroll.isChecked())));
+		scrollButton.setMessage(Component
+			.literal("Use Mouse Wheel: " + onOrOff(scroll.isChecked())));
 	}
 	
 	private String onOrOff(boolean on)
@@ -89,25 +88,24 @@ public class ZoomManagerScreen extends Screen implements PressAKeyCallback
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
 		ZoomOtf zoom = WurstClient.INSTANCE.getOtfs().zoomOtf;
 		SliderSetting level = zoom.getLevelSetting();
 		
-		context.drawCenteredTextWithShadow(textRenderer, "Zoom Manager",
-			width / 2, 40, Colors.WHITE);
-		context.drawTextWithShadow(textRenderer,
-			"Zoom Level: " + level.getValueString(), width / 2 - 75,
-			height / 4 + 44, WurstColors.VERY_LIGHT_GRAY);
+		context.drawCenteredString(font, "Zoom Manager", width / 2, 40,
+			CommonColors.WHITE);
+		context.drawString(font, "Zoom Level: " + level.getValueString(),
+			width / 2 - 75, height / 4 + 44, WurstColors.VERY_LIGHT_GRAY);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
diff --git a/src/main/java/net/wurstclient/other_feature/OtfList.java b/src/main/java/net/wurstclient/other_feature/OtfList.java
index 6802e5fc3..1487be272 100644
--- a/src/main/java/net/wurstclient/other_feature/OtfList.java
+++ b/src/main/java/net/wurstclient/other_feature/OtfList.java
@@ -10,9 +10,8 @@ package net.wurstclient.other_feature;
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.TreeMap;
-
-import net.minecraft.util.crash.CrashException;
-import net.minecraft.util.crash.CrashReport;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportedException;
 import net.wurstclient.other_features.*;
 
 public final class OtfList
@@ -56,8 +55,8 @@ public final class OtfList
 		}catch(Exception e)
 		{
 			String message = "Initializing other Wurst features";
-			CrashReport report = CrashReport.create(e, message);
-			throw new CrashException(report);
+			CrashReport report = CrashReport.forThrowable(e, message);
+			throw new ReportedException(report);
 		}
 	}
 	
diff --git a/src/main/java/net/wurstclient/other_features/AntiFingerprintOtf.java b/src/main/java/net/wurstclient/other_features/AntiFingerprintOtf.java
index c8597c26f..89348b481 100644
--- a/src/main/java/net/wurstclient/other_features/AntiFingerprintOtf.java
+++ b/src/main/java/net/wurstclient/other_features/AntiFingerprintOtf.java
@@ -12,7 +12,7 @@ import java.util.List;
 import net.cevapi.config.AntiFingerprintConfig;
 import net.cevapi.config.AntiFingerprintConfigScreen;
 import net.cevapi.security.ResourcePackProtector;
-import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.screens.Screen;
 import net.wurstclient.Category;
 import net.wurstclient.other_feature.OtherFeature;
 import net.wurstclient.settings.Setting;
@@ -47,7 +47,7 @@ public final class AntiFingerprintOtf extends OtherFeature
 	@Override
 	public void doPrimaryAction()
 	{
-		Screen parent = MC.currentScreen;
+		Screen parent = MC.screen;
 		MC.setScreen(new AntiFingerprintConfigScreen(parent));
 	}
 }
diff --git a/src/main/java/net/wurstclient/other_features/ChangelogOtf.java b/src/main/java/net/wurstclient/other_features/ChangelogOtf.java
index 7eaf3b8d3..d3efa7199 100644
--- a/src/main/java/net/wurstclient/other_features/ChangelogOtf.java
+++ b/src/main/java/net/wurstclient/other_features/ChangelogOtf.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.other_features;
 
-import net.minecraft.util.Util;
+import net.minecraft.Util;
 import net.wurstclient.DontBlock;
 import net.wurstclient.SearchTags;
 import net.wurstclient.WurstClient;
@@ -35,6 +35,6 @@ public final class ChangelogOtf extends OtherFeature
 	{
 		String link = new Version(WurstClient.VERSION).getChangelogLink()
 			+ "?utm_source=Wurst+Client&utm_medium=ChangelogOtf&utm_content=View+Changelog";
-		Util.getOperatingSystem().open(link);
+		Util.getPlatform().openUri(link);
 	}
 }
diff --git a/src/main/java/net/wurstclient/other_features/HackListOtf.java b/src/main/java/net/wurstclient/other_features/HackListOtf.java
index 2dfa9309f..66c0deb49 100644
--- a/src/main/java/net/wurstclient/other_features/HackListOtf.java
+++ b/src/main/java/net/wurstclient/other_features/HackListOtf.java
@@ -266,8 +266,8 @@ public final class HackListOtf extends OtherFeature
 	{
 		NAME("Name", (a, b) -> a.getName().compareToIgnoreCase(b.getName())),
 		
-		WIDTH("Width", Comparator.comparingInt(
-			h -> WurstClient.MC.textRenderer.getWidth(h.getRenderName())));
+		WIDTH("Width", Comparator
+			.comparingInt(h -> WurstClient.MC.font.width(h.getRenderName())));
 		
 		private final String name;
 		private final Comparator<Hack> comparator;
diff --git a/src/main/java/net/wurstclient/other_features/KeybindManagerOtf.java b/src/main/java/net/wurstclient/other_features/KeybindManagerOtf.java
index 020ee73f9..b1c49505a 100644
--- a/src/main/java/net/wurstclient/other_features/KeybindManagerOtf.java
+++ b/src/main/java/net/wurstclient/other_features/KeybindManagerOtf.java
@@ -32,6 +32,6 @@ public final class KeybindManagerOtf extends OtherFeature
 	@Override
 	public void doPrimaryAction()
 	{
-		MC.setScreen(new KeybindManagerScreen(MC.currentScreen));
+		MC.setScreen(new KeybindManagerScreen(MC.screen));
 	}
 }
diff --git a/src/main/java/net/wurstclient/other_features/NoChatReportsOtf.java b/src/main/java/net/wurstclient/other_features/NoChatReportsOtf.java
index 7191c05d0..62b689229 100644
--- a/src/main/java/net/wurstclient/other_features/NoChatReportsOtf.java
+++ b/src/main/java/net/wurstclient/other_features/NoChatReportsOtf.java
@@ -10,18 +10,18 @@ package net.wurstclient.other_features;
 import java.net.URI;
 
 import net.fabricmc.fabric.api.client.networking.v1.ClientLoginConnectionEvents;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.hud.MessageIndicator;
-import net.minecraft.client.gui.hud.MessageIndicator.Icon;
-import net.minecraft.client.network.ClientLoginNetworkHandler;
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.network.encryption.ClientPlayerSession;
-import net.minecraft.network.message.MessageChain;
-import net.minecraft.network.message.MessageSignatureData;
-import net.minecraft.text.ClickEvent;
-import net.minecraft.text.HoverEvent;
-import net.minecraft.text.Text;
-import net.minecraft.text.TranslatableTextContent;
+import net.minecraft.client.GuiMessageTag;
+import net.minecraft.client.GuiMessageTag.Icon;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientHandshakePacketListenerImpl;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.LocalChatSession;
+import net.minecraft.network.chat.MessageSignature;
+import net.minecraft.network.chat.SignedMessageChain;
+import net.minecraft.network.chat.contents.TranslatableContents;
 import net.wurstclient.Category;
 import net.wurstclient.DontBlock;
 import net.wurstclient.SearchTags;
@@ -68,20 +68,21 @@ public final class NoChatReportsOtf extends OtherFeature
 	@Override
 	public void onUpdate()
 	{
-		ClientPlayNetworkHandler netHandler = MC.getNetworkHandler();
+		ClientPacketListener netHandler = MC.getConnection();
 		if(netHandler == null)
 			return;
 		
 		if(isActive())
 		{
-			netHandler.session = null;
-			netHandler.messagePacker = MessageChain.Packer.NONE;
+			netHandler.chatSession = null;
+			netHandler.signedMessageEncoder =
+				SignedMessageChain.Encoder.UNSIGNED;
 			
-		}else if(netHandler.session == null)
-			MC.getProfileKeys().fetchKeyPair()
+		}else if(netHandler.chatSession == null)
+			MC.getProfileKeyPairManager().prepareKeyPair()
 				.thenAcceptAsync(optional -> optional
-					.ifPresent(profileKeys -> netHandler.session =
-						ClientPlayerSession.create(profileKeys)),
+					.ifPresent(profileKeys -> netHandler.chatSession =
+						LocalChatSession.create(profileKeys)),
 					MC);
 		
 		EVENTS.remove(UpdateListener.class, this);
@@ -93,9 +94,9 @@ public final class NoChatReportsOtf extends OtherFeature
 		if(!isActive())
 			return;
 		
-		Text originalText = event.getComponent();
+		Component originalText = event.getComponent();
 		if(!(originalText
-			.getContent() instanceof TranslatableTextContent trContent))
+			.getContents() instanceof TranslatableContents trContent))
 			return;
 		
 		if(!trContent.getKey().equals("chat.disabled.missingProfileKey"))
@@ -106,31 +107,32 @@ public final class NoChatReportsOtf extends OtherFeature
 		ClickEvent clickEvent = new ClickEvent.OpenUrl(
 			URI.create("https://www.wurstclient.net/chat-disabled-mpk/"));
 		HoverEvent hoverEvent = new HoverEvent.ShowText(
-			Text.literal("Original message: ").append(originalText));
+			Component.literal("Original message: ").append(originalText));
 		
-		ChatUtils.component(Text.literal(
+		ChatUtils.component(Component.literal(
 			"The server is refusing to let you chat without enabling chat reports. Click \u00a7nhere\u00a7r to learn more.")
-			.styled(
+			.withStyle(
 				s -> s.withClickEvent(clickEvent).withHoverEvent(hoverEvent)));
 	}
 	
-	private void onLoginStart(ClientLoginNetworkHandler handler,
-		MinecraftClient client)
+	private void onLoginStart(ClientHandshakePacketListenerImpl handler,
+		Minecraft client)
 	{
 		EVENTS.add(UpdateListener.class, NoChatReportsOtf.this);
 	}
 	
-	public MessageIndicator modifyIndicator(Text message,
-		MessageSignatureData signature, MessageIndicator indicator)
+	public GuiMessageTag modifyIndicator(Component message,
+		MessageSignature signature, GuiMessageTag indicator)
 	{
-		if(!WURST.isEnabled() || MC.isInSingleplayer())
+		if(!WURST.isEnabled() || MC.isLocalServer())
 			return indicator;
 		
 		if(indicator != null || signature == null)
 			return indicator;
 		
-		return new MessageIndicator(0xE84F58, Icon.CHAT_MODIFIED,
-			Text.literal(ChatUtils.WURST_PREFIX + "\u00a7cReportable\u00a7r - "
+		return new GuiMessageTag(0xE84F58, Icon.CHAT_MODIFIED,
+			Component.literal(ChatUtils.WURST_PREFIX
+				+ "\u00a7cReportable\u00a7r - "
 				+ WURST.translate(
 					"description.wurst.nochatreports.message_is_reportable")),
 			"Reportable");
@@ -144,7 +146,7 @@ public final class NoChatReportsOtf extends OtherFeature
 	
 	public boolean isActive()
 	{
-		return isEnabled() && WURST.isEnabled() && !MC.isInSingleplayer();
+		return isEnabled() && WURST.isEnabled() && !MC.isLocalServer();
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/other_features/VanillaSpoofOtf.java b/src/main/java/net/wurstclient/other_features/VanillaSpoofOtf.java
index 9bc3bba9d..0428fe9ce 100644
--- a/src/main/java/net/wurstclient/other_features/VanillaSpoofOtf.java
+++ b/src/main/java/net/wurstclient/other_features/VanillaSpoofOtf.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.other_features;
 
-import net.minecraft.network.packet.BrandCustomPayload;
-import net.minecraft.network.packet.c2s.common.CustomPayloadC2SPacket;
+import net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket;
+import net.minecraft.network.protocol.common.custom.BrandPayload;
 import net.wurstclient.DontBlock;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.ConnectionPacketOutputListener;
@@ -39,13 +39,14 @@ public final class VanillaSpoofOtf extends OtherFeature
 		if(!spoof.isChecked())
 			return;
 		
-		if(!(event.getPacket() instanceof CustomPayloadC2SPacket packet))
+		if(!(event
+			.getPacket() instanceof ServerboundCustomPayloadPacket packet))
 			return;
 		
 		// change client brand "fabric" back to "vanilla"
-		if(packet.payload() instanceof BrandCustomPayload)
-			event.setPacket(
-				new CustomPayloadC2SPacket(new BrandCustomPayload("vanilla")));
+		if(packet.payload() instanceof BrandPayload)
+			event.setPacket(new ServerboundCustomPayloadPacket(
+				new BrandPayload("vanilla")));
 			
 		// cancel Fabric's "c:version", "c:register" and
 		// "fabric:custom_ingredient_sync" packets
diff --git a/src/main/java/net/wurstclient/other_features/ZoomOtf.java b/src/main/java/net/wurstclient/other_features/ZoomOtf.java
index b926fa9d7..c79d4acc5 100644
--- a/src/main/java/net/wurstclient/other_features/ZoomOtf.java
+++ b/src/main/java/net/wurstclient/other_features/ZoomOtf.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.other_features;
 
-import net.minecraft.client.option.SimpleOption;
-import net.minecraft.client.util.InputUtil;
-import net.minecraft.text.Text;
+import com.mojang.blaze3d.platform.InputConstants;
+import net.minecraft.client.OptionInstance;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.DontBlock;
 import net.wurstclient.SearchTags;
 import net.wurstclient.events.MouseScrollListener;
@@ -60,8 +60,8 @@ public final class ZoomOtf extends OtherFeature implements MouseScrollListener
 	
 	public float changeFovBasedOnZoom(float fov)
 	{
-		SimpleOption<Double> mouseSensitivitySetting =
-			MC.options.getMouseSensitivity();
+		OptionInstance<Double> mouseSensitivitySetting =
+			MC.options.sensitivity();
 		
 		if(currentLevel == null)
 			currentLevel = level.getValue();
@@ -72,7 +72,7 @@ public final class ZoomOtf extends OtherFeature implements MouseScrollListener
 			
 			if(defaultMouseSensitivity != null)
 			{
-				mouseSensitivitySetting.setValue(defaultMouseSensitivity);
+				mouseSensitivitySetting.set(defaultMouseSensitivity);
 				defaultMouseSensitivity = null;
 			}
 			
@@ -80,13 +80,13 @@ public final class ZoomOtf extends OtherFeature implements MouseScrollListener
 		}
 		
 		if(defaultMouseSensitivity == null)
-			defaultMouseSensitivity = mouseSensitivitySetting.getValue();
+			defaultMouseSensitivity = mouseSensitivitySetting.get();
 			
 		// Adjust mouse sensitivity in relation to zoom level.
 		// 1.0 / currentLevel is a value between 0.02 (50x zoom)
 		// and 1 (no zoom).
 		mouseSensitivitySetting
-			.setValue(defaultMouseSensitivity * (1.0 / currentLevel));
+			.set(defaultMouseSensitivity * (1.0 / currentLevel));
 		
 		return (float)(fov / currentLevel);
 	}
@@ -114,10 +114,9 @@ public final class ZoomOtf extends OtherFeature implements MouseScrollListener
 		return isZoomKeyPressed() && scroll.isChecked();
 	}
 	
-	public Text getTranslatedKeybindName()
+	public Component getTranslatedKeybindName()
 	{
-		return InputUtil.fromTranslationKey(keybind.getValue())
-			.getLocalizedText();
+		return InputConstants.getKey(keybind.getValue()).getDisplayName();
 	}
 	
 	public void setBoundKey(String translationKey)
@@ -127,18 +126,18 @@ public final class ZoomOtf extends OtherFeature implements MouseScrollListener
 	
 	private boolean isZoomKeyPressed()
 	{
-		if(MC.currentScreen != null && !zoomInScreens.isChecked())
+		if(MC.screen != null && !zoomInScreens.isChecked())
 			return false;
 		
-		return InputUtil.isKeyPressed(MC.getWindow(),
-			InputUtil.fromTranslationKey(keybind.getValue()).getCode());
+		return InputConstants.isKeyDown(MC.getWindow(),
+			InputConstants.getKey(keybind.getValue()).getValue());
 	}
 	
 	private boolean isValidKeybind(String keybind)
 	{
 		try
 		{
-			return InputUtil.fromTranslationKey(keybind) != null;
+			return InputConstants.getKey(keybind) != null;
 			
 		}catch(IllegalArgumentException e)
 		{
diff --git a/src/main/java/net/wurstclient/serverfinder/CleanUpScreen.java b/src/main/java/net/wurstclient/serverfinder/CleanUpScreen.java
index e874e5616..82d5f74df 100644
--- a/src/main/java/net/wurstclient/serverfinder/CleanUpScreen.java
+++ b/src/main/java/net/wurstclient/serverfinder/CleanUpScreen.java
@@ -15,24 +15,24 @@ import org.lwjgl.glfw.GLFW;
 
 import net.fabricmc.fabric.api.client.screen.v1.Screens;
 import net.minecraft.SharedConstants;
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerServerListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.ClickableWidget;
-import net.minecraft.client.input.AbstractInput;
-import net.minecraft.client.input.KeyInput;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.AbstractWidget;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.multiplayer.JoinMultiplayerScreen;
+import net.minecraft.client.gui.screens.multiplayer.ServerSelectionList;
+import net.minecraft.client.input.InputWithModifiers;
+import net.minecraft.client.input.KeyEvent;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 
 public class CleanUpScreen extends Screen
 {
-	private MultiplayerScreen prevScreen;
-	private ButtonWidget cleanUpButton;
+	private JoinMultiplayerScreen prevScreen;
+	private Button cleanUpButton;
 	
 	private boolean removeAll;
 	private boolean cleanupFailed = true;
@@ -41,37 +41,39 @@ public class CleanUpScreen extends Screen
 	private boolean cleanupUnknown = true;
 	private boolean cleanupGriefMe;
 	
-	public CleanUpScreen(MultiplayerScreen prevScreen)
+	public CleanUpScreen(JoinMultiplayerScreen prevScreen)
 	{
-		super(Text.literal(""));
+		super(Component.literal(""));
 		this.prevScreen = prevScreen;
 	}
 	
 	@Override
 	public void init()
 	{
-		addDrawableChild(new CleanUpButton(width / 2 - 100,
-			height / 4 + 168 + 12, () -> "Cancel", "", b -> close()));
+		addRenderableWidget(new CleanUpButton(width / 2 - 100,
+			height / 4 + 168 + 12, () -> "Cancel", "", b -> onClose()));
 		
-		addDrawableChild(cleanUpButton = new CleanUpButton(width / 2 - 100,
+		addRenderableWidget(cleanUpButton = new CleanUpButton(width / 2 - 100,
 			height / 4 + 144 + 12, () -> "Clean Up",
 			"Start the Clean Up with the settings\n" + "you specified above.\n"
 				+ "It might look like the game is not\n"
 				+ "responding for a couple of seconds.",
 			b -> cleanUp()));
 		
-		addDrawableChild(
+		addRenderableWidget(
 			new CleanUpButton(width / 2 - 100, height / 4 - 24 + 12,
 				() -> "Unknown Hosts: " + removeOrKeep(cleanupUnknown),
 				"Servers that clearly don't exist.",
 				b -> cleanupUnknown = !cleanupUnknown));
 		
-		addDrawableChild(new CleanUpButton(width / 2 - 100, height / 4 + 0 + 12,
-			() -> "Outdated Servers: " + removeOrKeep(cleanupOutdated),
-			"Servers that run a different Minecraft\n" + "version than you.",
-			b -> cleanupOutdated = !cleanupOutdated));
+		addRenderableWidget(
+			new CleanUpButton(width / 2 - 100, height / 4 + 0 + 12,
+				() -> "Outdated Servers: " + removeOrKeep(cleanupOutdated),
+				"Servers that run a different Minecraft\n"
+					+ "version than you.",
+				b -> cleanupOutdated = !cleanupOutdated));
 		
-		addDrawableChild(
+		addRenderableWidget(
 			new CleanUpButton(width / 2 - 100, height / 4 + 24 + 12,
 				() -> "Failed Ping: " + removeOrKeep(cleanupFailed),
 				"All servers that failed the last ping.\n"
@@ -81,21 +83,21 @@ public class CleanUpScreen extends Screen
 					+ "all servers are done refreshing.",
 				b -> cleanupFailed = !cleanupFailed));
 		
-		addDrawableChild(
+		addRenderableWidget(
 			new CleanUpButton(width / 2 - 100, height / 4 + 48 + 12,
 				() -> "\"Grief me\" Servers: " + removeOrKeep(cleanupGriefMe),
 				"All servers where the name starts with \"Grief me\"\n"
 					+ "Useful for removing servers found by ServerFinder.",
 				b -> cleanupGriefMe = !cleanupGriefMe));
 		
-		addDrawableChild(
+		addRenderableWidget(
 			new CleanUpButton(width / 2 - 100, height / 4 + 72 + 12,
 				() -> "\u00a7cRemove all Servers: " + yesOrNo(removeAll),
 				"This will completely clear your server\n"
 					+ "list. \u00a7cUse with caution!\u00a7r",
 				b -> removeAll = !removeAll));
 		
-		addDrawableChild(
+		addRenderableWidget(
 			new CleanUpButton(width / 2 - 100, height / 4 + 96 + 12,
 				() -> "Rename all Servers: " + yesOrNo(cleanupRename),
 				"Renames your servers to \"Grief me #1\",\n"
@@ -115,26 +117,26 @@ public class CleanUpScreen extends Screen
 	
 	private void cleanUp()
 	{
-		for(int i = prevScreen.getServerList().size() - 1; i >= 0; i--)
+		for(int i = prevScreen.getServers().size() - 1; i >= 0; i--)
 		{
-			ServerInfo server = prevScreen.getServerList().get(i);
+			ServerData server = prevScreen.getServers().get(i);
 			
 			if(removeAll || shouldRemove(server))
-				prevScreen.getServerList().remove(server);
+				prevScreen.getServers().remove(server);
 		}
 		
 		if(cleanupRename)
-			for(int i = 0; i < prevScreen.getServerList().size(); i++)
+			for(int i = 0; i < prevScreen.getServers().size(); i++)
 			{
-				ServerInfo server = prevScreen.getServerList().get(i);
+				ServerData server = prevScreen.getServers().get(i);
 				server.name = "Grief me #" + (i + 1);
 			}
 		
 		saveServerList();
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
-	private boolean shouldRemove(ServerInfo server)
+	private boolean shouldRemove(ServerData server)
 	{
 		if(server == null)
 			return false;
@@ -154,45 +156,44 @@ public class CleanUpScreen extends Screen
 		return false;
 	}
 	
-	private boolean isUnknownHost(ServerInfo server)
+	private boolean isUnknownHost(ServerData server)
 	{
-		if(server.label == null)
+		if(server.motd == null)
 			return false;
 		
-		if(server.label.getString() == null)
+		if(server.motd.getString() == null)
 			return false;
 		
-		return server.label.getString()
-			.equals("\u00a74Can\'t resolve hostname");
+		return server.motd.getString().equals("\u00a74Can\'t resolve hostname");
 	}
 	
-	private boolean isSameProtocol(ServerInfo server)
+	private boolean isSameProtocol(ServerData server)
 	{
-		return server.protocolVersion == SharedConstants.getGameVersion()
+		return server.protocol == SharedConstants.getCurrentVersion()
 			.protocolVersion();
 	}
 	
-	private boolean isFailedPing(ServerInfo server)
+	private boolean isFailedPing(ServerData server)
 	{
 		return server.ping != -2L && server.ping < 0L;
 	}
 	
-	private boolean isGriefMeServer(ServerInfo server)
+	private boolean isGriefMeServer(ServerData server)
 	{
 		return server.name != null && server.name.startsWith("Grief me");
 	}
 	
 	private void saveServerList()
 	{
-		prevScreen.getServerList().saveFile();
+		prevScreen.getServers().save();
 		
-		MultiplayerServerListWidget listWidget = prevScreen.serverListWidget;
+		ServerSelectionList listWidget = prevScreen.serverSelectionList;
 		listWidget.setSelected(null);
-		listWidget.setServers(prevScreen.getServerList());
+		listWidget.updateOnlineServers(prevScreen.getServers());
 	}
 	
 	@Override
-	public boolean keyPressed(KeyInput context)
+	public boolean keyPressed(KeyEvent context)
 	{
 		if(context.key() == GLFW.GLFW_KEY_ENTER)
 			cleanUpButton.onPress(context);
@@ -201,11 +202,11 @@ public class CleanUpScreen extends Screen
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		if(context.button() == GLFW.GLFW_MOUSE_BUTTON_4)
 		{
-			close();
+			onClose();
 			return true;
 		}
 		
@@ -213,27 +214,28 @@ public class CleanUpScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(textRenderer, "Clean Up", width / 2,
-			20, Colors.WHITE);
-		context.drawCenteredTextWithShadow(textRenderer,
+		context.drawCenteredString(font, "Clean Up", width / 2, 20,
+			CommonColors.WHITE);
+		context.drawCenteredString(font,
 			"Please select the servers you want to remove:", width / 2, 36,
-			Colors.LIGHT_GRAY);
+			CommonColors.LIGHT_GRAY);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 		
 		renderButtonTooltip(context, mouseX, mouseY);
 	}
 	
-	private void renderButtonTooltip(DrawContext context, int mouseX,
+	private void renderButtonTooltip(GuiGraphics context, int mouseX,
 		int mouseY)
 	{
-		for(ClickableWidget button : Screens.getButtons(this))
+		for(AbstractWidget button : Screens.getButtons(this))
 		{
-			if(!button.isSelected() || !(button instanceof CleanUpButton))
+			if(!button.isHoveredOrFocused()
+				|| !(button instanceof CleanUpButton))
 				continue;
 			
 			CleanUpButton cuButton = (CleanUpButton)button;
@@ -241,27 +243,28 @@ public class CleanUpScreen extends Screen
 			if(cuButton.tooltip.isEmpty())
 				continue;
 			
-			context.drawTooltip(textRenderer, cuButton.tooltip, mouseX, mouseY);
+			context.setComponentTooltipForNextFrame(font, cuButton.tooltip,
+				mouseX, mouseY);
 			break;
 		}
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
-	private final class CleanUpButton extends ButtonWidget
+	private final class CleanUpButton extends Button
 	{
 		private final Supplier<String> messageSupplier;
-		private final List<Text> tooltip;
+		private final List<Component> tooltip;
 		
 		public CleanUpButton(int x, int y, Supplier<String> messageSupplier,
-			String tooltip, PressAction pressAction)
+			String tooltip, OnPress pressAction)
 		{
-			super(x, y, 200, 20, Text.literal(messageSupplier.get()),
-				pressAction, ButtonWidget.DEFAULT_NARRATION_SUPPLIER);
+			super(x, y, 200, 20, Component.literal(messageSupplier.get()),
+				pressAction, Button.DEFAULT_NARRATION);
 			this.messageSupplier = messageSupplier;
 			
 			if(tooltip.isEmpty())
@@ -270,19 +273,19 @@ public class CleanUpScreen extends Screen
 			{
 				String[] lines = tooltip.split("\n");
 				
-				Text[] lines2 = new Text[lines.length];
+				Component[] lines2 = new Component[lines.length];
 				for(int i = 0; i < lines.length; i++)
-					lines2[i] = Text.literal(lines[i]);
+					lines2[i] = Component.literal(lines[i]);
 				
 				this.tooltip = Arrays.asList(lines2);
 			}
 		}
 		
 		@Override
-		public void onPress(AbstractInput context)
+		public void onPress(InputWithModifiers context)
 		{
 			super.onPress(context);
-			setMessage(Text.literal(messageSupplier.get()));
+			setMessage(Component.literal(messageSupplier.get()));
 		}
 	}
 }
diff --git a/src/main/java/net/wurstclient/serverfinder/ServerFinderScreen.java b/src/main/java/net/wurstclient/serverfinder/ServerFinderScreen.java
index 5eca9d690..39af188fb 100644
--- a/src/main/java/net/wurstclient/serverfinder/ServerFinderScreen.java
+++ b/src/main/java/net/wurstclient/serverfinder/ServerFinderScreen.java
@@ -12,88 +12,84 @@ import java.net.UnknownHostException;
 import java.util.ArrayList;
 
 import org.lwjgl.glfw.GLFW;
-
-import net.minecraft.client.gui.Click;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.Drawable;
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerServerListWidget;
-import net.minecraft.client.gui.widget.ButtonWidget;
-import net.minecraft.client.gui.widget.TextFieldWidget;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.client.network.ServerInfo.ServerType;
-import net.minecraft.client.option.ServerList;
-import net.minecraft.text.Text;
-import net.minecraft.util.Colors;
-import net.minecraft.util.Util;
 import net.cevapi.config.AntiFingerprintConfigScreen;
+import net.minecraft.Util;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.components.Button;
+import net.minecraft.client.gui.components.EditBox;
+import net.minecraft.client.gui.components.Renderable;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.multiplayer.JoinMultiplayerScreen;
+import net.minecraft.client.gui.screens.multiplayer.ServerSelectionList;
+import net.minecraft.client.input.MouseButtonEvent;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.multiplayer.ServerData.Type;
+import net.minecraft.client.multiplayer.ServerList;
+import net.minecraft.network.chat.Component;
+import net.minecraft.util.CommonColors;
 import net.wurstclient.util.MathUtils;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
 public class ServerFinderScreen extends Screen
 {
-	private final MultiplayerScreen prevScreen;
+	private final JoinMultiplayerScreen prevScreen;
 	
-	private TextFieldWidget ipBox;
-	private TextFieldWidget maxThreadsBox;
-	private ButtonWidget searchButton;
+	private EditBox ipBox;
+	private EditBox maxThreadsBox;
+	private Button searchButton;
 	
 	private ServerFinderState state;
 	private int maxThreads;
 	private int checked;
 	private int working;
 	
-	public ServerFinderScreen(MultiplayerScreen prevScreen)
+	public ServerFinderScreen(JoinMultiplayerScreen prevScreen)
 	{
-		super(Text.literal("Server Finder"));
+		super(Component.literal("Server Finder"));
 		this.prevScreen = prevScreen;
 	}
 	
 	@Override
 	public void init()
 	{
-		addDrawableChild(searchButton =
-			ButtonWidget.builder(Text.literal("Search"), b -> searchOrCancel())
-				.dimensions(width / 2 - 100, height / 4 + 96 + 12, 200, 20)
-				.build());
+		addRenderableWidget(searchButton = Button
+			.builder(Component.literal("Search"), b -> searchOrCancel())
+			.bounds(width / 2 - 100, height / 4 + 96 + 12, 200, 20).build());
 		searchButton.active = false;
 		
-		addDrawableChild(
-			ButtonWidget
-				.builder(Text.literal("Tutorial"),
-					b -> Util.getOperatingSystem().open(
-						"https://www.wurstclient.net/serverfinder-tutorial/"))
-				.dimensions(width / 2 - 100, height / 4 + 120 + 12, 200, 20)
-				.build());
+		addRenderableWidget(Button
+			.builder(Component.literal("Tutorial"),
+				b -> Util.getPlatform().openUri(
+					"https://www.wurstclient.net/serverfinder-tutorial/"))
+			.bounds(width / 2 - 100, height / 4 + 120 + 12, 200, 20).build());
 		
 		if(NiceWurstModule.showAntiFingerprintControls())
 		{
-			addDrawableChild(ButtonWidget
-				.builder(Text.literal("Anti-Fingerprint"),
-					b -> client
+			addRenderableWidget(Button
+				.builder(Component.literal("Anti-Fingerprint"),
+					b -> minecraft
 						.setScreen(new AntiFingerprintConfigScreen(this)))
-				.dimensions(width / 2 - 100, height / 4 + 144 + 12, 200, 20)
+				.bounds(width / 2 - 100, height / 4 + 144 + 12, 200, 20)
 				.build());
 		}
 		
 		int backButtonY = height / 4
 			+ (NiceWurstModule.showAntiFingerprintControls() ? 168 : 144) + 12;
-		addDrawableChild(
-			ButtonWidget.builder(Text.literal("Back"), b -> close())
-				.dimensions(width / 2 - 100, backButtonY, 200, 20).build());
+		addRenderableWidget(
+			Button.builder(Component.literal("Back"), b -> onClose())
+				.bounds(width / 2 - 100, backButtonY, 200, 20).build());
 		
-		ipBox = new TextFieldWidget(textRenderer, width / 2 - 100,
-			height / 4 + 34, 200, 20, Text.empty());
+		ipBox = new EditBox(font, width / 2 - 100, height / 4 + 34, 200, 20,
+			Component.empty());
 		ipBox.setMaxLength(200);
-		addSelectableChild(ipBox);
+		addWidget(ipBox);
 		setFocused(ipBox);
 		
-		maxThreadsBox = new TextFieldWidget(textRenderer, width / 2 - 32,
-			height / 4 + 58, 26, 12, Text.empty());
+		maxThreadsBox = new EditBox(font, width / 2 - 32, height / 4 + 58, 26,
+			12, Component.empty());
 		maxThreadsBox.setMaxLength(3);
-		maxThreadsBox.setText("128");
-		addSelectableChild(maxThreadsBox);
+		maxThreadsBox.setValue("128");
+		addWidget(maxThreadsBox);
 		
 		state = ServerFinderState.NOT_RUNNING;
 	}
@@ -105,15 +101,15 @@ public class ServerFinderScreen extends Screen
 			state = ServerFinderState.CANCELLED;
 			ipBox.active = true;
 			maxThreadsBox.active = true;
-			searchButton.setMessage(Text.literal("Search"));
+			searchButton.setMessage(Component.literal("Search"));
 			return;
 		}
 		
 		state = ServerFinderState.RESOLVING;
-		maxThreads = Integer.parseInt(maxThreadsBox.getText());
+		maxThreads = Integer.parseInt(maxThreadsBox.getValue());
 		ipBox.active = false;
 		maxThreadsBox.active = false;
-		searchButton.setMessage(Text.literal("Cancel"));
+		searchButton.setMessage(Component.literal("Cancel"));
 		checked = 0;
 		working = 0;
 		
@@ -125,7 +121,7 @@ public class ServerFinderScreen extends Screen
 		try
 		{
 			InetAddress addr =
-				InetAddress.getByName(ipBox.getText().split(":")[0].trim());
+				InetAddress.getByName(ipBox.getValue().split(":")[0].trim());
 			
 			int[] ipParts = new int[4];
 			for(int i = 0; i < 4; i++)
@@ -203,31 +199,31 @@ public class ServerFinderScreen extends Screen
 	// but without changing the current screen.
 	private void addServerToList(String name, String ip)
 	{
-		ServerList serverList = prevScreen.getServerList();
+		ServerList serverList = prevScreen.getServers();
 		if(serverList.get(ip) != null)
 			return;
 		
-		serverList.add(new ServerInfo(name, ip, ServerType.OTHER), false);
-		serverList.saveFile();
+		serverList.add(new ServerData(name, ip, Type.OTHER), false);
+		serverList.save();
 		
-		MultiplayerServerListWidget listWidget = prevScreen.serverListWidget;
+		ServerSelectionList listWidget = prevScreen.serverSelectionList;
 		listWidget.setSelected(null);
-		listWidget.setServers(serverList);
+		listWidget.updateOnlineServers(serverList);
 	}
 	
 	@Override
 	public void tick()
 	{
-		searchButton.active = MathUtils.isInteger(maxThreadsBox.getText())
-			&& !ipBox.getText().isEmpty();
+		searchButton.active = MathUtils.isInteger(maxThreadsBox.getValue())
+			&& !ipBox.getValue().isEmpty();
 	}
 	
 	@Override
-	public boolean mouseClicked(Click context, boolean doubleClick)
+	public boolean mouseClicked(MouseButtonEvent context, boolean doubleClick)
 	{
 		if(context.button() == GLFW.GLFW_MOUSE_BUTTON_4)
 		{
-			close();
+			onClose();
 			return true;
 		}
 		
@@ -235,47 +231,46 @@ public class ServerFinderScreen extends Screen
 	}
 	
 	@Override
-	public void render(DrawContext context, int mouseX, int mouseY,
+	public void render(GuiGraphics context, int mouseX, int mouseY,
 		float partialTicks)
 	{
-		context.drawCenteredTextWithShadow(textRenderer, "Server Finder",
-			width / 2, 20, Colors.WHITE);
-		context.drawCenteredTextWithShadow(textRenderer,
+		context.drawCenteredString(font, "Server Finder", width / 2, 20,
+			CommonColors.WHITE);
+		context.drawCenteredString(font,
 			"This will search for servers with similar IPs", width / 2, 40,
-			Colors.LIGHT_GRAY);
-		context.drawCenteredTextWithShadow(textRenderer,
+			CommonColors.LIGHT_GRAY);
+		context.drawCenteredString(font,
 			"to the IP you type into the field below.", width / 2, 50,
-			Colors.LIGHT_GRAY);
-		context.drawCenteredTextWithShadow(textRenderer,
+			CommonColors.LIGHT_GRAY);
+		context.drawCenteredString(font,
 			"The servers it finds will be added to your server list.",
-			width / 2, 60, Colors.LIGHT_GRAY);
+			width / 2, 60, CommonColors.LIGHT_GRAY);
 		
-		context.drawTextWithShadow(textRenderer, "Server address:",
-			width / 2 - 100, height / 4 + 24, Colors.LIGHT_GRAY);
+		context.drawString(font, "Server address:", width / 2 - 100,
+			height / 4 + 24, CommonColors.LIGHT_GRAY);
 		ipBox.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawTextWithShadow(textRenderer, "Max. threads:",
-			width / 2 - 100, height / 4 + 60, Colors.LIGHT_GRAY);
+		context.drawString(font, "Max. threads:", width / 2 - 100,
+			height / 4 + 60, CommonColors.LIGHT_GRAY);
 		maxThreadsBox.render(context, mouseX, mouseY, partialTicks);
 		
-		context.drawCenteredTextWithShadow(textRenderer, state.toString(),
-			width / 2, height / 4 + 73, Colors.LIGHT_GRAY);
+		context.drawCenteredString(font, state.toString(), width / 2,
+			height / 4 + 73, CommonColors.LIGHT_GRAY);
 		
-		context.drawTextWithShadow(textRenderer,
-			"Checked: " + checked + " / 1792", width / 2 - 100, height / 4 + 84,
-			Colors.LIGHT_GRAY);
-		context.drawTextWithShadow(textRenderer, "Working: " + working,
-			width / 2 - 100, height / 4 + 94, Colors.LIGHT_GRAY);
+		context.drawString(font, "Checked: " + checked + " / 1792",
+			width / 2 - 100, height / 4 + 84, CommonColors.LIGHT_GRAY);
+		context.drawString(font, "Working: " + working, width / 2 - 100,
+			height / 4 + 94, CommonColors.LIGHT_GRAY);
 		
-		for(Drawable drawable : drawables)
+		for(Renderable drawable : renderables)
 			drawable.render(context, mouseX, mouseY, partialTicks);
 	}
 	
 	@Override
-	public void close()
+	public void onClose()
 	{
 		state = ServerFinderState.CANCELLED;
-		client.setScreen(prevScreen);
+		minecraft.setScreen(prevScreen);
 	}
 	
 	enum ServerFinderState
diff --git a/src/main/java/net/wurstclient/serverfinder/WurstServerPinger.java b/src/main/java/net/wurstclient/serverfinder/WurstServerPinger.java
index 8169aadeb..4d0a4ec31 100644
--- a/src/main/java/net/wurstclient/serverfinder/WurstServerPinger.java
+++ b/src/main/java/net/wurstclient/serverfinder/WurstServerPinger.java
@@ -9,15 +9,14 @@ package net.wurstclient.serverfinder;
 
 import java.net.UnknownHostException;
 import java.util.concurrent.atomic.AtomicInteger;
-
-import net.minecraft.client.network.MultiplayerServerListPinger;
-import net.minecraft.client.network.ServerInfo;
-import net.minecraft.client.network.ServerInfo.ServerType;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.multiplayer.ServerData.Type;
+import net.minecraft.client.multiplayer.ServerStatusPinger;
 
 public class WurstServerPinger
 {
 	private static final AtomicInteger threadNumber = new AtomicInteger(0);
-	private ServerInfo server;
+	private ServerData server;
 	private boolean done = false;
 	private boolean failed = false;
 	
@@ -28,7 +27,7 @@ public class WurstServerPinger
 	
 	public void ping(String ip, int port)
 	{
-		server = new ServerInfo("", ip + ":" + port, ServerType.OTHER);
+		server = new ServerData("", ip + ":" + port, Type.OTHER);
 		
 		new Thread(() -> pingInCurrentThread(ip, port),
 			"Wurst Server Pinger #" + threadNumber.incrementAndGet()).start();
@@ -36,12 +35,12 @@ public class WurstServerPinger
 	
 	private void pingInCurrentThread(String ip, int port)
 	{
-		MultiplayerServerListPinger pinger = new MultiplayerServerListPinger();
+		ServerStatusPinger pinger = new ServerStatusPinger();
 		System.out.println("Pinging " + ip + ":" + port + "...");
 		
 		try
 		{
-			pinger.add(server, () -> {}, () -> {});
+			pinger.pingServer(server, () -> {}, () -> {});
 			System.out.println("Ping successful: " + ip + ":" + port);
 			
 		}catch(UnknownHostException e)
@@ -55,7 +54,7 @@ public class WurstServerPinger
 			failed = true;
 		}
 		
-		pinger.cancel();
+		pinger.removeAll();
 		done = true;
 	}
 	
@@ -71,6 +70,6 @@ public class WurstServerPinger
 	
 	public String getServerIP()
 	{
-		return server.address;
+		return server.ip;
 	}
 }
diff --git a/src/main/java/net/wurstclient/settings/AimAtSetting.java b/src/main/java/net/wurstclient/settings/AimAtSetting.java
index e71f66713..60eb6719e 100644
--- a/src/main/java/net/wurstclient/settings/AimAtSetting.java
+++ b/src/main/java/net/wurstclient/settings/AimAtSetting.java
@@ -8,11 +8,10 @@
 package net.wurstclient.settings;
 
 import java.util.function.Function;
-
-import net.minecraft.entity.Entity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.util.RotationUtils;
 
 public final class AimAtSetting extends EnumSetting<AimAtSetting.AimAt>
@@ -42,7 +41,7 @@ public final class AimAtSetting extends EnumSetting<AimAtSetting.AimAt>
 		this(description, AimAt.AUTO);
 	}
 	
-	public Vec3d getAimPoint(Entity e)
+	public Vec3 getAimPoint(Entity e)
 	{
 		return getSelected().aimFunction.apply(e);
 	}
@@ -59,35 +58,35 @@ public final class AimAtSetting extends EnumSetting<AimAtSetting.AimAt>
 		return builder.toString();
 	}
 	
-	private static Vec3d aimAtClosestPoint(Entity e)
+	private static Vec3 aimAtClosestPoint(Entity e)
 	{
-		Box box = e.getBoundingBox();
-		Vec3d eyes = RotationUtils.getEyesPos();
+		AABB box = e.getBoundingBox();
+		Vec3 eyes = RotationUtils.getEyesPos();
 		
 		if(box.contains(eyes))
 			return eyes;
 		
-		double clampedX = MathHelper.clamp(eyes.x, box.minX, box.maxX);
-		double clampedY = MathHelper.clamp(eyes.y, box.minY, box.maxY);
-		double clampedZ = MathHelper.clamp(eyes.z, box.minZ, box.maxZ);
+		double clampedX = Mth.clamp(eyes.x, box.minX, box.maxX);
+		double clampedY = Mth.clamp(eyes.y, box.minY, box.maxY);
+		double clampedZ = Mth.clamp(eyes.z, box.minZ, box.maxZ);
 		
-		return new Vec3d(clampedX, clampedY, clampedZ);
+		return new Vec3(clampedX, clampedY, clampedZ);
 	}
 	
-	private static Vec3d aimAtHead(Entity e)
+	private static Vec3 aimAtHead(Entity e)
 	{
 		float eyeHeight = e.getEyeHeight(e.getPose());
-		return e.getEntityPos().add(0, eyeHeight, 0);
+		return e.position().add(0, eyeHeight, 0);
 	}
 	
-	private static Vec3d aimAtCenter(Entity e)
+	private static Vec3 aimAtCenter(Entity e)
 	{
 		return e.getBoundingBox().getCenter();
 	}
 	
-	private static Vec3d aimAtFeet(Entity e)
+	private static Vec3 aimAtFeet(Entity e)
 	{
-		return e.getEntityPos().add(0, 0.001, 0);
+		return e.position().add(0, 0.001, 0);
 	}
 	
 	public enum AimAt
@@ -106,17 +105,17 @@ public final class AimAtSetting extends EnumSetting<AimAtSetting.AimAt>
 		
 		private final String name;
 		private final String description;
-		private final Function<Entity, Vec3d> aimFunction;
+		private final Function<Entity, Vec3> aimFunction;
 		
 		private AimAt(String name, String description,
-			Function<Entity, Vec3d> aimFunction)
+			Function<Entity, Vec3> aimFunction)
 		{
 			this.name = name;
 			this.description = description;
 			this.aimFunction = aimFunction;
 		}
 		
-		public Vec3d getAimPoint(Entity e)
+		public Vec3 getAimPoint(Entity e)
 		{
 			return aimFunction.apply(e);
 		}
diff --git a/src/main/java/net/wurstclient/settings/AttackSpeedSliderSetting.java b/src/main/java/net/wurstclient/settings/AttackSpeedSliderSetting.java
index 28efb7aac..cbe94241c 100644
--- a/src/main/java/net/wurstclient/settings/AttackSpeedSliderSetting.java
+++ b/src/main/java/net/wurstclient/settings/AttackSpeedSliderSetting.java
@@ -7,12 +7,13 @@
  */
 package net.wurstclient.settings;
 
-import net.minecraft.util.math.random.Random;
+import net.minecraft.util.RandomSource;
 import net.wurstclient.WurstClient;
 
 public final class AttackSpeedSliderSetting extends SliderSetting
 {
-	private final Random random = Random.createLocal();
+	private final RandomSource random =
+		RandomSource.createNewThreadLocalInstance();
 	private int tickTimer;
 	
 	public AttackSpeedSliderSetting()
@@ -71,7 +72,7 @@ public final class AttackSpeedSliderSetting extends SliderSetting
 	public boolean isTimeToAttack()
 	{
 		double value = getValue();
-		if(value <= 0 && WurstClient.MC.player.getAttackCooldownProgress(0) < 1)
+		if(value <= 0 && WurstClient.MC.player.getAttackStrengthScale(0) < 1)
 			return false;
 		
 		return tickTimer <= 0;
diff --git a/src/main/java/net/wurstclient/settings/BlockListSetting.java b/src/main/java/net/wurstclient/settings/BlockListSetting.java
index c3f10f502..5e437b2ab 100644
--- a/src/main/java/net/wurstclient/settings/BlockListSetting.java
+++ b/src/main/java/net/wurstclient/settings/BlockListSetting.java
@@ -18,10 +18,9 @@ import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.block.Block;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.BlockListEditButton;
@@ -58,10 +57,10 @@ public class BlockListSetting extends Setting
 		if(raw.isEmpty())
 			return;
 		
-		Identifier id = Identifier.tryParse(raw);
+		ResourceLocation id = ResourceLocation.tryParse(raw);
 		String name = raw;
 		
-		if(id != null && Registries.BLOCK.containsId(id))
+		if(id != null && BuiltInRegistries.BLOCK.containsKey(id))
 			name = id.toString();
 		
 		if(Collections.binarySearch(blockNames, name) < 0)
@@ -233,7 +232,7 @@ public class BlockListSetting extends Setting
 	 * name). Intended for lighter checks; performance-sensitive hacks should
 	 * precompute keyword caches themselves.
 	 */
-	public boolean matchesBlock(net.minecraft.block.Block block)
+	public boolean matchesBlock(net.minecraft.world.level.block.Block block)
 	{
 		String idFull = net.wurstclient.util.BlockUtils.getName(block);
 		if(contains(idFull))
@@ -241,12 +240,12 @@ public class BlockListSetting extends Setting
 		String localId = idFull.contains(":")
 			? idFull.substring(idFull.indexOf(":") + 1) : idFull;
 		String localSpaced = localId.replace('_', ' ');
-		String transKey = block.getTranslationKey();
+		String transKey = block.getDescriptionId();
 		String display = block.getName().getString();
 		for(String s : blockNames)
 		{
-			net.minecraft.util.Identifier id =
-				net.minecraft.util.Identifier.tryParse(s);
+			net.minecraft.resources.ResourceLocation id =
+				net.minecraft.resources.ResourceLocation.tryParse(s);
 			if(id != null)
 				continue; // already checked exact ID above
 			String term = s.toLowerCase(java.util.Locale.ROOT);
diff --git a/src/main/java/net/wurstclient/settings/BlockSetting.java b/src/main/java/net/wurstclient/settings/BlockSetting.java
index ccac3963d..4d1d9fdd5 100644
--- a/src/main/java/net/wurstclient/settings/BlockSetting.java
+++ b/src/main/java/net/wurstclient/settings/BlockSetting.java
@@ -14,10 +14,9 @@ import java.util.Set;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.block.AirBlock;
-import net.minecraft.block.Block;
-import net.minecraft.util.Identifier;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.AirBlock;
+import net.minecraft.world.level.block.Block;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.BlockComponent;
@@ -119,7 +118,7 @@ public final class BlockSetting extends Setting
 		{
 			String rawName = JsonUtils.getAsString(json);
 			
-			Identifier id = Identifier.tryParse(rawName);
+			ResourceLocation id = ResourceLocation.tryParse(rawName);
 			if(id == null)
 				throw new JsonException("Discarding Block \"" + rawName
 					+ "\" as it is not a valid identifier");
diff --git a/src/main/java/net/wurstclient/settings/ChunkAreaSetting.java b/src/main/java/net/wurstclient/settings/ChunkAreaSetting.java
index 739a93e1f..ba641bbf5 100644
--- a/src/main/java/net/wurstclient/settings/ChunkAreaSetting.java
+++ b/src/main/java/net/wurstclient/settings/ChunkAreaSetting.java
@@ -8,17 +8,16 @@
 package net.wurstclient.settings;
 
 import java.util.ArrayList;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.world.chunk.Chunk;
-import net.minecraft.world.chunk.EmptyChunk;
+import net.minecraft.client.Minecraft;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
 import net.wurstclient.WurstClient;
 
 public final class ChunkAreaSetting
 	extends EnumSetting<ChunkAreaSetting.ChunkArea>
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public ChunkAreaSetting(String name, String description)
 	{
@@ -30,7 +29,7 @@ public final class ChunkAreaSetting
 		super(name, description, ChunkArea.values(), selected);
 	}
 	
-	public ArrayList<Chunk> getChunksInRange()
+	public ArrayList<ChunkAccess> getChunksInRange()
 	{
 		return getSelected().getChunksInRange();
 	}
@@ -84,17 +83,17 @@ public final class ChunkAreaSetting
 			this.chunkRange = chunkRange;
 		}
 		
-		public ArrayList<Chunk> getChunksInRange()
+		public ArrayList<ChunkAccess> getChunksInRange()
 		{
-			ChunkPos center = MC.player.getChunkPos();
-			ArrayList<Chunk> chunksInRange = new ArrayList<>();
+			ChunkPos center = MC.player.chunkPosition();
+			ArrayList<ChunkAccess> chunksInRange = new ArrayList<>();
 			
 			for(int x = center.x - chunkRange; x <= center.x + chunkRange; x++)
 				for(int z = center.z - chunkRange; z <= center.z
 					+ chunkRange; z++)
 				{
-					Chunk chunk = MC.world.getChunk(x, z);
-					if(chunk instanceof EmptyChunk)
+					ChunkAccess chunk = MC.level.getChunk(x, z);
+					if(chunk instanceof EmptyLevelChunk)
 						continue;
 					
 					chunksInRange.add(chunk);
@@ -105,7 +104,7 @@ public final class ChunkAreaSetting
 		
 		public boolean isInRange(ChunkPos pos)
 		{
-			ChunkPos center = MC.player.getChunkPos();
+			ChunkPos center = MC.player.chunkPosition();
 			return Math.abs(pos.x - center.x) <= chunkRange
 				&& Math.abs(pos.z - center.z) <= chunkRange;
 		}
diff --git a/src/main/java/net/wurstclient/settings/ColorSetting.java b/src/main/java/net/wurstclient/settings/ColorSetting.java
index 3c7c69c51..0f937c366 100644
--- a/src/main/java/net/wurstclient/settings/ColorSetting.java
+++ b/src/main/java/net/wurstclient/settings/ColorSetting.java
@@ -15,8 +15,7 @@ import java.util.Set;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.ColorComponent;
@@ -73,7 +72,7 @@ public final class ColorSetting extends Setting
 	
 	public int getColorI(float alpha)
 	{
-		return getColorI((int)(MathHelper.clamp(alpha, 0, 1) * 255));
+		return getColorI((int)(Mth.clamp(alpha, 0, 1) * 255));
 	}
 	
 	public int getRed()
diff --git a/src/main/java/net/wurstclient/settings/EntityTypeListSetting.java b/src/main/java/net/wurstclient/settings/EntityTypeListSetting.java
index 1135abc41..39b6d33cd 100644
--- a/src/main/java/net/wurstclient/settings/EntityTypeListSetting.java
+++ b/src/main/java/net/wurstclient/settings/EntityTypeListSetting.java
@@ -18,11 +18,10 @@ import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.entity.EntityType;
-import net.minecraft.entity.SpawnGroup;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MobCategory;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.EntityTypeListEditButton;
@@ -47,10 +46,10 @@ public final class EntityTypeListSetting extends Setting
 		}else
 		{
 			// Default to all non-MISC spawn group entity types (typical mobs)
-			Registries.ENTITY_TYPE.getIds().forEach(id -> {
-				EntityType<?> t = Registries.ENTITY_TYPE.get(id);
-				SpawnGroup g = t.getSpawnGroup();
-				if(g != SpawnGroup.MISC)
+			BuiltInRegistries.ENTITY_TYPE.keySet().forEach(id -> {
+				EntityType<?> t = BuiltInRegistries.ENTITY_TYPE.getValue(id);
+				MobCategory g = t.getCategory();
+				if(g != MobCategory.MISC)
 					typeNames.add(id.toString());
 			});
 			Collections.sort(typeNames);
@@ -76,9 +75,9 @@ public final class EntityTypeListSetting extends Setting
 		if(raw.isEmpty())
 			return;
 		
-		Identifier id = Identifier.tryParse(raw);
+		ResourceLocation id = ResourceLocation.tryParse(raw);
 		String name = raw;
-		if(id != null && Registries.ENTITY_TYPE.containsId(id))
+		if(id != null && BuiltInRegistries.ENTITY_TYPE.containsKey(id))
 			name = id.toString();
 		
 		if(Collections.binarySearch(typeNames, name) < 0)
@@ -99,7 +98,7 @@ public final class EntityTypeListSetting extends Setting
 	
 	public void add(EntityType<?> type)
 	{
-		String name = Registries.ENTITY_TYPE.getId(type).toString();
+		String name = BuiltInRegistries.ENTITY_TYPE.getKey(type).toString();
 		if(Collections.binarySearch(typeNames, name) >= 0)
 			return;
 		typeNames.add(name);
diff --git a/src/main/java/net/wurstclient/settings/FaceTargetSetting.java b/src/main/java/net/wurstclient/settings/FaceTargetSetting.java
index edd80abb0..2e84c91f2 100644
--- a/src/main/java/net/wurstclient/settings/FaceTargetSetting.java
+++ b/src/main/java/net/wurstclient/settings/FaceTargetSetting.java
@@ -8,8 +8,7 @@
 package net.wurstclient.settings;
 
 import java.util.function.Consumer;
-
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hack.Hack;
 import net.wurstclient.util.RotationUtils;
@@ -65,7 +64,7 @@ public final class FaceTargetSetting
 			+ hack.getName().toLowerCase() + ".face_target");
 	}
 	
-	public void face(Vec3d v)
+	public void face(Vec3 v)
 	{
 		getSelected().face(v);
 	}
@@ -102,9 +101,9 @@ public final class FaceTargetSetting
 		
 		private final String name;
 		private final WText description;
-		private final Consumer<Vec3d> face;
+		private final Consumer<Vec3> face;
 		
-		private FaceTarget(String name, Consumer<Vec3d> face)
+		private FaceTarget(String name, Consumer<Vec3> face)
 		{
 			this.name = name;
 			description =
@@ -112,7 +111,7 @@ public final class FaceTargetSetting
 			this.face = face;
 		}
 		
-		public void face(Vec3d v)
+		public void face(Vec3 v)
 		{
 			face.accept(v);
 		}
diff --git a/src/main/java/net/wurstclient/settings/ItemListSetting.java b/src/main/java/net/wurstclient/settings/ItemListSetting.java
index 6b0274dd5..b1cfd5290 100644
--- a/src/main/java/net/wurstclient/settings/ItemListSetting.java
+++ b/src/main/java/net/wurstclient/settings/ItemListSetting.java
@@ -18,10 +18,9 @@ import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.item.Item;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.ItemListEditButton;
@@ -56,9 +55,9 @@ public final class ItemListSetting extends Setting
 		if(raw.isEmpty())
 			return;
 		
-		Identifier id = Identifier.tryParse(raw);
+		ResourceLocation id = ResourceLocation.tryParse(raw);
 		String name = raw;
-		if(id != null && Registries.ITEM.containsId(id))
+		if(id != null && BuiltInRegistries.ITEM.containsKey(id))
 			name = id.toString();
 		
 		if(Collections.binarySearch(itemNames, name) < 0)
@@ -75,7 +74,7 @@ public final class ItemListSetting extends Setting
 	
 	public void add(Item item)
 	{
-		String name = Registries.ITEM.getId(item).toString();
+		String name = BuiltInRegistries.ITEM.getKey(item).toString();
 		if(Collections.binarySearch(itemNames, name) >= 0)
 			return;
 		
diff --git a/src/main/java/net/wurstclient/settings/MobWeaponRuleSetting.java b/src/main/java/net/wurstclient/settings/MobWeaponRuleSetting.java
index 03be357c8..3fbf6774b 100644
--- a/src/main/java/net/wurstclient/settings/MobWeaponRuleSetting.java
+++ b/src/main/java/net/wurstclient/settings/MobWeaponRuleSetting.java
@@ -17,19 +17,18 @@ import java.util.Set;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.SpawnGroup;
-import net.minecraft.entity.attribute.EntityAttributes;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.item.MaceItem;
-import net.minecraft.item.TridentItem;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.tag.ItemTags;
-import net.minecraft.util.Identifier;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.MobCategory;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.MaceItem;
+import net.minecraft.world.item.TridentItem;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.MobWeaponRuleComponent;
@@ -111,7 +110,7 @@ public final class MobWeaponRuleSetting extends Setting
 		return entity.getType() == selectedMob.type();
 	}
 	
-	public int findPreferredHotbarSlot(ClientPlayerEntity player)
+	public int findPreferredHotbarSlot(LocalPlayer player)
 	{
 		if(player == null)
 			return -1;
@@ -182,12 +181,13 @@ public final class MobWeaponRuleSetting extends Setting
 	{
 		List<MobOption> options = new ArrayList<>();
 		options.add(ANY_OPTION);
-		Registries.ENTITY_TYPE.getIds().stream()
-			.map(Registries.ENTITY_TYPE::get)
-			.filter(type -> type.getSpawnGroup() != SpawnGroup.MISC)
+		BuiltInRegistries.ENTITY_TYPE.keySet().stream()
+			.map(BuiltInRegistries.ENTITY_TYPE::getValue)
+			.filter(type -> type.getCategory() != MobCategory.MISC)
 			.map(type -> {
-				Identifier id = Registries.ENTITY_TYPE.getId(type);
-				String name = type.getName().getString();
+				ResourceLocation id =
+					BuiltInRegistries.ENTITY_TYPE.getKey(type);
+				String name = type.getDescription().getString();
 				return new MobOption(id.toString(), name, type);
 			}).sorted(Comparator.comparing(MobOption::displayName,
 				String.CASE_INSENSITIVE_ORDER))
@@ -196,7 +196,7 @@ public final class MobWeaponRuleSetting extends Setting
 	}
 	
 	public record MobOption(String id, String displayName,
-		net.minecraft.entity.EntityType<?> type)
+		net.minecraft.world.entity.EntityType<?> type)
 	{
 		public boolean isAny()
 		{
@@ -226,7 +226,7 @@ public final class MobWeaponRuleSetting extends Setting
 			@Override
 			protected boolean matches(ItemStack stack)
 			{
-				return stack.isIn(ItemTags.SWORDS);
+				return stack.is(ItemTags.SWORDS);
 			}
 		},
 		
@@ -235,7 +235,7 @@ public final class MobWeaponRuleSetting extends Setting
 			@Override
 			protected boolean matches(ItemStack stack)
 			{
-				return stack.isIn(ItemTags.AXES);
+				return stack.is(ItemTags.AXES);
 			}
 		},
 		
@@ -244,7 +244,7 @@ public final class MobWeaponRuleSetting extends Setting
 			@Override
 			protected boolean matches(ItemStack stack)
 			{
-				return stack.isIn(ItemTags.HOES);
+				return stack.is(ItemTags.HOES);
 			}
 		},
 		
@@ -253,7 +253,7 @@ public final class MobWeaponRuleSetting extends Setting
 			@Override
 			protected boolean matches(ItemStack stack)
 			{
-				return stack.isIn(ItemTags.PICKAXES);
+				return stack.is(ItemTags.PICKAXES);
 			}
 		},
 		
@@ -262,7 +262,7 @@ public final class MobWeaponRuleSetting extends Setting
 			@Override
 			protected boolean matches(ItemStack stack)
 			{
-				return stack.isIn(ItemTags.SHOVELS);
+				return stack.is(ItemTags.SHOVELS);
 			}
 		},
 		
@@ -291,14 +291,14 @@ public final class MobWeaponRuleSetting extends Setting
 			this.displayName = displayName;
 		}
 		
-		public int findBestSlot(PlayerInventory inventory)
+		public int findBestSlot(Inventory inventory)
 		{
 			int bestSlot = -1;
 			float bestScore = Float.NEGATIVE_INFINITY;
 			
 			for(int i = 0; i < 9; i++)
 			{
-				ItemStack stack = inventory.getStack(i);
+				ItemStack stack = inventory.getItem(i);
 				if(stack.isEmpty() || !matches(stack))
 					continue;
 				
@@ -320,8 +320,7 @@ public final class MobWeaponRuleSetting extends Setting
 		
 		protected float getDamageScore(Item item)
 		{
-			return (float)ItemUtils
-				.getAttribute(item, EntityAttributes.ATTACK_DAMAGE)
+			return (float)ItemUtils.getAttribute(item, Attributes.ATTACK_DAMAGE)
 				.orElse(0.0D);
 		}
 		
diff --git a/src/main/java/net/wurstclient/settings/PauseAttackOnContainersSetting.java b/src/main/java/net/wurstclient/settings/PauseAttackOnContainersSetting.java
index 898051992..91c4f83da 100644
--- a/src/main/java/net/wurstclient/settings/PauseAttackOnContainersSetting.java
+++ b/src/main/java/net/wurstclient/settings/PauseAttackOnContainersSetting.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.settings;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;
-import net.minecraft.client.gui.screen.ingame.HandledScreen;
-import net.minecraft.client.gui.screen.ingame.InventoryScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
+import net.minecraft.client.gui.screens.inventory.CreativeModeInventoryScreen;
+import net.minecraft.client.gui.screens.inventory.InventoryScreen;
 import net.wurstclient.WurstClient;
 
 public final class PauseAttackOnContainersSetting extends CheckboxSetting
@@ -33,10 +33,10 @@ public final class PauseAttackOnContainersSetting extends CheckboxSetting
 		if(!isChecked())
 			return false;
 		
-		Screen screen = WurstClient.MC.currentScreen;
+		Screen screen = WurstClient.MC.screen;
 		
-		return screen instanceof HandledScreen
+		return screen instanceof AbstractContainerScreen
 			&& !(screen instanceof InventoryScreen
-				|| screen instanceof CreativeInventoryScreen);
+				|| screen instanceof CreativeModeInventoryScreen);
 	}
 }
diff --git a/src/main/java/net/wurstclient/settings/PlantTypeSetting.java b/src/main/java/net/wurstclient/settings/PlantTypeSetting.java
index bbb2fdf1d..7462ba46c 100644
--- a/src/main/java/net/wurstclient/settings/PlantTypeSetting.java
+++ b/src/main/java/net/wurstclient/settings/PlantTypeSetting.java
@@ -13,9 +13,8 @@ import java.util.Set;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.PlantTypeComponent;
diff --git a/src/main/java/net/wurstclient/settings/SliderSetting.java b/src/main/java/net/wurstclient/settings/SliderSetting.java
index 73ed37255..8eb52e5d8 100644
--- a/src/main/java/net/wurstclient/settings/SliderSetting.java
+++ b/src/main/java/net/wurstclient/settings/SliderSetting.java
@@ -13,8 +13,7 @@ import java.util.LinkedHashSet;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
-
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.WurstClient;
 import net.wurstclient.clickgui.Component;
 import net.wurstclient.clickgui.components.SliderComponent;
@@ -76,7 +75,7 @@ public class SliderSetting extends Setting implements SliderLock
 	
 	public final double getValueSq()
 	{
-		return MathHelper.square(getValue());
+		return Mth.square(getValue());
 	}
 	
 	public final float getValueF()
@@ -91,7 +90,7 @@ public class SliderSetting extends Setting implements SliderLock
 	
 	public final int getValueCeil()
 	{
-		return MathHelper.ceil(getValue());
+		return Mth.ceil(getValue());
 	}
 	
 	/**
diff --git a/src/main/java/net/wurstclient/settings/SwingHandSetting.java b/src/main/java/net/wurstclient/settings/SwingHandSetting.java
index b1b5cd0bf..ca69ff63a 100644
--- a/src/main/java/net/wurstclient/settings/SwingHandSetting.java
+++ b/src/main/java/net/wurstclient/settings/SwingHandSetting.java
@@ -8,10 +8,9 @@
 package net.wurstclient.settings;
 
 import java.util.function.Consumer;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
-import net.minecraft.util.Hand;
+import net.minecraft.client.Minecraft;
+import net.minecraft.network.protocol.game.ServerboundSwingPacket;
+import net.minecraft.world.InteractionHand;
 import net.wurstclient.WurstClient;
 import net.wurstclient.hack.Hack;
 import net.wurstclient.util.text.WText;
@@ -19,7 +18,7 @@ import net.wurstclient.util.text.WText;
 public final class SwingHandSetting
 	extends EnumSetting<SwingHandSetting.SwingHand>
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	private static final WText FULL_DESCRIPTION_SUFFIX =
 		buildDescriptionSuffix(true);
 	private static final WText REDUCED_DESCRIPTION_SUFFIX =
@@ -76,7 +75,7 @@ public final class SwingHandSetting
 			+ hack.getName().toLowerCase() + ".swing_hand");
 	}
 	
-	public void swing(Hand hand)
+	public void swing(InteractionHand hand)
 	{
 		getSelected().swing(hand);
 	}
@@ -99,19 +98,19 @@ public final class SwingHandSetting
 		OFF("Off", hand -> {}),
 		
 		SERVER("Server-side",
-			hand -> MC.player.networkHandler
-				.sendPacket(new HandSwingC2SPacket(hand))),
+			hand -> MC.player.connection
+				.send(new ServerboundSwingPacket(hand))),
 		
-		CLIENT("Client-side", hand -> MC.player.swingHand(hand));
+		CLIENT("Client-side", hand -> MC.player.swing(hand));
 		
 		private static final String TRANSLATION_KEY_PREFIX =
 			"description.wurst.setting.generic.swing_hand.";
 		
 		private final String name;
 		private final WText description;
-		private final Consumer<Hand> swing;
+		private final Consumer<InteractionHand> swing;
 		
-		private SwingHand(String name, Consumer<Hand> swing)
+		private SwingHand(String name, Consumer<InteractionHand> swing)
 		{
 			this.name = name;
 			description =
@@ -119,7 +118,7 @@ public final class SwingHandSetting
 			this.swing = swing;
 		}
 		
-		public void swing(Hand hand)
+		public void swing(InteractionHand hand)
 		{
 			swing.accept(hand);
 		}
diff --git a/src/main/java/net/wurstclient/settings/filterlists/EntityFilterList.java b/src/main/java/net/wurstclient/settings/filterlists/EntityFilterList.java
index 07b376a19..a46824470 100644
--- a/src/main/java/net/wurstclient/settings/filterlists/EntityFilterList.java
+++ b/src/main/java/net/wurstclient/settings/filterlists/EntityFilterList.java
@@ -13,8 +13,7 @@ import java.util.List;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
-
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.settings.Setting;
 import net.wurstclient.settings.filters.*;
 
diff --git a/src/main/java/net/wurstclient/settings/filters/AttackDetectingEntityFilter.java b/src/main/java/net/wurstclient/settings/filters/AttackDetectingEntityFilter.java
index ed5418540..6e9c21c52 100644
--- a/src/main/java/net/wurstclient/settings/filters/AttackDetectingEntityFilter.java
+++ b/src/main/java/net/wurstclient/settings/filters/AttackDetectingEntityFilter.java
@@ -8,8 +8,7 @@
 package net.wurstclient.settings.filters;
 
 import java.util.function.Supplier;
-
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.settings.CheckboxSetting;
 import net.wurstclient.settings.EnumSetting;
 import net.wurstclient.settings.Setting;
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterAllaysSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterAllaysSetting.java
index 19b2b1be2..d1ce70b3f 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterAllaysSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterAllaysSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.passive.AllayEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.allay.Allay;
 
 public final class FilterAllaysSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterAllaysSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof AllayEntity);
+		return !(e instanceof Allay);
 	}
 	
 	public static FilterAllaysSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterArmorStandsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterArmorStandsSetting.java
index 573361e92..91254c069 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterArmorStandsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterArmorStandsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.decoration.ArmorStandEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.decoration.ArmorStand;
 
 public final class FilterArmorStandsSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterArmorStandsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof ArmorStandEntity);
+		return !(e instanceof ArmorStand);
 	}
 	
 	public static FilterArmorStandsSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterBabiesSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterBabiesSetting.java
index 9045919a5..4796479f0 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterBabiesSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterBabiesSetting.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.Monster;
-import net.minecraft.entity.passive.PassiveEntity;
-import net.minecraft.entity.passive.TadpoleEntity;
+import net.minecraft.world.entity.AgeableMob;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.frog.Tadpole;
+import net.minecraft.world.entity.monster.Enemy;
 
 public final class FilterBabiesSetting extends EntityFilterCheckbox
 {
@@ -26,15 +26,15 @@ public final class FilterBabiesSetting extends EntityFilterCheckbox
 	public boolean test(Entity e)
 	{
 		// never filter out hostile mobs (including hoglins)
-		if(e instanceof Monster)
+		if(e instanceof Enemy)
 			return true;
 		
 		// filter out passive entity babies
-		if(e instanceof PassiveEntity pe && pe.isBaby())
+		if(e instanceof AgeableMob pe && pe.isBaby())
 			return false;
 		
 		// filter out tadpoles
-		if(e instanceof TadpoleEntity)
+		if(e instanceof Tadpole)
 			return false;
 		
 		return true;
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterBatsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterBatsSetting.java
index 7559fa54e..674a42fd1 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterBatsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterBatsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.AmbientEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.ambient.AmbientCreature;
 
 public final class FilterBatsSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterBatsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof AmbientEntity);
+		return !(e instanceof AmbientCreature);
 	}
 	
 	public static FilterBatsSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterCrystalsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterCrystalsSetting.java
index 6099211b0..95fc1bd73 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterCrystalsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterCrystalsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.decoration.EndCrystalEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.boss.enderdragon.EndCrystal;
 
 public final class FilterCrystalsSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterCrystalsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof EndCrystalEntity);
+		return !(e instanceof EndCrystal);
 	}
 	
 	public static FilterCrystalsSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterEndermenSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterEndermenSetting.java
index 9d7c35188..8a236a2a4 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterEndermenSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterEndermenSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.EndermanEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.EnderMan;
 
 public final class FilterEndermenSetting extends AttackDetectingEntityFilter
 {
@@ -26,13 +26,13 @@ public final class FilterEndermenSetting extends AttackDetectingEntityFilter
 	@Override
 	public boolean onTest(Entity e)
 	{
-		return !(e instanceof EndermanEntity);
+		return !(e instanceof EnderMan);
 	}
 	
 	@Override
 	public boolean ifCalmTest(Entity e)
 	{
-		return !(e instanceof EndermanEntity ee) || ee.isAttacking();
+		return !(e instanceof EnderMan ee) || ee.isAggressive();
 	}
 	
 	public static FilterEndermenSetting genericCombat(Mode selected)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterFlyingSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterFlyingSetting.java
index 1282c97df..d4872331b 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterFlyingSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterFlyingSetting.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.Box;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.Setting;
 import net.wurstclient.settings.SliderSetting;
@@ -27,12 +27,12 @@ public final class FilterFlyingSetting extends SliderSetting
 	@Override
 	public boolean test(Entity e)
 	{
-		if(!(e instanceof PlayerEntity))
+		if(!(e instanceof Player))
 			return true;
 		
-		Box box = e.getBoundingBox();
-		box = box.union(box.offset(0, -getValue(), 0));
-		return !WurstClient.MC.world.isSpaceEmpty(box);
+		AABB box = e.getBoundingBox();
+		box = box.minmax(box.move(0, -getValue(), 0));
+		return !WurstClient.MC.level.noCollision(box);
 	}
 	
 	@Override
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterGolemsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterGolemsSetting.java
index 3a7cc2620..cc5469ed4 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterGolemsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterGolemsSetting.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.ShulkerEntity;
-import net.minecraft.entity.passive.GolemEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.AbstractGolem;
+import net.minecraft.world.entity.monster.Shulker;
 
 public final class FilterGolemsSetting extends EntityFilterCheckbox
 {
@@ -21,7 +21,7 @@ public final class FilterGolemsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof GolemEntity) || e instanceof ShulkerEntity;
+		return !(e instanceof AbstractGolem) || e instanceof Shulker;
 	}
 	
 	public static FilterGolemsSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterHostileSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterHostileSetting.java
index 22e763448..7a18e1967 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterHostileSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterHostileSetting.java
@@ -7,10 +7,10 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.Angerable;
-import net.minecraft.entity.mob.Monster;
-import net.minecraft.entity.mob.PiglinEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.NeutralMob;
+import net.minecraft.world.entity.monster.Enemy;
+import net.minecraft.world.entity.monster.piglin.Piglin;
 
 public final class FilterHostileSetting extends EntityFilterCheckbox
 {
@@ -26,10 +26,10 @@ public final class FilterHostileSetting extends EntityFilterCheckbox
 	public boolean test(Entity e)
 	{
 		// never filter out neutral mobs (including piglins)
-		if(e instanceof Angerable || e instanceof PiglinEntity)
+		if(e instanceof NeutralMob || e instanceof Piglin)
 			return true;
 		
-		return !(e instanceof Monster);
+		return !(e instanceof Enemy);
 	}
 	
 	public static FilterHostileSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterInvisibleSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterInvisibleSetting.java
index b805f87a5..8d7e879a1 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterInvisibleSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterInvisibleSetting.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 
 public final class FilterInvisibleSetting extends EntityFilterCheckbox
 {
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterMinecartsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterMinecartsSetting.java
index 291199e53..e6307a26b 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterMinecartsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterMinecartsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.vehicle.AbstractMinecartEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.vehicle.AbstractMinecart;
 
 public final class FilterMinecartsSetting extends EntityFilterCheckbox
 {
@@ -20,6 +20,6 @@ public final class FilterMinecartsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof AbstractMinecartEntity);
+		return !(e instanceof AbstractMinecart);
 	}
 }
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterNamedSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterNamedSetting.java
index beacc38c5..b373d959f 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterNamedSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterNamedSetting.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
+import net.minecraft.world.entity.Entity;
 
 public final class FilterNamedSetting extends EntityFilterCheckbox
 {
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterNeutralSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterNeutralSetting.java
index 86c1458d8..188b95b74 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterNeutralSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterNeutralSetting.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.Angerable;
-import net.minecraft.entity.mob.MobEntity;
-import net.minecraft.entity.mob.PiglinEntity;
-import net.minecraft.entity.passive.PufferfishEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.NeutralMob;
+import net.minecraft.world.entity.animal.Pufferfish;
+import net.minecraft.world.entity.monster.piglin.Piglin;
 
 public final class FilterNeutralSetting extends AttackDetectingEntityFilter
 {
@@ -29,20 +29,20 @@ public final class FilterNeutralSetting extends AttackDetectingEntityFilter
 	@Override
 	public boolean onTest(Entity e)
 	{
-		return !(e instanceof Angerable || e instanceof PufferfishEntity
-			|| e instanceof PiglinEntity);
+		return !(e instanceof NeutralMob || e instanceof Pufferfish
+			|| e instanceof Piglin);
 	}
 	
 	@Override
 	public boolean ifCalmTest(Entity e)
 	{
 		// special case for pufferfish
-		if(e instanceof PufferfishEntity pfe)
+		if(e instanceof Pufferfish pfe)
 			return pfe.getPuffState() > 0;
 		
-		if(e instanceof Angerable || e instanceof PiglinEntity)
-			if(e instanceof MobEntity me)
-				return me.isAttacking();
+		if(e instanceof NeutralMob || e instanceof Piglin)
+			if(e instanceof Mob me)
+				return me.isAggressive();
 			
 		return true;
 	}
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterPassiveSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterPassiveSetting.java
index 83c1e1c78..51829c89b 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterPassiveSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterPassiveSetting.java
@@ -7,14 +7,14 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.AmbientEntity;
-import net.minecraft.entity.mob.Angerable;
-import net.minecraft.entity.mob.Monster;
-import net.minecraft.entity.mob.WaterCreatureEntity;
-import net.minecraft.entity.passive.AnimalEntity;
-import net.minecraft.entity.passive.PufferfishEntity;
-import net.minecraft.entity.passive.WaterAnimalEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.NeutralMob;
+import net.minecraft.world.entity.ambient.AmbientCreature;
+import net.minecraft.world.entity.animal.AgeableWaterCreature;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.animal.Pufferfish;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.monster.Enemy;
 
 public final class FilterPassiveSetting extends EntityFilterCheckbox
 {
@@ -30,16 +30,15 @@ public final class FilterPassiveSetting extends EntityFilterCheckbox
 	public boolean test(Entity e)
 	{
 		// never filter out hostile mobs (including hoglins)
-		if(e instanceof Monster)
+		if(e instanceof Enemy)
 			return true;
 		
 		// never filter out neutral mobs (including pufferfish)
-		if(e instanceof Angerable || e instanceof PufferfishEntity)
+		if(e instanceof NeutralMob || e instanceof Pufferfish)
 			return true;
 		
-		return !(e instanceof AnimalEntity || e instanceof AmbientEntity
-			|| e instanceof WaterCreatureEntity
-			|| e instanceof WaterAnimalEntity);
+		return !(e instanceof Animal || e instanceof AmbientCreature
+			|| e instanceof WaterAnimal || e instanceof AgeableWaterCreature);
 	}
 	
 	public static FilterPassiveSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterPassiveWaterSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterPassiveWaterSetting.java
index dca45df14..247fd8110 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterPassiveWaterSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterPassiveWaterSetting.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.WaterCreatureEntity;
-import net.minecraft.entity.passive.AxolotlEntity;
-import net.minecraft.entity.passive.PufferfishEntity;
-import net.minecraft.entity.passive.WaterAnimalEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.AgeableWaterCreature;
+import net.minecraft.world.entity.animal.Pufferfish;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.animal.axolotl.Axolotl;
 
 public final class FilterPassiveWaterSetting extends EntityFilterCheckbox
 {
@@ -28,11 +28,11 @@ public final class FilterPassiveWaterSetting extends EntityFilterCheckbox
 	public boolean test(Entity e)
 	{
 		// never filter out pufferfish
-		if(e instanceof PufferfishEntity)
+		if(e instanceof Pufferfish)
 			return true;
 		
-		return !(e instanceof WaterCreatureEntity
-			|| e instanceof WaterAnimalEntity || e instanceof AxolotlEntity);
+		return !(e instanceof WaterAnimal || e instanceof AgeableWaterCreature
+			|| e instanceof Axolotl);
 	}
 	
 	public static FilterPassiveWaterSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterPetsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterPetsSetting.java
index a3b2cc1ae..3548c8e05 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterPetsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterPetsSetting.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.passive.AbstractHorseEntity;
-import net.minecraft.entity.passive.TameableEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.animal.horse.AbstractHorse;
 
 public final class FilterPetsSetting extends EntityFilterCheckbox
 {
@@ -21,9 +21,8 @@ public final class FilterPetsSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof TameableEntity && ((TameableEntity)e).isTamed())
-			&& !(e instanceof AbstractHorseEntity
-				&& ((AbstractHorseEntity)e).isTame());
+		return !(e instanceof TamableAnimal && ((TamableAnimal)e).isTame())
+			&& !(e instanceof AbstractHorse && ((AbstractHorse)e).isTamed());
 	}
 	
 	public static FilterPetsSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterPiglinsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterPiglinsSetting.java
index c8bfd92df..77fdd1b8d 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterPiglinsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterPiglinsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.PiglinEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.piglin.Piglin;
 
 public final class FilterPiglinsSetting extends AttackDetectingEntityFilter
 {
@@ -30,13 +30,13 @@ public final class FilterPiglinsSetting extends AttackDetectingEntityFilter
 	@Override
 	public boolean onTest(Entity e)
 	{
-		return !(e instanceof PiglinEntity);
+		return !(e instanceof Piglin);
 	}
 	
 	@Override
 	public boolean ifCalmTest(Entity e)
 	{
-		return !(e instanceof PiglinEntity pe) || pe.isAttacking();
+		return !(e instanceof Piglin pe) || pe.isAggressive();
 	}
 	
 	public static FilterPiglinsSetting genericCombat(Mode selected)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterPlayersSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterPlayersSetting.java
index ffdaa91ea..21b409090 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterPlayersSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterPlayersSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
 
 public final class FilterPlayersSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterPlayersSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof PlayerEntity);
+		return !(e instanceof Player);
 	}
 	
 	public static FilterPlayersSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterShulkerBulletSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterShulkerBulletSetting.java
index d4357271f..ce1242a4d 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterShulkerBulletSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterShulkerBulletSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.projectile.ShulkerBulletEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.projectile.ShulkerBullet;
 
 public final class FilterShulkerBulletSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterShulkerBulletSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof ShulkerBulletEntity);
+		return !(e instanceof ShulkerBullet);
 	}
 	
 	public static FilterShulkerBulletSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterShulkersSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterShulkersSetting.java
index 7fd8f9e2c..2bc6ff5e7 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterShulkersSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterShulkersSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.ShulkerEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.Shulker;
 
 public final class FilterShulkersSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterShulkersSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof ShulkerEntity);
+		return !(e instanceof Shulker);
 	}
 	
 	public static FilterShulkersSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterSleepingSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterSleepingSetting.java
index 2dc282146..e68566f1a 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterSleepingSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterSleepingSetting.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityPose;
-import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Pose;
+import net.minecraft.world.entity.player.Player;
 
 public final class FilterSleepingSetting extends EntityFilterCheckbox
 {
@@ -21,10 +21,10 @@ public final class FilterSleepingSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		if(!(e instanceof PlayerEntity pe))
+		if(!(e instanceof Player pe))
 			return true;
 		
-		return !pe.isSleeping() && pe.getPose() != EntityPose.SLEEPING;
+		return !pe.isSleeping() && pe.getPose() != Pose.SLEEPING;
 	}
 	
 	public static FilterSleepingSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterSlimesSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterSlimesSetting.java
index a70058c55..a3af2f4fa 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterSlimesSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterSlimesSetting.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.MagmaCubeEntity;
-import net.minecraft.entity.mob.SlimeEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.MagmaCube;
+import net.minecraft.world.entity.monster.Slime;
 
 public final class FilterSlimesSetting extends EntityFilterCheckbox
 {
@@ -24,7 +24,7 @@ public final class FilterSlimesSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof SlimeEntity) || e instanceof MagmaCubeEntity;
+		return !(e instanceof Slime) || e instanceof MagmaCube;
 	}
 	
 	public static FilterSlimesSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterVillagersSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterVillagersSetting.java
index 2a7bbd3a6..d0ccd2507 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterVillagersSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterVillagersSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.passive.MerchantEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.npc.AbstractVillager;
 
 public final class FilterVillagersSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterVillagersSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof MerchantEntity);
+		return !(e instanceof AbstractVillager);
 	}
 	
 	public static FilterVillagersSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterZombiePiglinsSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterZombiePiglinsSetting.java
index 9bf74c58f..2d03a53f2 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterZombiePiglinsSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterZombiePiglinsSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.ZombifiedPiglinEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.ZombifiedPiglin;
 
 public final class FilterZombiePiglinsSetting
 	extends AttackDetectingEntityFilter
@@ -27,13 +27,13 @@ public final class FilterZombiePiglinsSetting
 	@Override
 	public boolean onTest(Entity e)
 	{
-		return !(e instanceof ZombifiedPiglinEntity);
+		return !(e instanceof ZombifiedPiglin);
 	}
 	
 	@Override
 	public boolean ifCalmTest(Entity e)
 	{
-		return !(e instanceof ZombifiedPiglinEntity zpe) || zpe.isAttacking();
+		return !(e instanceof ZombifiedPiglin zpe) || zpe.isAggressive();
 	}
 	
 	public static FilterZombiePiglinsSetting genericCombat(Mode selected)
diff --git a/src/main/java/net/wurstclient/settings/filters/FilterZombieVillagersSetting.java b/src/main/java/net/wurstclient/settings/filters/FilterZombieVillagersSetting.java
index 38cf05639..126a3dbcd 100644
--- a/src/main/java/net/wurstclient/settings/filters/FilterZombieVillagersSetting.java
+++ b/src/main/java/net/wurstclient/settings/filters/FilterZombieVillagersSetting.java
@@ -7,8 +7,8 @@
  */
 package net.wurstclient.settings.filters;
 
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.mob.ZombieVillagerEntity;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.ZombieVillager;
 
 public final class FilterZombieVillagersSetting extends EntityFilterCheckbox
 {
@@ -20,7 +20,7 @@ public final class FilterZombieVillagersSetting extends EntityFilterCheckbox
 	@Override
 	public boolean test(Entity e)
 	{
-		return !(e instanceof ZombieVillagerEntity);
+		return !(e instanceof ZombieVillager);
 	}
 	
 	public static FilterZombieVillagersSetting genericCombat(boolean checked)
diff --git a/src/main/java/net/wurstclient/update/ProblematicResourcePackDetector.java b/src/main/java/net/wurstclient/update/ProblematicResourcePackDetector.java
index b1a11db66..25c2fd1e2 100644
--- a/src/main/java/net/wurstclient/update/ProblematicResourcePackDetector.java
+++ b/src/main/java/net/wurstclient/update/ProblematicResourcePackDetector.java
@@ -11,10 +11,9 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collection;
-
-import net.minecraft.resource.InputSupplier;
-import net.minecraft.resource.ResourcePack;
-import net.minecraft.resource.ResourcePackProfile;
+import net.minecraft.server.packs.PackResources;
+import net.minecraft.server.packs.repository.Pack;
+import net.minecraft.server.packs.resources.IoSupplier;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.util.ChatUtils;
@@ -49,15 +48,15 @@ public final class ProblematicResourcePackDetector implements UpdateListener
 	
 	private boolean isTwinklingStarsInstalled()
 	{
-		Collection<ResourcePackProfile> enabledProfiles =
-			WurstClient.MC.getResourcePackManager().getEnabledProfiles();
+		Collection<Pack> enabledProfiles =
+			WurstClient.MC.getResourcePackRepository().getSelectedPacks();
 		
-		for(ResourcePackProfile profile : enabledProfiles)
+		for(Pack profile : enabledProfiles)
 		{
 			if(!isVanillaTweaks(profile))
 				continue;
 			
-			ResourcePack pack = profile.createResourcePack();
+			PackResources pack = profile.open();
 			if(!containsTwinklingStars(pack))
 				continue;
 			
@@ -67,20 +66,20 @@ public final class ProblematicResourcePackDetector implements UpdateListener
 		return false;
 	}
 	
-	private boolean isVanillaTweaks(ResourcePackProfile profile)
+	private boolean isVanillaTweaks(Pack profile)
 	{
 		return profile.getDescription().getString().contains("Vanilla Tweaks");
 	}
 	
-	private boolean containsTwinklingStars(ResourcePack pack)
+	private boolean containsTwinklingStars(PackResources pack)
 	{
 		try
 		{
 			// some implementations of ResourcePack.openRoot() throw an
 			// IllegalArgumentException when the pack doesn't contain the
 			// specified file
-			InputSupplier<InputStream> supplier =
-				pack.openRoot("Selected Packs.txt");
+			IoSupplier<InputStream> supplier =
+				pack.getRootResource("Selected Packs.txt");
 			if(supplier == null)
 				return false;
 			
diff --git a/src/main/java/net/wurstclient/update/WurstUpdater.java b/src/main/java/net/wurstclient/update/WurstUpdater.java
index 12cb22acd..b290fd0b8 100644
--- a/src/main/java/net/wurstclient/update/WurstUpdater.java
+++ b/src/main/java/net/wurstclient/update/WurstUpdater.java
@@ -10,9 +10,8 @@ package net.wurstclient.update;
 import java.net.URI;
 import java.net.URLEncoder;
 import java.nio.charset.StandardCharsets;
-
-import net.minecraft.text.ClickEvent;
-import net.minecraft.text.Text;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.Component;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.UpdateListener;
 import net.wurstclient.util.ChatUtils;
@@ -25,7 +24,7 @@ public final class WurstUpdater implements UpdateListener
 {
 	private Thread thread;
 	private boolean outdated;
-	private Text component;
+	private Component component;
 	
 	@Override
 	public void onUpdate()
@@ -120,7 +119,8 @@ public final class WurstUpdater implements UpdateListener
 	private void showLink(String text, String url)
 	{
 		ClickEvent event = new ClickEvent.OpenUrl(URI.create(url));
-		component = Text.literal(text).styled(s -> s.withClickEvent(event));
+		component =
+			Component.literal(text).withStyle(s -> s.withClickEvent(event));
 	}
 	
 	private boolean containsCompatibleAsset(WsonArray wsonArray)
diff --git a/src/main/java/net/wurstclient/util/AutoBuildTemplate.java b/src/main/java/net/wurstclient/util/AutoBuildTemplate.java
index 39bc1a3bc..0b073d76f 100644
--- a/src/main/java/net/wurstclient/util/AutoBuildTemplate.java
+++ b/src/main/java/net/wurstclient/util/AutoBuildTemplate.java
@@ -11,10 +11,9 @@ import java.io.IOException;
 import java.nio.file.Path;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-
-import net.minecraft.item.Item;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Direction;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
 import net.wurstclient.settings.FileSetting;
 import net.wurstclient.util.json.JsonException;
 import net.wurstclient.util.json.JsonUtils;
@@ -107,7 +106,7 @@ public final class AutoBuildTemplate
 		Direction direction)
 	{
 		Direction front = direction;
-		Direction left = front.rotateYCounterclockwise();
+		Direction left = front.getCounterClockWise();
 		LinkedHashMap<BlockPos, Item> blocksToPlace = new LinkedHashMap<>();
 		
 		for(BlockData block : blocks)
@@ -140,7 +139,8 @@ public final class AutoBuildTemplate
 		public BlockPos toBlockPos(BlockPos origin, Direction front,
 			Direction left)
 		{
-			return origin.offset(left, pos[0]).up(pos[1]).offset(front, pos[2]);
+			return origin.relative(left, pos[0]).above(pos[1]).relative(front,
+				pos[2]);
 		}
 		
 		public Item toItem()
diff --git a/src/main/java/net/wurstclient/util/BlockBreaker.java b/src/main/java/net/wurstclient/util/BlockBreaker.java
index 7d321dd5d..9ac0f7c85 100644
--- a/src/main/java/net/wurstclient/util/BlockBreaker.java
+++ b/src/main/java/net/wurstclient/util/BlockBreaker.java
@@ -9,20 +9,19 @@ package net.wurstclient.util;
 
 import java.util.Comparator;
 import java.util.function.Function;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
-import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket.Action;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.Vec3i;
-import net.minecraft.util.shape.VoxelShape;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Vec3i;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket.Action;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.SwingHandSetting.SwingHand;
 
@@ -31,7 +30,7 @@ public enum BlockBreaker
 	;
 	
 	private static final WurstClient WURST = WurstClient.INSTANCE;
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static boolean breakOneBlock(BlockPos pos)
 	{
@@ -48,12 +47,11 @@ public enum BlockBreaker
 		WURST.getRotationFaker().faceVectorPacket(params.hitVec);
 		
 		// damage block
-		if(!MC.interactionManager.updateBlockBreakingProgress(params.pos,
-			params.side))
+		if(!MC.gameMode.continueDestroyBlock(params.pos, params.side))
 			return false;
 		
 		// swing arm
-		SwingHand.SERVER.swing(Hand.MAIN_HAND);
+		SwingHand.SERVER.swing(InteractionHand.MAIN_HAND);
 		return true;
 	}
 	
@@ -74,37 +72,37 @@ public enum BlockBreaker
 	 * squared distance to that hit vector, and whether or not there is line of
 	 * sight to that hit vector.
 	 */
-	public static BlockBreakingParams getBlockBreakingParams(Vec3d eyes,
+	public static BlockBreakingParams getBlockBreakingParams(Vec3 eyes,
 		BlockPos pos)
 	{
 		Direction[] sides = Direction.values();
 		
 		BlockState state = BlockUtils.getState(pos);
-		VoxelShape shape = state.getOutlineShape(MC.world, pos);
+		VoxelShape shape = state.getShape(MC.level, pos);
 		if(shape.isEmpty())
 			return null;
 		
-		Box box = shape.getBoundingBox();
-		Vec3d halfSize = new Vec3d(box.maxX - box.minX, box.maxY - box.minY,
-			box.maxZ - box.minZ).multiply(0.5);
-		Vec3d center = Vec3d.of(pos).add(box.getCenter());
+		AABB box = shape.bounds();
+		Vec3 halfSize = new Vec3(box.maxX - box.minX, box.maxY - box.minY,
+			box.maxZ - box.minZ).scale(0.5);
+		Vec3 center = Vec3.atLowerCornerOf(pos).add(box.getCenter());
 		
-		Vec3d[] hitVecs = new Vec3d[sides.length];
+		Vec3[] hitVecs = new Vec3[sides.length];
 		for(int i = 0; i < sides.length; i++)
 		{
-			Vec3i dirVec = sides[i].getVector();
-			Vec3d relHitVec = new Vec3d(halfSize.x * dirVec.getX(),
+			Vec3i dirVec = sides[i].getUnitVec3i();
+			Vec3 relHitVec = new Vec3(halfSize.x * dirVec.getX(),
 				halfSize.y * dirVec.getY(), halfSize.z * dirVec.getZ());
 			hitVecs[i] = center.add(relHitVec);
 		}
 		
-		double distanceSqToCenter = eyes.squaredDistanceTo(center);
+		double distanceSqToCenter = eyes.distanceToSqr(center);
 		double[] distancesSq = new double[sides.length];
 		boolean[] linesOfSight = new boolean[sides.length];
 		
 		for(int i = 0; i < sides.length; i++)
 		{
-			distancesSq[i] = eyes.squaredDistanceTo(hitVecs[i]);
+			distancesSq[i] = eyes.distanceToSqr(hitVecs[i]);
 			
 			// no need to raytrace the rear sides,
 			// they can't possibly have line of sight
@@ -139,7 +137,7 @@ public enum BlockBreaker
 	}
 	
 	public static record BlockBreakingParams(BlockPos pos, Direction side,
-		Vec3d hitVec, double distanceSq, boolean lineOfSight)
+		Vec3 hitVec, double distanceSq, boolean lineOfSight)
 	{
 		public BlockHitResult toHitResult()
 		{
@@ -170,27 +168,27 @@ public enum BlockBreaker
 	
 	public static void breakBlocksWithPacketSpam(Iterable<BlockPos> blocks)
 	{
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		ClientPlayNetworkHandler netHandler = MC.player.networkHandler;
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		ClientPacketListener netHandler = MC.player.connection;
 		
 		for(BlockPos pos : blocks)
 		{
-			Vec3d posVec = Vec3d.ofCenter(pos);
-			double distanceSqPosVec = eyesPos.squaredDistanceTo(posVec);
+			Vec3 posVec = Vec3.atCenterOf(pos);
+			double distanceSqPosVec = eyesPos.distanceToSqr(posVec);
 			
 			for(Direction side : Direction.values())
 			{
-				Vec3d hitVec =
-					posVec.add(Vec3d.of(side.getVector()).multiply(0.5));
+				Vec3 hitVec = posVec
+					.add(Vec3.atLowerCornerOf(side.getUnitVec3i()).scale(0.5));
 				
 				// check if side is facing towards player
-				if(eyesPos.squaredDistanceTo(hitVec) >= distanceSqPosVec)
+				if(eyesPos.distanceToSqr(hitVec) >= distanceSqPosVec)
 					continue;
 				
 				// break block
-				netHandler.sendPacket(new PlayerActionC2SPacket(
+				netHandler.send(new ServerboundPlayerActionPacket(
 					Action.START_DESTROY_BLOCK, pos, side));
-				netHandler.sendPacket(new PlayerActionC2SPacket(
+				netHandler.send(new ServerboundPlayerActionPacket(
 					Action.STOP_DESTROY_BLOCK, pos, side));
 				
 				break;
diff --git a/src/main/java/net/wurstclient/util/BlockBreakingCache.java b/src/main/java/net/wurstclient/util/BlockBreakingCache.java
index 3c6a7cd03..f2a57acd6 100644
--- a/src/main/java/net/wurstclient/util/BlockBreakingCache.java
+++ b/src/main/java/net/wurstclient/util/BlockBreakingCache.java
@@ -13,8 +13,7 @@ import java.util.HashSet;
 import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 
 public final class BlockBreakingCache
 {
diff --git a/src/main/java/net/wurstclient/util/BlockPlacer.java b/src/main/java/net/wurstclient/util/BlockPlacer.java
index da34b2b0b..9ac597b05 100644
--- a/src/main/java/net/wurstclient/util/BlockPlacer.java
+++ b/src/main/java/net/wurstclient/util/BlockPlacer.java
@@ -7,15 +7,15 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.block.BlockState;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Direction;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.math.Vec3i;
-import net.minecraft.util.shape.VoxelShape;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Vec3i;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IMinecraftClient;
 import net.wurstclient.util.BlockBreaker.BlockBreakingParams;
@@ -25,7 +25,7 @@ public enum BlockPlacer
 	;
 	
 	private static final WurstClient WURST = WurstClient.INSTANCE;
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	private static final IMinecraftClient IMC = WurstClient.IMC;
 	
 	public static boolean placeOneBlock(BlockPos pos)
@@ -56,7 +56,7 @@ public enum BlockPlacer
 		// if there is a replaceable block at the position, we need to place
 		// against the block itself instead of a neighbor
 		if(BlockUtils.canBeClicked(pos)
-			&& BlockUtils.getState(pos).isReplaceable())
+			&& BlockUtils.getState(pos).canBeReplaced())
 		{
 			// the parameters for this happen to be the same as for breaking
 			// the block, so we can just use BlockBreaker to get them
@@ -73,34 +73,34 @@ public enum BlockPlacer
 		}
 		
 		Direction[] sides = Direction.values();
-		Vec3d[] hitVecs = new Vec3d[sides.length];
+		Vec3[] hitVecs = new Vec3[sides.length];
 		
 		// get hit vectors for all usable sides
 		for(int i = 0; i < sides.length; i++)
 		{
-			BlockPos neighbor = pos.offset(sides[i]);
+			BlockPos neighbor = pos.relative(sides[i]);
 			BlockState state = BlockUtils.getState(neighbor);
-			VoxelShape shape = state.getOutlineShape(MC.world, neighbor);
+			VoxelShape shape = state.getShape(MC.level, neighbor);
 			
 			// if neighbor has no shape or is replaceable, it can't be used
-			if(shape.isEmpty() || state.isReplaceable())
+			if(shape.isEmpty() || state.canBeReplaced())
 				continue;
 			
-			Box box = shape.getBoundingBox();
-			Vec3d halfSize = new Vec3d(box.maxX - box.minX, box.maxY - box.minY,
-				box.maxZ - box.minZ).multiply(0.5);
-			Vec3d center = Vec3d.of(neighbor).add(box.getCenter());
+			AABB box = shape.bounds();
+			Vec3 halfSize = new Vec3(box.maxX - box.minX, box.maxY - box.minY,
+				box.maxZ - box.minZ).scale(0.5);
+			Vec3 center = Vec3.atLowerCornerOf(neighbor).add(box.getCenter());
 			
-			Vec3i dirVec = sides[i].getOpposite().getVector();
-			Vec3d relHitVec = new Vec3d(halfSize.x * dirVec.getX(),
+			Vec3i dirVec = sides[i].getOpposite().getUnitVec3i();
+			Vec3 relHitVec = new Vec3(halfSize.x * dirVec.getX(),
 				halfSize.y * dirVec.getY(), halfSize.z * dirVec.getZ());
 			hitVecs[i] = center.add(relHitVec);
 		}
 		
-		Vec3d eyesPos = RotationUtils.getEyesPos();
-		Vec3d posVec = Vec3d.ofCenter(pos);
+		Vec3 eyesPos = RotationUtils.getEyesPos();
+		Vec3 posVec = Vec3.atCenterOf(pos);
 		
-		double distanceSqToPosVec = eyesPos.squaredDistanceTo(posVec);
+		double distanceSqToPosVec = eyesPos.distanceToSqr(posVec);
 		double[] distancesSq = new double[sides.length];
 		boolean[] linesOfSight = new boolean[sides.length];
 		
@@ -114,7 +114,7 @@ public enum BlockPlacer
 				continue;
 			}
 			
-			distancesSq[i] = eyesPos.squaredDistanceTo(hitVecs[i]);
+			distancesSq[i] = eyesPos.distanceToSqr(hitVecs[i]);
 			
 			// to place against a neighbor in front of the block, we would
 			// have to place against that neighbor's rear face, which can't
@@ -154,13 +154,13 @@ public enum BlockPlacer
 		if(hitVecs[side.ordinal()] == null)
 			return null;
 		
-		return new BlockPlacingParams(pos.offset(side), side.getOpposite(),
+		return new BlockPlacingParams(pos.relative(side), side.getOpposite(),
 			hitVecs[side.ordinal()], distancesSq[side.ordinal()],
 			linesOfSight[side.ordinal()]);
 	}
 	
 	public static record BlockPlacingParams(BlockPos neighbor, Direction side,
-		Vec3d hitVec, double distanceSq, boolean lineOfSight)
+		Vec3 hitVec, double distanceSq, boolean lineOfSight)
 	{
 		public BlockHitResult toHitResult()
 		{
diff --git a/src/main/java/net/wurstclient/util/BlockUtils.java b/src/main/java/net/wurstclient/util/BlockUtils.java
index 923700c6a..0747879b1 100644
--- a/src/main/java/net/wurstclient/util/BlockUtils.java
+++ b/src/main/java/net/wurstclient/util/BlockUtils.java
@@ -10,35 +10,34 @@ package net.wurstclient.util;
 import java.util.ArrayList;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.block.Blocks;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.Entity;
-import net.minecraft.registry.Registries;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.InvalidIdentifierException;
-import net.minecraft.util.hit.BlockHitResult;
-import net.minecraft.util.hit.HitResult;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.util.shape.VoxelShape;
-import net.minecraft.util.shape.VoxelShapes;
-import net.minecraft.world.CollisionView;
-import net.minecraft.world.RaycastContext;
+import net.minecraft.ResourceLocationException;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.CollisionGetter;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
 import net.wurstclient.WurstClient;
 
 public enum BlockUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static BlockState getState(BlockPos pos)
 	{
-		return MC.world.getBlockState(pos);
+		return MC.level.getBlockState(pos);
 	}
 	
 	public static Block getBlock(BlockPos pos)
@@ -48,7 +47,7 @@ public enum BlockUtils
 	
 	public static int getId(BlockPos pos)
 	{
-		return Block.getRawIdFromState(getState(pos));
+		return Block.getId(getState(pos));
 	}
 	
 	public static String getName(BlockPos pos)
@@ -58,12 +57,13 @@ public enum BlockUtils
 	
 	public static String getName(Block block)
 	{
-		return Registries.BLOCK.getId(block).toString();
+		return BuiltInRegistries.BLOCK.getKey(block).toString();
 	}
 	
 	/**
 	 * @param name
-	 *            a String containing the block's name ({@link Identifier})
+	 *            a String containing the block's name
+	 *            ({@link ResourceLocation})
 	 * @return the requested block, or <code>minecraft:air</code> if the block
 	 *         doesn't exist.
 	 */
@@ -71,9 +71,10 @@ public enum BlockUtils
 	{
 		try
 		{
-			return Registries.BLOCK.get(Identifier.of(name));
+			return BuiltInRegistries.BLOCK
+				.getValue(ResourceLocation.parse(name));
 			
-		}catch(InvalidIdentifierException e)
+		}catch(ResourceLocationException e)
 		{
 			return Blocks.AIR;
 		}
@@ -81,7 +82,8 @@ public enum BlockUtils
 	
 	/**
 	 * @param nameOrId
-	 *            a String containing the block's name ({@link Identifier}) or
+	 *            a String containing the block's name
+	 *            ({@link ResourceLocation}) or
 	 *            numeric ID.
 	 * @return the requested block, or null if the block doesn't exist.
 	 */
@@ -89,7 +91,8 @@ public enum BlockUtils
 	{
 		if(MathUtils.isInteger(nameOrId))
 		{
-			BlockState state = Block.STATE_IDS.get(Integer.parseInt(nameOrId));
+			BlockState state =
+				Block.BLOCK_STATE_REGISTRY.byId(Integer.parseInt(nameOrId));
 			if(state == null)
 				return null;
 			
@@ -98,13 +101,13 @@ public enum BlockUtils
 		
 		try
 		{
-			Identifier id = Identifier.of(nameOrId);
-			if(!Registries.BLOCK.containsId(id))
+			ResourceLocation id = ResourceLocation.parse(nameOrId);
+			if(!BuiltInRegistries.BLOCK.containsKey(id))
 				return null;
 			
-			return Registries.BLOCK.get(id);
+			return BuiltInRegistries.BLOCK.getValue(id);
 			
-		}catch(InvalidIdentifierException e)
+		}catch(ResourceLocationException e)
 		{
 			return null;
 		}
@@ -112,54 +115,54 @@ public enum BlockUtils
 	
 	public static float getHardness(BlockPos pos)
 	{
-		return getState(pos).calcBlockBreakingDelta(MC.player, MC.world, pos);
+		return getState(pos).getDestroyProgress(MC.player, MC.level, pos);
 	}
 	
 	public static boolean isUnbreakable(BlockPos pos)
 	{
-		return getBlock(pos).getHardness() < 0;
+		return getBlock(pos).defaultDestroyTime() < 0;
 	}
 	
 	private static VoxelShape getOutlineShape(BlockPos pos)
 	{
-		return getState(pos).getOutlineShape(MC.world, pos);
+		return getState(pos).getShape(MC.level, pos);
 	}
 	
-	public static Box getBoundingBox(BlockPos pos)
+	public static AABB getBoundingBox(BlockPos pos)
 	{
-		return getOutlineShape(pos).getBoundingBox().offset(pos);
+		return getOutlineShape(pos).bounds().move(pos);
 	}
 	
 	public static boolean canBeClicked(BlockPos pos)
 	{
-		return getOutlineShape(pos) != VoxelShapes.empty();
+		return getOutlineShape(pos) != Shapes.empty();
 	}
 	
 	public static boolean isOpaqueFullCube(BlockPos pos)
 	{
-		return getState(pos).isOpaqueFullCube();
+		return getState(pos).isSolidRender();
 	}
 	
-	public static BlockHitResult raycast(Vec3d from, Vec3d to,
-		RaycastContext.FluidHandling fluidHandling)
+	public static BlockHitResult raycast(Vec3 from, Vec3 to,
+		ClipContext.Fluid fluidHandling)
 	{
-		RaycastContext context = new RaycastContext(from, to,
-			RaycastContext.ShapeType.COLLIDER, fluidHandling, MC.player);
+		ClipContext context = new ClipContext(from, to,
+			ClipContext.Block.COLLIDER, fluidHandling, MC.player);
 		
-		return MC.world.raycast(context);
+		return MC.level.clip(context);
 	}
 	
-	public static BlockHitResult raycast(Vec3d from, Vec3d to)
+	public static BlockHitResult raycast(Vec3 from, Vec3 to)
 	{
-		return raycast(from, to, RaycastContext.FluidHandling.NONE);
+		return raycast(from, to, ClipContext.Fluid.NONE);
 	}
 	
-	public static boolean hasLineOfSight(Vec3d from, Vec3d to)
+	public static boolean hasLineOfSight(Vec3 from, Vec3 to)
 	{
 		return raycast(from, to).getType() == HitResult.Type.MISS;
 	}
 	
-	public static boolean hasLineOfSight(Vec3d to)
+	public static boolean hasLineOfSight(Vec3 to)
 	{
 		return raycast(RotationUtils.getEyesPos(), to)
 			.getType() == HitResult.Type.MISS;
@@ -169,18 +172,19 @@ public enum BlockUtils
 	 * Returns a stream of all blocks that collide with the given box.
 	 *
 	 * <p>
-	 * Unlike {@link CollisionView#getBlockCollisions(Entity, Box)}, this method
+	 * Unlike {@link CollisionGetter#getBlockCollisions(Entity, AABB)}, this
+	 * method
 	 * breaks the voxel shapes down into their bounding boxes and only returns
 	 * those that actually intersect with the given box. It also assumes that
 	 * the entity is the player.
 	 */
-	public static Stream<Box> getBlockCollisions(Box box)
+	public static Stream<AABB> getBlockCollisions(AABB box)
 	{
 		Iterable<VoxelShape> blockCollisions =
-			MC.world.getBlockCollisions(MC.player, box);
+			MC.level.getBlockCollisions(MC.player, box);
 		
 		return StreamSupport.stream(blockCollisions.spliterator(), false)
-			.flatMap(shape -> shape.getBoundingBoxes().stream())
+			.flatMap(shape -> shape.toAabbs().stream())
 			.filter(shapeBox -> shapeBox.intersects(box));
 	}
 	
@@ -203,8 +207,8 @@ public enum BlockUtils
 	
 	public static ArrayList<BlockPos> getAllInBox(BlockPos center, int range)
 	{
-		return getAllInBox(center.add(-range, -range, -range),
-			center.add(range, range, range));
+		return getAllInBox(center.offset(-range, -range, -range),
+			center.offset(range, range, range));
 	}
 	
 	public static Stream<BlockPos> getAllInBoxStream(BlockPos from, BlockPos to)
@@ -248,7 +252,7 @@ public enum BlockUtils
 	
 	public static Stream<BlockPos> getAllInBoxStream(BlockPos center, int range)
 	{
-		return getAllInBoxStream(center.add(-range, -range, -range),
-			center.add(range, range, range));
+		return getAllInBoxStream(center.offset(-range, -range, -range),
+			center.offset(range, range, range));
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/BlockVertexCompiler.java b/src/main/java/net/wurstclient/util/BlockVertexCompiler.java
index 5433f83ba..f800188eb 100644
--- a/src/main/java/net/wurstclient/util/BlockVertexCompiler.java
+++ b/src/main/java/net/wurstclient/util/BlockVertexCompiler.java
@@ -12,8 +12,7 @@ import java.util.HashSet;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.Stream.Builder;
-
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 import net.wurstclient.hacks.SearchHack;
 
 /**
@@ -52,7 +51,7 @@ public enum BlockVertexCompiler
 	{
 		Builder<int[]> builder = Stream.<int[]> builder();
 		
-		if(!matchingBlocks.contains(pos.down()))
+		if(!matchingBlocks.contains(pos.below()))
 		{
 			builder.accept(getVertex(pos, 0, 0, 0));
 			builder.accept(getVertex(pos, 1, 0, 0));
@@ -60,7 +59,7 @@ public enum BlockVertexCompiler
 			builder.accept(getVertex(pos, 0, 0, 1));
 		}
 		
-		if(!matchingBlocks.contains(pos.up()))
+		if(!matchingBlocks.contains(pos.above()))
 		{
 			builder.accept(getVertex(pos, 0, 1, 0));
 			builder.accept(getVertex(pos, 0, 1, 1));
diff --git a/src/main/java/net/wurstclient/util/BufferWithLayer.java b/src/main/java/net/wurstclient/util/BufferWithLayer.java
index f7d239afe..6031198c7 100644
--- a/src/main/java/net/wurstclient/util/BufferWithLayer.java
+++ b/src/main/java/net/wurstclient/util/BufferWithLayer.java
@@ -7,44 +7,43 @@
  */
 package net.wurstclient.util;
 
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.function.Consumer;
-
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.util.math.MatrixStack;
+import net.minecraft.client.renderer.RenderType;
 
 public record BufferWithLayer(EasyVertexBuffer buffer,
-	RenderLayer.MultiPhase layer) implements AutoCloseable
+	RenderType.CompositeRenderType layer) implements AutoCloseable
 {
-	public static BufferWithLayer createAndUpload(RenderLayer.MultiPhase layer,
-		Consumer<VertexConsumer> callback)
+	public static BufferWithLayer createAndUpload(
+		RenderType.CompositeRenderType layer, Consumer<VertexConsumer> callback)
 	{
-		return new BufferWithLayer(EasyVertexBuffer.createAndUpload(
-			layer.getDrawMode(), layer.getVertexFormat(), callback), layer);
+		return new BufferWithLayer(EasyVertexBuffer
+			.createAndUpload(layer.mode(), layer.format(), callback), layer);
 	}
 	
-	public void draw(MatrixStack matrixStack)
+	public void draw(PoseStack matrixStack)
 	{
 		buffer.draw(matrixStack, layer);
 	}
 	
-	public void draw(MatrixStack matrixStack, float red, float green,
-		float blue, float alpha)
+	public void draw(PoseStack matrixStack, float red, float green, float blue,
+		float alpha)
 	{
 		buffer.draw(matrixStack, layer, red, green, blue, alpha);
 	}
 	
-	public void draw(MatrixStack matrixStack, float[] rgba)
+	public void draw(PoseStack matrixStack, float[] rgba)
 	{
 		buffer.draw(matrixStack, layer, rgba);
 	}
 	
-	public void draw(MatrixStack matrixStack, float[] rgb, float alpha)
+	public void draw(PoseStack matrixStack, float[] rgb, float alpha)
 	{
 		buffer.draw(matrixStack, layer, rgb, alpha);
 	}
 	
-	public void draw(MatrixStack matrixStack, int argb)
+	public void draw(PoseStack matrixStack, int argb)
 	{
 		buffer.draw(matrixStack, layer, argb);
 	}
diff --git a/src/main/java/net/wurstclient/util/ChatUtils.java b/src/main/java/net/wurstclient/util/ChatUtils.java
index 3348f5e9f..837509152 100644
--- a/src/main/java/net/wurstclient/util/ChatUtils.java
+++ b/src/main/java/net/wurstclient/util/ChatUtils.java
@@ -9,22 +9,21 @@ package net.wurstclient.util;
 
 import java.util.List;
 import java.util.StringJoiner;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.gui.hud.ChatHud;
-import net.minecraft.client.gui.hud.ChatHudLine;
-import net.minecraft.text.MutableText;
-import net.minecraft.text.OrderedText;
-import net.minecraft.text.StringVisitable;
-import net.minecraft.text.Style;
-import net.minecraft.text.Text;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.components.ChatComponent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.FormattedText;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.util.FormattedCharSequence;
 import net.wurstclient.WurstClient;
 
 public enum ChatUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static final String WURST_PREFIX =
 		"\u00a7c[\u00a76Wurst\u00a7c]\u00a7r ";
@@ -42,19 +41,19 @@ public enum ChatUtils
 		ChatUtils.enabled = enabled;
 	}
 	
-	public static void component(Text component)
+	public static void component(Component component)
 	{
 		if(!enabled)
 			return;
 		
-		ChatHud chatHud = MC.inGameHud.getChatHud();
-		MutableText prefix = Text.literal(WURST_PREFIX);
+		ChatComponent chatHud = MC.gui.getChat();
+		MutableComponent prefix = Component.literal(WURST_PREFIX);
 		chatHud.addMessage(prefix.append(component));
 	}
 	
 	public static void message(String message)
 	{
-		component(Text.literal(message));
+		component(Component.literal(message));
 	}
 	
 	public static void warning(String message)
@@ -72,12 +71,12 @@ public enum ChatUtils
 		message(SYNTAX_ERROR_PREFIX + message);
 	}
 	
-	public static String getAsString(ChatHudLine.Visible visible)
+	public static String getAsString(GuiMessage.Line visible)
 	{
 		return getAsString(visible.content());
 	}
 	
-	public static String getAsString(OrderedText text)
+	public static String getAsString(FormattedCharSequence text)
 	{
 		JustGiveMeTheStringVisitor visitor = new JustGiveMeTheStringVisitor();
 		text.accept(visitor);
@@ -91,11 +90,11 @@ public enum ChatUtils
 	
 	public static final String wrapText(String text, int width, Style style)
 	{
-		List<StringVisitable> lines = MC.textRenderer.getTextHandler()
-			.wrapLines(text, width, Style.EMPTY);
+		List<FormattedText> lines =
+			MC.font.getSplitter().splitLines(text, width, Style.EMPTY);
 		
 		StringJoiner joiner = new StringJoiner("\n");
-		lines.stream().map(StringVisitable::getString)
+		lines.stream().map(FormattedText::getString)
 			.forEach(s -> joiner.add(s));
 		
 		return joiner.toString();
diff --git a/src/main/java/net/wurstclient/util/CmdUtils.java b/src/main/java/net/wurstclient/util/CmdUtils.java
index 6ebb4d88f..f1ad930f2 100644
--- a/src/main/java/net/wurstclient/util/CmdUtils.java
+++ b/src/main/java/net/wurstclient/util/CmdUtils.java
@@ -8,11 +8,10 @@
 package net.wurstclient.util;
 
 import java.util.stream.Stream;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
+import net.minecraft.client.Minecraft;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.Feature;
 import net.wurstclient.WurstClient;
 import net.wurstclient.command.CmdError;
@@ -23,7 +22,7 @@ public enum CmdUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static Feature findFeature(String name) throws CmdError
 	{
@@ -65,8 +64,8 @@ public enum CmdUtils
 	
 	public static void giveItem(ItemStack stack) throws CmdError
 	{
-		PlayerInventory inventory = MC.player.getInventory();
-		int slot = inventory.getEmptySlot();
+		Inventory inventory = MC.player.getInventory();
+		int slot = inventory.getFreeSlot();
 		if(slot < 0)
 			throw new CmdError("Cannot give item. Your inventory is full.");
 		
diff --git a/src/main/java/net/wurstclient/util/ColorUtils.java b/src/main/java/net/wurstclient/util/ColorUtils.java
index b25b3334d..eb0ee74ec 100644
--- a/src/main/java/net/wurstclient/util/ColorUtils.java
+++ b/src/main/java/net/wurstclient/util/ColorUtils.java
@@ -8,8 +8,7 @@
 package net.wurstclient.util;
 
 import java.awt.Color;
-
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.wurstclient.util.json.JsonException;
 
 public enum ColorUtils
@@ -38,7 +37,7 @@ public enum ColorUtils
 			{
 				String channelString = s.substring(i * 2 + 1, i * 2 + 3);
 				int channel = Integer.parseUnsignedInt(channelString, 16);
-				rgb[i] = MathHelper.clamp(channel, 0, 255);
+				rgb[i] = Mth.clamp(channel, 0, 255);
 			}
 			
 		}catch(NumberFormatException e)
@@ -72,7 +71,7 @@ public enum ColorUtils
 			for(int i = 0; i < rgb.length; i++)
 			{
 				int channel = Integer.parseInt(rgbStrings[i]);
-				rgb[i] = MathHelper.clamp(channel, 0, 255);
+				rgb[i] = Mth.clamp(channel, 0, 255);
 			}
 			
 		}catch(NumberFormatException e)
diff --git a/src/main/java/net/wurstclient/util/CustomQuadRenderState.java b/src/main/java/net/wurstclient/util/CustomQuadRenderState.java
index 7d5e151b0..b71028afb 100644
--- a/src/main/java/net/wurstclient/util/CustomQuadRenderState.java
+++ b/src/main/java/net/wurstclient/util/CustomQuadRenderState.java
@@ -11,57 +11,57 @@ import org.jetbrains.annotations.Nullable;
 import org.joml.Matrix3x2f;
 
 import com.mojang.blaze3d.pipeline.RenderPipeline;
-
-import net.minecraft.client.gl.RenderPipelines;
-import net.minecraft.client.gui.ScreenRect;
-import net.minecraft.client.gui.render.state.SimpleGuiElementRenderState;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.texture.TextureSetup;
+import com.mojang.blaze3d.vertex.VertexConsumer;
+import net.minecraft.client.gui.navigation.ScreenRectangle;
+import net.minecraft.client.gui.render.TextureSetup;
+import net.minecraft.client.gui.render.state.GuiElementRenderState;
+import net.minecraft.client.renderer.RenderPipelines;
 
 public record CustomQuadRenderState(RenderPipeline pipeline,
 	TextureSetup textureSetup, Matrix3x2f pose, float x1, float y1, float x2,
 	float y2, float x3, float y3, float x4, float y4, int color1, int color2,
-	int color3, int color4, @Nullable ScreenRect scissorArea,
-	@Nullable ScreenRect bounds) implements SimpleGuiElementRenderState
+	int color3, int color4, @Nullable ScreenRectangle scissorArea,
+	@Nullable ScreenRectangle bounds) implements GuiElementRenderState
 {
 	public CustomQuadRenderState(Matrix3x2f pose, float x1, float y1, float x2,
 		float y2, float x3, float y3, float x4, float y4, int color1,
-		int color2, int color3, int color4, @Nullable ScreenRect scissorArea)
+		int color2, int color3, int color4,
+		@Nullable ScreenRectangle scissorArea)
 	{
-		this(RenderPipelines.GUI, TextureSetup.empty(), pose, x1, y1, x2, y2,
-			x3, y3, x4, y4, color1, color2, color3, color4, scissorArea,
+		this(RenderPipelines.GUI, TextureSetup.noTexture(), pose, x1, y1, x2,
+			y2, x3, y3, x4, y4, color1, color2, color3, color4, scissorArea,
 			createBounds(x1, y1, x2, y2, x3, y3, x4, y4, pose, scissorArea));
 	}
 	
 	public CustomQuadRenderState(Matrix3x2f pose, float x1, float y1, float x2,
 		float y2, float x3, float y3, float x4, float y4, int color,
-		@Nullable ScreenRect scissorArea)
+		@Nullable ScreenRectangle scissorArea)
 	{
 		this(pose, x1, y1, x2, y2, x3, y3, x4, y4, color, color, color, color,
 			scissorArea);
 	}
 	
 	@Override
-	public void setupVertices(VertexConsumer vertices)
+	public void buildVertices(VertexConsumer vertices)
 	{
-		vertices.vertex(pose(), x1(), y1()).color(color1());
-		vertices.vertex(pose(), x2(), y2()).color(color2());
-		vertices.vertex(pose(), x3(), y3()).color(color3());
-		vertices.vertex(pose(), x4(), y4()).color(color4());
+		vertices.addVertexWith2DPose(pose(), x1(), y1()).setColor(color1());
+		vertices.addVertexWith2DPose(pose(), x2(), y2()).setColor(color2());
+		vertices.addVertexWith2DPose(pose(), x3(), y3()).setColor(color3());
+		vertices.addVertexWith2DPose(pose(), x4(), y4()).setColor(color4());
 	}
 	
 	@Nullable
-	private static ScreenRect createBounds(float x1, float y1, float x2,
+	private static ScreenRectangle createBounds(float x1, float y1, float x2,
 		float y2, float x3, float y3, float x4, float y4, Matrix3x2f pose,
-		@Nullable ScreenRect scissorArea)
+		@Nullable ScreenRectangle scissorArea)
 	{
 		float minX = Math.min(x1, Math.min(x2, Math.min(x3, x4)));
 		float maxX = Math.max(x1, Math.max(x2, Math.max(x3, x4)));
 		float minY = Math.min(y1, Math.min(y2, Math.min(y3, y4)));
 		float maxY = Math.max(y1, Math.max(y2, Math.max(y3, y4)));
 		
-		ScreenRect screenRect = new ScreenRect((int)minX, (int)minY,
-			(int)(maxX - minX), (int)(maxY - minY)).transformEachVertex(pose);
+		ScreenRectangle screenRect = new ScreenRectangle((int)minX, (int)minY,
+			(int)(maxX - minX), (int)(maxY - minY)).transformMaxBounds(pose);
 		return scissorArea != null ? scissorArea.intersection(screenRect)
 			: screenRect;
 	}
diff --git a/src/main/java/net/wurstclient/util/EasyVertexBuffer.java b/src/main/java/net/wurstclient/util/EasyVertexBuffer.java
index 551e04183..7d13ead1b 100644
--- a/src/main/java/net/wurstclient/util/EasyVertexBuffer.java
+++ b/src/main/java/net/wurstclient/util/EasyVertexBuffer.java
@@ -18,19 +18,18 @@ import org.joml.Vector4f;
 import com.mojang.blaze3d.buffers.GpuBuffer;
 import com.mojang.blaze3d.buffers.GpuBufferSlice;
 import com.mojang.blaze3d.pipeline.RenderPipeline;
+import com.mojang.blaze3d.pipeline.RenderTarget;
 import com.mojang.blaze3d.systems.RenderPass;
 import com.mojang.blaze3d.systems.RenderSystem;
+import com.mojang.blaze3d.vertex.BufferBuilder;
+import com.mojang.blaze3d.vertex.MeshData;
+import com.mojang.blaze3d.vertex.MeshData.DrawState;
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.Tesselator;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import com.mojang.blaze3d.vertex.VertexFormat;
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.client.gl.Framebuffer;
-import net.minecraft.client.render.BufferBuilder;
-import net.minecraft.client.render.BuiltBuffer;
-import net.minecraft.client.render.BuiltBuffer.DrawParameters;
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.Tessellator;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.util.math.MatrixStack;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
+import net.minecraft.client.renderer.RenderType;
 import net.wurstclient.nicewurst.NiceWurstModule;
 
 /**
@@ -39,21 +38,21 @@ import net.wurstclient.nicewurst.NiceWurstModule;
  */
 public final class EasyVertexBuffer implements AutoCloseable
 {
-	private final RenderSystem.ShapeIndexBuffer shapeIndexBuffer;
+	private final RenderSystem.AutoStorageIndexBuffer shapeIndexBuffer;
 	private final GpuBuffer vertexBuffer;
 	private final int indexCount;
 	
 	/**
 	 * Drop-in replacement for {@code VertexBuffer.createAndUpload()}.
 	 */
-	public static EasyVertexBuffer createAndUpload(DrawMode drawMode,
+	public static EasyVertexBuffer createAndUpload(Mode drawMode,
 		VertexFormat format, Consumer<VertexConsumer> callback)
 	{
 		BufferBuilder bufferBuilder =
-			Tessellator.getInstance().begin(drawMode, format);
+			Tesselator.getInstance().begin(drawMode, format);
 		callback.accept(bufferBuilder);
 		
-		try(BuiltBuffer buffer = bufferBuilder.endNullable())
+		try(MeshData buffer = bufferBuilder.build())
 		{
 			if(buffer == null)
 				return new EasyVertexBuffer(drawMode);
@@ -62,30 +61,31 @@ public final class EasyVertexBuffer implements AutoCloseable
 		}
 	}
 	
-	private EasyVertexBuffer(BuiltBuffer buffer, DrawMode drawMode)
+	private EasyVertexBuffer(MeshData buffer, Mode drawMode)
 	{
-		DrawParameters drawParams = buffer.getDrawParameters();
+		DrawState drawParams = buffer.drawState();
 		shapeIndexBuffer = RenderSystem.getSequentialBuffer(drawParams.mode());
 		indexCount = drawParams.indexCount();
 		
-		vertexBuffer =
-			RenderSystem.getDevice().createBuffer(null, 40, buffer.getBuffer());
+		vertexBuffer = RenderSystem.getDevice().createBuffer(null, 40,
+			buffer.vertexBuffer());
 	}
 	
-	private EasyVertexBuffer(DrawMode drawMode)
+	private EasyVertexBuffer(Mode drawMode)
 	{
 		shapeIndexBuffer = null;
 		indexCount = 0;
 		vertexBuffer = null;
 	}
 	
-	public void draw(MatrixStack matrixStack, RenderLayer.MultiPhase layer)
+	public void draw(PoseStack matrixStack,
+		RenderType.CompositeRenderType layer)
 	{
 		draw(matrixStack, layer, 1, 1, 1, 1);
 	}
 	
-	public void draw(MatrixStack matrixStack, RenderLayer.MultiPhase layer,
-		int argb)
+	public void draw(PoseStack matrixStack,
+		RenderType.CompositeRenderType layer, int argb)
 	{
 		float alpha = (argb >> 24 & 0xFF) / 255F;
 		float red = (argb >> 16 & 0xFF) / 255F;
@@ -94,57 +94,59 @@ public final class EasyVertexBuffer implements AutoCloseable
 		draw(matrixStack, layer, red, green, blue, alpha);
 	}
 	
-	public void draw(MatrixStack matrixStack, RenderLayer.MultiPhase layer,
-		float[] rgba)
+	public void draw(PoseStack matrixStack,
+		RenderType.CompositeRenderType layer, float[] rgba)
 	{
 		draw(matrixStack, layer, rgba[0], rgba[1], rgba[2], rgba[3]);
 	}
 	
-	public void draw(MatrixStack matrixStack, RenderLayer.MultiPhase layer,
-		float[] rgb, float alpha)
+	public void draw(PoseStack matrixStack,
+		RenderType.CompositeRenderType layer, float[] rgb, float alpha)
 	{
 		draw(matrixStack, layer, rgb[0], rgb[1], rgb[2], alpha);
 	}
 	
-	public void draw(MatrixStack matrixStack, RenderLayer.MultiPhase layer,
-		float red, float green, float blue, float alpha)
+	public void draw(PoseStack matrixStack,
+		RenderType.CompositeRenderType layer, float red, float green,
+		float blue, float alpha)
 	{
 		if(vertexBuffer == null)
 			return;
 		
-		RenderLayer.MultiPhase effectiveLayer =
+		RenderType.CompositeRenderType effectiveLayer =
 			NiceWurstModule.enforceDepthTest(layer);
 		
 		Matrix4fStack modelViewStack = RenderSystem.getModelViewStack();
 		modelViewStack.pushMatrix();
-		modelViewStack.mul(matrixStack.peek().getPositionMatrix());
+		modelViewStack.mul(matrixStack.last().pose());
 		
-		effectiveLayer.startDrawing();
-		GpuBufferSlice gpuBufferSlice = RenderSystem.getDynamicUniforms().write(
-			RenderSystem.getModelViewMatrix(),
-			new Vector4f(red, green, blue, alpha), new Vector3f(),
-			RenderSystem.getTextureMatrix(), RenderSystem.getShaderLineWidth());
+		effectiveLayer.setupRenderState();
+		GpuBufferSlice gpuBufferSlice = RenderSystem.getDynamicUniforms()
+			.writeTransform(RenderSystem.getModelViewMatrix(),
+				new Vector4f(red, green, blue, alpha), new Vector3f(),
+				RenderSystem.getTextureMatrix(),
+				RenderSystem.getShaderLineWidth());
 		
-		Framebuffer framebuffer = effectiveLayer.phases.target.get();
-		RenderPipeline pipeline = effectiveLayer.pipeline;
-		GpuBuffer indexBuffer = shapeIndexBuffer.getIndexBuffer(indexCount);
+		RenderTarget framebuffer =
+			effectiveLayer.state.outputState.getRenderTarget();
+		RenderPipeline pipeline = effectiveLayer.renderPipeline;
+		GpuBuffer indexBuffer = shapeIndexBuffer.getBuffer(indexCount);
 		
 		try(RenderPass renderPass =
 			RenderSystem.getDevice().createCommandEncoder().createRenderPass(
-				() -> "something from Wurst",
-				framebuffer.getColorAttachmentView(), OptionalInt.empty(),
-				framebuffer.getDepthAttachmentView(), OptionalDouble.empty()))
+				() -> "something from Wurst", framebuffer.getColorTextureView(),
+				OptionalInt.empty(), framebuffer.getDepthTextureView(),
+				OptionalDouble.empty()))
 		{
 			renderPass.setPipeline(pipeline);
 			RenderSystem.bindDefaultUniforms(renderPass);
 			renderPass.setUniform("DynamicTransforms", gpuBufferSlice);
 			renderPass.setVertexBuffer(0, vertexBuffer);
-			renderPass.setIndexBuffer(indexBuffer,
-				shapeIndexBuffer.getIndexType());
+			renderPass.setIndexBuffer(indexBuffer, shapeIndexBuffer.type());
 			renderPass.drawIndexed(0, 0, indexCount, 1);
 		}
 		
-		effectiveLayer.endDrawing();
+		effectiveLayer.clearRenderState();
 		modelViewStack.popMatrix();
 	}
 	
diff --git a/src/main/java/net/wurstclient/util/EntityUtils.java b/src/main/java/net/wurstclient/util/EntityUtils.java
index ff3ec9714..723e2de41 100644
--- a/src/main/java/net/wurstclient/util/EntityUtils.java
+++ b/src/main/java/net/wurstclient/util/EntityUtils.java
@@ -10,16 +10,15 @@ package net.wurstclient.util;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.LivingEntity;
-import net.minecraft.entity.decoration.EndCrystalEntity;
-import net.minecraft.entity.passive.AnimalEntity;
-import net.minecraft.entity.projectile.ShulkerBulletEntity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.boss.enderdragon.EndCrystal;
+import net.minecraft.world.entity.projectile.ShulkerBullet;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 
 public enum EntityUtils
@@ -27,30 +26,31 @@ public enum EntityUtils
 	;
 	
 	protected static final WurstClient WURST = WurstClient.INSTANCE;
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	
 	public static Stream<Entity> getAttackableEntities()
 	{
-		return StreamSupport.stream(MC.world.getEntities().spliterator(), true)
+		return StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
 			.filter(IS_ATTACKABLE);
 	}
 	
-	public static final Predicate<Entity> IS_ATTACKABLE = e -> e != null
-		&& !e.isRemoved()
-		&& (e instanceof LivingEntity && ((LivingEntity)e).getHealth() > 0
-			|| e instanceof EndCrystalEntity
-			|| e instanceof ShulkerBulletEntity)
-		&& e != MC.player && !(e instanceof FakePlayerEntity)
-		&& !WURST.getFriends().isFriend(e);
+	public static final Predicate<Entity> IS_ATTACKABLE =
+		e -> e != null && !e.isRemoved()
+			&& (e instanceof LivingEntity && ((LivingEntity)e).getHealth() > 0
+				|| e instanceof EndCrystal || e instanceof ShulkerBullet)
+			&& e != MC.player && !(e instanceof FakePlayerEntity)
+			&& !WURST.getFriends().isFriend(e);
 	
-	public static Stream<AnimalEntity> getValidAnimals()
+	public static Stream<Animal> getValidAnimals()
 	{
-		return StreamSupport.stream(MC.world.getEntities().spliterator(), true)
-			.filter(AnimalEntity.class::isInstance).map(e -> (AnimalEntity)e)
+		return StreamSupport
+			.stream(MC.level.entitiesForRendering().spliterator(), true)
+			.filter(Animal.class::isInstance).map(e -> (Animal)e)
 			.filter(IS_VALID_ANIMAL);
 	}
 	
-	public static final Predicate<AnimalEntity> IS_VALID_ANIMAL =
+	public static final Predicate<Animal> IS_VALID_ANIMAL =
 		a -> a != null && !a.isRemoved() && a.getHealth() > 0;
 	
 	/**
@@ -63,17 +63,17 @@ public enum EntityUtils
 	 * current tick position directly would cause animations to look choppy
 	 * because that position is only updated 20 times per second.
 	 */
-	public static Vec3d getLerpedPos(Entity e, float partialTicks)
+	public static Vec3 getLerpedPos(Entity e, float partialTicks)
 	{
 		// When an entity is removed, it stops moving and its lastRenderX/Y/Z
 		// values are no longer updated.
 		if(e.isRemoved())
-			return e.getEntityPos();
+			return e.position();
 		
-		double x = MathHelper.lerp(partialTicks, e.lastRenderX, e.getX());
-		double y = MathHelper.lerp(partialTicks, e.lastRenderY, e.getY());
-		double z = MathHelper.lerp(partialTicks, e.lastRenderZ, e.getZ());
-		return new Vec3d(x, y, z);
+		double x = Mth.lerp(partialTicks, e.xOld, e.getX());
+		double y = Mth.lerp(partialTicks, e.yOld, e.getY());
+		double z = Mth.lerp(partialTicks, e.zOld, e.getZ());
+		return new Vec3(x, y, z);
 	}
 	
 	/**
@@ -87,14 +87,14 @@ public enum EntityUtils
 	 * because that box, just like the position, is only updated 20 times per
 	 * second.
 	 */
-	public static Box getLerpedBox(Entity e, float partialTicks)
+	public static AABB getLerpedBox(Entity e, float partialTicks)
 	{
 		// When an entity is removed, it stops moving and its lastRenderX/Y/Z
 		// values are no longer updated.
 		if(e.isRemoved())
 			return e.getBoundingBox();
 		
-		Vec3d offset = getLerpedPos(e, partialTicks).subtract(e.getEntityPos());
-		return e.getBoundingBox().offset(offset);
+		Vec3 offset = getLerpedPos(e, partialTicks).subtract(e.position());
+		return e.getBoundingBox().move(offset);
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/FakePlayerEntity.java b/src/main/java/net/wurstclient/util/FakePlayerEntity.java
index 49541fcde..910673d1f 100644
--- a/src/main/java/net/wurstclient/util/FakePlayerEntity.java
+++ b/src/main/java/net/wurstclient/util/FakePlayerEntity.java
@@ -10,26 +10,25 @@ package net.wurstclient.util;
 import java.util.UUID;
 
 import org.jetbrains.annotations.Nullable;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.client.network.OtherClientPlayerEntity;
-import net.minecraft.client.network.PlayerListEntry;
-import net.minecraft.client.world.ClientWorld;
-import net.minecraft.entity.Entity;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.multiplayer.PlayerInfo;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.client.player.RemotePlayer;
+import net.minecraft.world.entity.Entity;
 import net.wurstclient.WurstClient;
 
-public class FakePlayerEntity extends OtherClientPlayerEntity
+public class FakePlayerEntity extends RemotePlayer
 {
-	private final ClientPlayerEntity player = WurstClient.MC.player;
-	private final ClientWorld world = WurstClient.MC.world;
-	private PlayerListEntry playerListEntry;
+	private final LocalPlayer player = WurstClient.MC.player;
+	private final ClientLevel world = WurstClient.MC.level;
+	private PlayerInfo playerListEntry;
 	
 	public FakePlayerEntity()
 	{
-		super(WurstClient.MC.world, WurstClient.MC.player.getGameProfile());
-		setUuid(UUID.randomUUID());
-		copyPositionAndRotation(player);
+		super(WurstClient.MC.level, WurstClient.MC.player.getGameProfile());
+		setUUID(UUID.randomUUID());
+		copyPosition(player);
 		
 		copyInventory();
 		copyRotation();
@@ -38,30 +37,30 @@ public class FakePlayerEntity extends OtherClientPlayerEntity
 	}
 	
 	@Override
-	protected @Nullable PlayerListEntry getPlayerListEntry()
+	protected @Nullable PlayerInfo getPlayerInfo()
 	{
 		if(playerListEntry == null)
-			playerListEntry = MinecraftClient.getInstance().getNetworkHandler()
-				.getPlayerListEntry(getGameProfile().id());
+			playerListEntry = Minecraft.getInstance().getConnection()
+				.getPlayerInfo(getGameProfile().id());
 		
 		return playerListEntry;
 	}
 	
 	@Override
-	protected void pushAway(Entity entity)
+	protected void doPush(Entity entity)
 	{
 		// Prevents pushing the real player away
 	}
 	
 	private void copyInventory()
 	{
-		getInventory().clone(player.getInventory());
+		getInventory().replaceWith(player.getInventory());
 	}
 	
 	private void copyRotation()
 	{
-		headYaw = player.headYaw;
-		bodyYaw = player.bodyYaw;
+		yHeadRot = player.yHeadRot;
+		yBodyRot = player.yBodyRot;
 	}
 	
 	private void spawn()
@@ -76,7 +75,6 @@ public class FakePlayerEntity extends OtherClientPlayerEntity
 	
 	public void resetPlayerPosition()
 	{
-		player.refreshPositionAndAngles(getX(), getY(), getZ(), getYaw(),
-			getPitch());
+		player.snapTo(getX(), getY(), getZ(), getYRot(), getXRot());
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/InteractionSimulator.java b/src/main/java/net/wurstclient/util/InteractionSimulator.java
index 4ee8d8709..cb3a7265d 100644
--- a/src/main/java/net/wurstclient/util/InteractionSimulator.java
+++ b/src/main/java/net/wurstclient/util/InteractionSimulator.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.Hand;
-import net.minecraft.util.hit.BlockHitResult;
+import net.minecraft.client.Minecraft;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.BlockHitResult;
 import net.wurstclient.WurstClient;
 import net.wurstclient.settings.SwingHandSetting.SwingHand;
 
@@ -20,7 +20,7 @@ import net.wurstclient.settings.SwingHandSetting.SwingHand;
  * without sacrificing anti-cheat resistance or customizability.
  *
  * <p>
- * Accurately replicates {@link MinecraftClient#doItemUse()} as of 25w02a
+ * Accurately replicates {@link Minecraft#startUseItem()} as of 25w02a
  * (1.21.5), while being much easier to read and adding convenient ways to
  * change parts of the behavior.
  */
@@ -28,7 +28,7 @@ public enum InteractionSimulator
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	/**
 	 * @see #rightClickBlock(BlockHitResult, SwingHand)
@@ -45,7 +45,8 @@ public enum InteractionSimulator
 	 * <p>
 	 * This method automatically decides which hand to use in order to match
 	 * vanilla behavior as closely as possible. If you need to force a specific
-	 * hand, use {@link #rightClickBlock(BlockHitResult, Hand, SwingHand)}
+	 * hand, use
+	 * {@link #rightClickBlock(BlockHitResult, InteractionHand, SwingHand)}
 	 * instead.
 	 *
 	 * <p>
@@ -64,10 +65,10 @@ public enum InteractionSimulator
 	public static void rightClickBlock(BlockHitResult hitResult,
 		SwingHand swing)
 	{
-		for(Hand hand : Hand.values())
+		for(InteractionHand hand : InteractionHand.values())
 		{
-			ItemStack stack = MC.player.getStackInHand(hand);
-			if(!stack.isItemEnabled(MC.world.getEnabledFeatures()))
+			ItemStack stack = MC.player.getItemInHand(hand);
+			if(!stack.isItemEnabled(MC.level.enabledFeatures()))
 				return;
 			
 			if(interactBlockAndSwing(hitResult, swing, hand, stack))
@@ -79,9 +80,10 @@ public enum InteractionSimulator
 	}
 	
 	/**
-	 * @see #rightClickBlock(BlockHitResult, Hand, SwingHand)
+	 * @see #rightClickBlock(BlockHitResult, InteractionHand, SwingHand)
 	 */
-	public static void rightClickBlock(BlockHitResult hitResult, Hand hand)
+	public static void rightClickBlock(BlockHitResult hitResult,
+		InteractionHand hand)
 	{
 		rightClickBlock(hitResult, hand, SwingHand.CLIENT);
 	}
@@ -95,10 +97,10 @@ public enum InteractionSimulator
 	 * possible in vanilla. For a more realistic right-click simulation, use
 	 * {@link #rightClickBlock(BlockHitResult, SwingHand)} instead.
 	 */
-	public static void rightClickBlock(BlockHitResult hitResult, Hand hand,
-		SwingHand swing)
+	public static void rightClickBlock(BlockHitResult hitResult,
+		InteractionHand hand, SwingHand swing)
 	{
-		ItemStack stack = MC.player.getStackInHand(hand);
+		ItemStack stack = MC.player.getItemInHand(hand);
 		if(interactBlockAndSwing(hitResult, swing, hand, stack))
 			return;
 		
@@ -113,26 +115,26 @@ public enum InteractionSimulator
 	 *         any further block/item interactions
 	 */
 	private static boolean interactBlockAndSwing(BlockHitResult hitResult,
-		SwingHand swing, Hand hand, ItemStack stack)
+		SwingHand swing, InteractionHand hand, ItemStack stack)
 	{
 		// save old stack size and call interactBlock()
 		int oldCount = stack.getCount();
-		ActionResult result =
-			MC.interactionManager.interactBlock(MC.player, hand, hitResult);
+		InteractionResult result =
+			MC.gameMode.useItemOn(MC.player, hand, hitResult);
 		
 		// swing hand and reset equip animation
-		if(result instanceof ActionResult.Success success
-			&& success.swingSource() == ActionResult.SwingSource.CLIENT)
+		if(result instanceof InteractionResult.Success success
+			&& success.swingSource() == InteractionResult.SwingSource.CLIENT)
 		{
 			swing.swing(hand);
 			
 			if(!stack.isEmpty() && (stack.getCount() != oldCount
-				|| MC.player.isInCreativeMode()))
-				MC.gameRenderer.firstPersonRenderer.resetEquipProgress(hand);
+				|| MC.player.hasInfiniteMaterials()))
+				MC.gameRenderer.itemInHandRenderer.itemUsed(hand);
 		}
 		
-		return result instanceof ActionResult.Success
-			|| result instanceof ActionResult.Fail;
+		return result instanceof InteractionResult.Success
+			|| result instanceof InteractionResult.Fail;
 	}
 	
 	/**
@@ -143,25 +145,24 @@ public enum InteractionSimulator
 	 *         any further block/item interactions
 	 */
 	private static boolean interactItemAndSwing(ItemStack stack,
-		SwingHand swing, Hand hand)
+		SwingHand swing, InteractionHand hand)
 	{
 		// pass if hand is empty
 		if(stack.isEmpty())
 			return false;
 		
 		// call interactItem()
-		ActionResult result =
-			MC.interactionManager.interactItem(MC.player, hand);
+		InteractionResult result = MC.gameMode.useItem(MC.player, hand);
 		
-		if(!(result instanceof ActionResult.Success success))
+		if(!(result instanceof InteractionResult.Success success))
 			return false;
 		
 		// swing hand
-		if(success.swingSource() == ActionResult.SwingSource.CLIENT)
+		if(success.swingSource() == InteractionResult.SwingSource.CLIENT)
 			swing.swing(hand);
 		
 		// reset equip animation
-		MC.gameRenderer.firstPersonRenderer.resetEquipProgress(hand);
+		MC.gameRenderer.itemInHandRenderer.itemUsed(hand);
 		return true;
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/InventoryUtils.java b/src/main/java/net/wurstclient/util/InventoryUtils.java
index 9e448a3bb..a3a843bbe 100644
--- a/src/main/java/net/wurstclient/util/InventoryUtils.java
+++ b/src/main/java/net/wurstclient/util/InventoryUtils.java
@@ -9,12 +9,11 @@ package net.wurstclient.util;
 
 import java.util.function.Predicate;
 import java.util.stream.IntStream;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.entity.player.PlayerInventory;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.network.packet.c2s.play.CreativeInventoryActionC2SPacket;
+import net.minecraft.client.Minecraft;
+import net.minecraft.network.protocol.game.ServerboundSetCreativeModeSlotPacket;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IClientPlayerInteractionManager;
 import net.wurstclient.mixinterface.IMinecraftClient;
@@ -23,22 +22,22 @@ public enum InventoryUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	private static final IMinecraftClient IMC = WurstClient.IMC;
 	
 	public static int indexOf(Item item)
 	{
-		return indexOf(stack -> stack.isOf(item), 36, false);
+		return indexOf(stack -> stack.is(item), 36, false);
 	}
 	
 	public static int indexOf(Item item, int maxInvSlot)
 	{
-		return indexOf(stack -> stack.isOf(item), maxInvSlot, false);
+		return indexOf(stack -> stack.is(item), maxInvSlot, false);
 	}
 	
 	public static int indexOf(Item item, int maxInvSlot, boolean includeOffhand)
 	{
-		return indexOf(stack -> stack.isOf(item), maxInvSlot, includeOffhand);
+		return indexOf(stack -> stack.is(item), maxInvSlot, includeOffhand);
 	}
 	
 	public static int indexOf(Predicate<ItemStack> predicate)
@@ -75,17 +74,17 @@ public enum InventoryUtils
 	
 	public static int count(Item item)
 	{
-		return count(stack -> stack.isOf(item), 36, false);
+		return count(stack -> stack.is(item), 36, false);
 	}
 	
 	public static int count(Item item, int maxInvSlot)
 	{
-		return count(stack -> stack.isOf(item), maxInvSlot, false);
+		return count(stack -> stack.is(item), maxInvSlot, false);
 	}
 	
 	public static int count(Item item, int maxInvSlot, boolean includeOffhand)
 	{
-		return count(stack -> stack.isOf(item), maxInvSlot, includeOffhand);
+		return count(stack -> stack.is(item), maxInvSlot, includeOffhand);
 	}
 	
 	public static int count(Predicate<ItemStack> predicate)
@@ -118,16 +117,16 @@ public enum InventoryUtils
 	public static int count(Predicate<ItemStack> predicate, int maxInvSlot,
 		boolean includeOffhand)
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		
 		return getMatchingSlots(predicate, maxInvSlot, includeOffhand)
-			.map(slot -> inventory.getStack(slot).getCount()).sum();
+			.map(slot -> inventory.getItem(slot).getCount()).sum();
 	}
 	
 	private static IntStream getMatchingSlots(Predicate<ItemStack> predicate,
 		int maxInvSlot, boolean includeOffhand)
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		
 		// create a stream of all slots that we want to search
 		IntStream stream = IntStream.range(0, maxInvSlot);
@@ -135,24 +134,23 @@ public enum InventoryUtils
 			stream = IntStream.concat(stream, IntStream.of(40));
 		
 		// filter out the slots we don't want
-		return stream.filter(i -> predicate.test(inventory.getStack(i)));
+		return stream.filter(i -> predicate.test(inventory.getItem(i)));
 	}
 	
 	public static boolean selectItem(Item item)
 	{
-		return selectItem(stack -> stack.isOf(item), 36, false);
+		return selectItem(stack -> stack.is(item), 36, false);
 	}
 	
 	public static boolean selectItem(Item item, int maxInvSlot)
 	{
-		return selectItem(stack -> stack.isOf(item), maxInvSlot, false);
+		return selectItem(stack -> stack.is(item), maxInvSlot, false);
 	}
 	
 	public static boolean selectItem(Item item, int maxInvSlot,
 		boolean takeFromOffhand)
 	{
-		return selectItem(stack -> stack.isOf(item), maxInvSlot,
-			takeFromOffhand);
+		return selectItem(stack -> stack.is(item), maxInvSlot, takeFromOffhand);
 	}
 	
 	public static boolean selectItem(Predicate<ItemStack> predicate)
@@ -207,7 +205,7 @@ public enum InventoryUtils
 	 */
 	public static boolean selectItem(int slot)
 	{
-		PlayerInventory inventory = MC.player.getInventory();
+		Inventory inventory = MC.player.getInventory();
 		IClientPlayerInteractionManager im = IMC.getInteractionManager();
 		
 		// if the slot is negative, abort and return false
@@ -219,7 +217,7 @@ public enum InventoryUtils
 			inventory.setSelectedSlot(slot);
 		// if there is an empty slot in the hotbar, shift-click the item there
 		// it will be selected in the next tick
-		else if(inventory.getEmptySlot() > -1 && inventory.getEmptySlot() < 9)
+		else if(inventory.getFreeSlot() > -1 && inventory.getFreeSlot() < 9)
 			im.windowClick_QUICK_MOVE(toNetworkSlot(slot));
 		// otherwise, swap with the currently selected item
 		else
@@ -260,7 +258,7 @@ public enum InventoryUtils
 	 */
 	public static boolean giveCreativeItem(ItemStack stack)
 	{
-		return setCreativeStack(MC.player.getInventory().getEmptySlot(), stack);
+		return setCreativeStack(MC.player.getInventory().getFreeSlot(), stack);
 	}
 	
 	public static boolean setCreativeStack(int slot, Item item)
@@ -278,12 +276,12 @@ public enum InventoryUtils
 		if(slot < 0)
 			return false;
 		
-		if(!MC.player.isInCreativeMode())
+		if(!MC.player.hasInfiniteMaterials())
 			return false;
 		
-		MC.player.getInventory().setStack(slot, stack);
-		MC.player.networkHandler.sendPacket(
-			new CreativeInventoryActionC2SPacket(toNetworkSlot(slot), stack));
+		MC.player.getInventory().setItem(slot, stack);
+		MC.player.connection.send(new ServerboundSetCreativeModeSlotPacket(
+			toNetworkSlot(slot), stack));
 		return true;
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/ItemNameUtils.java b/src/main/java/net/wurstclient/util/ItemNameUtils.java
index 06c22be9c..f13bf8d0b 100644
--- a/src/main/java/net/wurstclient/util/ItemNameUtils.java
+++ b/src/main/java/net/wurstclient/util/ItemNameUtils.java
@@ -9,46 +9,45 @@ package net.wurstclient.util;
 
 import java.util.Arrays;
 import java.util.stream.Collectors;
-
-import net.minecraft.text.Text;
-import net.minecraft.util.Identifier;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
 
 public final class ItemNameUtils
 {
 	private ItemNameUtils()
 	{}
 	
-	public static String buildEnchantmentName(Identifier id, String path)
+	public static String buildEnchantmentName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Enchant";
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "enchantment." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
 	}
 	
-	public static String buildEffectName(Identifier id, String path)
+	public static String buildEffectName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Effect";
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "effect." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
 	}
 	
-	public static String buildPotionName(Identifier id, String path)
+	public static String buildPotionName(ResourceLocation id, String path)
 	{
 		if(path == null || path.isEmpty())
 			return "Unknown Potion";
 		String namespace = id != null ? id.getNamespace() : "minecraft";
 		String key = "potion." + namespace + "." + path;
-		String translated = Text.translatable(key).getString();
+		String translated = Component.translatable(key).getString();
 		if(translated.equals(key))
 			return humanize(path);
 		return translated;
diff --git a/src/main/java/net/wurstclient/util/ItemUtils.java b/src/main/java/net/wurstclient/util/ItemUtils.java
index 938f4921b..20cba5d4a 100644
--- a/src/main/java/net/wurstclient/util/ItemUtils.java
+++ b/src/main/java/net/wurstclient/util/ItemUtils.java
@@ -8,34 +8,34 @@
 package net.wurstclient.util;
 
 import java.util.OptionalDouble;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.component.DataComponentTypes;
-import net.minecraft.component.type.AttributeModifiersComponent;
-import net.minecraft.component.type.EquippableComponent;
-import net.minecraft.component.type.PotionContentsComponent;
-import net.minecraft.entity.EquipmentSlot;
-import net.minecraft.entity.attribute.EntityAttribute;
-import net.minecraft.entity.attribute.EntityAttributes;
-import net.minecraft.entity.effect.StatusEffect;
-import net.minecraft.entity.effect.StatusEffectInstance;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemStack;
-import net.minecraft.registry.Registries;
-import net.minecraft.registry.entry.RegistryEntry;
-import net.minecraft.util.Identifier;
-import net.minecraft.util.InvalidIdentifierException;
+import net.minecraft.ResourceLocationException;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.Holder;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.effect.MobEffect;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.alchemy.PotionContents;
+import net.minecraft.world.item.component.ItemAttributeModifiers;
+import net.minecraft.world.item.equipment.Equippable;
 import net.wurstclient.WurstClient;
 
 public enum ItemUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	/**
 	 * @param nameOrId
-	 *            a String containing the item's name ({@link Identifier}) or
+	 *            a String containing the item's name ({@link ResourceLocation})
+	 *            or
 	 *            numeric ID.
 	 * @return the requested item, or null if the item doesn't exist.
 	 */
@@ -46,8 +46,8 @@ public enum ItemUtils
 			// There is no getOptionalValue() for raw IDs, so this detects when
 			// the registry defaults and returns null instead
 			int id = Integer.parseInt(nameOrId);
-			Item item = Registries.ITEM.get(id);
-			if(id != 0 && Registries.ITEM.getRawId(item) == 0)
+			Item item = BuiltInRegistries.ITEM.byId(id);
+			if(id != 0 && BuiltInRegistries.ITEM.getId(item) == 0)
 				return null;
 			
 			return item;
@@ -57,10 +57,10 @@ public enum ItemUtils
 		{
 			// getOptionalValue() returns null instead of Items.AIR if the
 			// requested item doesn't exist
-			return Registries.ITEM.getOptionalValue(Identifier.of(nameOrId))
-				.orElse(null);
+			return BuiltInRegistries.ITEM
+				.getOptional(ResourceLocation.parse(nameOrId)).orElse(null);
 			
-		}catch(InvalidIdentifierException e)
+		}catch(ResourceLocationException e)
 		{
 			return null;
 		}
@@ -69,31 +69,29 @@ public enum ItemUtils
 	// TODO: Update AutoSword to use calculateModifiedAttribute() instead,
 	// then remove this method.
 	public static OptionalDouble getAttribute(Item item,
-		RegistryEntry<EntityAttribute> attribute)
+		Holder<Attribute> attribute)
 	{
-		return item.getComponents()
-			.getOrDefault(DataComponentTypes.ATTRIBUTE_MODIFIERS,
-				AttributeModifiersComponent.DEFAULT)
+		return item.components()
+			.getOrDefault(DataComponents.ATTRIBUTE_MODIFIERS,
+				ItemAttributeModifiers.EMPTY)
 			.modifiers().stream()
 			.filter(modifier -> modifier.attribute() == attribute)
-			.mapToDouble(modifier -> modifier.modifier().value()).findFirst();
+			.mapToDouble(modifier -> modifier.modifier().amount()).findFirst();
 	}
 	
 	public static double calculateModifiedAttribute(Item item,
-		RegistryEntry<EntityAttribute> attribute, double base,
-		EquipmentSlot slot)
+		Holder<Attribute> attribute, double base, EquipmentSlot slot)
 	{
-		AttributeModifiersComponent modifiers = item.getComponents()
-			.getOrDefault(DataComponentTypes.ATTRIBUTE_MODIFIERS,
-				AttributeModifiersComponent.DEFAULT);
+		ItemAttributeModifiers modifiers = item.components().getOrDefault(
+			DataComponents.ATTRIBUTE_MODIFIERS, ItemAttributeModifiers.EMPTY);
 		
 		double result = base;
-		for(AttributeModifiersComponent.Entry entry : modifiers.modifiers())
+		for(ItemAttributeModifiers.Entry entry : modifiers.modifiers())
 		{
-			if(entry.attribute() != attribute || !entry.slot().matches(slot))
+			if(entry.attribute() != attribute || !entry.slot().test(slot))
 				continue;
 			
-			double value = entry.modifier().value();
+			double value = entry.modifier().amount();
 			result += switch(entry.modifier().operation())
 			{
 				case ADD_VALUE -> value;
@@ -106,10 +104,10 @@ public enum ItemUtils
 	}
 	
 	public static double getArmorAttribute(Item item,
-		RegistryEntry<EntityAttribute> attribute)
+		Holder<Attribute> attribute)
 	{
-		EquippableComponent equippable =
-			item.getComponents().get(DataComponentTypes.EQUIPPABLE);
+		Equippable equippable =
+			item.components().get(DataComponents.EQUIPPABLE);
 		
 		double base = MC.player.getAttributeBaseValue(attribute);
 		if(equippable == null)
@@ -121,31 +119,29 @@ public enum ItemUtils
 	
 	public static double getArmorPoints(Item item)
 	{
-		return getArmorAttribute(item, EntityAttributes.ARMOR);
+		return getArmorAttribute(item, Attributes.ARMOR);
 	}
 	
 	public static double getToughness(Item item)
 	{
-		return getArmorAttribute(item, EntityAttributes.ARMOR_TOUGHNESS);
+		return getArmorAttribute(item, Attributes.ARMOR_TOUGHNESS);
 	}
 	
 	public static EquipmentSlot getArmorSlot(Item item)
 	{
-		EquippableComponent equippable =
-			item.getComponents().get(DataComponentTypes.EQUIPPABLE);
+		Equippable equippable =
+			item.components().get(DataComponents.EQUIPPABLE);
 		
 		return equippable != null ? equippable.slot() : null;
 	}
 	
-	public static boolean hasEffect(ItemStack stack,
-		RegistryEntry<StatusEffect> effect)
+	public static boolean hasEffect(ItemStack stack, Holder<MobEffect> effect)
 	{
-		PotionContentsComponent potionContents = stack.getComponents()
-			.getOrDefault(DataComponentTypes.POTION_CONTENTS,
-				PotionContentsComponent.DEFAULT);
+		PotionContents potionContents = stack.getComponents()
+			.getOrDefault(DataComponents.POTION_CONTENTS, PotionContents.EMPTY);
 		
-		for(StatusEffectInstance effectInstance : potionContents.getEffects())
-			if(effectInstance.getEffectType() == effect)
+		for(MobEffectInstance effectInstance : potionContents.getAllEffects())
+			if(effectInstance.getEffect() == effect)
 				return true;
 			
 		return false;
diff --git a/src/main/java/net/wurstclient/util/JustGiveMeTheStringVisitor.java b/src/main/java/net/wurstclient/util/JustGiveMeTheStringVisitor.java
index 81450b80a..c84e8a759 100644
--- a/src/main/java/net/wurstclient/util/JustGiveMeTheStringVisitor.java
+++ b/src/main/java/net/wurstclient/util/JustGiveMeTheStringVisitor.java
@@ -7,20 +7,20 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.client.gui.hud.ChatHudLine;
-import net.minecraft.text.CharacterVisitor;
-import net.minecraft.text.Style;
+import net.minecraft.client.GuiMessage;
+import net.minecraft.network.chat.Style;
+import net.minecraft.util.FormattedCharSink;
 
 /**
- * A {@link CharacterVisitor} to completely bypass Mojang's visitor
+ * A {@link FormattedCharSink} to completely bypass Mojang's visitor
  * system and just get the damn {@link String} out of a
- * {@link ChatHudLine.Visible}.
+ * {@link GuiMessage.Line}.
  *
  * <p>
  * Is this seriously the replacement for <code>getString()</code>?
  * What were they thinking?!
  */
-public class JustGiveMeTheStringVisitor implements CharacterVisitor
+public class JustGiveMeTheStringVisitor implements FormattedCharSink
 {
 	private final StringBuilder sb = new StringBuilder();
 	
diff --git a/src/main/java/net/wurstclient/util/LastServerRememberer.java b/src/main/java/net/wurstclient/util/LastServerRememberer.java
index e8b363236..45da6ea04 100644
--- a/src/main/java/net/wurstclient/util/LastServerRememberer.java
+++ b/src/main/java/net/wurstclient/util/LastServerRememberer.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.client.gui.screen.Screen;
-import net.minecraft.client.gui.screen.multiplayer.ConnectScreen;
-import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
-import net.minecraft.client.network.ServerAddress;
-import net.minecraft.client.network.ServerInfo;
+import net.minecraft.client.gui.screens.ConnectScreen;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.gui.screens.multiplayer.JoinMultiplayerScreen;
+import net.minecraft.client.multiplayer.ServerData;
+import net.minecraft.client.multiplayer.resolver.ServerAddress;
 import net.wurstclient.WurstClient;
 
 /**
@@ -22,24 +22,24 @@ public enum LastServerRememberer
 {
 	;
 	
-	private static ServerInfo lastServer;
+	private static ServerData lastServer;
 	
-	public static ServerInfo getLastServer()
+	public static ServerData getLastServer()
 	{
 		return lastServer;
 	}
 	
-	public static void setLastServer(ServerInfo server)
+	public static void setLastServer(ServerData server)
 	{
 		lastServer = server;
 	}
 	
-	public static void joinLastServer(MultiplayerScreen mpScreen)
+	public static void joinLastServer(JoinMultiplayerScreen mpScreen)
 	{
 		if(lastServer == null)
 			return;
 		
-		mpScreen.connect(lastServer);
+		mpScreen.join(lastServer);
 	}
 	
 	public static void reconnect(Screen prevScreen)
@@ -47,7 +47,7 @@ public enum LastServerRememberer
 		if(lastServer == null)
 			return;
 		
-		ConnectScreen.connect(prevScreen, WurstClient.MC,
-			ServerAddress.parse(lastServer.address), lastServer, false, null);
+		ConnectScreen.startConnecting(prevScreen, WurstClient.MC,
+			ServerAddress.parseString(lastServer.ip), lastServer, false, null);
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/LootrModCompat.java b/src/main/java/net/wurstclient/util/LootrModCompat.java
index af5739a1d..d1755383d 100644
--- a/src/main/java/net/wurstclient/util/LootrModCompat.java
+++ b/src/main/java/net/wurstclient/util/LootrModCompat.java
@@ -7,7 +7,7 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
 
 /**
  * Detects block entities from the Lootr mod for use in ChestESP.
diff --git a/src/main/java/net/wurstclient/util/OverlayRenderer.java b/src/main/java/net/wurstclient/util/OverlayRenderer.java
index d5b70af0b..3c0677af5 100644
--- a/src/main/java/net/wurstclient/util/OverlayRenderer.java
+++ b/src/main/java/net/wurstclient/util/OverlayRenderer.java
@@ -7,17 +7,17 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
+import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.AABB;
 import net.wurstclient.WurstClient;
 import net.wurstclient.mixinterface.IMinecraftClient;
 
 public final class OverlayRenderer
 {
-	protected static final MinecraftClient MC = WurstClient.MC;
+	protected static final Minecraft MC = WurstClient.MC;
 	protected static final IMinecraftClient IMC = WurstClient.IMC;
 	
 	private float progress;
@@ -34,14 +34,13 @@ public final class OverlayRenderer
 	public void updateProgress()
 	{
 		prevProgress = progress;
-		progress = MC.interactionManager.currentBreakingProgress;
+		progress = MC.gameMode.destroyProgress;
 		
 		if(progress < prevProgress)
 			prevProgress = progress;
 	}
 	
-	public void render(MatrixStack matrixStack, float partialTicks,
-		BlockPos pos)
+	public void render(PoseStack matrixStack, float partialTicks, BlockPos pos)
 	{
 		if(pos == null)
 			return;
@@ -53,10 +52,10 @@ public final class OverlayRenderer
 		prevPos = pos;
 		
 		// Get interpolated progress
-		boolean breaksInstantly = MC.player.getAbilities().creativeMode
+		boolean breaksInstantly = MC.player.getAbilities().instabuild
 			|| BlockUtils.getHardness(pos) >= 1;
 		float p = breaksInstantly ? 1
-			: MathHelper.lerp(partialTicks, prevProgress, progress);
+			: Mth.lerp(partialTicks, prevProgress, progress);
 		
 		// Get colors
 		float red = p * 2F;
@@ -66,9 +65,9 @@ public final class OverlayRenderer
 		int lineColor = RenderUtils.toIntColor(rgb, 0.5F);
 		
 		// Set size
-		Box box = new Box(pos);
+		AABB box = new AABB(pos);
 		if(p < 1)
-			box = box.contract((1 - p) * 0.5);
+			box = box.deflate((1 - p) * 0.5);
 		
 		RenderUtils.drawSolidBox(matrixStack, box, quadColor, false);
 		RenderUtils.drawOutlinedBox(matrixStack, box, lineColor, false);
diff --git a/src/main/java/net/wurstclient/util/PacketUtils.java b/src/main/java/net/wurstclient/util/PacketUtils.java
index 0623ce2c2..97925d267 100644
--- a/src/main/java/net/wurstclient/util/PacketUtils.java
+++ b/src/main/java/net/wurstclient/util/PacketUtils.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.Full;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.LookAndOnGround;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.OnGroundOnly;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionAndOnGround;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Pos;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.PosRot;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Rot;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.StatusOnly;
 
 public enum PacketUtils
 {
@@ -22,22 +22,22 @@ public enum PacketUtils
 	 * input packet if of a type that can't hold position data, it will be
 	 * upgraded to PositionAndOnGround or Full as needed.
 	 */
-	public static PlayerMoveC2SPacket modifyPosition(PlayerMoveC2SPacket packet,
-		double x, double y, double z)
+	public static ServerboundMovePlayerPacket modifyPosition(
+		ServerboundMovePlayerPacket packet, double x, double y, double z)
 	{
-		if(packet instanceof LookAndOnGround)
-			return new Full(x, y, z, packet.getYaw(0), packet.getPitch(0),
+		if(packet instanceof Rot)
+			return new PosRot(x, y, z, packet.getYRot(0), packet.getXRot(0),
 				packet.isOnGround(), packet.horizontalCollision());
 		
-		if(packet instanceof OnGroundOnly)
-			return new PositionAndOnGround(x, y, z, packet.isOnGround(),
+		if(packet instanceof StatusOnly)
+			return new Pos(x, y, z, packet.isOnGround(),
 				packet.horizontalCollision());
 		
-		if(packet instanceof Full)
-			return new Full(x, y, z, packet.getYaw(0), packet.getPitch(0),
+		if(packet instanceof PosRot)
+			return new PosRot(x, y, z, packet.getYRot(0), packet.getXRot(0),
 				packet.isOnGround(), packet.horizontalCollision());
 		
-		return new PositionAndOnGround(x, y, z, packet.isOnGround(),
+		return new Pos(x, y, z, packet.isOnGround(),
 			packet.horizontalCollision());
 	}
 	
@@ -46,67 +46,67 @@ public enum PacketUtils
 	 * input packet is of a type that can't hold rotation data, it will be
 	 * upgraded to LookAndOnGround or Full as needed.
 	 */
-	public static PlayerMoveC2SPacket modifyRotation(PlayerMoveC2SPacket packet,
-		float yaw, float pitch)
+	public static ServerboundMovePlayerPacket modifyRotation(
+		ServerboundMovePlayerPacket packet, float yaw, float pitch)
 	{
-		if(packet instanceof PositionAndOnGround)
-			return new Full(packet.getX(0), packet.getY(0), packet.getZ(0), yaw,
-				pitch, packet.isOnGround(), packet.horizontalCollision());
+		if(packet instanceof Pos)
+			return new PosRot(packet.getX(0), packet.getY(0), packet.getZ(0),
+				yaw, pitch, packet.isOnGround(), packet.horizontalCollision());
 		
-		if(packet instanceof OnGroundOnly)
-			return new LookAndOnGround(yaw, pitch, packet.isOnGround(),
+		if(packet instanceof StatusOnly)
+			return new Rot(yaw, pitch, packet.isOnGround(),
 				packet.horizontalCollision());
 		
-		if(packet instanceof Full)
-			return new Full(packet.getX(0), packet.getY(0), packet.getZ(0), yaw,
-				pitch, packet.isOnGround(), packet.horizontalCollision());
+		if(packet instanceof PosRot)
+			return new PosRot(packet.getX(0), packet.getY(0), packet.getZ(0),
+				yaw, pitch, packet.isOnGround(), packet.horizontalCollision());
 		
-		return new LookAndOnGround(yaw, pitch, packet.isOnGround(),
+		return new Rot(yaw, pitch, packet.isOnGround(),
 			packet.horizontalCollision());
 	}
 	
 	/**
 	 * Creates a new PlayerMoveC2SPacket with a modified onGround flag.
 	 */
-	public static PlayerMoveC2SPacket modifyOnGround(PlayerMoveC2SPacket packet,
-		boolean onGround)
+	public static ServerboundMovePlayerPacket modifyOnGround(
+		ServerboundMovePlayerPacket packet, boolean onGround)
 	{
-		if(packet instanceof Full)
-			return new Full(packet.getX(0), packet.getY(0), packet.getZ(0),
-				packet.getYaw(0), packet.getPitch(0), onGround,
+		if(packet instanceof PosRot)
+			return new PosRot(packet.getX(0), packet.getY(0), packet.getZ(0),
+				packet.getYRot(0), packet.getXRot(0), onGround,
 				packet.horizontalCollision());
 		
-		if(packet instanceof PositionAndOnGround)
-			return new PositionAndOnGround(packet.getX(0), packet.getY(0),
-				packet.getZ(0), onGround, packet.horizontalCollision());
-		
-		if(packet instanceof LookAndOnGround)
-			return new LookAndOnGround(packet.getYaw(0), packet.getPitch(0),
+		if(packet instanceof Pos)
+			return new Pos(packet.getX(0), packet.getY(0), packet.getZ(0),
 				onGround, packet.horizontalCollision());
 		
-		return new OnGroundOnly(onGround, packet.horizontalCollision());
+		if(packet instanceof Rot)
+			return new Rot(packet.getYRot(0), packet.getXRot(0), onGround,
+				packet.horizontalCollision());
+		
+		return new StatusOnly(onGround, packet.horizontalCollision());
 	}
 	
 	/**
 	 * Creates a new PlayerMoveC2SPacket with a modified horizontal collision
 	 * flag.
 	 */
-	public static PlayerMoveC2SPacket modifyHorizontalCollision(
-		PlayerMoveC2SPacket packet, boolean horizontalCollision)
+	public static ServerboundMovePlayerPacket modifyHorizontalCollision(
+		ServerboundMovePlayerPacket packet, boolean horizontalCollision)
 	{
-		if(packet instanceof Full)
-			return new Full(packet.getX(0), packet.getY(0), packet.getZ(0),
-				packet.getYaw(0), packet.getPitch(0), packet.isOnGround(),
+		if(packet instanceof PosRot)
+			return new PosRot(packet.getX(0), packet.getY(0), packet.getZ(0),
+				packet.getYRot(0), packet.getXRot(0), packet.isOnGround(),
 				horizontalCollision);
 		
-		if(packet instanceof PositionAndOnGround)
-			return new PositionAndOnGround(packet.getX(0), packet.getY(0),
-				packet.getZ(0), packet.isOnGround(), horizontalCollision);
+		if(packet instanceof Pos)
+			return new Pos(packet.getX(0), packet.getY(0), packet.getZ(0),
+				packet.isOnGround(), horizontalCollision);
 		
-		if(packet instanceof LookAndOnGround)
-			return new LookAndOnGround(packet.getYaw(0), packet.getPitch(0),
+		if(packet instanceof Rot)
+			return new Rot(packet.getYRot(0), packet.getXRot(0),
 				packet.isOnGround(), horizontalCollision);
 		
-		return new OnGroundOnly(packet.isOnGround(), horizontalCollision);
+		return new StatusOnly(packet.isOnGround(), horizontalCollision);
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/PlayerRangeAlertManager.java b/src/main/java/net/wurstclient/util/PlayerRangeAlertManager.java
index d4c91b35c..169eee0be 100644
--- a/src/main/java/net/wurstclient/util/PlayerRangeAlertManager.java
+++ b/src/main/java/net/wurstclient/util/PlayerRangeAlertManager.java
@@ -13,11 +13,10 @@ import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayNetworkHandler;
-import net.minecraft.entity.player.PlayerEntity;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientPacketListener;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.event.EventManager;
 import net.wurstclient.events.UpdateListener;
@@ -30,7 +29,7 @@ import net.wurstclient.events.UpdateListener;
 public final class PlayerRangeAlertManager implements UpdateListener
 {
 	private final EventManager events;
-	private final MinecraftClient mc = WurstClient.MC;
+	private final Minecraft mc = WurstClient.MC;
 	private final Set<Listener> listeners = new LinkedHashSet<>();
 	private final Map<UUID, PlayerInfo> knownPlayers = new HashMap<>();
 	private boolean running;
@@ -73,24 +72,24 @@ public final class PlayerRangeAlertManager implements UpdateListener
 		if(!running)
 			return;
 		
-		if(mc.player == null || mc.world == null)
+		if(mc.player == null || mc.level == null)
 		{
 			flushAll();
 			return;
 		}
 		
 		HashSet<UUID> seen = new HashSet<>();
-		for(PlayerEntity player : mc.world.getPlayers())
+		for(Player player : mc.level.players())
 		{
 			if(player == mc.player || player instanceof FakePlayerEntity)
 				continue;
 			
-			UUID id = player.getUuid();
+			UUID id = player.getUUID();
 			seen.add(id);
 			
 			PlayerInfo info = knownPlayers.get(id);
 			boolean npc = isProbablyNpc(id);
-			Vec3d pos = new Vec3d(player.getX(), player.getY(), player.getZ());
+			Vec3 pos = new Vec3(player.getX(), player.getY(), player.getZ());
 			String name = player.getName().getString();
 			
 			if(info == null)
@@ -121,8 +120,8 @@ public final class PlayerRangeAlertManager implements UpdateListener
 	
 	private boolean isProbablyNpc(UUID id)
 	{
-		ClientPlayNetworkHandler handler = mc.getNetworkHandler();
-		return handler != null && handler.getPlayerListEntry(id) == null;
+		ClientPacketListener handler = mc.getConnection();
+		return handler != null && handler.getPlayerInfo(id) == null;
 	}
 	
 	private void flushAll()
@@ -134,7 +133,7 @@ public final class PlayerRangeAlertManager implements UpdateListener
 		knownPlayers.clear();
 	}
 	
-	private void notifyEnter(PlayerEntity player, PlayerInfo info)
+	private void notifyEnter(Player player, PlayerInfo info)
 	{
 		for(Listener listener : snapshotListeners())
 			listener.onPlayerEnter(player, info);
@@ -159,7 +158,7 @@ public final class PlayerRangeAlertManager implements UpdateListener
 	
 	public interface Listener
 	{
-		void onPlayerEnter(PlayerEntity player, PlayerInfo info);
+		void onPlayerEnter(Player player, PlayerInfo info);
 		
 		void onPlayerExit(PlayerInfo info);
 	}
@@ -168,10 +167,10 @@ public final class PlayerRangeAlertManager implements UpdateListener
 	{
 		private final UUID uuid;
 		private String name;
-		private Vec3d lastPos;
+		private Vec3 lastPos;
 		private boolean probablyNpc;
 		
-		private PlayerInfo(UUID uuid, String name, Vec3d lastPos,
+		private PlayerInfo(UUID uuid, String name, Vec3 lastPos,
 			boolean probablyNpc)
 		{
 			this.uuid = uuid;
@@ -180,7 +179,7 @@ public final class PlayerRangeAlertManager implements UpdateListener
 			this.probablyNpc = probablyNpc;
 		}
 		
-		private void update(String name, Vec3d lastPos, boolean probablyNpc)
+		private void update(String name, Vec3 lastPos, boolean probablyNpc)
 		{
 			this.name = name;
 			this.lastPos = lastPos;
@@ -197,7 +196,7 @@ public final class PlayerRangeAlertManager implements UpdateListener
 			return name;
 		}
 		
-		public Vec3d getLastPos()
+		public Vec3 getLastPos()
 		{
 			return lastPos;
 		}
diff --git a/src/main/java/net/wurstclient/util/RegionPos.java b/src/main/java/net/wurstclient/util/RegionPos.java
index 29d3cd022..94299aff0 100644
--- a/src/main/java/net/wurstclient/util/RegionPos.java
+++ b/src/main/java/net/wurstclient/util/RegionPos.java
@@ -7,9 +7,9 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.phys.Vec3;
 
 public record RegionPos(int x, int z)
 {
@@ -28,9 +28,9 @@ public record RegionPos(int x, int z)
 		return new RegionPos(-x, -z);
 	}
 	
-	public Vec3d toVec3d()
+	public Vec3 toVec3d()
 	{
-		return new Vec3d(x, 0, z);
+		return new Vec3(x, 0, z);
 	}
 	
 	public BlockPos toBlockPos()
diff --git a/src/main/java/net/wurstclient/util/RenderUtils.java b/src/main/java/net/wurstclient/util/RenderUtils.java
index a3be984f7..b48309441 100644
--- a/src/main/java/net/wurstclient/util/RenderUtils.java
+++ b/src/main/java/net/wurstclient/util/RenderUtils.java
@@ -7,30 +7,29 @@
  */
 package net.wurstclient.util;
 
+import com.mojang.blaze3d.vertex.PoseStack;
+import com.mojang.blaze3d.vertex.PoseStack.Pose;
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import java.util.List;
 
 import org.joml.Matrix3x2f;
 import org.joml.Matrix3x2fStack;
 import org.joml.Matrix4f;
 import org.joml.Vector3f;
-
-import net.minecraft.block.Blocks;
-import net.minecraft.client.font.TextRenderer;
-import net.minecraft.client.gui.DrawContext;
-import net.minecraft.client.gui.ScreenRect;
-import net.minecraft.client.option.Perspective;
-import net.minecraft.client.render.Camera;
-import net.minecraft.client.render.RenderLayer;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.client.render.VertexConsumerProvider;
-import net.minecraft.client.util.math.MatrixStack;
-import net.minecraft.client.util.math.MatrixStack.Entry;
-import net.minecraft.item.ItemStack;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.chunk.Chunk;
+import net.minecraft.client.Camera;
+import net.minecraft.client.CameraType;
+import net.minecraft.client.gui.Font;
+import net.minecraft.client.gui.GuiGraphics;
+import net.minecraft.client.gui.navigation.ScreenRectangle;
+import net.minecraft.client.renderer.MultiBufferSource;
+import net.minecraft.client.renderer.RenderType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 import net.wurstclient.WurstRenderLayers;
 import net.wurstclient.nicewurst.NiceWurstModule;
@@ -39,46 +38,46 @@ public enum RenderUtils
 {
 	;
 	
-	public static void applyRegionalRenderOffset(MatrixStack matrixStack)
+	public static void applyRegionalRenderOffset(PoseStack matrixStack)
 	{
 		applyRegionalRenderOffset(matrixStack, getCameraRegion());
 	}
 	
-	public static void applyRegionalRenderOffset(MatrixStack matrixStack,
-		Chunk chunk)
+	public static void applyRegionalRenderOffset(PoseStack matrixStack,
+		ChunkAccess chunk)
 	{
 		applyRegionalRenderOffset(matrixStack, RegionPos.of(chunk.getPos()));
 	}
 	
-	public static void applyRegionalRenderOffset(MatrixStack matrixStack,
+	public static void applyRegionalRenderOffset(PoseStack matrixStack,
 		RegionPos region)
 	{
-		Vec3d offset = region.toVec3d().subtract(getCameraPos());
+		Vec3 offset = region.toVec3d().subtract(getCameraPos());
 		matrixStack.translate(offset.x, offset.y, offset.z);
 	}
 	
-	public static void applyRenderOffset(MatrixStack matrixStack)
+	public static void applyRenderOffset(PoseStack matrixStack)
 	{
-		Vec3d camPos = getCameraPos();
+		Vec3 camPos = getCameraPos();
 		matrixStack.translate(-camPos.x, -camPos.y, -camPos.z);
 	}
 	
-	public static Vec3d getCameraPos()
+	public static Vec3 getCameraPos()
 	{
-		Camera camera = WurstClient.MC.gameRenderer.getCamera();
+		Camera camera = WurstClient.MC.gameRenderer.getMainCamera();
 		if(camera == null)
-			return Vec3d.ZERO;
+			return Vec3.ZERO;
 		
-		return camera.getPos();
+		return camera.getPosition();
 	}
 	
 	public static BlockPos getCameraBlockPos()
 	{
-		Camera camera = WurstClient.MC.gameRenderer.getCamera();
+		Camera camera = WurstClient.MC.gameRenderer.getMainCamera();
 		if(camera == null)
-			return BlockPos.ORIGIN;
+			return BlockPos.ZERO;
 		
-		return camera.getBlockPos();
+		return camera.getBlockPosition();
 	}
 	
 	public static RegionPos getCameraRegion()
@@ -86,9 +85,9 @@ public enum RenderUtils
 		return RegionPos.of(getCameraBlockPos());
 	}
 	
-	public static VertexConsumerProvider.Immediate getVCP()
+	public static MultiBufferSource.BufferSource getVCP()
 	{
-		return WurstClient.MC.getBufferBuilders().getEntityVertexConsumers();
+		return WurstClient.MC.renderBuffers().bufferSource();
 	}
 	
 	public static float[] getRainbowColor()
@@ -97,46 +96,46 @@ public enum RenderUtils
 		float pi = (float)Math.PI;
 		
 		float[] rainbow = new float[3];
-		rainbow[0] = 0.5F + 0.5F * MathHelper.sin(x * pi);
-		rainbow[1] = 0.5F + 0.5F * MathHelper.sin((x + 4F / 3F) * pi);
-		rainbow[2] = 0.5F + 0.5F * MathHelper.sin((x + 8F / 3F) * pi);
+		rainbow[0] = 0.5F + 0.5F * Mth.sin(x * pi);
+		rainbow[1] = 0.5F + 0.5F * Mth.sin((x + 4F / 3F) * pi);
+		rainbow[2] = 0.5F + 0.5F * Mth.sin((x + 8F / 3F) * pi);
 		return rainbow;
 	}
 	
 	public static int toIntColor(float[] rgb, float opacity)
 	{
-		return (int)(MathHelper.clamp(opacity, 0, 1) * 255) << 24
-			| (int)(MathHelper.clamp(rgb[0], 0, 1) * 255) << 16
-			| (int)(MathHelper.clamp(rgb[1], 0, 1) * 255) << 8
-			| (int)(MathHelper.clamp(rgb[2], 0, 1) * 255);
+		return (int)(Mth.clamp(opacity, 0, 1) * 255) << 24
+			| (int)(Mth.clamp(rgb[0], 0, 1) * 255) << 16
+			| (int)(Mth.clamp(rgb[1], 0, 1) * 255) << 8
+			| (int)(Mth.clamp(rgb[2], 0, 1) * 255);
 	}
 	
-	public static void drawLine(MatrixStack matrices, Vec3d start, Vec3d end,
+	public static void drawLine(PoseStack matrices, Vec3 start, Vec3 end,
 		int color, boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d offset = getCameraPos().negate();
+		Vec3 offset = getCameraPos().reverse();
 		drawLine(matrices, buffer, start.add(offset), end.add(offset), color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	private static Vec3d getTracerOrigin(float partialTicks)
+	private static Vec3 getTracerOrigin(float partialTicks)
 	{
-		Vec3d start = RotationUtils.getClientLookVec(partialTicks).multiply(10);
+		Vec3 start = RotationUtils.getClientLookVec(partialTicks).scale(10);
 		if(WurstClient.MC.options
-			.getPerspective() == Perspective.THIRD_PERSON_FRONT)
-			start = start.negate();
+			.getCameraType() == CameraType.THIRD_PERSON_FRONT)
+			start = start.reverse();
 		
 		return start;
 	}
 	
-	public static void drawTracer(MatrixStack matrices, float partialTicks,
-		Vec3d end, int color, boolean depthTest)
+	public static void drawTracer(PoseStack matrices, float partialTicks,
+		Vec3 end, int color, boolean depthTest)
 	{
 		boolean enforceVisibility =
 			NiceWurstModule.shouldEnforceTracerVisibility();
@@ -145,34 +144,34 @@ public enum RenderUtils
 		
 		if(!enforceVisibility)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d start = getTracerOrigin(partialTicks);
-		Vec3d offset = getCameraPos().negate();
+		Vec3 start = getTracerOrigin(partialTicks);
+		Vec3 offset = getCameraPos().reverse();
 		drawLine(matrices, buffer, start, end.add(offset), color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawTracers(MatrixStack matrices, float partialTicks,
-		List<Vec3d> ends, int color, boolean depthTest)
+	public static void drawTracers(PoseStack matrices, float partialTicks,
+		List<Vec3> ends, int color, boolean depthTest)
 	{
 		boolean enforceVisibility =
 			NiceWurstModule.shouldEnforceTracerVisibility();
 		if(!enforceVisibility)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
 		
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d start = getTracerOrigin(partialTicks);
-		Vec3d offset = getCameraPos().negate();
+		Vec3 start = getTracerOrigin(partialTicks);
+		Vec3 offset = getCameraPos().reverse();
 		
 		boolean rendered = false;
-		for(Vec3d end : ends)
+		for(Vec3 end : ends)
 		{
 			if(enforceVisibility && !NiceWurstModule.shouldRenderTarget(end))
 				continue;
@@ -181,10 +180,10 @@ public enum RenderUtils
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawTracers(MatrixStack matrices, float partialTicks,
+	public static void drawTracers(PoseStack matrices, float partialTicks,
 		List<ColoredPoint> ends, boolean depthTest)
 	{
 		boolean enforceVisibility =
@@ -192,16 +191,16 @@ public enum RenderUtils
 		if(!enforceVisibility)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
 		
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d start = getTracerOrigin(partialTicks);
-		Vec3d offset = getCameraPos().negate();
+		Vec3 start = getTracerOrigin(partialTicks);
+		Vec3 offset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredPoint end : ends)
 		{
-			Vec3d point = end.point();
+			Vec3 point = end.point();
 			if(enforceVisibility && !NiceWurstModule.shouldRenderTarget(point))
 				continue;
 			drawLine(matrices, buffer, start, point.add(offset), end.color());
@@ -209,10 +208,10 @@ public enum RenderUtils
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawTracers(MatrixStack matrices, float partialTicks,
+	public static void drawTracers(PoseStack matrices, float partialTicks,
 		List<ColoredPoint> ends, boolean depthTest, double lineWidth)
 	{
 		if(ends == null || ends.isEmpty())
@@ -223,16 +222,16 @@ public enum RenderUtils
 		if(!enforceVisibility)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
 		
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest, lineWidth);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest, lineWidth);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d start = getTracerOrigin(partialTicks);
-		Vec3d offset = getCameraPos().negate();
+		Vec3 start = getTracerOrigin(partialTicks);
+		Vec3 offset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredPoint end : ends)
 		{
-			Vec3d point = end.point();
+			Vec3 point = end.point();
 			if(enforceVisibility && !NiceWurstModule.shouldRenderTarget(point))
 				continue;
 			drawLine(matrices, buffer, start, point.add(offset), end.color());
@@ -240,13 +239,13 @@ public enum RenderUtils
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawLine(MatrixStack matrices, VertexConsumer buffer,
-		Vec3d start, Vec3d end, int color)
+	public static void drawLine(PoseStack matrices, VertexConsumer buffer,
+		Vec3 start, Vec3 end, int color)
 	{
-		Entry entry = matrices.peek();
+		Pose entry = matrices.last();
 		float x1 = (float)start.x;
 		float y1 = (float)start.y;
 		float z1 = (float)start.z;
@@ -256,11 +255,12 @@ public enum RenderUtils
 		drawLine(entry, buffer, x1, y1, z1, x2, y2, z2, color);
 	}
 	
-	public static void drawLine(MatrixStack.Entry entry, VertexConsumer buffer,
+	public static void drawLine(PoseStack.Pose entry, VertexConsumer buffer,
 		float x1, float y1, float z1, float x2, float y2, float z2, int color)
 	{
 		Vector3f normal = new Vector3f(x2, y2, z2).sub(x1, y1, z1).normalize();
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, normal);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry,
+			normal);
 		
 		// If the line goes through the screen, add another vertex there. This
 		// works around a bug in Minecraft's line shader.
@@ -269,73 +269,77 @@ public enum RenderUtils
 		if(t > 0 && t < length)
 		{
 			Vector3f closeToCam = new Vector3f(normal).mul(t).add(x1, y1, z1);
-			buffer.vertex(entry, closeToCam).color(color).normal(entry, normal);
-			buffer.vertex(entry, closeToCam).color(color).normal(entry, normal);
+			buffer.addVertex(entry, closeToCam).setColor(color).setNormal(entry,
+				normal);
+			buffer.addVertex(entry, closeToCam).setColor(color).setNormal(entry,
+				normal);
 		}
 		
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, normal);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry,
+			normal);
 	}
 	
 	public static void drawLine(VertexConsumer buffer, float x1, float y1,
 		float z1, float x2, float y2, float z2, int color)
 	{
 		Vector3f n = new Vector3f(x2, y2, z2).sub(x1, y1, z1).normalize();
-		buffer.vertex(x1, y1, z1).color(color).normal(n.x, n.y, n.z);
-		buffer.vertex(x2, y2, z2).color(color).normal(n.x, n.y, n.z);
+		buffer.addVertex(x1, y1, z1).setColor(color).setNormal(n.x, n.y, n.z);
+		buffer.addVertex(x2, y2, z2).setColor(color).setNormal(n.x, n.y, n.z);
 	}
 	
-	public static void drawCurvedLine(MatrixStack matrices, List<Vec3d> points,
+	public static void drawCurvedLine(PoseStack matrices, List<Vec3> points,
 		int color, boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLineStrip(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLineStrip(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d offset = getCameraPos().negate();
-		List<Vec3d> points2 = points.stream().map(v -> v.add(offset)).toList();
+		Vec3 offset = getCameraPos().reverse();
+		List<Vec3> points2 = points.stream().map(v -> v.add(offset)).toList();
 		drawCurvedLine(matrices, buffer, points2, color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawCurvedLine(MatrixStack matrices, List<Vec3d> points,
+	public static void drawCurvedLine(PoseStack matrices, List<Vec3> points,
 		int color, boolean depthTest, double width)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLineStrip(depthTest, width);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLineStrip(depthTest, width);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d offset = getCameraPos().negate();
-		List<Vec3d> points2 = points.stream().map(v -> v.add(offset)).toList();
+		Vec3 offset = getCameraPos().reverse();
+		List<Vec3> points2 = points.stream().map(v -> v.add(offset)).toList();
 		drawCurvedLine(matrices, buffer, points2, color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawCurvedLine(MatrixStack matrices,
-		VertexConsumer buffer, List<Vec3d> points, int color)
+	public static void drawCurvedLine(PoseStack matrices, VertexConsumer buffer,
+		List<Vec3> points, int color)
 	{
 		if(points.size() < 2)
 			return;
 		
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		Vector3f first = points.get(0).toVector3f();
 		Vector3f second = points.get(1).toVector3f();
 		Vector3f normal = new Vector3f(first).sub(second).normalize();
-		buffer.vertex(entry, first).color(color).normal(entry, normal);
+		buffer.addVertex(entry, first).setColor(color).setNormal(entry, normal);
 		
 		for(int i = 1; i < points.size(); i++)
 		{
 			Vector3f prev = points.get(i - 1).toVector3f();
 			Vector3f current = points.get(i).toVector3f();
 			normal = new Vector3f(current).sub(prev).normalize();
-			buffer.vertex(entry, current).color(color).normal(entry, normal);
+			buffer.addVertex(entry, current).setColor(color).setNormal(entry,
+				normal);
 		}
 	}
 	
-	public static void drawSolidBox(MatrixStack matrices, Box box, int color,
+	public static void drawSolidBox(PoseStack matrices, AABB box, int color,
 		boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
@@ -344,52 +348,52 @@ public enum RenderUtils
 		
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getQuads(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getQuads(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		drawSolidBox(matrices, buffer, box.offset(getCameraPos().negate()),
+		drawSolidBox(matrices, buffer, box.move(getCameraPos().reverse()),
 			color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawSolidBoxes(MatrixStack matrices, List<Box> boxes,
+	public static void drawSolidBoxes(PoseStack matrices, List<AABB> boxes,
 		int color, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getQuads(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getQuads(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
-		for(Box box : boxes)
+		for(AABB box : boxes)
 		{
 			if(overlay && !NiceWurstModule.shouldRenderTarget(box.getCenter()))
 				continue;
 			
-			drawSolidBox(matrices, buffer, box.offset(camOffset), color);
+			drawSolidBox(matrices, buffer, box.move(camOffset), color);
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawSolidBoxes(MatrixStack matrices,
+	public static void drawSolidBoxes(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getQuads(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getQuads(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredBox box : boxes)
 		{
@@ -397,24 +401,24 @@ public enum RenderUtils
 				&& !NiceWurstModule.shouldRenderTarget(box.box().getCenter()))
 				continue;
 			
-			drawSolidBox(matrices, buffer, box.box().offset(camOffset),
+			drawSolidBox(matrices, buffer, box.box().move(camOffset),
 				box.color());
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawSolidBox(VertexConsumer buffer, Box box, int color)
+	public static void drawSolidBox(VertexConsumer buffer, AABB box, int color)
 	{
-		drawSolidBox(new MatrixStack(), buffer, box, color);
+		drawSolidBox(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawSolidBox(MatrixStack matrices, VertexConsumer buffer,
-		Box box, int color)
+	public static void drawSolidBox(PoseStack matrices, VertexConsumer buffer,
+		AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -422,74 +426,74 @@ public enum RenderUtils
 		float y2 = (float)box.maxY;
 		float z2 = (float)box.maxZ;
 		
-		buffer.vertex(entry, x1, y1, z1).color(color);
-		buffer.vertex(entry, x2, y1, z1).color(color);
-		buffer.vertex(entry, x2, y1, z2).color(color);
-		buffer.vertex(entry, x1, y1, z2).color(color);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color);
 		
-		buffer.vertex(entry, x1, y2, z1).color(color);
-		buffer.vertex(entry, x1, y2, z2).color(color);
-		buffer.vertex(entry, x2, y2, z2).color(color);
-		buffer.vertex(entry, x2, y2, z1).color(color);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color);
 		
-		buffer.vertex(entry, x1, y1, z1).color(color);
-		buffer.vertex(entry, x1, y2, z1).color(color);
-		buffer.vertex(entry, x2, y2, z1).color(color);
-		buffer.vertex(entry, x2, y1, z1).color(color);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color);
 		
-		buffer.vertex(entry, x2, y1, z1).color(color);
-		buffer.vertex(entry, x2, y2, z1).color(color);
-		buffer.vertex(entry, x2, y2, z2).color(color);
-		buffer.vertex(entry, x2, y1, z2).color(color);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color);
 		
-		buffer.vertex(entry, x1, y1, z2).color(color);
-		buffer.vertex(entry, x2, y1, z2).color(color);
-		buffer.vertex(entry, x2, y2, z2).color(color);
-		buffer.vertex(entry, x1, y2, z2).color(color);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color);
 		
-		buffer.vertex(entry, x1, y1, z1).color(color);
-		buffer.vertex(entry, x1, y1, z2).color(color);
-		buffer.vertex(entry, x1, y2, z2).color(color);
-		buffer.vertex(entry, x1, y2, z1).color(color);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color);
 	}
 	
-	public static void drawOutlinedOctahedrons(MatrixStack matrices,
-		List<Box> boxes, int color, boolean depthTest)
+	public static void drawOutlinedOctahedrons(PoseStack matrices,
+		List<AABB> boxes, int color, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
-		for(Box box : boxes)
+		for(AABB box : boxes)
 		{
 			if(overlay && !NiceWurstModule.shouldRenderTarget(box.getCenter()))
 				continue;
 			
-			drawOutlinedOctahedron(matrices, buffer, box.offset(camOffset),
+			drawOutlinedOctahedron(matrices, buffer, box.move(camOffset),
 				color);
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedOctahedrons(MatrixStack matrices,
+	public static void drawOutlinedOctahedrons(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredBox box : boxes)
 		{
@@ -497,51 +501,51 @@ public enum RenderUtils
 				&& !NiceWurstModule.shouldRenderTarget(box.box().getCenter()))
 				continue;
 			
-			drawOutlinedOctahedron(matrices, buffer,
-				box.box().offset(camOffset), box.color());
+			drawOutlinedOctahedron(matrices, buffer, box.box().move(camOffset),
+				box.color());
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawSolidOctahedrons(MatrixStack matrices,
-		List<Box> boxes, int color, boolean depthTest)
+	public static void drawSolidOctahedrons(PoseStack matrices,
+		List<AABB> boxes, int color, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getQuads(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getQuads(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
-		for(Box box : boxes)
+		for(AABB box : boxes)
 		{
 			if(overlay && !NiceWurstModule.shouldRenderTarget(box.getCenter()))
 				continue;
 			
-			drawSolidOctahedron(matrices, buffer, box.offset(camOffset), color);
+			drawSolidOctahedron(matrices, buffer, box.move(camOffset), color);
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawSolidOctahedrons(MatrixStack matrices,
+	public static void drawSolidOctahedrons(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getQuads(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getQuads(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredBox box : boxes)
 		{
@@ -549,25 +553,25 @@ public enum RenderUtils
 				&& !NiceWurstModule.shouldRenderTarget(box.box().getCenter()))
 				continue;
 			
-			drawSolidOctahedron(matrices, buffer, box.box().offset(camOffset),
+			drawSolidOctahedron(matrices, buffer, box.box().move(camOffset),
 				box.color());
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedOctahedron(VertexConsumer buffer, Box box,
+	public static void drawOutlinedOctahedron(VertexConsumer buffer, AABB box,
 		int color)
 	{
-		drawOutlinedOctahedron(new MatrixStack(), buffer, box, color);
+		drawOutlinedOctahedron(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawOutlinedOctahedron(MatrixStack matrices,
-		VertexConsumer buffer, Box box, int color)
+	public static void drawOutlinedOctahedron(PoseStack matrices,
+		VertexConsumer buffer, AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -600,16 +604,16 @@ public enum RenderUtils
 		putLine(entry, buffer, south, east, color);
 	}
 	
-	public static void drawSolidOctahedron(VertexConsumer buffer, Box box,
+	public static void drawSolidOctahedron(VertexConsumer buffer, AABB box,
 		int color)
 	{
-		drawSolidOctahedron(new MatrixStack(), buffer, box, color);
+		drawSolidOctahedron(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawSolidOctahedron(MatrixStack matrices,
-		VertexConsumer buffer, Box box, int color)
+	public static void drawSolidOctahedron(PoseStack matrices,
+		VertexConsumer buffer, AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -639,7 +643,7 @@ public enum RenderUtils
 		putTriangle(entry, buffer, center, bottom, east, south, color);
 	}
 	
-	private static void putLine(MatrixStack.Entry entry, VertexConsumer buffer,
+	private static void putLine(PoseStack.Pose entry, VertexConsumer buffer,
 		Vector3f from, Vector3f to, int color)
 	{
 		Vector3f normal = new Vector3f(to).sub(from);
@@ -652,9 +656,8 @@ public enum RenderUtils
 		putVertex(entry, buffer, to, normal, color);
 	}
 	
-	private static void putTriangle(MatrixStack.Entry entry,
-		VertexConsumer buffer, Vector3f center, Vector3f v1, Vector3f v2,
-		Vector3f v3, int color)
+	private static void putTriangle(PoseStack.Pose entry, VertexConsumer buffer,
+		Vector3f center, Vector3f v1, Vector3f v2, Vector3f v3, int color)
 	{
 		Vector3f normal =
 			new Vector3f(v2).sub(v1).cross(new Vector3f(v3).sub(v1));
@@ -674,14 +677,14 @@ public enum RenderUtils
 		putVertex(entry, buffer, v3, normal, color);
 	}
 	
-	private static void putVertex(MatrixStack.Entry entry,
-		VertexConsumer buffer, Vector3f pos, Vector3f normal, int color)
+	private static void putVertex(PoseStack.Pose entry, VertexConsumer buffer,
+		Vector3f pos, Vector3f normal, int color)
 	{
-		buffer.vertex(entry, pos.x(), pos.y(), pos.z()).color(color)
-			.normal(entry, normal.x(), normal.y(), normal.z());
+		buffer.addVertex(entry, pos.x(), pos.y(), pos.z()).setColor(color)
+			.setNormal(entry, normal.x(), normal.y(), normal.z());
 	}
 	
-	public static void drawOutlinedBox(MatrixStack matrices, Box box, int color,
+	public static void drawOutlinedBox(PoseStack matrices, AABB box, int color,
 		boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
@@ -690,52 +693,52 @@ public enum RenderUtils
 		
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		drawOutlinedBox(matrices, buffer, box.offset(getCameraPos().negate()),
+		drawOutlinedBox(matrices, buffer, box.move(getCameraPos().reverse()),
 			color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedBoxes(MatrixStack matrices, List<Box> boxes,
+	public static void drawOutlinedBoxes(PoseStack matrices, List<AABB> boxes,
 		int color, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
-		for(Box box : boxes)
+		for(AABB box : boxes)
 		{
 			if(overlay && !NiceWurstModule.shouldRenderTarget(box.getCenter()))
 				continue;
 			
-			drawOutlinedBox(matrices, buffer, box.offset(camOffset), color);
+			drawOutlinedBox(matrices, buffer, box.move(camOffset), color);
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedBoxes(MatrixStack matrices,
+	public static void drawOutlinedBoxes(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest)
 	{
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredBox box : boxes)
 		{
@@ -743,16 +746,16 @@ public enum RenderUtils
 				&& !NiceWurstModule.shouldRenderTarget(box.box().getCenter()))
 				continue;
 			
-			drawOutlinedBox(matrices, buffer, box.box().offset(camOffset),
+			drawOutlinedBox(matrices, buffer, box.box().move(camOffset),
 				box.color());
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedBoxes(MatrixStack matrices,
+	public static void drawOutlinedBoxes(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest, double lineWidth)
 	{
 		if(boxes == null || boxes.isEmpty())
@@ -761,11 +764,11 @@ public enum RenderUtils
 		boolean overlay = NiceWurstModule.shouldOverlayEntityShapes();
 		if(!overlay)
 			depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest, lineWidth);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest, lineWidth);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		boolean rendered = false;
 		for(ColoredBox box : boxes)
 		{
@@ -773,25 +776,25 @@ public enum RenderUtils
 				&& !NiceWurstModule.shouldRenderTarget(box.box().getCenter()))
 				continue;
 			
-			drawOutlinedBox(matrices, buffer, box.box().offset(camOffset),
+			drawOutlinedBox(matrices, buffer, box.box().move(camOffset),
 				box.color());
 			rendered = true;
 		}
 		
 		if(rendered)
-			vcp.draw(layer);
+			vcp.endBatch(layer);
 	}
 	
-	public static void drawOutlinedBox(VertexConsumer buffer, Box box,
+	public static void drawOutlinedBox(VertexConsumer buffer, AABB box,
 		int color)
 	{
-		drawOutlinedBox(new MatrixStack(), buffer, box, color);
+		drawOutlinedBox(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawOutlinedBox(MatrixStack matrices,
-		VertexConsumer buffer, Box box, int color)
+	public static void drawOutlinedBox(PoseStack matrices,
+		VertexConsumer buffer, AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -800,90 +803,114 @@ public enum RenderUtils
 		float z2 = (float)box.maxZ;
 		
 		// bottom lines
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, 1, 0, 0);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, 1,
+			0, 0);
 		
 		// top lines
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 0, 0, 1);
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, 1, 0, 0);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 1, 0, 0);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 0,
+			0, 1);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, 1,
+			0, 0);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 1,
+			0, 0);
 		
 		// side lines
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, 0, 1, 0);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 0, 1, 0);
-	}
-	
-	public static void drawCrossBox(MatrixStack matrices, Box box, int color,
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, 0,
+			1, 0);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 0,
+			1, 0);
+	}
+	
+	public static void drawCrossBox(PoseStack matrices, AABB box, int color,
 		boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		drawCrossBox(matrices, buffer, box.offset(getCameraPos().negate()),
+		drawCrossBox(matrices, buffer, box.move(getCameraPos().reverse()),
 			color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawCrossBoxes(MatrixStack matrices, List<Box> boxes,
+	public static void drawCrossBoxes(PoseStack matrices, List<AABB> boxes,
 		int color, boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
-		for(Box box : boxes)
-			drawCrossBox(matrices, buffer, box.offset(camOffset), color);
+		Vec3 camOffset = getCameraPos().reverse();
+		for(AABB box : boxes)
+			drawCrossBox(matrices, buffer, box.move(camOffset), color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawCrossBoxes(MatrixStack matrices,
+	public static void drawCrossBoxes(PoseStack matrices,
 		List<ColoredBox> boxes, boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		for(ColoredBox box : boxes)
-			drawCrossBox(matrices, buffer, box.box().offset(camOffset),
+			drawCrossBox(matrices, buffer, box.box().move(camOffset),
 				box.color());
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawCrossBox(VertexConsumer buffer, Box box, int color)
+	public static void drawCrossBox(VertexConsumer buffer, AABB box, int color)
 	{
-		drawCrossBox(new MatrixStack(), buffer, box, color);
+		drawCrossBox(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawCrossBox(MatrixStack matrices, VertexConsumer buffer,
-		Box box, int color)
+	public static void drawCrossBox(PoseStack matrices, VertexConsumer buffer,
+		AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -892,94 +919,117 @@ public enum RenderUtils
 		float z2 = (float)box.maxZ;
 		
 		// back
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 1, 1, 0);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 1, 1, 0);
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, -1, 1, 0);
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, -1, 1, 0);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 1,
+			1, 0);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 1,
+			1, 0);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, -1,
+			1, 0);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, -1,
+			1, 0);
 		
 		// left
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, 0, 1, 1);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 0, 1, 1);
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, 0, 1, -1);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 0, 1, -1);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, 0,
+			1, 1);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 0,
+			1, 1);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, 0,
+			1, -1);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 0,
+			1, -1);
 		
 		// front
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, -1, 1, 0);
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, -1, 1, 0);
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, 1, 1, 0);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 1, 1, 0);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, -1,
+			1, 0);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, -1,
+			1, 0);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, 1,
+			1, 0);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 1,
+			1, 0);
 		
 		// right
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, 0, 1, -1);
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, 0, 1, -1);
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 0, 1, 1);
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, 0, 1, 1);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, 0,
+			1, -1);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, 0,
+			1, -1);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 0,
+			1, 1);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, 0,
+			1, 1);
 		
 		// top
-		buffer.vertex(entry, x1, y2, z2).color(color).normal(entry, 1, 0, -1);
-		buffer.vertex(entry, x2, y2, z1).color(color).normal(entry, 1, 0, -1);
-		buffer.vertex(entry, x1, y2, z1).color(color).normal(entry, 1, 0, 1);
-		buffer.vertex(entry, x2, y2, z2).color(color).normal(entry, 1, 0, 1);
+		buffer.addVertex(entry, x1, y2, z2).setColor(color).setNormal(entry, 1,
+			0, -1);
+		buffer.addVertex(entry, x2, y2, z1).setColor(color).setNormal(entry, 1,
+			0, -1);
+		buffer.addVertex(entry, x1, y2, z1).setColor(color).setNormal(entry, 1,
+			0, 1);
+		buffer.addVertex(entry, x2, y2, z2).setColor(color).setNormal(entry, 1,
+			0, 1);
 		
 		// bottom
-		buffer.vertex(entry, x2, y1, z1).color(color).normal(entry, -1, 0, 1);
-		buffer.vertex(entry, x1, y1, z2).color(color).normal(entry, -1, 0, 1);
-		buffer.vertex(entry, x1, y1, z1).color(color).normal(entry, 1, 0, 1);
-		buffer.vertex(entry, x2, y1, z2).color(color).normal(entry, 1, 0, 1);
+		buffer.addVertex(entry, x2, y1, z1).setColor(color).setNormal(entry, -1,
+			0, 1);
+		buffer.addVertex(entry, x1, y1, z2).setColor(color).setNormal(entry, -1,
+			0, 1);
+		buffer.addVertex(entry, x1, y1, z1).setColor(color).setNormal(entry, 1,
+			0, 1);
+		buffer.addVertex(entry, x2, y1, z2).setColor(color).setNormal(entry, 1,
+			0, 1);
 	}
 	
-	public static void drawNode(MatrixStack matrices, Box box, int color,
+	public static void drawNode(PoseStack matrices, AABB box, int color,
 		boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		drawNode(matrices, buffer, box.offset(getCameraPos().negate()), color);
+		drawNode(matrices, buffer, box.move(getCameraPos().reverse()), color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawNodes(MatrixStack matrices, List<Box> boxes,
+	public static void drawNodes(PoseStack matrices, List<AABB> boxes,
 		int color, boolean depthTest)
 	{
 		depthTest = NiceWurstModule.enforceDepthTest(depthTest);
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
-		for(Box box : boxes)
-			drawNode(matrices, buffer, box.offset(camOffset), color);
+		Vec3 camOffset = getCameraPos().reverse();
+		for(AABB box : boxes)
+			drawNode(matrices, buffer, box.move(camOffset), color);
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawNodes(MatrixStack matrices, List<ColoredBox> boxes,
+	public static void drawNodes(PoseStack matrices, List<ColoredBox> boxes,
 		boolean depthTest)
 	{
-		VertexConsumerProvider.Immediate vcp = getVCP();
-		RenderLayer layer = WurstRenderLayers.getLines(depthTest);
+		MultiBufferSource.BufferSource vcp = getVCP();
+		RenderType layer = WurstRenderLayers.getLines(depthTest);
 		VertexConsumer buffer = vcp.getBuffer(layer);
 		
-		Vec3d camOffset = getCameraPos().negate();
+		Vec3 camOffset = getCameraPos().reverse();
 		for(ColoredBox box : boxes)
-			drawNode(matrices, buffer, box.box().offset(camOffset),
-				box.color());
+			drawNode(matrices, buffer, box.box().move(camOffset), box.color());
 		
-		vcp.draw(layer);
+		vcp.endBatch(layer);
 	}
 	
-	public static void drawNode(VertexConsumer buffer, Box box, int color)
+	public static void drawNode(VertexConsumer buffer, AABB box, int color)
 	{
-		drawNode(new MatrixStack(), buffer, box, color);
+		drawNode(new PoseStack(), buffer, box, color);
 	}
 	
-	public static void drawNode(MatrixStack matrices, VertexConsumer buffer,
-		Box box, int color)
+	public static void drawNode(PoseStack matrices, VertexConsumer buffer,
+		AABB box, int color)
 	{
-		MatrixStack.Entry entry = matrices.peek();
+		PoseStack.Pose entry = matrices.last();
 		float x1 = (float)box.minX;
 		float y1 = (float)box.minY;
 		float z1 = (float)box.minZ;
@@ -1009,26 +1059,26 @@ public enum RenderUtils
 		drawLine(entry, buffer, x3, y1, z3, x3, y3, z2, color);
 	}
 	
-	public static void drawArrow(MatrixStack matrices, VertexConsumer buffer,
+	public static void drawArrow(PoseStack matrices, VertexConsumer buffer,
 		BlockPos from, BlockPos to, RegionPos region, int color)
 	{
-		Vec3d fromVec = from.toCenterPos().subtract(region.x(), 0, region.z());
-		Vec3d toVec = to.toCenterPos().subtract(region.x(), 0, region.z());
+		Vec3 fromVec = from.getCenter().subtract(region.x(), 0, region.z());
+		Vec3 toVec = to.getCenter().subtract(region.x(), 0, region.z());
 		drawArrow(matrices, buffer, fromVec, toVec, color, 1 / 16F);
 	}
 	
-	public static void drawArrow(VertexConsumer buffer, Vec3d from, Vec3d to,
+	public static void drawArrow(VertexConsumer buffer, Vec3 from, Vec3 to,
 		int color, float headSize)
 	{
-		drawArrow(new MatrixStack(), buffer, from, to, color, headSize);
+		drawArrow(new PoseStack(), buffer, from, to, color, headSize);
 	}
 	
-	public static void drawArrow(MatrixStack matrices, VertexConsumer buffer,
-		Vec3d from, Vec3d to, int color, float headSize)
+	public static void drawArrow(PoseStack matrices, VertexConsumer buffer,
+		Vec3 from, Vec3 to, int color, float headSize)
 	{
-		matrices.push();
-		MatrixStack.Entry entry = matrices.peek();
-		Matrix4f matrix = entry.getPositionMatrix();
+		matrices.pushPose();
+		PoseStack.Pose entry = matrices.last();
+		Matrix4f matrix = entry.pose();
 		
 		// main line
 		drawLine(matrices, buffer, from, to, color);
@@ -1059,13 +1109,13 @@ public enum RenderUtils
 		drawLine(entry, buffer, 0, 0, 0, 0, 2, -1, color);
 		drawLine(entry, buffer, 0, 0, 0, 0, 2, 1, color);
 		
-		matrices.pop();
+		matrices.popPose();
 	}
 	
-	public static void drawItem(DrawContext context, ItemStack stack, int x,
+	public static void drawItem(GuiGraphics context, ItemStack stack, int x,
 		int y, boolean large)
 	{
-		Matrix3x2fStack matrixStack = context.getMatrices();
+		Matrix3x2fStack matrixStack = context.pose();
 		
 		matrixStack.pushMatrix();
 		matrixStack.translate(x, y);
@@ -1077,52 +1127,53 @@ public enum RenderUtils
 		ItemStack renderStack = stack.isEmpty() || stack.getItem() == null
 			? new ItemStack(Blocks.GRASS_BLOCK) : stack;
 		
-		context.drawItem(renderStack, 0, 0);
+		context.renderItem(renderStack, 0, 0);
 		
 		matrixStack.popMatrix();
 		
 		if(stack.isEmpty())
 		{
-			context.state.goUpLayer();
+			context.guiRenderState.up();
 			matrixStack.pushMatrix();
 			matrixStack.translate(x, y);
 			if(large)
 				matrixStack.scale(2, 2);
 			
-			TextRenderer tr = WurstClient.MC.textRenderer;
-			context.drawText(tr, "?", 3, 2, WurstColors.VERY_LIGHT_GRAY, true);
+			Font tr = WurstClient.MC.font;
+			context.drawString(tr, "?", 3, 2, WurstColors.VERY_LIGHT_GRAY,
+				true);
 			
 			matrixStack.popMatrix();
 		}
 	}
 	
 	/**
-	 * Similar to {@link DrawContext#fill(int, int, int, int, int)}, but uses
+	 * Similar to {@link GuiGraphics#fill(int, int, int, int, int)}, but uses
 	 * floating-point coordinates instead of integers.
 	 */
-	public static void fill2D(DrawContext context, float x1, float y1, float x2,
+	public static void fill2D(GuiGraphics context, float x1, float y1, float x2,
 		float y2, int color)
 	{
-		int scale = WurstClient.MC.getWindow().getScaleFactor();
+		int scale = WurstClient.MC.getWindow().getGuiScale();
 		int xs1 = (int)(x1 * scale);
 		int ys1 = (int)(y1 * scale);
 		int xs2 = (int)(x2 * scale);
 		int ys2 = (int)(y2 * scale);
 		
-		context.getMatrices().pushMatrix();
-		context.getMatrices().scale(1F / scale);
+		context.pose().pushMatrix();
+		context.pose().scale(1F / scale);
 		context.fill(xs1, ys1, xs2, ys2, color);
-		context.getMatrices().popMatrix();
+		context.pose().popMatrix();
 	}
 	
 	/**
 	 * Renders the given vertices in QUADS draw mode.
 	 */
-	public static void fillQuads2D(DrawContext context, float[][] vertices,
+	public static void fillQuads2D(GuiGraphics context, float[][] vertices,
 		int color)
 	{
-		Matrix3x2f pose = new Matrix3x2f(context.getMatrices());
-		ScreenRect scissor = context.scissorStack.peekLast();
+		Matrix3x2f pose = new Matrix3x2f(context.pose());
+		ScreenRectangle scissor = context.scissorStack.peek();
 		
 		for(int i = 0; i < vertices.length - 3; i += 4)
 		{
@@ -1138,8 +1189,8 @@ public enum RenderUtils
 			float x4 = vertices[i + 3][0];
 			float y4 = vertices[i + 3][1];
 			
-			context.state.addSimpleElement(new CustomQuadRenderState(pose, x1,
-				y1, x2, y2, x3, y3, x4, y4, color, scissor));
+			context.guiRenderState.submitGuiElement(new CustomQuadRenderState(
+				pose, x1, y1, x2, y2, x3, y3, x4, y4, color, scissor));
 		}
 	}
 	
@@ -1150,11 +1201,11 @@ public enum RenderUtils
 	 * <p>
 	 * ...blame Vibrant Visuals.
 	 */
-	public static void fillTriangle2D(DrawContext context, float[][] vertices,
+	public static void fillTriangle2D(GuiGraphics context, float[][] vertices,
 		int color)
 	{
-		Matrix3x2f pose = new Matrix3x2f(context.getMatrices());
-		ScreenRect scissor = context.scissorStack.peekLast();
+		Matrix3x2f pose = new Matrix3x2f(context.pose());
+		ScreenRectangle scissor = context.scissorStack.peek();
 		
 		for(int i = 0; i < vertices.length - 2; i += 3)
 		{
@@ -1168,64 +1219,64 @@ public enum RenderUtils
 			float x3 = vertices[i + 2][0];
 			float y3 = vertices[i + 2][1];
 			
-			context.state.addSimpleElement(new CustomQuadRenderState(pose, x1,
-				y1, x2, y2, x3, y3, x3, y3, color, scissor));
+			context.guiRenderState.submitGuiElement(new CustomQuadRenderState(
+				pose, x1, y1, x2, y2, x3, y3, x3, y3, color, scissor));
 		}
 	}
 	
 	/**
-	 * Similar to {@link DrawContext#drawHorizontalLine(int, int, int, int)} and
-	 * {@link DrawContext#drawVerticalLine(int, int, int, int)}, but supports
+	 * Similar to {@link GuiGraphics#hLine(int, int, int, int)} and
+	 * {@link GuiGraphics#vLine(int, int, int, int)}, but supports
 	 * diagonal lines, uses floating-point coordinates instead of integers, and
 	 * is one actual pixel wide instead of one scaled pixel.
 	 */
-	public static void drawLine2D(DrawContext context, float x1, float y1,
+	public static void drawLine2D(GuiGraphics context, float x1, float y1,
 		float x2, float y2, int color)
 	{
-		int scale = WurstClient.MC.getWindow().getScaleFactor();
+		int scale = WurstClient.MC.getWindow().getGuiScale();
 		float x = x1 * scale;
 		float y = y1 * scale;
 		float w = (x2 - x1) * scale;
 		float h = (y2 - y1) * scale;
-		float angle = (float)MathHelper.atan2(h, w);
-		int length = Math.round(MathHelper.sqrt(w * w + h * h));
+		float angle = (float)Mth.atan2(h, w);
+		int length = Math.round(Mth.sqrt(w * w + h * h));
 		
-		context.getMatrices().pushMatrix();
-		context.getMatrices().scale(1F / scale);
-		context.getMatrices().translate(x, y);
-		context.getMatrices().rotate(angle);
-		context.getMatrices().translate(-0.5F, -0.5F);
-		context.drawHorizontalLine(0, length - 1, 0, color);
-		context.getMatrices().popMatrix();
+		context.pose().pushMatrix();
+		context.pose().scale(1F / scale);
+		context.pose().translate(x, y);
+		context.pose().rotate(angle);
+		context.pose().translate(-0.5F, -0.5F);
+		context.hLine(0, length - 1, 0, color);
+		context.pose().popMatrix();
 	}
 	
 	/**
-	 * Similar to {@link DrawContext#drawBorder(int, int, int, int, int)}, but
+	 * Similar to {@link GuiGraphics#drawBorder(int, int, int, int, int)}, but
 	 * uses floating-point coordinates instead of integers, and is one actual
 	 * pixel wide instead of one scaled pixel.
 	 */
-	public static void drawBorder2D(DrawContext context, float x1, float y1,
+	public static void drawBorder2D(GuiGraphics context, float x1, float y1,
 		float x2, float y2, int color)
 	{
-		int scale = WurstClient.MC.getWindow().getScaleFactor();
+		int scale = WurstClient.MC.getWindow().getGuiScale();
 		int x = (int)(x1 * scale);
 		int y = (int)(y1 * scale);
 		int w = (int)((x2 - x1) * scale);
 		int h = (int)((y2 - y1) * scale);
 		
-		context.getMatrices().pushMatrix();
-		context.getMatrices().scale(1F / scale);
-		context.drawHorizontalLine(x, x + w - 1, y, color);
-		context.drawHorizontalLine(x, x + w - 1, y + h - 1, color);
-		context.drawVerticalLine(x, y + 1, y + h - 1, color);
-		context.drawVerticalLine(x + w - 1, y + 1, y + h - 1, color);
-		context.getMatrices().popMatrix();
+		context.pose().pushMatrix();
+		context.pose().scale(1F / scale);
+		context.hLine(x, x + w - 1, y, color);
+		context.hLine(x, x + w - 1, y + h - 1, color);
+		context.vLine(x, y + 1, y + h - 1, color);
+		context.vLine(x + w - 1, y + 1, y + h - 1, color);
+		context.pose().popMatrix();
 	}
 	
 	/**
 	 * Draws a 1px border around the given polygon.
 	 */
-	public static void drawLineStrip2D(DrawContext context, float[][] vertices,
+	public static void drawLineStrip2D(GuiGraphics context, float[][] vertices,
 		int color)
 	{
 		if(vertices.length < 2)
@@ -1242,7 +1293,7 @@ public enum RenderUtils
 	/**
 	 * Draws a box shadow around the given rectangle.
 	 */
-	public static void drawBoxShadow2D(DrawContext context, int x1, int y1,
+	public static void drawBoxShadow2D(GuiGraphics context, int x1, int y1,
 		int x2, int y2)
 	{
 		float[] acColor = WurstClient.INSTANCE.getGui().getAcColor();
@@ -1260,61 +1311,61 @@ public enum RenderUtils
 		int shadowColor1 = toIntColor(acColor, 0.75F);
 		int shadowColor2 = 0x00000000;
 		
-		Matrix3x2f pose = new Matrix3x2f(context.getMatrices());
-		ScreenRect scissor = context.scissorStack.peekLast();
+		Matrix3x2f pose = new Matrix3x2f(context.pose());
+		ScreenRectangle scissor = context.scissorStack.peek();
 		
 		// top
-		context.state.addSimpleElement(new CustomQuadRenderState(pose, x1, y1,
-			x2, y1, xs2, ys1, xs1, ys1, shadowColor1, shadowColor1,
+		context.guiRenderState.submitGuiElement(new CustomQuadRenderState(pose,
+			x1, y1, x2, y1, xs2, ys1, xs1, ys1, shadowColor1, shadowColor1,
 			shadowColor2, shadowColor2, scissor));
 		
 		// left
-		context.state.addSimpleElement(new CustomQuadRenderState(pose, xs1, ys1,
-			xs1, ys2, x1, y2, x1, y1, shadowColor2, shadowColor2, shadowColor1,
-			shadowColor1, scissor));
+		context.guiRenderState.submitGuiElement(new CustomQuadRenderState(pose,
+			xs1, ys1, xs1, ys2, x1, y2, x1, y1, shadowColor2, shadowColor2,
+			shadowColor1, shadowColor1, scissor));
 		
 		// right
-		context.state.addSimpleElement(new CustomQuadRenderState(pose, x2, y1,
-			x2, y2, xs2, ys2, xs2, ys1, shadowColor1, shadowColor1,
+		context.guiRenderState.submitGuiElement(new CustomQuadRenderState(pose,
+			x2, y1, x2, y2, xs2, ys2, xs2, ys1, shadowColor1, shadowColor1,
 			shadowColor2, shadowColor2, scissor));
 		
 		// bottom
-		context.state.addSimpleElement(new CustomQuadRenderState(pose, x2, y2,
-			x1, y2, xs1, ys2, xs2, ys2, shadowColor1, shadowColor1,
+		context.guiRenderState.submitGuiElement(new CustomQuadRenderState(pose,
+			x2, y2, x1, y2, xs1, ys2, xs2, ys2, shadowColor1, shadowColor1,
 			shadowColor2, shadowColor2, scissor));
 	}
 	
-	public record ColoredPoint(Vec3d point, int color)
+	public record ColoredPoint(Vec3 point, int color)
 	{}
 	
-	public record ColoredBox(Box box, int color)
+	public record ColoredBox(AABB box, int color)
 	{}
 	
 	/**
 	 * Draw text scaled by the given scale factor.
 	 * This applies a matrix transform so glyphs are scaled.
 	 */
-	public static void drawScaledText(DrawContext context, TextRenderer tr,
-		String text, int x, int y, int color, boolean shadow, double scale)
+	public static void drawScaledText(GuiGraphics context, Font tr, String text,
+		int x, int y, int color, boolean shadow, double scale)
 	{
 		if(text == null || text.isEmpty())
 			return;
 		if(Math.abs(scale - 1.0) < 1e-6)
 		{
-			context.drawText(tr, text, x, y, color, shadow);
+			context.drawString(tr, text, x, y, color, shadow);
 			return;
 		}
 		
 		// push matrix, scale, draw at coordinates adjusted by scale, pop
-		context.getMatrices().pushMatrix();
+		context.pose().pushMatrix();
 		// scale both axes; Z scale = 1
-		context.getMatrices().scale((float)scale);
+		context.pose().scale((float)scale);
 		// When the matrix is scaled by `scale`, coordinates supplied to
 		// drawText
 		// must be divided by `scale` to appear at the intended screen position.
 		int sx = (int)Math.round(x / scale);
 		int sy = (int)Math.round(y / scale);
-		context.drawText(tr, text, sx, sy, color, shadow);
-		context.getMatrices().popMatrix();
+		context.drawString(tr, text, sx, sy, color, shadow);
+		context.pose().popMatrix();
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/Rotation.java b/src/main/java/net/wurstclient/util/Rotation.java
index 83ec605e8..0dac4d024 100644
--- a/src/main/java/net/wurstclient/util/Rotation.java
+++ b/src/main/java/net/wurstclient/util/Rotation.java
@@ -8,48 +8,46 @@
 package net.wurstclient.util;
 
 import org.joml.Quaternionf;
-
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.WurstClient;
 
 public record Rotation(float yaw, float pitch)
 {
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public void applyToClientPlayer()
 	{
 		float adjustedYaw =
-			RotationUtils.limitAngleChange(MC.player.getYaw(), yaw);
-		MC.player.setYaw(adjustedYaw);
-		MC.player.setPitch(pitch);
+			RotationUtils.limitAngleChange(MC.player.getYRot(), yaw);
+		MC.player.setYRot(adjustedYaw);
+		MC.player.setXRot(pitch);
 	}
 	
 	public void sendPlayerLookPacket()
 	{
-		sendPlayerLookPacket(MC.player.isOnGround(),
+		sendPlayerLookPacket(MC.player.onGround(),
 			MC.player.horizontalCollision);
 	}
 	
 	public void sendPlayerLookPacket(boolean onGround,
 		boolean horizontalCollision)
 	{
-		MC.player.networkHandler
-			.sendPacket(new PlayerMoveC2SPacket.LookAndOnGround(yaw, pitch,
-				onGround, horizontalCollision));
+		MC.player.connection.send(new ServerboundMovePlayerPacket.Rot(yaw,
+			pitch, onGround, horizontalCollision));
 	}
 	
 	public double getAngleTo(Rotation other)
 	{
-		float yaw1 = MathHelper.wrapDegrees(yaw);
-		float yaw2 = MathHelper.wrapDegrees(other.yaw);
-		float diffYaw = MathHelper.wrapDegrees(yaw1 - yaw2);
+		float yaw1 = Mth.wrapDegrees(yaw);
+		float yaw2 = Mth.wrapDegrees(other.yaw);
+		float diffYaw = Mth.wrapDegrees(yaw1 - yaw2);
 		
-		float pitch1 = MathHelper.wrapDegrees(pitch);
-		float pitch2 = MathHelper.wrapDegrees(other.pitch);
-		float diffPitch = MathHelper.wrapDegrees(pitch1 - pitch2);
+		float pitch1 = Mth.wrapDegrees(pitch);
+		float pitch2 = Mth.wrapDegrees(other.pitch);
+		float diffPitch = Mth.wrapDegrees(pitch1 - pitch2);
 		
 		return Math.sqrt(diffYaw * diffYaw + diffPitch * diffPitch);
 	}
@@ -64,32 +62,32 @@ public record Rotation(float yaw, float pitch)
 		return new Rotation(yaw, pitch);
 	}
 	
-	public Vec3d toLookVec()
+	public Vec3 toLookVec()
 	{
-		float radPerDeg = MathHelper.RADIANS_PER_DEGREE;
-		float pi = MathHelper.PI;
+		float radPerDeg = Mth.DEG_TO_RAD;
+		float pi = Mth.PI;
 		
-		float adjustedYaw = -MathHelper.wrapDegrees(yaw) * radPerDeg - pi;
-		float cosYaw = MathHelper.cos(adjustedYaw);
-		float sinYaw = MathHelper.sin(adjustedYaw);
+		float adjustedYaw = -Mth.wrapDegrees(yaw) * radPerDeg - pi;
+		float cosYaw = Mth.cos(adjustedYaw);
+		float sinYaw = Mth.sin(adjustedYaw);
 		
-		float adjustedPitch = -MathHelper.wrapDegrees(pitch) * radPerDeg;
-		float nCosPitch = -MathHelper.cos(adjustedPitch);
-		float sinPitch = MathHelper.sin(adjustedPitch);
+		float adjustedPitch = -Mth.wrapDegrees(pitch) * radPerDeg;
+		float nCosPitch = -Mth.cos(adjustedPitch);
+		float sinPitch = Mth.sin(adjustedPitch);
 		
-		return new Vec3d(sinYaw * nCosPitch, sinPitch, cosYaw * nCosPitch);
+		return new Vec3(sinYaw * nCosPitch, sinPitch, cosYaw * nCosPitch);
 	}
 	
 	public Quaternionf toQuaternion()
 	{
-		float radPerDeg = MathHelper.RADIANS_PER_DEGREE;
-		float yawRad = -MathHelper.wrapDegrees(yaw) * radPerDeg;
-		float pitchRad = MathHelper.wrapDegrees(pitch) * radPerDeg;
+		float radPerDeg = Mth.DEG_TO_RAD;
+		float yawRad = -Mth.wrapDegrees(yaw) * radPerDeg;
+		float pitchRad = Mth.wrapDegrees(pitch) * radPerDeg;
 		
-		float sinYaw = MathHelper.sin(yawRad / 2);
-		float cosYaw = MathHelper.cos(yawRad / 2);
-		float sinPitch = MathHelper.sin(pitchRad / 2);
-		float cosPitch = MathHelper.cos(pitchRad / 2);
+		float sinYaw = Mth.sin(yawRad / 2);
+		float cosYaw = Mth.cos(yawRad / 2);
+		float sinPitch = Mth.sin(pitchRad / 2);
+		float cosPitch = Mth.cos(pitchRad / 2);
 		
 		float x = sinPitch * cosYaw;
 		float y = cosPitch * sinYaw;
@@ -101,7 +99,6 @@ public record Rotation(float yaw, float pitch)
 	
 	public static Rotation wrapped(float yaw, float pitch)
 	{
-		return new Rotation(MathHelper.wrapDegrees(yaw),
-			MathHelper.wrapDegrees(pitch));
+		return new Rotation(Mth.wrapDegrees(yaw), Mth.wrapDegrees(pitch));
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/RotationUtils.java b/src/main/java/net/wurstclient/util/RotationUtils.java
index 350f71520..07e3f5448 100644
--- a/src/main/java/net/wurstclient/util/RotationUtils.java
+++ b/src/main/java/net/wurstclient/util/RotationUtils.java
@@ -7,11 +7,11 @@
  */
 package net.wurstclient.util;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.client.network.ClientPlayerEntity;
-import net.minecraft.util.math.Box;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.player.LocalPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
 import net.wurstclient.RotationFaker;
 import net.wurstclient.WurstClient;
 
@@ -19,31 +19,31 @@ public enum RotationUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
-	public static Vec3d getEyesPos()
+	public static Vec3 getEyesPos()
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		float eyeHeight = player.getEyeHeight(player.getPose());
-		return player.getEntityPos().add(0, eyeHeight, 0);
+		return player.position().add(0, eyeHeight, 0);
 	}
 	
-	public static Vec3d getClientLookVec(float partialTicks)
+	public static Vec3 getClientLookVec(float partialTicks)
 	{
-		float yaw = MC.player.getYaw(partialTicks);
-		float pitch = MC.player.getPitch(partialTicks);
+		float yaw = MC.player.getViewYRot(partialTicks);
+		float pitch = MC.player.getViewXRot(partialTicks);
 		return new Rotation(yaw, pitch).toLookVec();
 	}
 	
-	public static Vec3d getServerLookVec()
+	public static Vec3 getServerLookVec()
 	{
 		RotationFaker rf = WurstClient.INSTANCE.getRotationFaker();
 		return new Rotation(rf.getServerYaw(), rf.getServerPitch()).toLookVec();
 	}
 	
-	public static Rotation getNeededRotations(Vec3d vec)
+	public static Rotation getNeededRotations(Vec3 vec)
 	{
-		Vec3d eyes = getEyesPos();
+		Vec3 eyes = getEyesPos();
 		
 		double diffX = vec.x - eyes.x;
 		double diffZ = vec.z - eyes.z;
@@ -56,19 +56,19 @@ public enum RotationUtils
 		return Rotation.wrapped((float)yaw, (float)pitch);
 	}
 	
-	public static double getAngleToLookVec(Vec3d vec)
+	public static double getAngleToLookVec(Vec3 vec)
 	{
-		ClientPlayerEntity player = MC.player;
-		Rotation current = new Rotation(player.getYaw(), player.getPitch());
+		LocalPlayer player = MC.player;
+		Rotation current = new Rotation(player.getYRot(), player.getXRot());
 		Rotation needed = getNeededRotations(vec);
 		return current.getAngleTo(needed);
 	}
 	
-	public static float getHorizontalAngleToLookVec(Vec3d vec)
+	public static float getHorizontalAngleToLookVec(Vec3 vec)
 	{
-		float currentYaw = MathHelper.wrapDegrees(MC.player.getYaw());
+		float currentYaw = Mth.wrapDegrees(MC.player.getYRot());
 		float neededYaw = getNeededRotations(vec).yaw();
-		return MathHelper.wrapDegrees(currentYaw - neededYaw);
+		return Mth.wrapDegrees(currentYaw - neededYaw);
 	}
 	
 	/**
@@ -80,7 +80,7 @@ public enum RotationUtils
 		return getAngleToLastReportedLookVec(rotation) <= 1.0;
 	}
 	
-	public static double getAngleToLastReportedLookVec(Vec3d vec)
+	public static double getAngleToLastReportedLookVec(Vec3 vec)
 	{
 		Rotation needed = getNeededRotations(vec);
 		return getAngleToLastReportedLookVec(needed);
@@ -88,12 +88,12 @@ public enum RotationUtils
 	
 	public static double getAngleToLastReportedLookVec(Rotation rotation)
 	{
-		ClientPlayerEntity player = MC.player;
+		LocalPlayer player = MC.player;
 		
 		// lastYaw/Pitch do not get updated when the player is in a vehicle
-		Rotation lastReported = player.hasVehicle()
-			? new Rotation(player.getYaw(), player.getPitch())
-			: new Rotation(player.lastYawClient, player.lastPitchClient);
+		Rotation lastReported = player.isPassenger()
+			? new Rotation(player.getYRot(), player.getXRot())
+			: new Rotation(player.yRotLast, player.xRotLast);
 		
 		return lastReported.getAngleTo(rotation);
 	}
@@ -102,11 +102,11 @@ public enum RotationUtils
 	 * Returns true if the player is facing anywhere within the given box
 	 * and is no further away than the given range.
 	 */
-	public static boolean isFacingBox(Box box, double range)
+	public static boolean isFacingBox(AABB box, double range)
 	{
-		Vec3d start = getEyesPos();
-		Vec3d end = start.add(getServerLookVec().multiply(range));
-		return box.raycast(start, end).isPresent();
+		Vec3 start = getEyesPos();
+		Vec3 end = start.add(getServerLookVec().scale(range));
+		return box.clip(start, end).isPresent();
 	}
 	
 	/**
@@ -116,14 +116,13 @@ public enum RotationUtils
 	 */
 	public static Rotation slowlyTurnTowards(Rotation end, float maxChange)
 	{
-		float startYaw = MC.player.lastYawClient;
-		float startPitch = MC.player.lastPitchClient;
+		float startYaw = MC.player.yRotLast;
+		float startPitch = MC.player.xRotLast;
 		float endYaw = end.yaw();
 		float endPitch = end.pitch();
 		
-		float yawChange = Math.abs(MathHelper.wrapDegrees(endYaw - startYaw));
-		float pitchChange =
-			Math.abs(MathHelper.wrapDegrees(endPitch - startPitch));
+		float yawChange = Math.abs(Mth.wrapDegrees(endYaw - startYaw));
+		float pitchChange = Math.abs(Mth.wrapDegrees(endPitch - startPitch));
 		
 		float maxChangeYaw = pitchChange == 0 ? maxChange
 			: Math.min(maxChange, maxChange * yawChange / pitchChange);
@@ -149,11 +148,11 @@ public enum RotationUtils
 	public static float limitAngleChange(float current, float intended,
 		float maxChange)
 	{
-		float currentWrapped = MathHelper.wrapDegrees(current);
-		float intendedWrapped = MathHelper.wrapDegrees(intended);
+		float currentWrapped = Mth.wrapDegrees(current);
+		float intendedWrapped = Mth.wrapDegrees(intended);
 		
-		float change = MathHelper.wrapDegrees(intendedWrapped - currentWrapped);
-		change = MathHelper.clamp(change, -maxChange, maxChange);
+		float change = Mth.wrapDegrees(intendedWrapped - currentWrapped);
+		change = Mth.clamp(change, -maxChange, maxChange);
 		
 		return current + change;
 	}
@@ -173,10 +172,10 @@ public enum RotationUtils
 	 */
 	public static float limitAngleChange(float current, float intended)
 	{
-		float currentWrapped = MathHelper.wrapDegrees(current);
-		float intendedWrapped = MathHelper.wrapDegrees(intended);
+		float currentWrapped = Mth.wrapDegrees(current);
+		float intendedWrapped = Mth.wrapDegrees(intended);
 		
-		float change = MathHelper.wrapDegrees(intendedWrapped - currentWrapped);
+		float change = Mth.wrapDegrees(intendedWrapped - currentWrapped);
 		
 		return current + change;
 	}
diff --git a/src/main/java/net/wurstclient/util/chunk/AbstractChunkCoordinator.java b/src/main/java/net/wurstclient/util/chunk/AbstractChunkCoordinator.java
index 6d350e5c6..cc020ad7c 100644
--- a/src/main/java/net/wurstclient/util/chunk/AbstractChunkCoordinator.java
+++ b/src/main/java/net/wurstclient/util/chunk/AbstractChunkCoordinator.java
@@ -18,13 +18,12 @@ import java.util.function.BiPredicate;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Stream;
-
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.world.chunk.Chunk;
-import net.minecraft.world.dimension.DimensionType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.dimension.DimensionType;
 import net.wurstclient.WurstClient;
 import net.wurstclient.events.PacketInputListener;
 import net.wurstclient.settings.ChunkAreaSetting;
@@ -52,7 +51,7 @@ public abstract class AbstractChunkCoordinator implements PacketInputListener
 	
 	public boolean update()
 	{
-		DimensionType dimension = WurstClient.MC.world.getDimension();
+		DimensionType dimension = WurstClient.MC.level.dimensionType();
 		HashSet<ChunkPos> chunkUpdates = clearChunksToUpdate();
 		HashMap<ChunkPos, ArrayList<ChunkSearcher.BlockUpdate>> blockUpdates =
 			clearBlockUpdates();
@@ -89,7 +88,7 @@ public abstract class AbstractChunkCoordinator implements PacketInputListener
 		}
 		
 		// add new ChunkSearchers
-		for(Chunk chunk : area.getChunksInRange())
+		for(ChunkAccess chunk : area.getChunksInRange())
 		{
 			ChunkPos chunkPos = chunk.getPos();
 			if(searchers.containsKey(chunkPos))
@@ -216,7 +215,7 @@ public abstract class AbstractChunkCoordinator implements PacketInputListener
 		BlockState state)
 	{
 		pendingBlockUpdates.add(new PendingBlockUpdate(chunkPos,
-			new ChunkSearcher.BlockUpdate(blockPos.toImmutable(), state)));
+			new ChunkSearcher.BlockUpdate(blockPos.immutable(), state)));
 	}
 	
 	protected record PendingBlockUpdate(ChunkPos chunkPos,
diff --git a/src/main/java/net/wurstclient/util/chunk/ChunkSearcher.java b/src/main/java/net/wurstclient/util/chunk/ChunkSearcher.java
index 93a8ed57b..7f27cb110 100644
--- a/src/main/java/net/wurstclient/util/chunk/ChunkSearcher.java
+++ b/src/main/java/net/wurstclient/util/chunk/ChunkSearcher.java
@@ -14,16 +14,15 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutorService;
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.world.chunk.Chunk;
-import net.minecraft.world.dimension.DimensionType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.dimension.DimensionType;
 import net.wurstclient.util.MinPriorityThreadFactory;
 
 /**
- * Searches the given {@link Chunk} for blocks matching the given query.
+ * Searches the given {@link ChunkAccess} for blocks matching the given query.
  */
 public final class ChunkSearcher
 {
@@ -31,7 +30,7 @@ public final class ChunkSearcher
 		MinPriorityThreadFactory.newFixedThreadPool();
 	
 	private final BiPredicate<BlockPos, BlockState> query;
-	private final Chunk chunk;
+	private final ChunkAccess chunk;
 	private final DimensionType dimension;
 	
 	private CompletableFuture<ArrayList<Result>> future;
@@ -39,8 +38,8 @@ public final class ChunkSearcher
 	private volatile ArrayList<Result> results;
 	private ArrayList<BlockUpdate> pendingUpdates;
 	
-	public ChunkSearcher(BiPredicate<BlockPos, BlockState> query, Chunk chunk,
-		DimensionType dimension)
+	public ChunkSearcher(BiPredicate<BlockPos, BlockState> query,
+		ChunkAccess chunk, DimensionType dimension)
 	{
 		this.query = query;
 		this.chunk = chunk;
@@ -61,12 +60,12 @@ public final class ChunkSearcher
 		ArrayList<Result> results = new ArrayList<>();
 		ChunkPos chunkPos = chunk.getPos();
 		
-		int minX = chunkPos.getStartX();
-		int minY = chunk.getBottomY();
-		int minZ = chunkPos.getStartZ();
-		int maxX = chunkPos.getEndX();
+		int minX = chunkPos.getMinBlockX();
+		int minY = chunk.getMinY();
+		int minZ = chunkPos.getMinBlockZ();
+		int maxX = chunkPos.getMaxBlockX();
 		int maxY = ChunkUtils.getHighestNonEmptySectionYOffset(chunk) + 16;
-		int maxZ = chunkPos.getEndZ();
+		int maxZ = chunkPos.getMaxBlockZ();
 		
 		for(int x = minX; x <= maxX; x++)
 			for(int y = minY; y <= maxY; y++)
@@ -80,7 +79,7 @@ public final class ChunkSearcher
 					if(!query.test(pos, state))
 						continue;
 					
-					results.add(new Result(pos.toImmutable(), state));
+					results.add(new Result(pos.immutable(), state));
 				}
 			
 		return results;
diff --git a/src/main/java/net/wurstclient/util/chunk/ChunkSearcherCoordinator.java b/src/main/java/net/wurstclient/util/chunk/ChunkSearcherCoordinator.java
index 0e4044bfd..37535df72 100644
--- a/src/main/java/net/wurstclient/util/chunk/ChunkSearcherCoordinator.java
+++ b/src/main/java/net/wurstclient/util/chunk/ChunkSearcherCoordinator.java
@@ -9,13 +9,12 @@ package net.wurstclient.util.chunk;
 
 import java.util.function.BiPredicate;
 import java.util.stream.Stream;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.network.packet.Packet;
-import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.settings.ChunkAreaSetting;
 import net.wurstclient.util.chunk.ChunkSearcher.Result;
 
@@ -37,17 +36,18 @@ public final class ChunkSearcherCoordinator extends AbstractChunkCoordinator
 	{
 		Packet<?> packet = event.getPacket();
 		
-		if(packet instanceof BlockUpdateS2CPacket blockUpdate)
+		if(packet instanceof ClientboundBlockUpdatePacket blockUpdate)
 		{
 			BlockPos pos = blockUpdate.getPos();
-			enqueueBlockUpdate(new ChunkPos(pos), pos, blockUpdate.getState());
+			enqueueBlockUpdate(new ChunkPos(pos), pos,
+				blockUpdate.getBlockState());
 			return;
 		}
 		
-		if(packet instanceof ChunkDeltaUpdateS2CPacket deltaUpdate)
+		if(packet instanceof ClientboundSectionBlocksUpdatePacket deltaUpdate)
 		{
-			ChunkPos chunkPos = deltaUpdate.sectionPos.toChunkPos();
-			deltaUpdate.visitUpdates(
+			ChunkPos chunkPos = deltaUpdate.sectionPos.chunk();
+			deltaUpdate.runUpdates(
 				(pos, state) -> enqueueBlockUpdate(chunkPos, pos, state));
 			return;
 		}
diff --git a/src/main/java/net/wurstclient/util/chunk/ChunkUtils.java b/src/main/java/net/wurstclient/util/chunk/ChunkUtils.java
index 53a587fc3..bfee735a4 100644
--- a/src/main/java/net/wurstclient/util/chunk/ChunkUtils.java
+++ b/src/main/java/net/wurstclient/util/chunk/ChunkUtils.java
@@ -9,24 +9,23 @@ package net.wurstclient.util.chunk;
 
 import java.util.Objects;
 import java.util.stream.Stream;
-
-import net.minecraft.block.entity.BlockEntity;
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.network.packet.Packet;
-import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
-import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
-import net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket;
-import net.minecraft.util.math.ChunkPos;
-import net.minecraft.util.math.ChunkSectionPos;
-import net.minecraft.world.chunk.Chunk;
-import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.wurstclient.WurstClient;
 
 public enum ChunkUtils
 {
 	;
 	
-	private static final MinecraftClient MC = WurstClient.MC;
+	private static final Minecraft MC = WurstClient.MC;
 	
 	public static Stream<BlockEntity> getLoadedBlockEntities()
 	{
@@ -41,8 +40,9 @@ public enum ChunkUtils
 	
 	/**
 	 * Returns the position of the chunk affected by the given
-	 * {@link BlockUpdateS2CPacket}, {@link ChunkDeltaUpdateS2CPacket}, or
-	 * {@link ChunkDataS2CPacket}.
+	 * {@link ClientboundBlockUpdatePacket},
+	 * {@link ClientboundSectionBlocksUpdatePacket}, or
+	 * {@link ClientboundLevelChunkWithLightPacket}.
 	 *
 	 * <p>
 	 * Returns <code>null</code> if the given packet is of a different type than
@@ -50,26 +50,26 @@ public enum ChunkUtils
 	 */
 	public static ChunkPos getAffectedChunk(Packet<?> packet)
 	{
-		if(packet instanceof BlockUpdateS2CPacket p)
+		if(packet instanceof ClientboundBlockUpdatePacket p)
 			return new ChunkPos(p.getPos());
-		if(packet instanceof ChunkDeltaUpdateS2CPacket p)
-			return p.sectionPos.toChunkPos();
-		if(packet instanceof ChunkDataS2CPacket p)
-			return new ChunkPos(p.getChunkX(), p.getChunkZ());
+		if(packet instanceof ClientboundSectionBlocksUpdatePacket p)
+			return p.sectionPos.chunk();
+		if(packet instanceof ClientboundLevelChunkWithLightPacket p)
+			return new ChunkPos(p.getX(), p.getZ());
 		
 		return null;
 	}
 	
-	public static Stream<WorldChunk> getLoadedChunks()
+	public static Stream<LevelChunk> getLoadedChunks()
 	{
-		int radius = Math.max(2, MC.options.getClampedViewDistance()) + 3;
+		int radius = Math.max(2, MC.options.getEffectiveRenderDistance()) + 3;
 		int diameter = radius * 2 + 1;
 		
-		ChunkPos center = MC.player.getChunkPos();
+		ChunkPos center = MC.player.chunkPosition();
 		ChunkPos min = new ChunkPos(center.x - radius, center.z - radius);
 		ChunkPos max = new ChunkPos(center.x + radius, center.z + radius);
 		
-		Stream<WorldChunk> stream = Stream.<ChunkPos> iterate(min, pos -> {
+		Stream<LevelChunk> stream = Stream.<ChunkPos> iterate(min, pos -> {
 			
 			int x = pos.x;
 			int z = pos.z;
@@ -87,9 +87,8 @@ public enum ChunkUtils
 			
 			return new ChunkPos(x, z);
 			
-		}).limit(diameter * diameter)
-			.filter(c -> MC.world.isChunkLoaded(c.x, c.z))
-			.map(c -> MC.world.getChunk(c.x, c.z)).filter(Objects::nonNull);
+		}).limit(diameter * diameter).filter(c -> MC.level.hasChunk(c.x, c.z))
+			.map(c -> MC.level.getChunk(c.x, c.z)).filter(Objects::nonNull);
 		
 		return stream;
 	}
@@ -99,16 +98,17 @@ public enum ChunkUtils
 	 *
 	 * <p>
 	 * This is a re-implementation of
-	 * {@link Chunk#getHighestNonEmptySectionYOffset()}, which has been
+	 * {@link ChunkAccess#getHighestSectionPosition()}, which has been
 	 * deprecated and marked for removal in 23w17a with no apparent replacement
 	 * provided by Mojang.
 	 */
-	public static int getHighestNonEmptySectionYOffset(Chunk chunk)
+	public static int getHighestNonEmptySectionYOffset(ChunkAccess chunk)
 	{
-		int i = chunk.getHighestNonEmptySection();
+		int i = chunk.getHighestFilledSectionIndex();
 		if(i == -1)
-			return chunk.getBottomY();
+			return chunk.getMinY();
 		
-		return ChunkSectionPos.getBlockCoord(chunk.sectionIndexToCoord(i));
+		return SectionPos
+			.sectionToBlockCoord(chunk.getSectionYFromSectionIndex(i));
 	}
 }
diff --git a/src/main/java/net/wurstclient/util/chunk/ChunkVertexBufferCoordinator.java b/src/main/java/net/wurstclient/util/chunk/ChunkVertexBufferCoordinator.java
index c0749c0fe..7206b60fa 100644
--- a/src/main/java/net/wurstclient/util/chunk/ChunkVertexBufferCoordinator.java
+++ b/src/main/java/net/wurstclient/util/chunk/ChunkVertexBufferCoordinator.java
@@ -14,14 +14,12 @@ import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.BiPredicate;
-
+import com.mojang.blaze3d.vertex.VertexConsumer;
 import com.mojang.blaze3d.vertex.VertexFormat;
-import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
-
-import net.minecraft.block.BlockState;
-import net.minecraft.client.render.VertexConsumer;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.ChunkPos;
+import com.mojang.blaze3d.vertex.VertexFormat.Mode;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.wurstclient.settings.ChunkAreaSetting;
 import net.wurstclient.util.EasyVertexBuffer;
 import net.wurstclient.util.chunk.ChunkSearcher.Result;
@@ -30,11 +28,11 @@ public final class ChunkVertexBufferCoordinator extends AbstractChunkCoordinator
 {
 	private final HashMap<ChunkPos, EasyVertexBuffer> buffers = new HashMap<>();
 	private final Renderer renderer;
-	private final DrawMode drawMode;
+	private final Mode drawMode;
 	private final VertexFormat format;
 	
 	public ChunkVertexBufferCoordinator(BiPredicate<BlockPos, BlockState> query,
-		DrawMode drawMode, VertexFormat format, Renderer renderer,
+		Mode drawMode, VertexFormat format, Renderer renderer,
 		ChunkAreaSetting area)
 	{
 		super(query, area);
diff --git a/src/main/java/net/wurstclient/util/text/WText.java b/src/main/java/net/wurstclient/util/text/WText.java
index aca366638..4c3694542 100644
--- a/src/main/java/net/wurstclient/util/text/WText.java
+++ b/src/main/java/net/wurstclient/util/text/WText.java
@@ -8,17 +8,16 @@
 package net.wurstclient.util.text;
 
 import java.util.ArrayList;
-
+import net.minecraft.network.chat.Component;
 import com.google.common.collect.Lists;
 
-import net.minecraft.text.Text;
-
 /**
  * Allows you to build more complex text out of multiple Wurst translations and
  * have everything update automatically when the user's language changes.
  *
  * <p>
- * This is necessary because Minecraft's {@link Text} does not have access to
+ * This is necessary because Minecraft's {@link Component} does not have access
+ * to
  * Wurst's translations for security reasons.
  */
 public final class WText
diff --git a/src/main/java/net/wurstclient/waypoints/Waypoint.java b/src/main/java/net/wurstclient/waypoints/Waypoint.java
index 5a8fb9a67..0bce22c9c 100644
--- a/src/main/java/net/wurstclient/waypoints/Waypoint.java
+++ b/src/main/java/net/wurstclient/waypoints/Waypoint.java
@@ -8,8 +8,7 @@
 package net.wurstclient.waypoints;
 
 import java.util.UUID;
-
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 
 public final class Waypoint
 {
@@ -55,7 +54,7 @@ public final class Waypoint
 		this.visible = true;
 		this.maxVisible = 5000;
 		this.scale = 1.5;
-		this.pos = BlockPos.ORIGIN;
+		this.pos = BlockPos.ZERO;
 		this.dimension = WaypointDimension.OVERWORLD;
 		this.opposite = false;
 		this.lines = false;
diff --git a/src/main/java/net/wurstclient/waypoints/WaypointsManager.java b/src/main/java/net/wurstclient/waypoints/WaypointsManager.java
index 534c9028b..47f437d93 100644
--- a/src/main/java/net/wurstclient/waypoints/WaypointsManager.java
+++ b/src/main/java/net/wurstclient/waypoints/WaypointsManager.java
@@ -18,15 +18,13 @@ import java.util.Locale;
 import java.util.Set;
 import java.util.UUID;
 import java.util.stream.Stream;
-
+import net.minecraft.client.Minecraft;
+import net.minecraft.core.BlockPos;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 
-import net.minecraft.client.MinecraftClient;
-import net.minecraft.util.math.BlockPos;
-
 public final class WaypointsManager
 {
 	private static final Gson GSON =
@@ -309,10 +307,11 @@ public final class WaypointsManager
 	
 	private Path xaeroRoot()
 	{
-		MinecraftClient client = MinecraftClient.getInstance();
+		Minecraft client = Minecraft.getInstance();
 		if(client == null)
 			return null;
-		return client.runDirectory.toPath().resolve("xaero").resolve("minimap");
+		return client.gameDirectory.toPath().resolve("xaero")
+			.resolve("minimap");
 	}
 	
 	private static List<Path> listDirectories(Path root)
diff --git a/src/main/java/net/wurstclient/waypoints/XaeroWaypointIO.java b/src/main/java/net/wurstclient/waypoints/XaeroWaypointIO.java
index 9afe3a5e5..334928548 100644
--- a/src/main/java/net/wurstclient/waypoints/XaeroWaypointIO.java
+++ b/src/main/java/net/wurstclient/waypoints/XaeroWaypointIO.java
@@ -17,8 +17,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-
-import net.minecraft.util.math.BlockPos;
+import net.minecraft.core.BlockPos;
 
 final class XaeroWaypointIO
 {
diff --git a/src/main/resources/wurst.accesswidener b/src/main/resources/wurst.accesswidener
index c8fa1cc3b..9d0fa1235 100644
--- a/src/main/resources/wurst.accesswidener
+++ b/src/main/resources/wurst.accesswidener
@@ -1,41 +1,41 @@
 accessWidener	v1	named
-accessible	class	net/minecraft/client/gui/DrawContext$ScissorStack
-accessible	method	net/minecraft/client/gl/RenderPipelines	register	(Lcom/mojang/blaze3d/pipeline/RenderPipeline;)Lcom/mojang/blaze3d/pipeline/RenderPipeline;
-accessible	method	net/minecraft/client/gui/screen/ingame/HandledScreen onMouseClick	(Lnet/minecraft/screen/slot/Slot;IILnet/minecraft/screen/slot/SlotActionType;)V
-accessible	method	net/minecraft/client/MinecraftClient	doItemUse	()V
-accessible	method	net/minecraft/client/Mouse	onMouseButton	(JLnet/minecraft/client/input/MouseInput;I)V
-accessible	method	net/minecraft/client/render/GameRenderer	setPostProcessor	(Lnet/minecraft/util/Identifier;)V
-accessible	method	net/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder	build	(Z)Lnet/minecraft/client/render/RenderLayer$MultiPhaseParameters;
-accessible	method	net/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder	layering	(Lnet/minecraft/client/render/RenderPhase$Layering;)Lnet/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder;
-accessible	method	net/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder	lineWidth	(Lnet/minecraft/client/render/RenderPhase$LineWidth;)Lnet/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder;
-accessible	method	net/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder	target	(Lnet/minecraft/client/render/RenderPhase$Target;)Lnet/minecraft/client/render/RenderLayer$MultiPhaseParameters$Builder;
-accessible	method	net/minecraft/component/ComponentMap$Builder	put	(Lnet/minecraft/component/ComponentType;Ljava/lang/Object;)V
-accessible	method	net/minecraft/entity/player/PlayerEntity	canGlide	()Z
-accessible	method	net/minecraft/entity/projectile/FishingBobberEntity	isOpenOrWaterAround	(Lnet/minecraft/util/math/BlockPos;)Z
-accessible	field	net/minecraft/client/MinecraftClient	itemUseCooldown	I
-accessible	field	net/minecraft/client/gui/DrawContext	scissorStack	Lnet/minecraft/client/gui/DrawContext$ScissorStack;
-accessible	field	net/minecraft/client/gui/DrawContext	state	Lnet/minecraft/client/gui/render/state/GuiRenderState;
-accessible	field	net/minecraft/client/gui/hud/ChatHud	visibleMessages	Ljava/util/List;
-accessible	field	net/minecraft/client/gui/screen/Screen	drawables	Ljava/util/List;
-accessible	field	net/minecraft/client/gui/screen/TitleScreen	doBackgroundFade	Z
-accessible	field	net/minecraft/client/gui/screen/ingame/CreativeInventoryScreen	selectedTab	Lnet/minecraft/item/ItemGroup;
-accessible	field	net/minecraft/client/gui/screen/multiplayer/MultiplayerScreen	serverListWidget	Lnet/minecraft/client/gui/screen/multiplayer/MultiplayerServerListWidget;
-accessible	field	net/minecraft/client/gui/screen/option/ControlsListWidget$KeyBindingEntry	bindingName	Lnet/minecraft/text/Text;
-accessible	field	net/minecraft/client/gui/widget/CyclingButtonWidget	optionText	Lnet/minecraft/text/Text;
-accessible	field	net/minecraft/client/network/ClientPlayNetworkHandler	messagePacker	Lnet/minecraft/network/message/MessageChain$Packer;
-accessible	field	net/minecraft/client/network/ClientPlayNetworkHandler	session	Lnet/minecraft/network/encryption/ClientPlayerSession;
-accessible	field	net/minecraft/client/network/ClientPlayerEntity	lastPitchClient	F
-accessible	field	net/minecraft/client/network/ClientPlayerEntity	lastYawClient	F
-accessible	field	net/minecraft/client/network/ClientPlayerInteractionManager	blockBreakingCooldown	I
-accessible	field	net/minecraft/client/network/ClientPlayerInteractionManager	breakingBlock	Z
-accessible	field	net/minecraft/client/network/ClientPlayerInteractionManager	currentBreakingProgress	F
-accessible	field	net/minecraft/client/render/RenderLayer$MultiPhase	phases	Lnet/minecraft/client/render/RenderLayer$MultiPhaseParameters;
-accessible	field	net/minecraft/client/render/RenderLayer$MultiPhase	pipeline	Lcom/mojang/blaze3d/pipeline/RenderPipeline;
-accessible	field	net/minecraft/client/render/RenderLayer$MultiPhaseParameters	target	Lnet/minecraft/client/render/RenderPhase$Target;
-accessible	field	net/minecraft/client/toast/ToastManager	toastQueue	Ljava/util/Deque;
-accessible	field	net/minecraft/entity/Entity	movementMultiplier	Lnet/minecraft/util/math/Vec3d;
-accessible	field	net/minecraft/entity/LivingEntity	equipment	Lnet/minecraft/entity/EntityEquipment;
-accessible	field	net/minecraft/entity/LivingEntity	jumping	Z
-accessible	field	net/minecraft/network/packet/s2c/play/ChunkDeltaUpdateS2CPacket	sectionPos	Lnet/minecraft/util/math/ChunkSectionPos;
-accessible	field	net/minecraft/client/gui/hud/BossBarHud	bossBars	Ljava/util/Map;
-accessible	method	net/minecraft/client/Keyboard	onKey	(JILnet/minecraft/client/input/KeyInput;)V
+accessible	class	net/minecraft/client/gui/GuiGraphics$ScissorStack
+accessible	method	net/minecraft/client/renderer/RenderPipelines	register	(Lcom/mojang/blaze3d/pipeline/RenderPipeline;)Lcom/mojang/blaze3d/pipeline/RenderPipeline;
+accessible	method	net/minecraft/client/gui/screens/inventory/AbstractContainerScreen	slotClicked	(Lnet/minecraft/world/inventory/Slot;IILnet/minecraft/world/inventory/ClickType;)V
+accessible	method	net/minecraft/client/KeyboardHandler	keyPress	(JILnet/minecraft/client/input/KeyEvent;)V
+accessible	method	net/minecraft/client/Minecraft	startUseItem	()V
+accessible	method	net/minecraft/client/MouseHandler	onButton	(JLnet/minecraft/client/input/MouseButtonInfo;I)V
+accessible	method	net/minecraft/client/renderer/GameRenderer	setPostEffect	(Lnet/minecraft/resources/ResourceLocation;)V
+accessible	method	net/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder	createCompositeState	(Z)Lnet/minecraft/client/renderer/RenderType$CompositeState;
+accessible	method	net/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder	setLayeringState	(Lnet/minecraft/client/renderer/RenderStateShard$LayeringStateShard;)Lnet/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder;
+accessible	method	net/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder	setLineState	(Lnet/minecraft/client/renderer/RenderStateShard$LineStateShard;)Lnet/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder;
+accessible	method	net/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder	setOutputState	(Lnet/minecraft/client/renderer/RenderStateShard$OutputStateShard;)Lnet/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder;
+accessible	method	net/minecraft/core/component/DataComponentMap$Builder	setUnchecked	(Lnet/minecraft/core/component/DataComponentType;Ljava/lang/Object;)V
+accessible	method	net/minecraft/world/entity/player/Player	canGlide	()Z
+accessible	method	net/minecraft/world/entity/projectile/FishingHook	calculateOpenWater	(Lnet/minecraft/core/BlockPos;)Z
+accessible	field	net/minecraft/client/Minecraft	rightClickDelay	I
+accessible	field	net/minecraft/client/gui/GuiGraphics	scissorStack	Lnet/minecraft/client/gui/GuiGraphics$ScissorStack;
+accessible	field	net/minecraft/client/gui/GuiGraphics	guiRenderState	Lnet/minecraft/client/gui/render/state/GuiRenderState;
+accessible	field	net/minecraft/client/gui/components/ChatComponent	trimmedMessages	Ljava/util/List;
+accessible	field	net/minecraft/client/gui/screens/Screen	renderables	Ljava/util/List;
+accessible	field	net/minecraft/client/gui/screens/TitleScreen	fading	Z
+accessible	field	net/minecraft/client/gui/screens/inventory/CreativeModeInventoryScreen	selectedTab	Lnet/minecraft/world/item/CreativeModeTab;
+accessible	field	net/minecraft/client/gui/screens/multiplayer/JoinMultiplayerScreen	serverSelectionList	Lnet/minecraft/client/gui/screens/multiplayer/ServerSelectionList;
+accessible	field	net/minecraft/client/gui/screens/options/controls/KeyBindsList$KeyEntry	name	Lnet/minecraft/network/chat/Component;
+accessible	field	net/minecraft/client/gui/components/CycleButton	name	Lnet/minecraft/network/chat/Component;
+accessible	field	net/minecraft/client/multiplayer/ClientPacketListener	signedMessageEncoder	Lnet/minecraft/network/chat/SignedMessageChain$Encoder;
+accessible	field	net/minecraft/client/multiplayer/ClientPacketListener	chatSession	Lnet/minecraft/network/chat/LocalChatSession;
+accessible	field	net/minecraft/client/player/LocalPlayer	xRotLast	F
+accessible	field	net/minecraft/client/player/LocalPlayer	yRotLast	F
+accessible	field	net/minecraft/client/multiplayer/MultiPlayerGameMode	destroyDelay	I
+accessible	field	net/minecraft/client/multiplayer/MultiPlayerGameMode	isDestroying	Z
+accessible	field	net/minecraft/client/multiplayer/MultiPlayerGameMode	destroyProgress	F
+accessible	field	net/minecraft/client/renderer/RenderType$CompositeRenderType	state	Lnet/minecraft/client/renderer/RenderType$CompositeState;
+accessible	field	net/minecraft/client/renderer/RenderType$CompositeRenderType	renderPipeline	Lcom/mojang/blaze3d/pipeline/RenderPipeline;
+accessible	field	net/minecraft/client/renderer/RenderType$CompositeState	outputState	Lnet/minecraft/client/renderer/RenderStateShard$OutputStateShard;
+accessible	field	net/minecraft/client/gui/components/toasts/ToastManager	queued	Ljava/util/Deque;
+accessible	field	net/minecraft/client/gui/components/BossHealthOverlay	events	Ljava/util/Map;
+accessible	field	net/minecraft/world/entity/Entity	stuckSpeedMultiplier	Lnet/minecraft/world/phys/Vec3;
+accessible	field	net/minecraft/world/entity/LivingEntity	equipment	Lnet/minecraft/world/entity/EntityEquipment;
+accessible	field	net/minecraft/world/entity/LivingEntity	jumping	Z
+accessible	field	net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket	sectionPos	Lnet/minecraft/core/SectionPos;
diff --git a/src/test/java/net/wurstclient/util/RotationTest.java b/src/test/java/net/wurstclient/util/RotationTest.java
index be42616ed..731112ba1 100644
--- a/src/test/java/net/wurstclient/util/RotationTest.java
+++ b/src/test/java/net/wurstclient/util/RotationTest.java
@@ -12,7 +12,7 @@ import static org.junit.jupiter.api.Assertions.*;
 import org.joml.Quaternionf;
 import org.junit.jupiter.api.Test;
 
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.phys.Vec3;
 
 class RotationTest
 {
@@ -123,7 +123,7 @@ class RotationTest
 	void testToLookVec()
 	{
 		Rotation r = new Rotation(0, 0);
-		Vec3d vec = r.toLookVec();
+		Vec3 vec = r.toLookVec();
 		assertAlmostEquals(0, vec.x);
 		assertAlmostEquals(0, vec.y);
 		assertAlmostEquals(1, vec.z);
